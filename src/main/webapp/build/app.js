/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _weixinJsSdk = __webpack_require__(170);
	
	var _weixinJsSdk2 = _interopRequireDefault(_weixinJsSdk);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	_vue2.default.filter('time', function (value) {
	    var hour = Math.floor(value / 3600);
	    var min = Math.floor(value % 3600 / 60);
	    if (hour < 10) {
	        hour = '0' + hour;
	    }
	    if (min < 10) {
	        min = '0' + min;
	    }
	    var sec = value % 60;
	    if (sec < 10) {
	        sec = '0' + sec;
	    }
	    return (hour > 0 ? hour + ':' : '') + min + ':' + sec;
	});
	_vue2.default.filter('datetime', function (value) {
	    return new Date(value).toLocaleString();
	});
	var config = {};
	_requestList2.default.getMainConfig().then(function (res) {
	    config = res.data;
	    console.log(config);
	}, function (res) {
	    console.error(res);
	});
	
	var main = new _vue2.default({
	    el: 'body',
	    components: { app: _App2.default }
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, jQuery) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2), __webpack_require__(3)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable no-unused-vars*/
	/*!
	 * jQuery JavaScript Library v3.1.0
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-07-07T21:44Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.0",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.0
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-04
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true;
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
		// Known :disabled false positives:
		// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
		// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Check form elements and option elements for explicit disabling
			return "label" in elem && elem.disabled === disabled ||
				"form" in elem && elem.disabled === disabled ||
	
				// Check non-disabled form elements for fieldset[disabled] ancestors
				"form" in elem && elem.disabled === false && (
					// Support: IE6-11+
					// Ancestry is covered for us
					elem.isDisabled === disabled ||
	
					// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						("label" in elem || !disabledAncestor( elem )) !== disabled
				);
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnotwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? JSON.parse( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) ),
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support: IE <=9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox <=42
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			opt.duration = typeof opt.duration === "number" ?
				opt.duration : opt.duration in jQuery.fx.speeds ?
					jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in uncached url if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rts, "" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	return jQuery;
	} );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(9)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(169)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0692510b/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue", function() {
				var newContent = require("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n", "", {"version":3,"sources":["/./src/App.vue?22194fe2"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsKA;IACA,UAAA;CACA;;AAEA;;IAEA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oCAAA;IACA,SAAA;IACA,QAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;CACA","file":"App.vue","sourcesContent":["<template lang=\"pug\">\n        background\n        menu-bar(v-bind:game-data=\"gameData\",v-bind:notice=\"notice\",v-bind:zoom-rate=\"zoomRate\")\n        bet-and-bonus(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        play-panel(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        state(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        //- bet-multiple\n        message(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        modal.modal(v-if=\"error\")\n        tip-modal\n</template>\n<script>\nimport Background from './components/Background.vue'\nimport MenuBar from './components/MenuBar.vue'\nimport BetAndBonus from './components/BetAndBonus.vue'\nimport PlayPanel from './components/PlayPanel.vue'\nimport State from './components/State.vue'\nimport BetMultiple from './components/BetMultiple.vue'\nimport Message from './components/Message.vue'\nimport gameData from './data/data' //  加载模板数据\nimport RequestList from './js/request-list'\nexport default {\n    props: [],\n    ready() {\n        let that = this\n        window.onresize = function() {\n            that.screenSize.width = window.innerWidth\n            that.screenSize.height = window.innerHeight\n        }\n        this.init()\n    },\n    data() {\n        return {\n            userBet: {\n                betmoney: 1000 //默认下注金额为1000\n            },\n            gameData: gameData,\n            lotterynum: { //开奖结果\n                id: '',\n                createdAt: 0,\n                lotterynums: ''\n            },\n            countDown: 300, // 倒计时秒数\n            countNum: 300, //开奖时间间隔 默认3分钟\n            error: false,\n            bets: [], // 下注集合，可以单次下多注\n            notice: require('./data/notice'),\n            userinfo: require('./data/singleuser'),\n            stageSize: { // 整体画布大小,所有变化组件再次基础上乘以放大倍率\n                width: 640,\n                height: 1008\n            },\n            screenSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            }\n        }\n    },\n    methods: {\n        init() {\n            // 初始化读取数据\n\n            // 读取开奖数据\n            RequestList.getBonusNum().then(res => this.lotterynum = res.data)\n            this.getUserInfoByNet()\n                // 获取公告数据\n            this.$emit('getLastNotice')\n        },\n        show() {},\n        getUserInfoByNet() { //从网络获取user信息\n            var that = this\n            RequestList.getuserCodeFromNet(RequestList.getCode()).then(res => {\n                // 获取用户数据\n                that.userinfo = Object.assign({}, that.userinfo, res.data)\n                that.userinfo = {\n                    // 用户信息数据模板\n                    'createdAt': 1469548675000,\n                    'money': 10000,\n                    'headimgurl': 'http://tse3.mm.bing.net/th?id=OIP.Mc8c03e62f78cbcad0969763649b6f50fo0&w=151&h=151&c=7&rs=1&qlt=90&o=4&pid=1.1',\n                    'nickname': '我自己',\n                    'openid': 'og7UbwBp0jhUHvfqcsKEY3T7dTLk'\n                }\n                that.$emit('getUserInfo')\n            }, res => {\n                that.userinfo = {\n                    // 用户信息数据模板\n                    'createdAt': 1469548675000,\n                    'money': 1000000,\n                    'headimgurl': 'http://tse3.mm.bing.net/th?id=OIP.Mc8c03e62f78cbcad0969763649b6f50fo0&w=151&h=151&c=7&rs=1&qlt=90&o=4&pid=1.1',\n                    'nickname': '我自己',\n                    'openid': 'og7UbwBp0jhUHvfqcsKEY3T7dTLk'\n                }\n                console.error(res.data)\n            })\n        }\n    },\n    computed: {\n        zoomRate() { // 初始化放大倍率\n            let x = this.screenSize.width / this.stageSize.width\n            let y = this.screenSize.height / this.stageSize.height\n            return {\n                x: x,\n                y: y\n            }\n        },\n        lockmoney() { //锁定金额\n            let result = 0\n            for (let i = 0; i < this.bets.length; i++) {\n                result += this.bets[i].betmoney\n            }\n            return result\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.$broadcast('showMessage', event)\n        },\n        getUserInfo(event) {\n            var that = this\n            RequestList.getuserinfo(JSON.parse(JSON.stringify(this.userinfo))).then((res) => {\n                if (Object.prototype.toString.call(res.data) === '[object Object]') {\n                    // that.userinfo = Object.assign({}, that.userinfo, res.data)\n                    // 数据库没有保存头像属性，所以不设置头像属性\n                    that.userinfo.openid = res.data.openid\n                    that.userinfo.nickname = res.data.nickname\n                    that.userinfo.money = res.data.money\n                    that.userBet.userinfoOpenid = res.data.openid\n                } else {}\n                return\n            }, (res) => {\n                console.error(res)\n            })\n        },\n        getLastNotice(event) {\n            RequestList.getLastNotice().then(res => this.notice = res.data, res => console.error(res))\n        },\n        cancelbet(event) {\n            this.$broadcast('cancelBet')\n        },\n        reloadinfo(event) {\n            this.init()\n        },\n        // 触发错误，并打开遮罩层\n        error() {\n            this.error = true\n        },\n        showTip(event) {\n            this.$broadcast('showTip', event)\n        }\n    },\n    components: {\n        'modal': {\n            template: '<div class=\"modal\"></div>'\n        },\n        'tip-modal': require('./components/tip-modal.vue'),\n        'background': Background,\n        'menu-bar': MenuBar,\n        'bet-and-bonus': BetAndBonus,\n        'play-panel': PlayPanel,\n        'state': State,\n        'bet-multiple': BetMultiple,\n        'message': Message\n    }\n}\n</script>\n<style>\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if (media) {
			styleElement.setAttribute("media", media);
		}
	
		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Background = __webpack_require__(49);
	
	var _Background2 = _interopRequireDefault(_Background);
	
	var _MenuBar = __webpack_require__(55);
	
	var _MenuBar2 = _interopRequireDefault(_MenuBar);
	
	var _BetAndBonus = __webpack_require__(67);
	
	var _BetAndBonus2 = _interopRequireDefault(_BetAndBonus);
	
	var _PlayPanel = __webpack_require__(77);
	
	var _PlayPanel2 = _interopRequireDefault(_PlayPanel);
	
	var _State = __webpack_require__(85);
	
	var _State2 = _interopRequireDefault(_State);
	
	var _BetMultiple = __webpack_require__(94);
	
	var _BetMultiple2 = _interopRequireDefault(_BetMultiple);
	
	var _Message = __webpack_require__(99);
	
	var _Message2 = _interopRequireDefault(_Message);
	
	var _data = __webpack_require__(161);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: [],
	    ready: function ready() {
	        var that = this;
	        window.onresize = function () {
	            that.screenSize.width = window.innerWidth;
	            that.screenSize.height = window.innerHeight;
	        };
	        this.init();
	    },
	    data: function data() {
	        return {
	            userBet: {
	                betmoney: 1000 },
	            gameData: _data2.default,
	            lotterynum: {
	                id: '',
	                createdAt: 0,
	                lotterynums: ''
	            },
	            countDown: 300,
	            countNum: 300,
	            error: false,
	            bets: [],
	            notice: __webpack_require__(162),
	            userinfo: __webpack_require__(163),
	            stageSize: {
	                width: 640,
	                height: 1008
	            },
	            screenSize: {
	                width: window.innerWidth,
	                height: window.innerHeight
	            }
	        };
	    },
	
	    methods: {
	        init: function init() {
	            var _this = this;
	
	            _requestList2.default.getBonusNum().then(function (res) {
	                return _this.lotterynum = res.data;
	            });
	            this.getUserInfoByNet();
	
	            this.$emit('getLastNotice');
	        },
	        show: function show() {},
	        getUserInfoByNet: function getUserInfoByNet() {
	            var that = this;
	            _requestList2.default.getuserCodeFromNet(_requestList2.default.getCode()).then(function (res) {
	                that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                that.userinfo = {
	                    'createdAt': 1469548675000,
	                    'money': 10000,
	                    'headimgurl': 'http://tse3.mm.bing.net/th?id=OIP.Mc8c03e62f78cbcad0969763649b6f50fo0&w=151&h=151&c=7&rs=1&qlt=90&o=4&pid=1.1',
	                    'nickname': '我自己',
	                    'openid': 'og7UbwBp0jhUHvfqcsKEY3T7dTLk'
	                };
	                that.$emit('getUserInfo');
	            }, function (res) {
	                that.userinfo = {
	                    'createdAt': 1469548675000,
	                    'money': 1000000,
	                    'headimgurl': 'http://tse3.mm.bing.net/th?id=OIP.Mc8c03e62f78cbcad0969763649b6f50fo0&w=151&h=151&c=7&rs=1&qlt=90&o=4&pid=1.1',
	                    'nickname': '我自己',
	                    'openid': 'og7UbwBp0jhUHvfqcsKEY3T7dTLk'
	                };
	                console.error(res.data);
	            });
	        }
	    },
	    computed: {
	        zoomRate: function zoomRate() {
	            var x = this.screenSize.width / this.stageSize.width;
	            var y = this.screenSize.height / this.stageSize.height;
	            return {
	                x: x,
	                y: y
	            };
	        },
	        lockmoney: function lockmoney() {
	            var result = 0;
	            for (var i = 0; i < this.bets.length; i++) {
	                result += this.bets[i].betmoney;
	            }
	            return result;
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.$broadcast('showMessage', event);
	        },
	        getUserInfo: function getUserInfo(event) {
	            var that = this;
	            _requestList2.default.getuserinfo(JSON.parse((0, _stringify2.default)(this.userinfo))).then(function (res) {
	                if (Object.prototype.toString.call(res.data) === '[object Object]') {
	                    that.userinfo.openid = res.data.openid;
	                    that.userinfo.nickname = res.data.nickname;
	                    that.userinfo.money = res.data.money;
	                    that.userBet.userinfoOpenid = res.data.openid;
	                } else {}
	                return;
	            }, function (res) {
	                console.error(res);
	            });
	        },
	        getLastNotice: function getLastNotice(event) {
	            var _this2 = this;
	
	            _requestList2.default.getLastNotice().then(function (res) {
	                return _this2.notice = res.data;
	            }, function (res) {
	                return console.error(res);
	            });
	        },
	        cancelbet: function cancelbet(event) {
	            this.$broadcast('cancelBet');
	        },
	        reloadinfo: function reloadinfo(event) {
	            this.init();
	        },
	        error: function error() {
	            this.error = true;
	        },
	        showTip: function showTip(event) {
	            this.$broadcast('showTip', event);
	        }
	    },
	    components: {
	        'modal': {
	            template: '<div class="modal"></div>'
	        },
	        'tip-modal': __webpack_require__(164),
	        'background': _Background2.default,
	        'menu-bar': _MenuBar2.default,
	        'bet-and-bonus': _BetAndBonus2.default,
	        'play-panel': _PlayPanel2.default,
	        'state': _State2.default,
	        'bet-multiple': _BetMultiple2.default,
	        'message': _Message2.default
	    }
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(11), __esModule: true };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(12)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(14), __esModule: true };

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(15);
	module.exports = __webpack_require__(12).Object.assign;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(16);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(30)});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , core      = __webpack_require__(12)
	  , ctx       = __webpack_require__(18)
	  , hide      = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 17 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(19);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(21)
	  , createDesc = __webpack_require__(29);
	module.exports = __webpack_require__(25) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(22)
	  , IE8_DOM_DEFINE = __webpack_require__(24)
	  , toPrimitive    = __webpack_require__(28)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(25) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(25) && !__webpack_require__(26)(function(){
	  return Object.defineProperty(__webpack_require__(27)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(26)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23)
	  , document = __webpack_require__(17).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(23);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(31)
	  , gOPS     = __webpack_require__(46)
	  , pIE      = __webpack_require__(47)
	  , toObject = __webpack_require__(48)
	  , IObject  = __webpack_require__(35)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(26)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(45);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(33)
	  , toIObject    = __webpack_require__(34)
	  , arrayIndexOf = __webpack_require__(38)(false)
	  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(35)
	  , defined = __webpack_require__(37);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(34)
	  , toLength  = __webpack_require__(39)
	  , toIndex   = __webpack_require__(41);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(40)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(43)('keys')
	  , uid    = __webpack_require__(44);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(17)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 46 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 47 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(37);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(50)
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7658d6de/Background.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(51);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(" + __webpack_require__(52) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(" + __webpack_require__(53) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/Background.vue?b29085ae"],"names":[],"mappings":";;;;;;AAMA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,YAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,iDAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,sBAAA;IACA,uBAAA;IACA,6BAAA;CACA","file":"Background.vue","sourcesContent":["<template lang=\"pug\">\n    div.background\n    \tdiv.up-background\n    \tdiv.buttom-background\n</template>\n<style>\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(../assets/切图/主界面/BG.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(../assets/切图/主界面/dock.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4b4a6609b989655a4d67f245bd57e41d.png";

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABlCAIAAAADEh6SAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5RjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDlBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlGQzJEOTlEM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yDa1IwAAABxJREFUeNpisArsZGJgYGB+//EbiB7FA48BAgwAr7gEtOjH9QQAAAAASUVORK5CYII="

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "<div class=\"background\"><div class=\"up-background\"></div><div class=\"buttom-background\"></div></div>";

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(56)
	__vue_script__ = __webpack_require__(59)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\MenuBar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(66)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a5fa5098/MenuBar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(" + __webpack_require__(58) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/MenuBar.vue?542b96fa"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;IACA,mBAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,eAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;IACA,aAAA;IACA,sBAAA;IACA,aAAA;IACA;2BACA;IACA,wBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"MenuBar.vue","sourcesContent":["<template lang=\"pug\">\n    //-菜单部分\n    div.menu\n        div.notice\n            table\n                tr\n                    td\n                        span(v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\",v-html='notice.title')\n        div.option(@touchend=\"triggerOption\")\n        options-dialog(v-bind:game-data=\"gameData\",v-bind:zoom-rate=\"zoomRate\")\n</template>\n<script>\nimport OptionsDialog from './OptionsDialog.vue'\nexport default {\n    props: ['gameData', 'zoomRate', 'notice'],\n    ready() {\n        console.log(this.gameData.notice)\n    },\n    data() {\n        return {\n            name: 'liu',\n            isShowOption: false\n        }\n    },\n    methods: {\n        triggerOption() {\n            this.$broadcast('triggerOption')\n        }\n    },\n    components: {\n        'options-dialog': OptionsDialog\n    }\n}\n</script>\n<style>\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(../assets/切图/主界面/菜单.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA0CAYAAAA5bTAhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUI5QzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUI5RDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcwMzg1MUZGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwMzg1MjAwM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+mrp5MgAABkJJREFU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"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _OptionsDialog = __webpack_require__(60);
	
	var _OptionsDialog2 = _interopRequireDefault(_OptionsDialog);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['gameData', 'zoomRate', 'notice'],
	    ready: function ready() {
	        console.log(this.gameData.notice);
	    },
	    data: function data() {
	        return {
	            name: 'liu',
	            isShowOption: false
	        };
	    },
	
	    methods: {
	        triggerOption: function triggerOption() {
	            this.$broadcast('triggerOption');
	        }
	    },
	    components: {
	        'options-dialog': _OptionsDialog2.default
	    }
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(61)
	__vue_script__ = __webpack_require__(63)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\OptionsDialog.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(65)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-3d271406/OptionsDialog.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/* 必需 */\n\n.expand-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter 定义进入的开始状态 */\n\n\n/* .expand-leave 定义离开的结束状态 */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n", "", {"version":3,"sources":["/./src/components/OptionsDialog.vue?53ddea8e"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,iBAAA;IACA,iBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;;AAGA,QAAA;;AAEA;IACA,iCAAA;IAAA,yBAAA;IACA,iBAAA;IACA,kBAAA;IACA,2BAAA;IACA,iBAAA;CACA;;;AAGA,6BAAA;;;AAGA,6BAAA;;AAEA;;IAEA,UAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,6BAAA;IACA,mBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;AAEA;IACA,eAAA;IACA,gBAAA;IACA,oBAAA;IACA,mBAAA;IACA,oBAAA;IACA,4BAAA;CACA;;AAEA;IACA,cAAA;IACA,mCAAA;CACA","file":"OptionsDialog.vue","sourcesContent":["<template lang=\"pug\">\n    //- 右上侧选项列表\n    div.option-list(v-show=\"isOptionShow\",transition=\"expand\",v-bind:style=\"optionStyle\")\n        //- img(v-bind:src=\"menuImg\")\n        div.pointer\n        div.inner-pointer\n        div.option-item(v-html=\"n\",v-for=\"n in gameData.options\",@touchend=\"showMessage($index)\",v-bind:style=\"itemStyle\")\n</template>\n<script>\nexport default {\n    ready() {\n            console.log(this.gameData)\n        },\n        props: ['gameData', 'zoomRate'],\n        data() {\n            return {\n                isOptionShow: false,\n                menuImg: require('../assets/切图/主界面/菜单展开.png')\n            }\n        },\n        computed: {\n            optionStyle() {\n                return {\n                    borderRadius: 12 * this.zoomRate.x + 'px'\n                }\n            },\n            itemStyle() {\n                return {\n                    fontSize: 26 * this.zoomRate.x + 'px'\n                }\n            }\n        },\n        methods: {\n            showMessage(event) {\n                this.isOptionShow = false\n                this.$dispatch('showMessage', event)\n            }\n        },\n        events: {\n            triggerOption() {\n                this.isOptionShow = !this.isOptionShow\n            }\n        }\n}\n</script>\n<style>\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/* 必需 */\n\n.expand-transition {\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter 定义进入的开始状态 */\n\n\n/* .expand-leave 定义离开的结束状态 */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.gameData);
	    },
	
	    props: ['gameData', 'zoomRate'],
	    data: function data() {
	        return {
	            isOptionShow: false,
	            menuImg: __webpack_require__(64)
	        };
	    },
	
	    computed: {
	        optionStyle: function optionStyle() {
	            return {
	                borderRadius: 12 * this.zoomRate.x + 'px'
	            };
	        },
	        itemStyle: function itemStyle() {
	            return {
	                fontSize: 26 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        showMessage: function showMessage(event) {
	            this.isOptionShow = false;
	            this.$dispatch('showMessage', event);
	        }
	    },
	    events: {
	        triggerOption: function triggerOption() {
	            this.isOptionShow = !this.isOptionShow;
	        }
	    }
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAFcCAYAAABhrZRpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUJBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUJBMTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQjlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkyN0JFQjlGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ePgOugAAKRNJREFU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"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<div class=\"option-list\" v-show=\"isOptionShow\" transition=\"expand\" v-bind:style=\"optionStyle\"><div class=\"pointer\"></div><div class=\"inner-pointer\"></div><div class=\"option-item\" v-html=\"n\" v-for=\"n in gameData.options\" @touchend=\"showMessage($index)\" v-bind:style=\"itemStyle\"></div></div>";

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<div class=\"menu\"><div class=\"notice\"><table><tr><td><span v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\" v-html=\"notice.title\"></span></td></tr></table></div><div class=\"option\" @touchend=\"triggerOption\"></div><options-dialog v-bind:game-data=\"gameData\" v-bind:zoom-rate=\"zoomRate\"></options-dialog></div>";

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(68)
	__vue_script__ = __webpack_require__(73)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetAndBonus.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7138c18e/BetAndBonus.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(70) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(71) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(72) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n", "", {"version":3,"sources":["/./src/components/BetAndBonus.vue?69df84a6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,gBAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,kBAAA;IACA,aAAA;CACA;;AAEA;;IAEA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;IACA,eAAA;CACA;;AAEA;IACA,aAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;CACA","file":"BetAndBonus.vue","sourcesContent":["<template lang=\"pug\">\n    //- 展示用户的下注金额 以及 奖金金额 当然还有倒计时\n    div.bonus-bar\n        div.bonus-item.bet\n            div.item-back.forzen\n                div.item-show\n                    div.bet-num(v-bind:style=\"betNum\",v-html=\"lockmoney\")\n        div.bonus-item.count-down\n            div.count-down-back\n                div.count-down-show\n                    div.count-down-num(v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\",v-html=\"countDown | time\")\n        div.bonus-item.bonus\n            div.item-back.balance\n                div.item-show(@touchend=\"showMessage\")\n                    div.bet-num(v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\")\n</template>\n<script>\nimport RequestList from '../js/request-list'\nexport default {\n    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],\n    ready() {\n        this.getCount(this.count(this.countDown))\n    },\n    data() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight\n        }\n    },\n    computed: {\n        betNum() {\n            return {\n                fontSize: 34 * this.zoomRate.x + 'px',\n                lineHeight: 3 * 34 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        //每次开奖都重新获取 倒计时\n        getCount(fn) {\n            var that = this\n            RequestList.getCount().then((res) => {\n                that.countDown = res.data.countDown\n                that.countNum = res.data.countNum\n                that.userBet.idnum = res.data.idnum //开奖期数\n                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {\n                    that.$dispatch('error')\n                    return\n                }\n                fn ? fn() : null\n            }, (res) => {\n                that.countDown = 0\n            })\n        },\n        // 买定离手\n        createUserBets() {\n            var that = this\n            RequestList.createUserBets(JSON.stringify(this.bets)).then((res) => {\n                if (typeof res.data.errmsg !== 'undefined') {\n                    that.$dispatch('showTip', res.data.errmsg)\n                }\n                console.log(res.data)\n            }, (res) => {\n                console.log(res.data)\n            })\n        },\n        // 兑奖\n        cashPrize() {\n            var that = this\n            RequestList.cashPrize(JSON.stringify(this.userinfo)).then(res => {\n                console.log(res.data)\n            }, res => {\n                console.log(res.data)\n            })\n        },\n        getBonusNum() { // 获取开奖结果\n            var that = this\n            RequestList.getBonusNum().then((res) => {\n                that.lotterynum = res.data\n                that.getCount(that.count)\n                that.$dispatch('cancelbet')\n                that.$dispatch('reloadinfo')\n            }, (res) => {\n                console.error(res)\n            })\n            this.countDown = this.countNum\n        },\n        showMessage() {\n            this.$dispatch('showMessage', 5)\n        },\n        count() {\n            // 距离开奖时间30秒时 买定离手\n            if (this.countDown === 30 && this.bets && this.bets.length > 0) {\n                this.createUserBets()\n            }\n            // 倒计时不是数字时不进行倒计时\n            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {\n                this.$dispatch('showTip', '倒计时读取错误,请刷新页面')\n                return\n            }\n            // console.log(this.countDown)\n            this.countDown--\n                let that = this\n            setTimeout(function() {\n                if (that.countDown > 0) {\n                    that.count()\n                } else {\n                    // 倒计时小于0 时 获取获奖结果 并兑奖\n                    that.getBonusNum()\n                    that.cashPrize()\n                }\n            }, 1000)\n        }\n    }\n}\n</script>\n<style>\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/冻结.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/余额.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/count-down.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ2RTNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ2RjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0ZCM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0ZDM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jqTgIAAAGLJJREFU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"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNkJDRDdGOTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGQTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0Y3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0Y4M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8Nwv7wAAFD1JREFU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"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAACVCAYAAACzfqM2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ3MjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ3MzNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBEMDg0NDcwM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBEMDg0NDcxM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gONmGwAAMvxJREFU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"

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],
	    ready: function ready() {
	        this.getCount(this.count(this.countDown));
	    },
	    data: function data() {
	        return {
	            width: window.innerWidth,
	            height: window.innerHeight
	        };
	    },
	
	    computed: {
	        betNum: function betNum() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                lineHeight: 3 * 34 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        getCount: function getCount(fn) {
	            var that = this;
	            _requestList2.default.getCount().then(function (res) {
	                that.countDown = res.data.countDown;
	                that.countNum = res.data.countNum;
	                that.userBet.idnum = res.data.idnum;
	                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {
	                    that.$dispatch('error');
	                    return;
	                }
	                fn ? fn() : null;
	            }, function (res) {
	                that.countDown = 0;
	            });
	        },
	        createUserBets: function createUserBets() {
	            var that = this;
	            _requestList2.default.createUserBets((0, _stringify2.default)(this.bets)).then(function (res) {
	                if (typeof res.data.errmsg !== 'undefined') {
	                    that.$dispatch('showTip', res.data.errmsg);
	                }
	                console.log(res.data);
	            }, function (res) {
	                console.log(res.data);
	            });
	        },
	        cashPrize: function cashPrize() {
	            var that = this;
	            _requestList2.default.cashPrize((0, _stringify2.default)(this.userinfo)).then(function (res) {
	                console.log(res.data);
	            }, function (res) {
	                console.log(res.data);
	            });
	        },
	        getBonusNum: function getBonusNum() {
	            var that = this;
	            _requestList2.default.getBonusNum().then(function (res) {
	                that.lotterynum = res.data;
	                that.getCount(that.count);
	                that.$dispatch('cancelbet');
	                that.$dispatch('reloadinfo');
	            }, function (res) {
	                console.error(res);
	            });
	            this.countDown = this.countNum;
	        },
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        count: function count() {
	            if (this.countDown === 30 && this.bets && this.bets.length > 0) {
	                this.createUserBets();
	            }
	
	            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {
	                this.$dispatch('showTip', '倒计时读取错误,请刷新页面');
	                return;
	            }
	
	            this.countDown--;
	            var that = this;
	            setTimeout(function () {
	                if (that.countDown > 0) {
	                    that.count();
	                } else {
	                    that.getBonusNum();
	                    that.cashPrize();
	                }
	            }, 1000);
	        }
	    }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	
	module.exports.getBonusRecord = function () {
	    return _vue2.default.http.get('getBonusRecord');
	};
	
	module.exports.getMainConfig = function () {
	    return _vue2.default.http.get('getMainConfig', { params: { url: window.location.href.split('#')[0] } });
	};
	
	module.exports.getCount = function () {
	    return _vue2.default.http.get('getCount');
	};
	
	module.exports.getBonusNum = function (params) {
	    return _vue2.default.http.get('getBonusNum', params);
	};
	
	module.exports.createUserBets = function (params) {
	    return _vue2.default.http.post('createUserBets', params);
	};
	
	module.exports.getuserCodeFromNet = function (code) {
	    return _vue2.default.http.get('getUserCode', { params: { code: code } });
	};
	
	module.exports.getuserinfo = function (userinfo) {
	    return _vue2.default.http.post('getuserinfo', userinfo);
	};
	
	module.exports.getLastNotice = function () {
	    return _vue2.default.http.get('getLastNotice');
	};
	
	module.exports.cashPrize = function (userinfo) {
	    return _vue2.default.http.post('cashPrize', userinfo);
	};
	
	module.exports.getCode = function () {
	    var reg = new RegExp("(^|&)" + 'code' + "=([^&]*)(&|$)", "i");
	    var r = window.location.search.substr(1).match(reg);
	    if (r != null) return unescape(r[2]);
	    return null;
	};
	
	module.exports.updateuserinfo = function (params) {
	    return _vue2.default.http.post('updateuserinfo', params);
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	/*!
	 * vue-resource v0.9.3
	 * https://github.com/vuejs/vue-resource
	 * Released under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */
	
	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING = 2;
	
	function Promise$2(executor) {
	
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	
	    var promise = this;
	
	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}
	
	Promise$2.reject = function (r) {
	    return new Promise$2(function (resolve, reject) {
	        reject(r);
	    });
	};
	
	Promise$2.resolve = function (x) {
	    return new Promise$2(function (resolve, reject) {
	        resolve(x);
	    });
	};
	
	Promise$2.all = function all(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        var count = 0,
	            result = [];
	
	        if (iterable.length === 0) {
	            resolve(result);
	        }
	
	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;
	
	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }
	
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};
	
	Promise$2.race = function race(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};
	
	var p$1 = Promise$2.prototype;
	
	p$1.resolve = function resolve(x) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        var called = false;
	
	        try {
	            var then = x && x['then'];
	
	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;
	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }
	
	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};
	
	p$1.reject = function reject(reason) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};
	
	p$1.notify = function notify() {
	    var promise = this;
	
	    nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];
	
	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};
	
	p$1.then = function then(onResolved, onRejected) {
	    var promise = this;
	
	    return new Promise$2(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};
	
	p$1.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};
	
	var PromiseObj = window.Promise || Promise$2;
	
	function Promise$1(executor, context) {
	
	    if (executor instanceof PromiseObj) {
	        this.promise = executor;
	    } else {
	        this.promise = new PromiseObj(executor.bind(context));
	    }
	
	    this.context = context;
	}
	
	Promise$1.all = function (iterable, context) {
	    return new Promise$1(PromiseObj.all(iterable), context);
	};
	
	Promise$1.resolve = function (value, context) {
	    return new Promise$1(PromiseObj.resolve(value), context);
	};
	
	Promise$1.reject = function (reason, context) {
	    return new Promise$1(PromiseObj.reject(reason), context);
	};
	
	Promise$1.race = function (iterable, context) {
	    return new Promise$1(PromiseObj.race(iterable), context);
	};
	
	var p = Promise$1.prototype;
	
	p.bind = function (context) {
	    this.context = context;
	    return this;
	};
	
	p.then = function (fulfilled, rejected) {
	
	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);
	};
	
	p.catch = function (rejected) {
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.catch(rejected), this.context);
	};
	
	p.finally = function (callback) {
	
	    return this.then(function (value) {
	        callback.call(this);
	        return value;
	    }, function (reason) {
	        callback.call(this);
	        return PromiseObj.reject(reason);
	    });
	};
	
	var debug = false;
	var util = {};
	var array = [];
	function Util (Vue) {
	    util = Vue.util;
	    debug = Vue.config.debug || !Vue.config.silent;
	}
	
	function warn(msg) {
	    if (typeof console !== 'undefined' && debug) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	}
	
	function error(msg) {
	    if (typeof console !== 'undefined') {
	        console.error(msg);
	    }
	}
	
	function nextTick(cb, ctx) {
	    return util.nextTick(cb, ctx);
	}
	
	function trim(str) {
	    return str.replace(/^\s*|\s*$/g, '');
	}
	
	var isArray = Array.isArray;
	
	function isString(val) {
	    return typeof val === 'string';
	}
	
	function isBoolean(val) {
	    return val === true || val === false;
	}
	
	function isFunction(val) {
	    return typeof val === 'function';
	}
	
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	
	function isPlainObject(obj) {
	    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	}
	
	function isFormData(obj) {
	    return typeof FormData !== 'undefined' && obj instanceof FormData;
	}
	
	function when(value, fulfilled, rejected) {
	
	    var promise = Promise$1.resolve(value);
	
	    if (arguments.length < 2) {
	        return promise;
	    }
	
	    return promise.then(fulfilled, rejected);
	}
	
	function options(fn, obj, opts) {
	
	    opts = opts || {};
	
	    if (isFunction(opts)) {
	        opts = opts.call(obj);
	    }
	
	    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
	}
	
	function each(obj, iterator) {
	
	    var i, key;
	
	    if (typeof obj.length == 'number') {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (isObject(obj)) {
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }
	
	    return obj;
	}
	
	var assign = Object.assign || _assign;
	
	function merge(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source, true);
	    });
	
	    return target;
	}
	
	function defaults(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	
	        for (var key in source) {
	            if (target[key] === undefined) {
	                target[key] = source[key];
	            }
	        }
	    });
	
	    return target;
	}
	
	function _assign(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source);
	    });
	
	    return target;
	}
	
	function _merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
	            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
	                target[key] = {};
	            }
	            if (isArray(source[key]) && !isArray(target[key])) {
	                target[key] = [];
	            }
	            _merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}
	
	function root (options, next) {
	
	    var url = next(options);
	
	    if (isString(options.root) && !url.match(/^(https?:)?\//)) {
	        url = options.root + '/' + url;
	    }
	
	    return url;
	}
	
	function query (options, next) {
	
	    var urlParams = Object.keys(Url.options.params),
	        query = {},
	        url = next(options);
	
	    each(options.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });
	
	    query = Url.params(query);
	
	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }
	
	    return url;
	}
	
	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */
	
	function expand(url, params, variables) {
	
	    var tmpl = parse(url),
	        expanded = tmpl.expand(params);
	
	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }
	
	    return expanded;
	}
	
	function parse(template) {
	
	    var operators = ['+', '#', '.', '/', ';', '?', '&'],
	        variables = [];
	
	    return {
	        vars: variables,
	        expand: function (context) {
	            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
	                if (expression) {
	
	                    var operator = null,
	                        values = [];
	
	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }
	
	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });
	
	                    if (operator && operator !== '+') {
	
	                        var separator = ',';
	
	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }
	
	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }
	                } else {
	                    return encodeReserved(literal);
	                }
	            });
	        }
	    };
	}
	
	function getValues(context, operator, key, modifier) {
	
	    var value = context[key],
	        result = [];
	
	    if (isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();
	
	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }
	
	            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            result.push(encodeValue(operator, value[k], k));
	                        }
	                    });
	                }
	            } else {
	                var tmp = [];
	
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        tmp.push(encodeValue(operator, value));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(encodeValue(operator, value[k].toString()));
	                        }
	                    });
	                }
	
	                if (isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }
	
	    return result;
	}
	
	function isDefined(value) {
	    return value !== undefined && value !== null;
	}
	
	function isKeyOperator(operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	}
	
	function encodeValue(operator, value, key) {
	
	    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);
	
	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	}
	
	function encodeReserved(str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	}
	
	function template (options) {
	
	    var variables = [],
	        url = expand(options.url, options.params, variables);
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	}
	
	/**
	 * Service for URL templating.
	 */
	
	var ie = document.documentMode;
	var el = document.createElement('a');
	
	function Url(url, params) {
	
	    var self = this || {},
	        options = url,
	        transform;
	
	    if (isString(url)) {
	        options = { url: url, params: params };
	    }
	
	    options = merge({}, Url.options, self.$options, options);
	
	    Url.transforms.forEach(function (handler) {
	        transform = factory(handler, transform, self.$vm);
	    });
	
	    return transform(options);
	}
	
	/**
	 * Url options.
	 */
	
	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};
	
	/**
	 * Url transforms.
	 */
	
	Url.transforms = [template, query, root];
	
	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */
	
	Url.params = function (obj) {
	
	    var params = [],
	        escape = encodeURIComponent;
	
	    params.add = function (key, value) {
	
	        if (isFunction(value)) {
	            value = value();
	        }
	
	        if (value === null) {
	            value = '';
	        }
	
	        this.push(escape(key) + '=' + escape(value));
	    };
	
	    serialize(params, obj);
	
	    return params.join('&').replace(/%20/g, '+');
	};
	
	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */
	
	Url.parse = function (url) {
	
	    if (ie) {
	        el.href = url;
	        url = el.href;
	    }
	
	    el.href = url;
	
	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};
	
	function factory(handler, next, vm) {
	    return function (options) {
	        return handler.call(vm, options, next);
	    };
	}
	
	function serialize(params, obj, scope) {
	
	    var array = isArray(obj),
	        plain = isPlainObject(obj),
	        hash;
	
	    each(obj, function (value, key) {
	
	        hash = isObject(value) || isArray(value);
	
	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }
	
	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}
	
	function xdrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xdr = new XDomainRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith(xdr.responseText, {
	                status: xdr.status,
	                statusText: xdr.statusText
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xdr.abort();
	        };
	
	        xdr.open(request.method, request.getUrl(), true);
	        xdr.timeout = 0;
	        xdr.onload = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = function () {};
	        xdr.onprogress = function () {};
	        xdr.send(request.getBody());
	    });
	}
	
	var ORIGIN_URL = Url.parse(location.href);
	var SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();
	
	function cors (request, next) {
	
	    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {
	        request.crossOrigin = true;
	    }
	
	    if (request.crossOrigin) {
	
	        if (!SUPPORTS_CORS) {
	            request.client = xdrClient;
	        }
	
	        delete request.emulateHTTP;
	    }
	
	    next();
	}
	
	function crossOrigin(request) {
	
	    var requestUrl = Url.parse(Url(request));
	
	    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;
	}
	
	function body (request, next) {
	
	    if (request.emulateJSON && isPlainObject(request.body)) {
	        request.body = Url.params(request.body);
	        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	    }
	
	    if (isFormData(request.body)) {
	        delete request.headers['Content-Type'];
	    }
	
	    if (isPlainObject(request.body)) {
	        request.body = JSON.stringify(request.body);
	    }
	
	    next(function (response) {
	
	        var contentType = response.headers['Content-Type'];
	
	        if (isString(contentType) && contentType.indexOf('application/json') === 0) {
	
	            try {
	                response.data = response.json();
	            } catch (e) {
	                response.data = null;
	            }
	        } else {
	            response.data = response.text();
	        }
	    });
	}
	
	function jsonpClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var name = request.jsonp || 'callback',
	            callback = '_jsonp' + Math.random().toString(36).substr(2),
	            body = null,
	            handler,
	            script;
	
	        handler = function (event) {
	
	            var status = 0;
	
	            if (event.type === 'load' && body !== null) {
	                status = 200;
	            } else if (event.type === 'error') {
	                status = 404;
	            }
	
	            resolve(request.respondWith(body, { status: status }));
	
	            delete window[callback];
	            document.body.removeChild(script);
	        };
	
	        request.params[name] = callback;
	
	        window[callback] = function (result) {
	            body = JSON.stringify(result);
	        };
	
	        script = document.createElement('script');
	        script.src = request.getUrl();
	        script.type = 'text/javascript';
	        script.async = true;
	        script.onload = handler;
	        script.onerror = handler;
	
	        document.body.appendChild(script);
	    });
	}
	
	function jsonp (request, next) {
	
	    if (request.method == 'JSONP') {
	        request.client = jsonpClient;
	    }
	
	    next(function (response) {
	
	        if (request.method == 'JSONP') {
	            response.data = response.json();
	        }
	    });
	}
	
	function before (request, next) {
	
	    if (isFunction(request.before)) {
	        request.before.call(this, request);
	    }
	
	    next();
	}
	
	/**
	 * HTTP method override Interceptor.
	 */
	
	function method (request, next) {
	
	    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	        request.headers['X-HTTP-Method-Override'] = request.method;
	        request.method = 'POST';
	    }
	
	    next();
	}
	
	function header (request, next) {
	
	    request.method = request.method.toUpperCase();
	    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);
	
	    next();
	}
	
	/**
	 * Timeout Interceptor.
	 */
	
	function timeout (request, next) {
	
	    var timeout;
	
	    if (request.timeout) {
	        timeout = setTimeout(function () {
	            request.abort();
	        }, request.timeout);
	    }
	
	    next(function (response) {
	
	        clearTimeout(timeout);
	    });
	}
	
	function xhrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xhr = new XMLHttpRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {
	                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
	                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),
	                headers: parseHeaders(xhr.getAllResponseHeaders())
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xhr.abort();
	        };
	
	        xhr.open(request.method, request.getUrl(), true);
	        xhr.timeout = 0;
	        xhr.onload = handler;
	        xhr.onerror = handler;
	
	        if (request.progress) {
	            if (request.method === 'GET') {
	                xhr.addEventListener('progress', request.progress);
	            } else if (/^(POST|PUT)$/i.test(request.method)) {
	                xhr.upload.addEventListener('progress', request.progress);
	            }
	        }
	
	        if (request.credentials === true) {
	            xhr.withCredentials = true;
	        }
	
	        each(request.headers || {}, function (value, header) {
	            xhr.setRequestHeader(header, value);
	        });
	
	        xhr.send(request.getBody());
	    });
	}
	
	function parseHeaders(str) {
	
	    var headers = {},
	        value,
	        name,
	        i;
	
	    each(trim(str).split('\n'), function (row) {
	
	        i = row.indexOf(':');
	        name = trim(row.slice(0, i));
	        value = trim(row.slice(i + 1));
	
	        if (headers[name]) {
	
	            if (isArray(headers[name])) {
	                headers[name].push(value);
	            } else {
	                headers[name] = [headers[name], value];
	            }
	        } else {
	
	            headers[name] = value;
	        }
	    });
	
	    return headers;
	}
	
	function Client (context) {
	
	    var reqHandlers = [sendRequest],
	        resHandlers = [],
	        handler;
	
	    if (!isObject(context)) {
	        context = null;
	    }
	
	    function Client(request) {
	        return new Promise$1(function (resolve) {
	
	            function exec() {
	
	                handler = reqHandlers.pop();
	
	                if (isFunction(handler)) {
	                    handler.call(context, request, next);
	                } else {
	                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');
	                    next();
	                }
	            }
	
	            function next(response) {
	
	                if (isFunction(response)) {
	
	                    resHandlers.unshift(response);
	                } else if (isObject(response)) {
	
	                    resHandlers.forEach(function (handler) {
	                        response = when(response, function (response) {
	                            return handler.call(context, response) || response;
	                        });
	                    });
	
	                    when(response, resolve);
	
	                    return;
	                }
	
	                exec();
	            }
	
	            exec();
	        }, context);
	    }
	
	    Client.use = function (handler) {
	        reqHandlers.push(handler);
	    };
	
	    return Client;
	}
	
	function sendRequest(request, resolve) {
	
	    var client = request.client || xhrClient;
	
	    resolve(client(request));
	}
	
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	
	/**
	 * HTTP Response.
	 */
	
	var Response = function () {
	    function Response(body, _ref) {
	        var url = _ref.url;
	        var headers = _ref.headers;
	        var status = _ref.status;
	        var statusText = _ref.statusText;
	        classCallCheck(this, Response);
	
	
	        this.url = url;
	        this.body = body;
	        this.headers = headers || {};
	        this.status = status || 0;
	        this.statusText = statusText || '';
	        this.ok = status >= 200 && status < 300;
	    }
	
	    Response.prototype.text = function text() {
	        return this.body;
	    };
	
	    Response.prototype.blob = function blob() {
	        return new Blob([this.body]);
	    };
	
	    Response.prototype.json = function json() {
	        return JSON.parse(this.body);
	    };
	
	    return Response;
	}();
	
	var Request = function () {
	    function Request(options) {
	        classCallCheck(this, Request);
	
	
	        this.method = 'GET';
	        this.body = null;
	        this.params = {};
	        this.headers = {};
	
	        assign(this, options);
	    }
	
	    Request.prototype.getUrl = function getUrl() {
	        return Url(this);
	    };
	
	    Request.prototype.getBody = function getBody() {
	        return this.body;
	    };
	
	    Request.prototype.respondWith = function respondWith(body, options) {
	        return new Response(body, assign(options || {}, { url: this.getUrl() }));
	    };
	
	    return Request;
	}();
	
	/**
	 * Service for sending network requests.
	 */
	
	var CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };
	var COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };
	var JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };
	
	function Http(options) {
	
	    var self = this || {},
	        client = Client(self.$vm);
	
	    defaults(options || {}, self.$options, Http.options);
	
	    Http.interceptors.forEach(function (handler) {
	        client.use(handler);
	    });
	
	    return client(new Request(options)).then(function (response) {
	
	        return response.ok ? response : Promise$1.reject(response);
	    }, function (response) {
	
	        if (response instanceof Error) {
	            error(response);
	        }
	
	        return Promise$1.reject(response);
	    });
	}
	
	Http.options = {};
	
	Http.headers = {
	    put: JSON_CONTENT_TYPE,
	    post: JSON_CONTENT_TYPE,
	    patch: JSON_CONTENT_TYPE,
	    delete: JSON_CONTENT_TYPE,
	    custom: CUSTOM_HEADERS,
	    common: COMMON_HEADERS
	};
	
	Http.interceptors = [before, timeout, method, body, jsonp, header, cors];
	
	['get', 'delete', 'head', 'jsonp'].forEach(function (method) {
	
	    Http[method] = function (url, options) {
	        return this(assign(options || {}, { url: url, method: method }));
	    };
	});
	
	['post', 'put', 'patch'].forEach(function (method) {
	
	    Http[method] = function (url, body, options) {
	        return this(assign(options || {}, { url: url, method: method, body: body }));
	    };
	});
	
	function Resource(url, params, actions, options) {
	
	    var self = this || {},
	        resource = {};
	
	    actions = assign({}, Resource.actions, actions);
	
	    each(actions, function (action, name) {
	
	        action = merge({ url: url, params: params || {} }, options, action);
	
	        resource[name] = function () {
	            return (self.$http || Http)(opts(action, arguments));
	        };
	    });
	
	    return resource;
	}
	
	function opts(action, args) {
	
	    var options = assign({}, action),
	        params = {},
	        body;
	
	    switch (args.length) {
	
	        case 2:
	
	            params = args[0];
	            body = args[1];
	
	            break;
	
	        case 1:
	
	            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
	                body = args[0];
	            } else {
	                params = args[0];
	            }
	
	            break;
	
	        case 0:
	
	            break;
	
	        default:
	
	            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';
	    }
	
	    options.body = body;
	    options.params = assign({}, options.params, params);
	
	    return options;
	}
	
	Resource.actions = {
	
	    get: { method: 'GET' },
	    save: { method: 'POST' },
	    query: { method: 'GET' },
	    update: { method: 'PUT' },
	    remove: { method: 'DELETE' },
	    delete: { method: 'DELETE' }
	
	};
	
	function plugin(Vue) {
	
	    if (plugin.installed) {
	        return;
	    }
	
	    Util(Vue);
	
	    Vue.url = Url;
	    Vue.http = Http;
	    Vue.resource = Resource;
	    Vue.Promise = Promise$1;
	
	    Object.defineProperties(Vue.prototype, {
	
	        $url: {
	            get: function () {
	                return options(Vue.url, this, this.$options.url);
	            }
	        },
	
	        $http: {
	            get: function () {
	                return options(Vue.http, this, this.$options.http);
	            }
	        },
	
	        $resource: {
	            get: function () {
	                return Vue.resource.bind(this);
	            }
	        },
	
	        $promise: {
	            get: function () {
	                var _this = this;
	
	                return function (executor) {
	                    return new Vue.Promise(executor, _this);
	                };
	            }
	        }
	
	    });
	}
	
	if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(plugin);
	}
	
	module.exports = plugin;

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bonus-bar\"><div class=\"bonus-item bet\"><div class=\"item-back forzen\"><div class=\"item-show\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"lockmoney\"></div></div></div></div><div class=\"bonus-item count-down\"><div class=\"count-down-back\"><div class=\"count-down-show\"><div class=\"count-down-num\" v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\" v-html=\"countDown | time\"></div></div></div></div><div class=\"bonus-item bonus\"><div class=\"item-back balance\"><div class=\"item-show\" @touchend=\"showMessage\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\"></div></div></div></div></div>";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(81)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\PlayPanel.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(84)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-5febd0b0/PlayPanel.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(79);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.playpanel {\n    /*background: url(../assets/切图/主界面/主操作.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    /*background: rgba(255, 0, 0, .3);*/\n}\n\ndiv.single {\n    /*background: rgba(0, 255, 255, .6);*/\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    /*background: rgba(0, 255, 255, .6);*/\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    /*background: rgba(0, 255, 255, .6);*/\n}\n\ndiv.bonudnum {\n    background: url(" + __webpack_require__(80) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/PlayPanel.vue?c92bd74a"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+NA;IACA,sDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;CACA;;AAEA;IACA,WAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;IACA,kBAAA;IACA,oCAAA;CACA;;AAEA;IACA,sCAAA;IACA,gCAAA;CACA;;AAEA;IACA,sCAAA;IACA,qBAAA;IACA,+BAAA;CACA;;AAEA;IACA,6BAAA;CACA;;AAEA;IACA,4BAAA;CACA;;AAEA;IACA,mBAAA;IACA,sCAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"PlayPanel.vue","sourcesContent":["<template lang=\"pug\">\n    //- 主游戏区\n    div.playpanel\n        div.table-panel(v-el:panel,v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n            div.num.single(v-bind:style=\"single\",@touchend=\"dobet('single')\")\n                img.chip(v-for=\"item in bets|filterBy 'single' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.double(v-bind:style=\"double\",@touchend=\"dobet('double')\")\n                img.chip(v-for=\"item in bets|filterBy 'double' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.zero(v-bind:style=\"zero\",@touchend=\"dobet(0)\")\n                img.chip(v-for=\"item in bets|filterBy 0 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.one(v-bind:style=\"one\",@touchend=\"dobet(1)\")\n                img.chip(v-for=\"item in bets|filterBy 1 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.two(v-bind:style=\"two\",@touchend=\"dobet(2)\")\n                img.chip(v-for=\"item in bets|filterBy 2 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.three(v-bind:style=\"three\",@touchend=\"dobet(3)\")\n                img.chip(v-for=\"item in bets|filterBy 3 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.four(v-bind:style=\"four\",@touchend=\"dobet(4)\")\n                img.chip(v-for=\"item in bets|filterBy 4 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.five(v-bind:style=\"five\",@touchend=\"dobet(5)\")\n                img.chip(v-for=\"item in bets|filterBy 5 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.six(v-bind:style=\"six\",@touchend=\"dobet(6)\")\n                img.chip(v-for=\"item in bets|filterBy 6 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.seven(v-bind:style=\"seven\",@touchend=\"dobet(7)\")\n                img.chip(v-for=\"item in bets|filterBy 7 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.eight(v-bind:style=\"eight\",@touchend=\"dobet(8)\")\n                img.chip(v-for=\"item in bets|filterBy 8 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.nine(v-bind:style=\"nine\",@touchend=\"dobet(9)\")\n                img.chip(v-for=\"item in bets|filterBy 9 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.big(v-bind:style=\"big\",@touchend=\"dobet('big')\")\n                img.chip(v-for=\"item in bets|filterBy 'big' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.small(v-bind:style=\"small\",@touchend=\"dobet('small')\")\n                img.chip(v-for=\"item in bets|filterBy 'small' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.formula(v-bind:style=\"formula\",v-html=\"bonusNum\") \n            div.num.bonudnum(v-bind:style=\"bonudnum\")\n                table\n                    tr\n                        td(v-html=\"userBet.betnum\")\n        img(v-bind:src=\"tablePanelImg\",v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],\n    data() {\n        return {\n            tablePanelImg: require('../assets/切图/主界面/主操作.png'),\n            chipImg: require('../assets/切图/主界面/5X筹码-拷贝.png'),\n            imgSize: {\n                width: 640,\n                height: 528\n            }\n        }\n    },\n    computed: {\n        // TODO 重新设定中奖规则\n        bonusNum() {\n            var nums = this.lotterynum.lotterynums.split(',')\n            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1])\n            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')'\n        },\n        single() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'\n            }\n        },\n        double() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        zero() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        one() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        two() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        three() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        four() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        five() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        six() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        seven() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        eight() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        nine() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        big() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'\n            }\n        },\n        small() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        formula() {\n            return {\n                width: 210 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                // height: 83 * this.zoomRate.y + 'px',\n                fontSize: 42 * this.zoomRate.x + 'px',\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'\n            }\n        },\n        // TODO 遍历上期下注记录，计算筛选是否有中奖号码\n        bonudnum() {\n            return {\n                width: 68 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                fontSize: 40 * this.zoomRate.x + 'px',\n                height: 68 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        bet(event) {\n            console.log('Height' + event.target.offsetHeight)\n            console.log('Width' + event.target.offsetWidth)\n            console.log(event)\n        },\n        // 用户下注\n        dobet(num) {\n            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return\n            if (this.countDown < 10) return // 倒计时小于10秒时禁止下注\n            if (Object.prototype.toString.call(num) === '[object Number]') {\n                this.userBet.type = 'NUMBER'\n                this.userBet.betnum = num\n            } else if (Object.prototype.toString.call(num) === '[object String]') {\n                switch (num) {\n                    case 'single':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'double':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'big':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    case 'small':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    default:\n                        break\n                }\n            }\n            this.bets.push(Object.assign({}, this.userBet))\n        }\n    },\n    events: {\n        cancelBet(event) {\n            this.bets = []\n        }\n    }\n}\n</script>\n<style>\n.playpanel {\n    /*background: url(../assets/切图/主界面/主操作.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    /*background: rgba(255, 0, 0, .3);*/\n}\n\ndiv.single {\n    /*background: rgba(0, 255, 255, .6);*/\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    /*background: rgba(0, 255, 255, .6);*/\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    /*background: rgba(0, 255, 255, .6);*/\n}\n\ndiv.bonudnum {\n    background: url(../assets/切图/主界面/显示-红.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABJCAYAAACesWDiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4NzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4ODNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTg1M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTg2M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Uv2HIAAABDxJREFUeNrsnLGOFDEMhuPM6BDFFbRX8wR0xyvwKDwPj8JrUCNETUd1BTppJyGZtXP/eDPL5ITAIEfKJuzMLcmX3453FQ99+JxDKeuLl215f/+WYnm5cRS75SaWl1vnsFtuK6AXzmG3vJh77/549zpMRGudS43cj9Cncl/klri1VKpTzTmvbeJ2KW3iKv0T92t9+fHrxed0AQmYKcY+JIHDfYFkClCFUsaUuF9h1DELnMhwysVAKe1+zi6gCmdmKFgRFKonGgMkqmmgRDW8oAvft466zDXvQOoCQjBzT0UMZmIo0aKJMZQy0LNieJyiHuIaCpg1xinX8lFAUUwM/BCqBxWEcKyYWVUNQkLTaqoBkNIuIyYWFZyeiUVlXmRIPWJmAofApBZ1b+Y5LyMKmjo7l/gmkWsEcyNLgLjWsYnPEX+5sK+ReyYGlHbUvwsodkxK4CC4CKZlAVKG700Z4ZxtrznkSZw57MpDu1hU7UW/Y2JWdrLEviZpQAxJNpfM/QTvHQJEoCJCtfSqChQtKEjMhhiSVpdUwpgu5zETk0lj1NyDYzGaxvgn8FavASVQj4hgTEHgW5opyfvS11u9AUirMiA4jAxJnHZmVUlMtMKBXe4YINiVNhDA5Mjo9zGSbR63eFZ7hsUVeMRwaFRBBE44dPwLQiFDwWIWNTAkUv6FOr6WrvigeGhVQFEXgaGxSJp2xhbVHI6OdX6OhLutkWhadidRkphVfubYYvDigByQA3JADsgBOSAH5MUBOSAH5IAckANyQA7IiwNyQA7IATkgB+SAHJADcgQOyAE5IAfkgP7ZMnw+KHfa9fwNn+aykNvZUhF2xvzbFSR5V3hCtP2HfA0HZgYOjC2pORwd67ynEsmxynBULXfuwaO2ZAUSLipA6s1hnaO659eAeOLtA+RIbXg6RiunSTdHbY0cAw4q07AtNtekr19Z2F0FSaZewJSi8HQIMvFA8KgtXVmJv6WgxEl0Mqek3QRcPwyo0ZYENEgp2uQ9dI7amlAQugmBpKrksKLCxhQkeZ7c3xyhVfeKp49GdrGWzIIq6kFSwA4DEtVgexYMO+SwzcnCncJUOpRSkOSsLqov7ZCJJfWHa6ZeTUaLsTnBHDo5WVZ8UM/EeA4JUsFRUUOAFlaDJHpIuuKajMam1BJDxCUZAtQzsUW1GtSYidU/DGGTw7DmYik/JQ68maCxSBohLQrSSf17SEEnmbQCFOBrxQR+qqU8GlKRLNwiDjmE7hMXTqMKak8kWGmlc9DIQBKkZ2L8Y/rBAqAgVNKiIE0jJkbskLNyfJtcK0hGM/loCgh4EzjsCxWVuS6jgMQhB6We9nATMK1r+VZWoukjDzc5bGL4FJTMO9jyn/7eM8HG4z+Y+S+KDuiPFwqv7u9K+6bUO8exKd9K/VSd9GOp353HRalMHiugh1K/BH/Ymy5VOA8/BRgA3V2MtlWnR+sAAAAASUVORK5CYII="

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],
	    data: function data() {
	        return {
	            tablePanelImg: __webpack_require__(82),
	            chipImg: __webpack_require__(83),
	            imgSize: {
	                width: 640,
	                height: 528
	            }
	        };
	    },
	
	    computed: {
	        bonusNum: function bonusNum() {
	            var nums = this.lotterynum.lotterynums.split(',');
	            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1]);
	            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')';
	        },
	        single: function single() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'
	            };
	        },
	        double: function double() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        zero: function zero() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        one: function one() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        two: function two() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        three: function three() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        four: function four() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        five: function five() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        six: function six() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        seven: function seven() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        eight: function eight() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        nine: function nine() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        big: function big() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'
	            };
	        },
	        small: function small() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        formula: function formula() {
	            return {
	                width: 210 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	
	                fontSize: 42 * this.zoomRate.x + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'
	            };
	        },
	        bonudnum: function bonudnum() {
	            return {
	                width: 68 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	                fontSize: 40 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        bet: function bet(event) {
	            console.log('Height' + event.target.offsetHeight);
	            console.log('Width' + event.target.offsetWidth);
	            console.log(event);
	        },
	        dobet: function dobet(num) {
	            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return;
	            if (this.countDown < 10) return;
	            if (Object.prototype.toString.call(num) === '[object Number]') {
	                this.userBet.type = 'NUMBER';
	                this.userBet.betnum = num;
	            } else if (Object.prototype.toString.call(num) === '[object String]') {
	                switch (num) {
	                    case 'single':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'double':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'big':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'small':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    default:
	                        break;
	                }
	            }
	            this.bets.push((0, _assign2.default)({}, this.userBet));
	        }
	    },
	    events: {
	        cancelBet: function cancelBet(event) {
	            this.bets = [];
	        }
	    }
	};

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAIQCAYAAAARq99gAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4MzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4NDNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTgxM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTgyM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+vclhJQAAXSNJREFU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"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAlCAYAAAAqXEs9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5NzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDk5ODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQkE2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTk2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EVwcGQAADetJREFU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"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "<div class=\"playpanel\"><div class=\"table-panel\" v-el:panel=\"v-el:panel\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"><div class=\"num single\" v-bind:style=\"single\" @touchend=\"dobet('single')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'single' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num double\" v-bind:style=\"double\" @touchend=\"dobet('double')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'double' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num zero\" v-bind:style=\"zero\" @touchend=\"dobet(0)\"><img class=\"chip\" v-for=\"item in bets|filterBy 0 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num one\" v-bind:style=\"one\" @touchend=\"dobet(1)\"><img class=\"chip\" v-for=\"item in bets|filterBy 1 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num two\" v-bind:style=\"two\" @touchend=\"dobet(2)\"><img class=\"chip\" v-for=\"item in bets|filterBy 2 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num three\" v-bind:style=\"three\" @touchend=\"dobet(3)\"><img class=\"chip\" v-for=\"item in bets|filterBy 3 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num four\" v-bind:style=\"four\" @touchend=\"dobet(4)\"><img class=\"chip\" v-for=\"item in bets|filterBy 4 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num five\" v-bind:style=\"five\" @touchend=\"dobet(5)\"><img class=\"chip\" v-for=\"item in bets|filterBy 5 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num six\" v-bind:style=\"six\" @touchend=\"dobet(6)\"><img class=\"chip\" v-for=\"item in bets|filterBy 6 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num seven\" v-bind:style=\"seven\" @touchend=\"dobet(7)\"><img class=\"chip\" v-for=\"item in bets|filterBy 7 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num eight\" v-bind:style=\"eight\" @touchend=\"dobet(8)\"><img class=\"chip\" v-for=\"item in bets|filterBy 8 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num nine\" v-bind:style=\"nine\" @touchend=\"dobet(9)\"><img class=\"chip\" v-for=\"item in bets|filterBy 9 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num big\" v-bind:style=\"big\" @touchend=\"dobet('big')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'big' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num small\" v-bind:style=\"small\" @touchend=\"dobet('small')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'small' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num formula\" v-bind:style=\"formula\" v-html=\"bonusNum\"> </div><div class=\"num bonudnum\" v-bind:style=\"bonudnum\"><table><tr><td v-html=\"userBet.betnum\"></td></tr></table></div></div><img v-bind:src=\"tablePanelImg\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"/></div>";

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(86)
	__vue_script__ = __webpack_require__(91)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\State.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(93)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0ce74191/State.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(87);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(" + __webpack_require__(88) + ") 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets/切图/主界面/头像1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(" + __webpack_require__(89) + ") 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(" + __webpack_require__(90) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets/切图/商城/金币.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n", "", {"version":3,"sources":["/./src/components/State.vue?46a91f68"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;IACA,gBAAA;IACA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,4DAAA;IACA,yBAAA;CACA;;AAEA;IACA,2EAAA;IACA,YAAA;IACA,aAAA;IACA;+BACA;IACA,aAAA;CACA;;AAEA;IACA,kDAAA;IACA,6BAAA;IACA,yBAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;IACA,YAAA;CACA;;AAEA;IACA,sBAAA;CACA;;;AAGA;;GAEA;;AAEA;IACA,oDAAA;IACA,6BAAA;IACA,iCAAA;CACA;;AAEA;IACA,YAAA;IACA,iBAAA;CACA;;AAEA;IACA,aAAA;IACA,+CAAA;IACA,iBAAA;CACA","file":"State.vue","sourcesContent":["<template lang=\"pug\">\n    //- 状态区 ，展示用户的一些状态\n    div.state\n        div.state-item.money.table\n            div.money-state.table-cell\n                div.button\n                    table\n                        tr\n                            td\n                                span.money-num(contenteditable=\"true\",@keyup=\"checkData\",@blur=\"changeData\",v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\",v-html=\"userBet.betmoney\")\n        div.state-item.portrait\n            div.polygon(@touchend=\"showMessage\",v-bind:style=\"headstyle\")\n                svg(xmlns=\"http://www.w3.org/2000/svg\",version=\"1.1\",v-bind:width=\"headsize.width+'px'\",v-bind:height=\"headsize.height+'px'\")\n                    defs\n                        pattern(id=\"image\",x=\"0\",y=\"0\",patternUnits=\"userSpaceOnUse\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                            image(v-el:image,x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                    polygon(v-bind:points=\"headborder\",fill=\"url(#image)\")\n                    image(x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\",v-bind:xlink:href=\"headborderimg\")\n        div.state-item.stars.table\n            div.money-state.table-cell\n                div.button.undo(@click=\"cancelbet\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userBet', 'userinfo'],\n    ready() {\n        console.log(this.zoomRate)\n        console.log(this.$els.image)\n    },\n    data() {\n        return {\n            headzoom: 1.2,\n            headborderimg: require('../assets/切图/主界面/头像1.png')\n        }\n    },\n    watch: {\n        'userinfo.headimgurl': function(newval) {\n            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval)\n        }\n    },\n    computed: {\n        headsize() {\n            return {\n                width: 142 * this.headzoom * this.zoomRate.x,\n                height: 165 * this.headzoom * this.zoomRate.y\n            }\n        },\n        headborder() {\n            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y\n        },\n        headstyle() {\n            return {\n                // width: 640 / 3 * this.zoomRate.x + 'px',\n                // height: 640 / 3 * this.zoomRate.y + 'px',\n                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' //\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ')'\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ',' + this.headsize.height / (1008 * 0.17) + ')'\n            }\n        }\n    },\n    methods: {\n        showMessage() {\n            this.$dispatch('showMessage', 5) // 5代表背景数组的最后一个，即显示充值的背景\n        },\n        cancelbet() {\n            this.$dispatch('cancelbet')\n        },\n        checkData(event) {\n            // console.log(/\\d+/.test(event.target.innerHTML))\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 //最小值为 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        },\n        changeData(event) {\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 //最小值为 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        }\n    }\n}\n</script>\n<style>\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(../assets/th.jpg) 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets/切图/主界面/头像1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(./../assets/切图/主界面/撤销.png) 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(./../assets/切图/主界面/投注金额.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets/切图/商城/金币.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGMjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkI2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkI3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0Y1lLQAAHf9JREFU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"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCNDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNkNBNkJCNTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkIyM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkIzM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++LpzqQAAEvFJREFU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"

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userBet', 'userinfo'],
	    ready: function ready() {
	        console.log(this.zoomRate);
	        console.log(this.$els.image);
	    },
	    data: function data() {
	        return {
	            headzoom: 1.2,
	            headborderimg: __webpack_require__(92)
	        };
	    },
	
	    watch: {
	        'userinfo.headimgurl': function userinfoHeadimgurl(newval) {
	            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval);
	        }
	    },
	    computed: {
	        headsize: function headsize() {
	            return {
	                width: 142 * this.headzoom * this.zoomRate.x,
	                height: 165 * this.headzoom * this.zoomRate.y
	            };
	        },
	        headborder: function headborder() {
	            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y;
	        },
	        headstyle: function headstyle() {
	            return {
	                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' };
	        }
	    },
	    methods: {
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        cancelbet: function cancelbet() {
	            this.$dispatch('cancelbet');
	        },
	        checkData: function checkData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        },
	        changeData: function changeData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        }
	    }
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "<div class=\"state\"><div class=\"state-item money table\"><div class=\"money-state table-cell\"><div class=\"button\"><table><tr><td><span class=\"money-num\" contenteditable=\"true\" @keyup=\"checkData\" @blur=\"changeData\" v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\" v-html=\"userBet.betmoney\"></span></td></tr></table></div></div></div><div class=\"state-item portrait\"><div class=\"polygon\" @touchend=\"showMessage\" v-bind:style=\"headstyle\"><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" v-bind:width=\"headsize.width+'px'\" v-bind:height=\"headsize.height+'px'\"><defs><pattern id=\"image\" x=\"0\" y=\"0\" patternUnits=\"userSpaceOnUse\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"><image v-el:image=\"v-el:image\" x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"></image></pattern></defs><polygon v-bind:points=\"headborder\" fill=\"url(#image)\"></polygon><image x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\" v-bind:xlink:href=\"headborderimg\"></image></svg></div></div><div class=\"state-item stars table\"><div class=\"money-state table-cell\"><div class=\"button undo\" @click=\"cancelbet\"></div></div></div></div>";

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(95)
	__vue_script__ = __webpack_require__(97)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetMultiple.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(98)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-8ff4067e/BetMultiple.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(96);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n", "", {"version":3,"sources":["/./src/components/BetMultiple.vue?3803979b"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA;IACA,iCAAA;IACA,YAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,aAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,gBAAA;IACA,gBAAA;IACA,eAAA;IACA,qBAAA;IACA,oEAAA;IACA,kBAAA;IACA,mBAAA;CACA","file":"BetMultiple.vue","sourcesContent":["<template lang=\"pug\">\n    //- 选择下注部分\n    div.multiple\n        div.bet-button-area.one\n            div.table-cell\n                a.button 1X\n        div.bet-button-area.five\n            div.table-cell\n                a.button 5X\n        div.bet-button-area.ten\n            div.table-cell\n                a.button 10X\n</template>\n<script>\nexport default {\n    data() {\n        return {}\n    }\n}\n</script>\n<style>\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 97 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multiple\"><div class=\"bet-button-area one\"><div class=\"table-cell\"><a class=\"button\">1X</a></div></div><div class=\"bet-button-area five\"><div class=\"table-cell\"><a class=\"button\">5X</a></div></div><div class=\"bet-button-area ten\"><div class=\"table-cell\"><a class=\"button\">10X</a></div></div></div>";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(100)
	__vue_script__ = __webpack_require__(103)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\Message.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(160)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-33fdb807/Message.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(101);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(" + __webpack_require__(102) + ");\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n", "", {"version":3,"sources":["/./src/components/Message.vue?5d23d056"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,aAAA;IACA,mCAAA;IACA,0CAAA;IACA,OAAA;IACA,sBAAA;CACA;;AAEA;IACA,iCAAA;IAAA,yBAAA;CACA;;AAEA;;IAEA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,sBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA","file":"Message.vue","sourcesContent":["<template lang=\"pug\">\n    div.model(v-show='dialogShow',transition=\"message\")\n        div.dialog(v-bind:style=\"dialog\")\n            div.close(v-bind:style=\"close\",@touchend=\"dialogShow = false\")\n            div.content(v-bind:style=\"content\")\n            div(v-bind:is=\"dialogImg[currentIndex].type\",v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\")\n            img(v-bind:src=\"dialogImg[currentIndex].background\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo'],\n    data() {\n        return {\n            dialogShow: false,\n            currentIndex: 0,\n            dialogImg: [{\n                type: 'betInfo',\n                background: require('../assets/切图/投注记录/投注记录.png'),\n                close: require('../assets/切图/投注记录/关闭.png')\n            }, {\n                type: 'bonusRecord',\n                background: require('../assets/切图/开奖记录/开奖记录.png'),\n                close: require('../assets/切图/开奖记录/关闭.png')\n            }, {\n                type: 'ruleIntroduce',\n                background: require('../assets/切图/游戏规则/游戏规则.png'),\n                close: require('../assets/切图/游戏规则/关闭.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets/切图/商城/兑换商城.png'),\n                close: require('../assets/切图/商城/关闭.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets/切图/赠送/赠送好友金币.png'),\n                close: require('../assets/切图/赠送/关闭.png')\n            }, {\n                type: 'recharge',\n                background: require('../assets/切图/充值/底.png'),\n                close: require('../assets/切图/充值/关闭.png')\n            }]\n        }\n    },\n    computed: {\n        dialog() {\n            return {\n                width: 550 * this.zoomRate.x + 'px',\n                height: 760 * this.zoomRate.y + 'px',\n                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'\n            }\n        },\n        content() {\n            return {\n                width: 478 * this.zoomRate.x + 'px',\n                height: 618 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\n            }\n        },\n        close() {\n            return {\n                width: 42 * this.zoomRate.x + 'px',\n                height: 42 * this.zoomRate.y + 'px',\n                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',\n                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'\n            }\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.dialogShow = true\n            this.currentIndex = event\n        }\n    },\n    components: {\n        betInfo: require('./messageComponent/betInfo.vue'),\n        bonusRecord: require('./messageComponent/bonusRecord.vue'),\n        exchange: require('./messageComponent/Exchange.vue'),\n        Recharge: require('./messageComponent/Recharge.vue'),\n        ruleIntroduce: require('./messageComponent/ruleIntroduce.vue')\n    }\n}\n</script>\n<style>\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(../assets/切图/暗色挡板.png);\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZEQzMwRDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZEQzMwRTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkRDMzBCM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkRDMzBDM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+X2ymawAAAA9JREFUeNpiYGBgmAkQYAAAngCaoMXLCwAAAABJRU5ErkJggg=="

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    data: function data() {
	        return {
	            dialogShow: false,
	            currentIndex: 0,
	            dialogImg: [{
	                type: 'betInfo',
	                background: __webpack_require__(104),
	                close: __webpack_require__(105)
	            }, {
	                type: 'bonusRecord',
	                background: __webpack_require__(106),
	                close: __webpack_require__(107)
	            }, {
	                type: 'ruleIntroduce',
	                background: __webpack_require__(108),
	                close: __webpack_require__(109)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(110),
	                close: __webpack_require__(111)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(112),
	                close: __webpack_require__(113)
	            }, {
	                type: 'recharge',
	                background: __webpack_require__(114),
	                close: __webpack_require__(115)
	            }]
	        };
	    },
	
	    computed: {
	        dialog: function dialog() {
	            return {
	                width: 550 * this.zoomRate.x + 'px',
	                height: 760 * this.zoomRate.y + 'px',
	                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        close: function close() {
	            return {
	                width: 42 * this.zoomRate.x + 'px',
	                height: 42 * this.zoomRate.y + 'px',
	                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',
	                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'
	            };
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.dialogShow = true;
	            this.currentIndex = event;
	        }
	    },
	    components: {
	        betInfo: __webpack_require__(116),
	        bonusRecord: __webpack_require__(122),
	        exchange: __webpack_require__(128),
	        Recharge: __webpack_require__(140),
	        ruleIntroduce: __webpack_require__(154)
	    }
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMDVDNDY0MjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMDVDNDY0MzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAwNUM0NjQxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Ii2N+QAAGLNJREFU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AAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhYhcAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCpAv09fT4jgDAKuumo29XhclArzABgNU22Ns9OdBVYTLS1+enAwBW2Yb+7jn+dlWYbBoc8NMBAKvsp7ro+NtVYbJ53UBXnU4CgDe7OO5uFiblYobJCSNDfkoAYJXEcbebpnh23emJqLafWb/OTwoAdFgcbzd32TSKrrxuctzwUDpqaNBPDAB0SBxn43jbbfq7cWfFGaW3jqxPhw30p2fGJ9LETNVPEACsgKG+3lqQbO7SG076u3nnxU6LO3X2Tk6lfZWptH96JlWq1TTr5woA2v5lPya4xi3BcUyNG026edWw/kNhh27JdmIMAODNzb25AIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAoD5MKgu29PXZKwBA59U3RyXCZDS/pWfdoB0FAHRcSXOMRpg8n9/Su2HEngIAOq6kOZ6PMHksv6VvyyZ7CgDouJLmeCzC5KH8lv6tR9lTAEDH9W89urjpwQiTe/JbBre9zZ4CADpucNvJxU33RJh8NxvPzW/pPeKwNLTjdHsLAOiYaI1ojpxokQciTKrZ+NKCgjntVHsMAOiYktb4Utq+szq/wNoNKbeeScwzGTr7THsNAFhx0RiFOa2VuRY5uPJrnD75q/wzhi84N/W95Uh7DwBYMX0/vaXWGAV/k7bvfC4fJuHqbOzNP2vkwvNSz9CQvQgALFs0xcjO84uboz1+f/4PvYUHPpl/Zv/xx6QNF7839QwO2JsAwNKjZN1grSmiLQo+nbbv3FsWJuEr2bgpv2HgxBPSxkt/2WUdAGBJoiE2fugDtaYo+IssSv5+QcDM7rqz+KRYuP7WbFxUfGD87m+nifsesocBgLYMnX1GGr7gnWUP3Z6ND2ZhUmkVJmE4G/+YjZ3FB6b3vJAqu3aniQe+Z28DAOVBsuP02i3BDVaU/9dsXJJFyXjxgUZhEmJiyReycUXZg9VXf5Iqj/4wC5Xn08zL+1J1dH+ancyip1r13QCAtaK3tzZ/pHfjhtp738Qy84PbTkq9Rxze6CNiysinsiiZKnuwv8mnig+4MhvfmguULQu+juwTxukZAIA2vJxiomtKtzTtnDZeKCbEbsvGjSm3CBsAQBsqcw2xrVWUtBsm85VzVTZOzMafZGOP/QwANLFnrhlOnGuIl9v5oGZzTFoFzY5sxCopcT0n3pI4bkzekF6fmwIArA0x9WN/en0V+cezEbfvfjMbD6TX34+v3PadpZv/T4ABAMFnY+3Ft1qIAAAAAElFTkSuQmCC"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMxRDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMxRTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQ0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzFDM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MfthnAAABlJJREFU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"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyNjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzIzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzI0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+M8ZK3gAAF+xJREFU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TAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMLnwv0xbm38RAJhjLS0twqRI27wOnw4AmOvjb3vzHH+bKkzmL1jo0wEAc6xzYbcwKdK1ZKlPBwBcwsffpgqT7t5laV67yzkAMFfiuNvd2ydMisTkm2Vr1/uUAMAcieNuS0vz5EDT3S4c1da78jKfFABosDjeNtPZkqYMk9C35orUs3y1TwwANEjP8lWl422zmdeUe6ulJS2/fH1asGhxOrB7Zxo9OewTBAB10D6/M/Vdti51L+lryt9vXjPvvNhpXT1L09FDA+nY4YPp5PGj6dToSBobG/PJAoCa/q/fUprgOn9hd+num7jRpJkWVLuowqS8QxctXV4aAMBHm2flAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAgIlhMlK5oa21xV4BABquoDlGIkyGKrd0tDmJAgA0XkFzDMWW/sotXfPb7SkAoOEKmqM/wuStyi1LuzrsKQCg4Qqa460Ik5cqt6zqWWBPAQANt7pnYX7TixEm2yq3bFjRY08BAA13zYrF+U3bIkyez8au8pbFC9rTTZcvtbcAgIaJ1ojmqBAt8kKEyZlsPF75yg2rl9hjAEDDFLTG45vXpzPl+3S+kSrWM4l5JhvXLbPXAIC6i8bIzWkdOdci51d+jdMnf1v5jk9vWJmWL+q09wCAulnW3VlqjJy/37z+7LSSypVN/iwbByrftena1amzvc1eBABmLZrijutW5TdHe/xJ+YvW3At/UPnOtb0L069+cm1qtxosADALHfNaS02xtrcr/9JXN6//8MRIyxPvjOXf8M1s3Fe5Ydeh42nbW/1p/9CwPQsATMvy7s606brVpRMeOY9lUTKuOYrCJJZh++ds3J1/4btv700v7TxgDwMANbllXV/6pQ2ril56Ohu/mYXJyFRhEiJpnsrGnfkX9g6eSK/3H06vvH/Q3gYACsU6JXFLcJUV5Z/Jxj1ZlBzPv1AtTEKsevJIyl3WKRs8MZJ+8sFQ6h88ng4eG0lHT46mkVNn0pmxMf8aAHCJaG1pKc0f6Z7fXnr2TSwz/7EVi1LPgqrP3ns0Gw9kUTJa9OJkYVK2+VygWNgEAJipgWx8NRtPlOJifZXQqeEHbcnG9enspNgR+xUAmIaRcw1xfTlKJlPrfcBROfdn4+psfD0bu+1nAGASu881w9XnGmKglm+q5VJOtaC5NRt3ZOOWbGzIxtpsdKezc1MAgEtDzBU5ms6uIv92Nl7Kxn9l44V09nl8hapdyvl/AQYAVOAKyrWfc2EAAAAASUVORK5CYII="

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyQ0I2ODYzNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyQ0I2ODYzNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJDQjY4NjMyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJDQjY4NjMzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IMkNPQAABoZJREFU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"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNkE4MjEwNjNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozQzNFNkNCQTNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM2QTgyMTA0M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM2QTgyMTA1M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jGVjpAAAGdJJREFU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TAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTGwCAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwsQmAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABg1YZJ1/Sk3wgArLTpaWFSaeqINwcArLCuDtr/dlSYdB/9qXcHAKz4/veQMKnSM/6idwcArOL9b0eFSe/4gdQ1NeEdAgArJPa7sf8VJlWmp1PfyG7vEgBYITP7XYNfG+sZfyGtGXvWOwUA2iz2t7Hf7SQdOY/JmtHh1PvT57xjAKBNYj8b+9uO+746c3PFKZ2nUs/ESJpYtyVN9/R7BwHAMuiaHE99o3s67khJh4fJrNhoL5t4MR3tH0yT/aelqd6BLFL6YrN6ZwFAi3/sd01OpO6jYzNX38wMdO2gMSUnVJjMbs/p1Ht4/8wCAJzc3CsHABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAA1IfJRHFNj60CAKxAhdQ1x0SEyUjxSf02FACwAmFS1xwjESbPFFb1rbOhAID2q2+OZyJMHiusWrvRhgIA2q++OR6LMHmgsGrduTYUANB+6zaX1+yMMPlmYdXgpTYUANB+g5eU13wzwuS+bNkzv6p/Q0pnb7exAID2idaI5jgmWuT+CJOpbPls4clnDNlgAED71LfGZ9PQjqnaBGufSPn5TGKcyaarbTQAYPlFYxTHtE7Mtcj8zK9x+ORThU/a+rqUBs628QCA5TNw1mxjFH0mDe3Ykw+T8MFs2V942vlvSKl3rY0IABy/aIqfe2N5bbTHX9Q+6C498MeFp67fmtJFv5VST5+NCQAsXU//bFOcurX8yK1paMf+qjAJn8+WTxbWbLggpW1vcVoHAFiaOH2z7cbZpii6LYuSz+VXVN1d+NZs+XJhTRw5GXpnSpuusnEBgNZFOwz9wWxLFEVr3FJe2TX98B2VbZMtX8yWHXWPjD6d0r5dKe3daWMDANVinpK4JLh6RvmvZMuNaWjHWKthEtZky8ey5V2Vj46/mNKBx7JQGU7p8P6UJkZSmhxPaXrKLwMAVouu7tnxI33rZ+99E9PMD25Lqf+0Rp8RQ0ZuyaLkSNWDvU2+VHzCu7Pl7rlAOaPwaHxBp3YAgNbsS7PDRf6l2ZO6W3ihGBAbN9D5+5SfhA0AYGETcw1x6UJR0mqY1CrnPdlyYbb8VbYM284AQBPDc81w4VxD7Gvlk5qNMVkoaK7MltdmyxXZcnG2bMmWdWl2bAoAsDrE0I/RNDuL/A+y5YFs+Ua23J9m78dXbWhH5er/F2AAstWqWoT5nd4AAAAASUVORK5CYII="

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyMTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyMjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzFGM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzIwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++YKmbwAABkhJREFU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"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5ODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5OTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjk2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjk3M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MTGWBAAAFjdJREFU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CQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAEAEyWh+w6K2drMCALRMSWuMRpAMTLpRe7eZAgBaFyS1rTEQQXIov6Wte7mZAgBapqQ1DkWQPJPfsrj3EjMFALRMSWs8E0Hy0/yWjos2mykAoGVKWmNPBMkj+S1dl15tpgCAlilpjUciSP4zGweqWxb39KUlm28yWwBA00VjRGvkRIPsjiAZz8Z9+T3dG95kxgCApitpjPvSmu3j1QujfSHlrkfScdHrUs/W7WYNAGiaaItojJzRiQZ57Uqtcbjky/lb9L7+3al9xXqzBwDMWfvySyttUfDVtGb7gXyQhD/PxtH8rZZddXta1NFjFgGAWYuWWHbVjuLmaI4/q37TVtjxR/lbdvRtTSuu+1Ba1N5lNgGAmcdIe3elJTr6Lyvu+mRas/1oWZCEB7LxpfyGzouvTCt/6+PevgEAZqR9+bqsIe6qtETBvVmMfH1SuJw+9FDxRp3Z+EY23lHcMfjkt9PQc7vMMAAwpVjAWrJmJDyYjduyIBmdLkgq95ONb2bjbcUdJ1/+RRre/5N0Yt+jZhsAmCSuMxKn9hbOpqn6XjZuz8ZQFiSpkSAJHdn4XDY+Urbz1NDRNPLC41mg7EunBl9M48PH0/jYcErjp/w2AOB817Y4tbV3p7buFZXPponLwccVWAsXPcuLJSGfyMbJynczCJKq90yESb/ZBwBm6EiKBawp3T9payFI2hq4o1joekU2vphyF08DAJjC6EQ7XFETIyXaGrzTqJuPZWNLNv4mGwfNMwBQ4uBEK2yZaIcjjfyhRt6yqRcy12fjlmxcm41t2YjzgnvTmbUnAMD5LdaCDKYzV3t/Nhs/zcb3s7E7nfmcvKkV3rL5fwEGAEDIMmUyEQC5AAAAAElFTkSuQmCC"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5QzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5RDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlBM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjlCM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+uB+DYwAABmJJREFU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"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwNzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTA1M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTA2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+E7Z1owAAIPNJREFUeNrs3VuMXPd92PH/zN54W5HUUhRJUaJkShR1tWzJdpzU8U1FaiMQCgh1GzdAbw9tWrsPeWkf2j40fQmKtg9OgLYo2pc0dtKqKIzEaWEljgM0tuXYkSVZ1tUWJd4kkVyK5JLcJXem53dmZvfM2TO7s8u96/NJTpY7e51DMf/v/M//nFNrnvpmWoJ6tn0k2z6dbY9l25Fsuy3btmfbSAIANrvJbJvIthPZ9kq2/UW2fSvbvp9tjQW/et/jXe8OLvKHH8y2f5Jtfzvbbvd3AQDvWyPt7eZseyjbnmw//la2/fds++1sO97vN6v3+Xlj7W/8erb9czECAPRwe7sVXm+3w9hyBckXsu2lbPvH2TZsPwMAfRhut0M0xN9c6JMHF/jYV7LtH1V98PTVgfStt7ekF94bSm9eHkxnJuvpynQtTTVq/goAYLPXRr2Ztg40056RRrpj2/X04M5r6dO3Xk37tkyXP3VPtn0t2z6VbV/OtutV36/WY1Hrtmz7vWz75fIHXrwwlP7o1Nb01Fvb/G0AAF2evP1y+tz+K+n+m65VffgPUmu25HJ5UWtVkMTMyFPZ9kT5A7/16mj63WPb7W0AYF5fPDSRvnTPxaoPfT26JQuSrpmSqjUkv1WOkR+dH05/93tjYgQA6Es0w9/J2iEaouSJdmt0Kc+QxDTK14oPfO/sSPqXz+9Kl65bGwIALM6OwWb6jYfOp4+NTZY/9MW07/GvVgVJnJYTK2H3dB54dnw4/bPndqWL1+r2KACwJKNDjfSbD59Pj+yeKj58LtuOZlHybrxTLI1/U4yR8B9eGRUjAMANiZb49y/fVH44Lqj2G513OrVxR7b9g+JnxQLWVy8O2YsAwA177dJg+soro+WH/346/fQdxSD5tWybqY8fvzdkASsAsKy++ub2vDEKhtoNkgdJbL9a/GhcZwQAYLlVNMavptNP1zt37T3YefTUlYH0v4676BkAsPyiMaI1CqJBPhJB8pnio3/6zhZ7CwBYMRWt8ekIkkeLj7zwnoWsAMDKqWiNxyJI7i0+EjfKAwBYKRWtcW8Eyf7iI2cnXXcEAFg5Fa2xPx7pOil4Ytol4gGAlVPRGqMRJF13vbnWECQAwMqpaI1hx2cAgDUnSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAMGgXsNlcuzKRrl2+1Pfnj9y0OzWuX0sXTr7Z9fhNB+5IQ1u3dz129vWfdL2/ddfNadvYrTPvXz77dnrpT7/R9Tm7s+9z18c/m//5Z9/54zRe+DnFj80nfu6xZ7/b9djRT32+62cXxc/p+h0O3pl23X648mP7H/hw2pLtg/Jz61fVfup456UfpYnxM12P9fN8l/O/hee/8fs3/H2GRrako599oufzXA1rvS9BkMAiRViUB+/5xMAeyl9zqB0cReXPOZgN5hE0A0PDS/pdp6cm09UL46lxbao18G3bkQ96xcfC5MTFRX3f8XJc7T3Q82O3Hnmw8rn1vf+yfdRroD7+4x/OibPVdHyJz2lO2ExeTcee+Xa6+5Ofn/fzfvjUf1vV53eXf+4IEthcyrMa/Q7QMeDuuGVfz5mKBePpzNvpxW/+79kIeuTn0tjh+9Kp7PuWw2EjKM8AVYXS+DIP2h9+8u9VPh4zPsu5D+PvKmYp9h79oH8wIEhgYxvZPrqi33/62lSavDA+5/GYYYnDSVWunD+Xz8xsBvEc47lMnDmdTv7k2WX//hGgkxMX0q7b7sxnxW5kduxGbR3d6R8UggQ2ijj2v2Nsb+Ur9X4+v7zeY6GvX8jo3v3p9Ks/XpbnFYPhnPDIYqRqtid+Zq+fGzNBcXiqc+hqPpfePd11GCZ+j6XODq2Equde/Ptb7JqL1779jXxmpOjdN17Lt5TmX8ez0vYevs8/cAQJbBQRF1WDUK/DBvH5nTUVMdAUP+/gIz+XL5aNV+C9giS+ptchhDxI9t2e7v+rfz1NZAN75ave9pqVWIRaXPdRNDA8nLbv2bfsr8z7GVjPvvFK1/u79h/sHvQLv3fMypQjaN89D6z4LFGv2YQ7HvvEor/u0Ec/mV7646/na0j6sZg1MpfOvjPn+8bvuWWBmY/B7O9/NNvHnUXKIEhgAykuNpwvGMLr3/mTfKAof15nsWys86hSdYZN8ZV5P2exxOGT2OYzPTU1c0ZQ+SyfldaZGZgJrFI0FQfJi6ffmhMku247tCYzCoce/YUlBVws1r3nF/9aevXP/k9fUbKYGZiq9TYx6zFm5gNBAnRmSWKgiFNGl9OxZTrjo2ugzeKoOMDXs0H3pj23zjnMEI8NDI/kfy4PghFMMeuykAiMspjx6WVq4tKq/92VZyi2795zQ4uOQ5wSff8vPZkfDivH4mZZewOCBNbjP4r24Pxu6dX9+PGfzcxKrFcxeB548NF0oTRTE491BuXy4ariq/r5ZnEuvHOy6/1b7rx70bMO863xWGqQFWcU4nBbORr6mXVaiq0Vpzuff+v1fAarH1cvvrfgPl6I2RQECWxi23btyf7va3MON5RnHcpidiJeoW/E03U7FjOL09pPqe+AWQ0RHisxE9UrhsozL+PH37ihv//8tOhFfL0gQZDAJrb9ln352SNVawbi8V7T9DE7EbMNvRbMLrR2pWpNwUJfAyBIYJOKsHjol38l//NiFsPSrXxIIs4gWeqpqpfPn5mzoDYMb7eGAwQJbNJBtNc6iuLjvWZQNrr5omuxl0W/UgqSOJ11KYcY4mJvVRc5i8v2lxfVxn11jva5xuf8iWOVpyXHmUD9sKAVBAmsmBhEe61BuNG1CUu5z8lCX7OWF+ZaKCLm/D+b4eF80Wess6gS1y8pB0t8n5/9+dNz4i8W1FZdwj0WmfZ7A7yqha5xjZTl3p/lhbcdVYfoen1ur1PKQZAAXinPo+ry9bEINs5A6bVoMx6P04+L1zI5+dz3Kk9hPvDwxyq/R9VdkRcjvrbfr+8VD4AggRt6FbsUW+e50+1GUnVr+wW/Jhv840ya/Q98OF93sxx++syfpaNZ4MUsRfxO5XUjcajs4Ic+vmb3jwEECayoOLOmcW1qRX/GfJcVj7UrVyquS7HQ19WXaWCOGFns6apX2r9z51L7XR+rOBwSC1DjEEzx+VRdPj2ulHvgvke67pnTcedjf2XZ4gcQJLDunMoGv6VeP6Lfs296XVY8rggb90vpJdY1HHj4oxt+H8esRixCLV9e/tX/93T3/sgCpeqwScxizXdl2PxnDA/3fT+Z6anJOYeDFnOvnfV8gTwQJMCixIzBsWe+Pe8ZO50zQW4kSqZXePanLG6sV1a11iYC4wMf/cX8UM18IhT6Wa8RNx0cLv2cXotUY6Fo+Yq2ve61E9EYN1bs5/sCggSWzXx3XV2uK7FGJLz9k2crF23GoZBipESUTF+bzBdzLrR+YqTikMbbLz+fD6Dn33y98mti9uauBX7f8hk/8y3qrAySHmttYsZk3/jZOafgFvfHrfc90vc+LZ+NEndXvtHDPHEbgfLv57o0IEhgUco3yevnpnnz3XV1fAmn71YN6FVi0Wbc8j4G1vIdZmOBZ3mRZ1UURLCUr5MS0RNnrFQtEl0PIjjOZrFUNVMUNwXsdxFrhEfEZHE9zvG//E7afbA7txaabSnfk+ZsKeQikgBBAosyfqx7EL7QxwzHWtyHJRz++GdmrqWxmNvel93+wY/OOQxSdaXTsTsOr8w+r7ij8HxipqjX84zvNfLcM30fstq572BXkESMlWehFgqShe5JM7Jj1D8sECQwv7HC7EbMNLz4f58qDTY/q5huf2HOILhsh2amJvv6vPLN2uLV/lKjJA6DHMpe4c93TY3FHApZSSez2Oh1uKYjPh6LTftZRxLrQBb6fjdqdO8B/9BAkED/4iyO8mAer5avXhhftdNH4+fFYaKqWYK4emlcMCzO2KhaJBm/49HPPpHP8lRdJyTOKpkvzGItR9XgHIc17vr5x1fkeh5XKy6Ktn139Z2B40JmVb9f1aX5I67KF06rEvvxnl94PB1/7vs9T6W+EfH3uNDvAAgS6HLqJz+qjoSTb84bJDHo3NTjVfBSrgQaZ9LE2pClXEQtvqbqMukLidmhyz0udhYDdcTaSgysVddzqQqfWKdRtS9j39/x2Cfyma1ylLz1o2fSlp03LxiTcfbOfQucIjyfuNhb1fVV4rovq3kdlKrLy4MggQ0mTussvkKOm7F1LrYVixTnG+Sr7quyUJDMd7+RmCV5/hu/v+zPsXwvm+K9Yua72FqINSYHJy7lsRA3pYvw6XVjwcUMoHGxszlBMjw852qwVQNtHEaKGInfqepwVfw5HtsxtnfmseL1XeLn9x1sFYfSTr7wg3wR7WLCxYXaQJBApar7mcQhit2H7p4JkhioO2e9VJ2+uZh7msw7u7HKdwWe714xVTr742j7EviLec5x5dWyXj87rg8yfvy78/5uESPFw0i91tDEn4vf564+fn6/yotfF1I1i7Ja4tossJnU7QLeD+JskhhwV/N0zYiRGFBjsepan14bz/uhz38hD7PlEodO+hEzUwsdqup1j5qIkjhjiG5xWGs9LEiG5WSGhE2vMzuSv6K996E5Fx270YG+Iy5IFodQiu8PtNccxOGfOKSz3MoXQau6dHocftqVBVn8Lnd/4pfS8We/e0MzCbE/Dz78kcrIKN+kMO4R1DmksfvgnT3X5XQOGVWJdS5xw72q++NUDdSr+oquFFBVz7HXJeb7+dyqtSxxxdvNcENHKKs1T32zWXzg55/eZ6/wvhNnhiz25nqrvcARYDP588dPd71vhgRSEhYAa8waEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAACBIAQJAAAAgSAECQAAAIEgBAkAAADK7L36rZTJMXzqer42fT5MX30vUrl9P01GRqTjeyDzX8rQHAAmq1eqoN1NPA8Ega3LotjYzuTFt2j6WRm3bFBwXJfK5fvZIuHj+WJt45mQXIVL7DYoemWmrtvGzH1moD/isDgD5e3DdjbJ28mo2vV9OVc2dSeuO1LFCG0/a9B9LowUNpcMtWQVLUuDaVxn/6Spo4fSLfebV6Fh6DQ+0gqbViJI+5ztuZ/vMfHADMVkjpj83W22ZzZmtMT6cLJ46li9m2fd9tafcHjqT60LAgmXj7ZDr3youp0ZhuhUh9INsiPOrdQZL3hwABgP77pDn7dmZrpNTI3jYa6dLpE+nyO6fTzffcn8XJgfdnkDSznXLu5RfynVEbyCJkcDCPkRRREuFRb4VILVXNjggTAJhnlC28aRbeRohkL/jrrSBJjVrWJ4105qXn0tXzZ9PN9z7YGoPfL0HSnJ5O777ww3Rl/GwWI4N5kOQhUq/PBklxm+kQIQIAi3j1PzuEdmZIap23nXG2kb/QjwmC6cmr6ZYHP9walzd7kMTMyLsv/GUWI+dasyLxpGOGJA+RentmpD4TIDWzIgCwNPkg2myPv7WZQKnFYZv20Yhmoz3WZluMzTFG3/Lwo6s+U7LqQXLupReyJ3ymHSOl2ZF2rdXMjADAclVJHiK1zhmr+dk3rcM2tWa7RGa2lI/RsaRi7OhDq/pbruqF0SZOn0yX3j4xEyKt2ZHWedKpc7imEyadEBEjAHCDTdJ9gkhniUQ+7sYYnI/FA+1tMD98E2e+bsogiVN7z736YiFEijMjrXUjNSECAKsSJjPjbm12DWeaiZKBdDYbs/Nrgm22IBl//ZX81N7iTEgxRpzaCwCrGCbtt8UoKc6cxNk353/68uYKkrgC68Tp4+1rjBQWsJbPpBEjALDqUTK7hrNeuCbYQH7YJsbwTRMkcTn4Zr6at17YCgtYxQgArFmUzBypqHeP1TF2xxi+OYKk2cyvxtoqrlr3MSsxAgDrKEpm13TmY3Y2dscYXryeyYYNkrhr7/S1qfal4GdnRoQIAKy/MJmZKWmP2zGGx1i+4YPk6vjZ2eNT9Zp1IwCwnmOkYszOx/IVtuIXRpu8+F5rkUz7vjSte9PUdAgArMMuaXbuI5c6QVLPx/KVtuIzJNcvX25fAK7zxCqKDABY+xqZ+XP3uJ2P5Rs9SKavTZZCpFZ6CwCskyrpftsOk3ws3+hB0pxuzD65TpiYGQGAddokxbG6VhrLN3KQdO4oqEEAYIPFSStM8rF8owdJ9bMDANZ3iayuup0OAKy1VQwSMyMAsLGs3ththgQAWHOCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAB4PwVJ094GgA1l9cZuMyQAwJpbgyAxUwIA69vqj9UrHiS1WvYjmk0dAgAbsUuyMTwfyzd8kAzUZ59VJ0ya6gQA1meEFMfqZmks38BBMjA0UpohaZbeAgDrpEa637bDJB/LN3qQDG7bNlta5UM3ZkoAYJ20SLO7Swrjdj6Wb/QgGRndmT2fRrY1U+d/4glqEQBYh01SGK/zsTsbw2Ms3/BBsmX32GxlNZqF4mrOLTIAYI1KJHWP0YUxOx/LN3qQjNy0Kw0MDWdPqNHaGmIEANZ1lORjdWvcjjE8xvINHySpVkvbbz2QPadGtnWmf1pPtClMAGBdhEhxbM63GLOzsTvG8BjLN36QZEYPHkr5U2k0CltnLYkoAYC1j5H2zEhhrK61x/DVsCpBMrhla9q+77astKbbWyNfJGM9CQCsbYwUx+L8JJT8iEZrvN5+6235GL5pgiTs/sCRVKsPzFRXs73NHLoRJQCw6jEyc6imMy53ZkeyMXv34SOr9iutWpDUh4bT2D33p+b0dL6l2EpR0izXGgCwvCFSOExTjJE8RNpjdGxj99yXj92bLkjC9n0H0o44dDN9vRAm2Y6YbnTNnCRhAgArEiL5rEhhJiQfg/OxuBMj1/OxOpZarKbB1d4nNx95IE1PTqYr42c7eynbBvK3+c176rXsT+0b8tVqrYW9+U6s+Q8KABZfIzNNMhslrZNLOmtGZmZGrk+nrbv35GP1alv1IKnV6+mWBz+U3nn+B+nq+XP5fqpFuNWz/1PP/5BFSCtGYmvOnGrUXJXTjgBg87RIs/vPzcIZroU1I52ZkbgAWozRMVZv+iDJo2RgIO394GPp3Ms/TpdOn2jFRjNmRQZmZkZipiSfIYmZkbxDaoVJEmECAPOUSOFNs/2/s6f2zgbJ9EyQxGGam+99oHW0Yg0MrtWuiic8dvShtGXXWDr36oupcf16a4ak3jpskxrtt6k2OzNihgQAFtElhXUjafYKrM3GbJDU6wP5eLzaa0bWTZB0xELXLWN70vnXX0kTb59o1VpESRRa+7BNa0upe5ak/T4A0CmQ0h+bM3funbnERnvdSIygO269Le06fKR1i5c1Nrgedl/siLGjD6addx5OF4+/kS69fSo1rk21Q6Te6g6zJACwiDYpnrGaZi5IGqfyju4/mEYP3rlqFz3bMEEy88tkO2b33fel3YePpskL59PV8bNp8uJ76fqVy/mZOfmim+Q0YABYSL4Kc2AgDYxsSYNbt6WR0Z35otX8Rnnr8MX94Prci7U0snN3vgEAm1/dLgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBgPQTJVPGBoXrTXgEAVkxFa0xFkFwsPrJ9QJAAACunojUuRpCcKj4yNtKwpwCAFVPRGqciSF4uPnLHtuv2FACwYipa4+UIkh8UH3lg5zV7CgBYMQ/ObY2/iCD5VvGRT++9ak8BACvmU3Nb41sRJM9k2/HOI/u3Tqcnb79sbwEAyy4aI1qjIBrk+xEksbLkd4of+dz+K/YYALDsKhrjd9K+xxudC6P9dipcj+T+m66lLx6asNcAgGUTbRGNUTDVbpCZK7XGdMl/KX7Gl+65mO4edcYNAHDjDu+4nrdFyX9N+x4/XgyS8K+y7Wzxs379yIU0OuS6JADA0kVL/Pq9F8oPR3P8i8479dIHvlT8zEd2T6V//eB7aaurtwIAS7B9sJm3xId2T5U/9E/TvsfPVgVJ+Fq2/afiAx8bm0z/7pFxh28AgEW5e8f19G8/OJ63RMl/zmLkd4sP1Jqnvln+pOFs+x/Z9kT5A195dTR99dh2exgAmNevHJpIX567ZiR8Pdv+RhYkUwsFSdiWbf8z2z5X/sCLF4bSH53amp56a5u9DQB0ieuMxKm9pbNpOv4w276QbZezIEn9BEkYyravZNs/rPrgySsD6dvvbEkvvDeU3rw8mN6drKfL1+vpuuUmALDpDdZS2jbYSLeMNPJ708Tl4D+592o60H3Rs6JYEvLlbGuVyiKCpONvtcNkj90PACzSmRQLWFP6atejpSCp9/GNYqHrfdn2H1Ph4mkAAPOYarfDfXNipEK9z28adfNr2XY4234z207YzwBAhRPtVjjcbocz/XxRP4dseoXMR7LtM9n2aLYdybaD2bYjtdaeAACbW6wFuZRaV3t/Jdt+kG1/km3fT6375M2vdMjm/wswAOFHcKYGBK+BAAAAAElFTkSuQmCC"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwMzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTAxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTAyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/IKTpgAABoJJREFU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"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFGNzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGODNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU1REU2MUY1M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUY2M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xBVG6wAADz5JREFUeNrs3U9sVVUewPHD62tLrXVaCppaamRqJCXOwiBuR91NYnRhojHjyiHB/2tjjBvduFYTHYkrZ3SSWU0y28GZpUjGhYKYICbQaYZ/VaCUvrYPz6+84u3lSl+lLyb4+SS/Bee+9iXnbb65vZy34f2Dl9LPUMuzK8+Dee7Lc3ee0Tz9eXoTAHCjm8szk2cyz9d5PsuzL8/+PM3Vfnj3xMp/19f45lvzPJ/nj3nGfBYA8KvV25pNeX6X57HW+rE8f8nzTp7j7f6yWpuvG2794iN5XhYjAMBPGGu1wpFWOwyvV5A8nuerPM/l6bHPAEAbelrtEA3xxGovrq9y7a08z1RdnJ1rpP+dmk7T52bSzOxcujg3nxaazdRsNn0EAHCDq9VqqZ5nY2936u/rTUMD/en2zUOpr/eqexeb83yc54E8L+ZZWEuQ3JTnb3keLl/4LgfIsRNn0rdTJ30aAPArFTcgGjELC+nszGyaOvVdOnh0Mt05siWN3bopDQ70l38kbnDEs6hxt+RCO0ESax9VxUi80ZHJ//sUAIBKccMiZnz0trRj22j58sOtxogHYFfcKal6huTtPI8UF86cPZ/+8/lXYgQAaEs0w7//e2ipIUoeabVGulaQxG2UPcWFk9Nn06cHj6Tvz1+wuwBA2+JPOdEQ0RIle/YeSk/+VJAMl4vl9Pfn04HDR9P8wqJdBQDWLBoiWiKaouTtHCVbqoLkjXT5SdgrvvjmmBgBAK47SqIpSuJAtdfLQXJHnj8VXxUPsMatFgCA6xVN8eXRqw5ufXrvoaUGuRIkz+bpXr4aZ4t4gBUAWE/fTJ5YaoyC7laDLAVJzFPFq8dPnLFrAMC6q2iMp/YeSrXlb+3durx64WLDoWcAQEdEY0RrFESD7Iogeai4OnV62m4BAB1T0RoPRpDsLK6U/rYDALCuKlrjvgiS7cWV+KI8AIBOqWiN7REkI8WVi415OwUAdExFa4xEkAwUVxYWHYQGAHRORWsMRJD0FFeazUt2CgDomIrW6KnZFgDglyZIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAEEHSWLFQ22BXAIDOxcfVrdGIIDlXXKl3ddkpAKBjKlrjXATJVHFlY0+3nQIAOqaiNaYiSA4XV/r7eu0UANAxFa1xOILkQHFlaKDfTgEAHVPRGp9FkOwrrowMD9kpAKBjKlpjXwTJp3mOL6/ctLEn3TmyxW4BAOsuGiNaoyAaZH8ESTPPh8UrY7dusmMAwLqraIwPd0+k5vLBaO+kwnkkgwP9aXz0NrsGAKybaIvBlc+PNFoNcuWk1rhdsrf4ih3bRtMt/X12DwC4btEU0RYlH+yeuPzYSPHo+NfynC6+6p7fjqXuuoPSAICfL1oimqIkmuPV5X/UShdeKL5y+Dc3p53bt6V6l6+8AQDWLk5ljZaIpih5affEjzdCyqXxcZ73igtbhm5J9++4y59vAIA1iXa4f8f4UkuU/DnHyF+LC1W3Pl7K84/iQlTN7++d8KArANCWaIZoh4o7I9EYL5YX6xW/I554fTLP3/P8oXghHka5ffNgOnbiTPp26qTdBgBWiHNG4r/2Dlaf/P7PVmM02gmScCHPo3neyrOneCHeYPm/BU+dnk7T52bSzOxcmp2bT4uLi6l56ZJPAwBucLUNG1JXV1fq6+1e+m6aOA4+TmAtHXpWFI+ExJ2R+aqL9Wu8V/zAM3k+aYXJ5uLFeEN/wgEAVnEqXX4c5KNrBk4bvygedJ3I826quMUCAFCh0WqHidVipN0gWa6bZ/OM53kzz6R9BgAqTLZaYbzVDqfa+aH6Gt8kTlN7Oc8reXbleSjPzjx359maJx6l7fZZAMANLx7tON9qg6/zHMjzrzz70+XvyVuTHwQYANsFYMWa99MrAAAAAElFTkSuQmCC"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4MDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4MTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjdFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjdGM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+o5CrmQAABp1JREFU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"

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(117)
	__vue_script__ = __webpack_require__(119)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\betInfo.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(121)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-e2a4ac6e/betInfo.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(118);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/betInfo.vue?7661e2a1"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;CACA","file":"betInfo.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.bet-info(v-bind:style=\"content\")\r\n\t\tdiv.record(v-for=\"item in betRecord\")\r\n\t\t\tp.created-time(v-html=\"item.createdAt\")\r\n\t\t\tp.detail\r\n\t\t\t\tspan 玩法：\r\n\t\t\t\tspan(v-html=\"item.playlaw\")\r\n\t\t\t\tspan 下注金额：\r\n\t\t\t\tspan(v-html=\"item.betmoney\")\r\n\t\t\t\tspan 倍数：\r\n\t\t\t\tspan(v-html=\"item.multiple\")\r\n\t\t\tp.bonus-num\r\n\t\t\t\tspan 数字：\r\n\t\t\t\tspan(v-html=\"item.num\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {},\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                betRecord: require('../../data/betRecord')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            betRecord: __webpack_require__(120)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in betRecord\"><p class=\"created-time\" v-html=\"item.createdAt\"></p><p class=\"detail\"><span>玩法：</span><span v-html=\"item.playlaw\"></span><span>下注金额：</span><span v-html=\"item.betmoney\"></span><span>倍数：</span><span v-html=\"item.multiple\"></span></p><p class=\"bonus-num\"><span>数字：</span><span v-html=\"item.num\"></span></p></div></div>";

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(123)
	__vue_script__ = __webpack_require__(125)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\bonusRecord.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(127)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-692cd0ba/bonusRecord.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(124);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/bonusRecord.vue?c765f018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,oBAAA;IACA,iBAAA;CACA","file":"bonusRecord.vue","sourcesContent":["<template lang=\"pug\">\r\n    div.bet-info(v-bind:style=\"content\")\r\n        div.record(v-for=\"item in bonusRecord\")\r\n            p.created-time(v-html=\"item.createdAt | datetime\")\r\n            p.bonus-num\r\n                span 开奖号码：\r\n                span(v-html=\"lotterynum(item.lotterynums)\")\r\n</template>\r\n<script>\r\nimport RequestList from '../../js/request-list'\r\nexport default {\r\n    props: ['zoomRate'],\r\n    ready() {\r\n        RequestList.getBonusRecord().then(res => this.bonusRecord = res.data)\r\n    },\r\n    data() {\r\n        return {\r\n            bonusRecord: require('../../data/bounsRecord')\r\n        }\r\n    },\r\n    methods: {\r\n        lotterynum(nums) {\r\n            if (Object.prototype.toString.call(nums) !== '[object String]') {\r\n                throw new Error('获取中奖结果出错')\r\n            }\r\n            // 中奖数字总共十位数，取第一位和最后一位相加结果的个位数作为开奖结果\r\n            nums = nums.split(',')\r\n            return (nums[0] + nums[nums.length - 1]) % 10\r\n        }\r\n    },\r\n    computed: {\r\n        content() {\r\n            return {\r\n                width: 458 * this.zoomRate.x + 'px',\r\n                height: 580 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate'],
	    ready: function ready() {
	        var _this = this;
	
	        _requestList2.default.getBonusRecord().then(function (res) {
	            return _this.bonusRecord = res.data;
	        });
	    },
	    data: function data() {
	        return {
	            bonusRecord: __webpack_require__(126)
	        };
	    },
	
	    methods: {
	        lotterynum: function lotterynum(nums) {
	            if (Object.prototype.toString.call(nums) !== '[object String]') {
	                throw new Error('获取中奖结果出错');
	            }
	
	            nums = nums.split(',');
	            return (nums[0] + nums[nums.length - 1]) % 10;
	        }
	    },
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in bonusRecord\"><p class=\"created-time\" v-html=\"item.createdAt | datetime\"></p><p class=\"bonus-num\"><span>开奖号码：</span><span v-html=\"lotterynum(item.lotterynums)\"></span></p></div></div>";

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(129)
	__vue_script__ = __webpack_require__(131)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Exchange.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(139)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-f367a86e/Exchange.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(130);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Exchange.vue?4d705018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Exchange.vue","sourcesContent":["<template lang=\"pug\">\r\n    //- 兑换 商城 模板\r\n    div.exchange(v-bind:style=\"content\")\r\n        //- img.background-img(v-bind:src=\"backgroundImg\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"bonusMoney\",v-html=\"item.goodname\")\r\n                    img.exchange(v-bind:src=\"doexchange\",v-bind:style=\"exchangeBtn\")\r\n            div.change-button(v-bind:style=\"buttonBar\")\r\n                div.bonus-button\r\n                    img.bonus-button(v-bind:src=\"bonusButton\")\r\n                div.prize-button\r\n                    img.prize-button(v-bind:src=\"prizeButton\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                moneyData: require('../../data/money-data.js'),\r\n                backgroundImg: require('../../assets/切图/商城/内底.png'),\r\n                moneyBack: require('../../assets/切图/商城/块.png'),\r\n                bonusButton: require('../../assets/切图/商城/奖金.png'),\r\n                prizeButton: require('../../assets/切图/商城/奖品.png'),\r\n                doexchange: require('../../assets/切图/商城/兑换.png'),\r\n                moneyImg: require('../../assets/切图/商城/金币.png')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 618 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyblock() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n                }\r\n            },\r\n            buttonBar() {\r\n                return {\r\n                    width: 260 * this.zoomRate.x + 'px',\r\n                    height: 68 * this.zoomRate.y + 'px',\r\n                    margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            barcontent() {\r\n                return {\r\n                    margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n                }\r\n            },\r\n            bonusMoney() {\r\n                return {\r\n                    width: 150 * this.zoomRate.x + 'px',\r\n                    height: 20 * this.zoomRate.y + 'px',\r\n                    margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyImg() {\r\n                return {\r\n                    width: 116 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: 0 * this.zoomRate.y + 'px 0 0 0px'\r\n                }\r\n            },\r\n            exchangeBtn() {\r\n                return {\r\n                    width: 90 * this.zoomRate.x + 'px',\r\n                    height: 50 * this.zoomRate.y + 'px',\r\n                    margin: 30 * this.zoomRate.y + 'px 0 0 ' + (364) * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(132),
	            backgroundImg: __webpack_require__(134),
	            moneyBack: __webpack_require__(135),
	            bonusButton: __webpack_require__(136),
	            prizeButton: __webpack_require__(137),
	            doexchange: __webpack_require__(138),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: 0 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        exchangeBtn: function exchangeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '10000金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50000金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '10W金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50W金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEMzREOUUxMjQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEMzREOUUxMzQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzNEQ5RTEwNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzNEQ5RTExNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MrPF1wAAIN9JREFU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"

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAIICAYAAACYbhx1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg4MTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg4MjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjYzODRGODdGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODgwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6e7g8wAAD2RJREFU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AwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwD/f4Je/Y8BAI+Uug26kAPAIx/2chL4etyuSg8A16zb9TiY19MhvUwpndd6usf95AcAgOswhD8wcLet1vDW8hJbv1yeqO2JkykdALiGYV8iPrd7eVx/Waaafj4/UXvM+7heVR0ArlfML2n11AbyaHkEvf5wOjyxlP6yY+oAwNVO5euqLYduLw3/YZvQ/2dc6t6f7CN8dWIcAFyfqPc239fs3vDvl3Gq355iqz0x9trPE/uac1M6AFz5dD5P5ak3um663RoeLS/x4Lv7qd4dlyfmF9YRfjulizoAXEHMT6bzvqu9N7stc8Nr/V4ZxzrFg3/ZL0+mfT2d1i+71g0A+P3E/DCdb/rcWn3odjT8L++8PpX9NKX9OL0ay3nbjsDPyzKpx4dMfUoXdQC4gpjXucXzrvapHjrd+33eGt7eWi7ixVjuXoz1a7Gki3Fqj+fqr7vfpyrqAHAVMZ82u9n3S7OXVs/Nrv/8F3devzsHfR7X44XzcXo5RvQ3zvsb9+2Nrf51M62LOgD8fmPeD4fPTe6Dd2v13Oxx+vL6I+0Yeq/8/MJL8YYW93Sv17/98CHqUz/7fb2gXdgB4HcS8sPZ7POdW3tze8z3vdX3lgE89VZ/4dk7r7+xfsbwZ08+lnJOseS2/kFJ+YmU01PxaPnmlry8sT2uef2xfPJ8ysf/qOz/FwB469P4ZiI/3Jt9PvktzWext8l8Hrz3S8j/d1n/00f+7cdf3X7Ebj7lPd5Y8hRL+/q1/IWo8hOx+UyL83J/95LqMKVdFL3Em4b5F4D5vbFeRvWcj/+BWdYB4CEx33zBSj2up3552rg5Zr7vk/nFHPMx3dtP/xnL5+//zF37DSDHD+R4c14m7PP447nY/Ea89OfrLvaziPrUYh41n6LeZV7qMtlvhvblkR3xAPBmUd/eNGa9A9zh8rTxeALcfCh8Py//Fctz9/bj+QNBn0+BT2uM57q3538Tmx+J5ZX4zBfWg/LTUNIQU/ouL5P6Iepp2WW/lL2azwHgoTE/bqzfmHZyNvsa9OMJcG35xzaZR8wv2sT+YNDr4X5y/Y8yX3weT13Eny/GbwnfGaf6yrgrj7e/YDeVtGuT+rzrPS+73ueY1+WYe5/WAYCHF3392vL1Dq3zZH64Ycxy7DxC/ot2Alwsr/Wwz89fEvT+a0E5Rr0us/p6uvyd+PBvxvKV/ZA/uRvqjW3QSw/64cS67acLOwBcMpofd7NvvgL1NOjjdN6uM4+Q/21M6hH19frz5fK1B4K+XOeWT6K+/CVTH/1L+/BfxPKZizH/QwT9pQj687G8s2yivsY8Zx0HgDfrer3v2PnmRLifzrdkH6fb+/nGb/0s934d+r7fw/2BoM/77/Mm6nn7F+QUPU/7WLcD82cl392N9YvDkL8UIf9ATOkfipi/Pyb098b6VtT87fH2M9M5ADx8So/5+SJi+6vI690YoH80f535VL/Vvmhl+Z6V451b11u9zl/I0s9ru9//CTAAwcI8aGUDpYoAAAAASUVORK5CYII="

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OTRCNTVEQzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OTRCNTVERDNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY5NEI1NURBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY5NEI1NURCM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FIWMwgAAJ/FJREFU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"

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI2RTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI2RjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjczMzVBODg5M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjczMzVBODhBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Nzdc8AAAB/ZJREFUeNrsXWtsk1UYPi1d127d2NjmGPcZFCeIRKgD1OAWjYogLAqBENBgJI4/JsONiBKyoBCC/NGEEg3+mCGSDYIoTo0GJCiIoCIBBoE4t0XG3KW7t3Sz83vOdj6+lnY93c2v3fskJ926fpee85znvO9z3q6G6qJ5LBCSspeZlYflfW2B0iYozcwI0QyHKQgZCliPd09XUy3rct5i3e1NzOtxM+U56rIohjLu+Sa/J6YpD0Vdztp8V/Vl5nV3UC+NMph8yNDTU+mqqWC3a69Tz4xSGDU/FxEZCMY+ddjS1XQzn8hAMPJsosf7nqvqEvUGgSvECk/jTSWLcFFvEDghlitZBfUEQSWE/d+OZuoJgkqI8d4uN/UEQSVELPOSA0nQpJ0EAhGCQIQgECEIRAgCEYIwOglhtN3Dmx7vK1pgiqSbnbj1K/7Y9vMx1nykOOjgZBSWMU9dFWs7eZC5L5cP+32lbXAwoyWOtf10hLWf/IgUYliYmp41oOPGrSzmg2OZmsW8ncNvySflbWPm9CnMNDaVGa0JpBDDQYSUNe/yDq7b+zrrrquQPjbx2U3MOqO3aNhdVcFMqVN4CwZP9R9hnd8ftkUbWML8JXfuPXk8EWKogQHCDEdLfvEtVr93nfTgjM1Zpf4OhUDrD153J2ss3TWgZQXXS178Wu89tzRwAsfPeVJRCQdr+CSfloyhhPPoh+qgouNllEEMTrjwVJ0fNBnq9xcwZ/nH/HcoVHrB4QEveaQQAYAZ23Ehh8+4hMfyggZqCCARM4hlwlNXzRoPvNPvMiCCTihQx4XjzNv+T3gxyurd/L60ZMD12pXm7WxlKS9t4jFF+sZ9rOX4gYgLMnUbVDZ/uZtLOqQ4zr4q6MAKMriunedkME95WCroxLlbv3NI3485cyGf+YIMIJ8gg0DnuYOsbt8bnCh8yVNUJG1jSUSphW7TTszctjNfME9NRcA1Xvw9YcEL/LHz93I+K3mGMX0ua/qsMKDUCwJh9sqoA4iX+HS+T/CIgLWx5M2Ax3sqT7O6D15mKeveV+OYjIISniqDgOEq0kjD0Hp4e0/z2aO6N6S0g6L1IfA30clQEki2GDRtQGqZuZilrStW1SRU4Ifz2h5fywkHkgn054EEDHRz16jHQ5VA3vYfP9UlMZKyl+nbmBJEiJ+T6zMo/kqhlWys4xh4zEzINUiBoFNkIJD6ptJt/aa9ibnrmfWBR++6JojkdbXz88kCcYq4fzTcB0jmuvoL67x4YkSMs4hfMjAotoUrfYiAgUSwJhOQNh5K5ErB5XrL1zwOCSX1/gqjTU3F0oTlRiw54aK+ZBsb+8yr/D3gPSEWQXOWT9JV4GnSmyIkLS1UAzcRyQtLePKuc3JeRkO1SiBBBhmph8Ig/sD1cd2O375X5T3+kaeCqlTI+1HOBaKigXTx9sWcrFAcvWUhulMISLV2ZrZ+s0fqOMQIlvvtzJo1XyWBUJaWb/dLSzOyG/eNXzk5tKjd8VzA16eud6iqUbPZHvL8OC8aspbu+huUZchkFkCowAsEiJudw8Ykpwd0JEGEtlNldw2szD2Ee8yADDElG6G0UwKyitDdUKlIe/FdJHBdOc3c187otsPJhxhCICg0WuJ5pA9DqOXEQWa02pTnbMxz8zpzXz01qM0qQoT4EKEyEhg/3GxSCCKrMKGCW1F7MVz4e/vzuvMi4ENEfAmdKTXzzpJRQ+oQdUuG1jeQCgKVbEQgZeVmZfkoDut62HvwjzcwcxsPySlNwhMreHqL+3Aek98b0auFrb8CmTDIwOVd4w0MxCfwdjqDpodabwTpcKCCnbiHFjHWZzYFyk6QXqa9spM7lu2nS3Uf4+iOEHD0jHGJUq81T5rhs+kEdFz4gfsI0oToaAw5k2My7uUDDks70KZZf0jMWdvnTOaGtbtKhBCZRBjefry9RF02UFQLPyI2c1bv1vkQSjKMLeyPwMFsPZ4lPcvhlYS7u/p/I2KDSmwwCUMKcuw8vFOtn8DW81CTFCkvv66iErJIWLRKTZcjpVDGGKlk0O5eYo8Cs1YEdWKncyg/L4GSfq5KqJuUOC+2vgVhQdZIQUQRAp4D9g4EGbBphCopbSAoahv5TmdhmVRNpqxKgHw8kJy7PKSPgToI4Y1EklkWEU4lInXb/DyfGoVg9ZOQZtREJC/JV8vYUJeJnUtUVQ1mcLA3gnOHinN42lq6i2+2DYVRNpLQpVOJGWaeOo93aGzmbJ86CMQJiBlCbWVDTVDG77/xBSJ11f7JrW5P9SW+46gN9rQV1cONcKqvRgK6q5iCEqSs3hrQixBEkK1LhBKgWgqRvi17qRrtg1xooubCf1Ci4dNXUbNkwDHsuvWXSgjECLcrLw2q1EwUpkB1LFm5vAAGvgJIIQJSn9dfOzNy71eHVrvulgxIPfYn8AGa4c7btQW6BJ0W2ULqRyoqJzJEiQ9BIEIQiBAEIgSBCEEgQhCIEAQiBIEIQYgOQrQZxpioJwgqIWoNMRbqCYJKiItjJKucCaODEJ/HJGdQTxBUQpSZUyYwo9lKvUFgxuazRz3MYHzbOnUW9QahN+1USLEjZtwER2zGdOoRIoSK3dbJD7LY9EzqFSIEV4lKZjDMtE6b7Yi/z87/MQdh9MHHkVJIcUV52JiUvexGTPL4PfiSeHwvOL4K2utxM9ZDX/ga7TBUFwX+v4sKKczKwwql5SltrtImKi2Guiyq4fhPgAEAVYy5zoLMEH0AAAAASUVORK5CYII="

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI3MjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI3MzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4NzE2MjcwM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NzE2MjcxM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+QQjJUwAACBpJREFU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"

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDg5RkQxOTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDg5RkQxQTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlFM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY0ODlGRDE4M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CgsFFAAAC2RJREFUeNrsXXmMFGUWf9Vd3TPdc/ccO8CgEDYYiSKCuihKgq4osOstmJUVhegCi9F/FDzYBBEBEyUiy5JsAA/ILghB3IBXsppBwESQwyEgchkG5mKme/qanr5q3/vqq5runu6Z6pmerp6lXualuo6v6qv3+95Z31QJTQ8+CH0kE/KtyFOQb0EejTwMuQA5DwzSQp3IPuRLyKeRDyF/g/wDclTLCUaeL4xbF/vQiRrkvyI/iTzcwKRflMfZgXwj8qN8+0Xkrch/R65PV8u0Ujm/wFnkJQaYA0rDuYzPcpmXZxrQmcinkBciWw15Z42sXOYk+1mZAFREQ74Bl9uQKwz56kYk+39zLHp0k6KUep8d920XAGZIhkBzghCLvyCoNYJsMf3paKgYQa0kMA0x5hyoMyKyxRQ1A4oN1psB/mCILzeJsCGMNAHaKcGfsMGzhthyHtRnEavZ3TS48YEH1JWWiFBZbpZOmeS8yKAcJ4xtnJfCpjGT6wsak2posUlaaYA5qPxpWaU5uiLO5Eoy0nAhZBplEWCOsm7w4GDE7Kn/DvONitPQUReKBDS1i4S+lQIN0ldLRcJO/skB/V1+JM8mSE8Y4hmcRNgRhiqgf3MEJpkFqDZEM0gjXsSOMGQFBDS3pv013nv17pT98cfZ0v/JJ2m1K1m8GDqPH4fg999D1OlMq23BM8+AZcQIiLS0gGfdul6PL122DCS/n10v8PnnOQVqqUn6PS6+IZ9pyTPBeD3Le8WLFkHBvfKYCp4+DaFjxzQPAtsddzDuvPtuaHvppbSuS2DmjxsHofp66O3+bdOmsWNZH8+dg1wrhyKGE+iWyORarRgX6dkZ79atEGlrY7/LXnxRUxtTWRkUPSo/Pox2dED7+vUD2seimTPZkvqZrhXJBnEMrSIDVJB0fZJCprJ940ZwoIaZHQ5mRttXr+5ZwM89Byabjf327NwJkfPnB6x/hWiaqV/MX+FyyO7dye8DB5bvyy/Bu3lz9gGVMbSamJoKYNd7hHV+9x0Ejh6VTSmaUMtNN6U2L3feyY4hojYDqTHUj6KHHtJmNXCAFdx3H5hHjsy6/DiGFpEFSZIk5oJPcK1ZA1UbNjDBFD7yCLRxgBNNbcm8ear5ozaS1P/eJzsHXUtxAcysf/hhcv86caLqX8lahNHH6pGPEpaikpDq4sjvugtMRUVx20IXL4JYUQGddXVgmz49qfAU8+errYW822+PN3seD3Tu25dS2/ImTOgK9ytkT2Oy26Fw7lx5kDQ2QsfevbI/f+019VpOjIKTnZfuQQHTf+AA+LZv17XOoCug5T1EpSWzZ/ceHacwhZdTAEpgJmtDoCnbKeLtPHiQgZk3ejTb1r5lS1IwaYCULVokuwyMzl2rVuleOLqqSn2S16ttoK1YAZaamrjB1dsAswwfDkM/+0xdb1m6VHP6lUligOrtP71ffw3t77/fr3M43ngDbNz0pbofL5pDb4xJVNqQVjYvXNgVMaLmlb/6qhpFaw2I4ky/262LXI1ifBIKomY1zZ8PQ3gQ5P70U/Dt2tVVYXr4YdVEN73wAkRdLtmkoz93YDs9yQC0h9y4p3V1O4KZbslxQNMXA7r/L8oJHypluA9Shtsk9k/S0HdJJ7mKPKvWGVEps33ow7lMpaVgmzoV8m+4AVoxQu2xf4m/lfVU2682H1qEgiTWiyhFGfrRR3EVIq1+MZf851UZFFkxTbFRdWfMmLhcUyEqEPQqtKoqtgy3tho+NJZa3n67W+mPJfYLFrBlBxXeDx6M21f29NMs50u2j2mMx5PyfhxLlkDBpEnd21CddudO8H/1FVvP5+VE2k7XIgBjy5CWa69V98dtH9X1FNI2ZQqEr78egidPQngAnwTllIYGkpTTxJgnFYG6OvDzumoi2OHm5m77es0vUbAKoAHURLG8nDFpmnfbNrbdjgAp11DzTmyTbCBYUcMTj1WoBHNVonbMX91XC6DJKP+229Tf4cuXM3puRQNpSb6vYvlyBmiihqeVr3ItTrnf57u6fag1RkODqKGZLhYomtiT1biYorhPNOSDD+IGgeeLL8C9aZNRWEhFtvHjZTDr63MugiyeO1cF07d/vxyh339/nJvICUBzZRZ4waxZqvnyfvtt0mMSE/dUTLMGtFxT6/nouafiF/0YkLWuWsX8MPW3/OWXQcBUR2/5dWmokgTryJT7lcZM+mL+LtmxyRL+JFy9ejVUvfMOe3KS8jiN56JzVDz/vJqqtL37Ltvetm4d6ysFRxWvv66/HHPF5JocDqh66y1VO107dkCUzwLs6/noXPmjR4M4bFi/+mafMQOq33yTnY/Aa162TO0bTTW5wh/70bWqEGiTw6G/yY1i33SLaidPhuo1a9goZ6YWfVNvgYuWMl5fo9bYQeF45RWoUNIk1MzGxYu7zRcK1NZC28cfq6DSvdA9ZZsUDFmUG5IgYBWgMJsaacPkvfCee5gQFCIwW1eu7LEtCZYCE6r0kPYkHSRjx3ZVfjBSTlVooLlEsT5ULUWiLy997DHVYpCvbEEtTWU1PDgAww0NzCxT36rQp/qnTgUnRr/ZmjBGGCqASgFJcFoFKSuAVqJg8q+7Li53I5Bc27eDb8+e3osDNIkMhcb8VoqkXs07MXhJBKEcta4woUgQ9ftVIIunT1cjWTKxbkxLaM5wb9SBmtqAkXklgkl9s48bB/a1azUN0owUaRBDwpJMrtQeFS5lSzupXKeAyYDctQsuzZmjCUyiVvRTJKSe6qgsqKJIlIKXxBs/frzbsTQjgf32elUwqX0DTfjWAKY6MFEbG+bPZ/dE52UlxX66D63EMZRIQyONEdPp4WJ0YjYuTMCJ1dXQcfgwBJPMu+3VV6DG9WfEd+CAclXL/2gXpimbuK5oMfWNfG7E7e5T31Th4iDwIKjiNddkzeReRgwJSwI0dKhTPHRLXvipbGmpK41Rn2lik7N7uL4fTWemrhPpR6SeLv3YKdILH0NkcoP/dOcd9ss22KBBSIQdYvgjYckARYfqOhE07zdEMziJsCMMCUtmcpHdG915u8ZXhKaZ2StwDBosFME/wo4wZCb3RI2TXrTr2Rew/FwXFPcZIhps2inuJ+wIQ4oZTTyh7kBuXu60b0HV9RmvixkcTFgtc9qpTNXMMVRruWR2W0+GzL/s8Fn/ZYz7wUGI1bZTITOlK60cQxnQuhonAU7/yVO/0mXfezQoHjDEldt0DDFCrKgaU8+xk2I1lEAN4qIF+dcFVwo3ng2ZTxhiy00ibOYjRoQVxyyo7Et8fEZFzYueqHBm3pXC9RfC5lOG+HKLzoXMJwkbwgjkjw3EvQg5DlDU0ggVcmgQXImYfp7ZVPTekaB40BBjbhBh8URz0VrCBuQPDDjlzCUG0MTI6acaZ4ir8Wm/JJz5c3PRpk2efCP61Tma3YwYEBaIyS8gf+OlhWMVR0ln/eGBwRvry5r4+YLvttuCu/3Wk0tL/X+8OS98q8koPmSFoqh9RzrFH5a77P9Bv0nBzwWumQRmMFkb4WySF1MohKBacEGP/+k7IjRdvGqsNTx0QXFgMgJ7c4EglRhizzz5JKEdgTzyD3d+7fGgeJnnmb9yn+mK1UzESDugvAFpIz3arwT5q0pDCGRRAPsMe3Dk5PzQb0eIkZpyk1RZaJJKLIJkNTRYuwaGJCHojQrtrVGhBYPQ+tqA5cwev/V8WGLBDsUzDTw1ITfo/0mOc6DPgMY0pI/C0KwGegL8G74sRs4H+YMxImcBdHyzyiAjxU2GOZMZpakkbl4saOJLbyoT2w1Q+9gn0+kAAUVmmKYcFHFAiznQNg6sGYz/DE9DSVmUGuSlOy8Hk9jDt4Ugjf8nE/swooKcPdwMWDlbOJiGhqavoREOnCLbEGj8OmEi/U+AAQBLy/FbOQ8N5AAAAABJRU5ErkJggg=="

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = "<div class=\"exchange\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"bonusMoney\" v-html=\"item.goodname\"></div><img class=\"exchange\" v-bind:src=\"doexchange\" v-bind:style=\"exchangeBtn\"/></div></div><div class=\"change-button\" v-bind:style=\"buttonBar\"><div class=\"bonus-button\"><img class=\"bonus-button\" v-bind:src=\"bonusButton\"/></div><div class=\"prize-button\"><img class=\"prize-button\" v-bind:src=\"prizeButton\"/></div></div></div></div>";

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(141)
	__vue_script__ = __webpack_require__(143)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Recharge.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(153)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-9e1d8b66/Recharge.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Recharge.vue?4d573667"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Recharge.vue","sourcesContent":["<template lang=\"pug\">\r\n    //- 兑换 商城 模板\r\n    img.recharge-record(v-bind:src=\"recordImg\",v-bind:style=\"recordImgStyle\")\r\n    div.recharge(v-bind:style=\"content\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\",v-html=\"item.goodname\")\r\n                        //- 副标题\r\n                    div.bonus-money.bonus-sub(v-if=\"item.sub\",v-bind:style=\"bonusSub\",v-html=\"item.sub\")\r\n                    img.recharge(v-bind:src=\"dorecharge\",v-bind:style=\"rechargeBtn\")\r\n    div.my-money(v-bind:style=\"footer\") 我的金币: {{userinfo.money}}\r\n</template>\r\n<script>\r\nexport default {\r\n    props: ['zoomRate', 'userinfo'],\r\n    ready() {\r\n\r\n    },\r\n    data() {\r\n        return {\r\n            moneyData: require('../../data/exchange-data'),\r\n            recordImg: require('../../assets/切图/充值/充值记录按钮.png'),\r\n            moneyBack: require('../../assets/切图/充值/块.png'),\r\n            dorecharge: require('../../assets/切图/充值/充值.png'),\r\n            moneyImg: require('../../assets/切图/商城/金币.png')\r\n        }\r\n    },\r\n    computed: {\r\n        recordImgStyle() {\r\n            return {\r\n                width: 136 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        content() {\r\n            return {\r\n                width: 495 * this.zoomRate.x + 'px',\r\n                height: 618 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyblock() {\r\n            return {\r\n                width: '100%',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n            }\r\n        },\r\n        buttonBar() {\r\n            return {\r\n                width: 260 * this.zoomRate.x + 'px',\r\n                height: 68 * this.zoomRate.y + 'px',\r\n                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        barcontent() {\r\n            return {\r\n                margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n            }\r\n        },\r\n        bonusMoney() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusMoneyHasSub() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusSub() {\r\n            return {\r\n                fontSize: 14 * this.zoomRate.x + 'px',\r\n                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',\r\n                borderRadius: 10 * this.zoomRate.x + 'px',\r\n                // width: 150 * this.zoomRate.x + 'px',\r\n                // height: 20 * this.zoomRate.y + 'px',\r\n                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyImg() {\r\n            return {\r\n                width: 116 * this.zoomRate.x + 'px',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: -2 * this.zoomRate.y + 'px 0 0 0px'\r\n            }\r\n        },\r\n        rechargeBtn() {\r\n            return {\r\n                width: 90 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        footer() {\r\n            return {\r\n                // width: 136 * this.zoomRate.x + 'px',\r\n                fontSize: 34 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    ready: function ready() {},
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(144),
	            recordImg: __webpack_require__(150),
	            moneyBack: __webpack_require__(151),
	            dorecharge: __webpack_require__(152),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        recordImgStyle: function recordImgStyle() {
	            return {
	                width: 136 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 495 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: '100%',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusMoneyHasSub: function bonusMoneyHasSub() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusSub: function bonusSub() {
	            return {
	                fontSize: 14 * this.zoomRate.x + 'px',
	                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',
	                borderRadius: 10 * this.zoomRate.x + 'px',
	
	                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: -2 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        rechargeBtn: function rechargeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        },
	        footer: function footer() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '500金币',
	        price: 500,
	        sub: '',
	        goodsimg: __webpack_require__(145),
	        goodsnum: 200
	    }, {
	        goodname: '1000金币',
	        price: 1000,
	        sub: '',
	        goodsimg: __webpack_require__(146),
	        goodsnum: 200
	    }, {
	        goodname: '2000金币',
	        price: 2000,
	        sub: '+188金币',
	        goodsimg: __webpack_require__(147),
	        goodsnum: 200
	    }, {
	        goodname: '5000金币',
	        price: 5000,
	        sub: '+888金币',
	        goodsimg: __webpack_require__(148),
	        goodsnum: 200
	    }, {
	        goodname: '10000金币',
	        price: 10000,
	        sub: '+2888金币',
	        goodsimg: __webpack_require__(149),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg3OTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg3QTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjQwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODc4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+3Q/9KQAAEj9JREFU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"

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzRjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjNDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjNENDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Z4g2cwAAGIhJREFU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"

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzQTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzQjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjM4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjM5NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YbZkgAAJTdJREFUeNrsfQmYXFW17r/PUENXV8+d7s48EUKIZAICQsIYMIAgowNyRfTq48lTroJwBwNPryB6VYSn9+OiPgfu1ev4lCc+BclFIEQgBAIhJCQ9pDs9pMfqrumM+629z6mu6kp3pzrppFtSJ9/JqTrn1Bn2v9da/1p7rd2Mc47i8s5ZlGITFAEtLkVAi0sR0OJSBLS4FAEtAlpcioAWlyKgxaUIaHEpAloEtLgUAS0uRUCLSxHQ4lIEtAhocSkCWlyKgBaXIqDFpQhoEdDiUgS0uEzFoh3vG57O2GHPEWdYtKaAqA7MVoG5DlDt0krHaqkXzqK1hvYHdBWVioKQqqBcURGiy4tE4yCt+nj34BzccWDQ6rouLFrjdH2D1hhdoI/u10GnNdM9Oule3fQ8+2hfewCIB8TvC3jXl6cg51mbbuoiDaiDwE0zdFyxZCYusNOo6h4gJGuAUJjO8XWKRS2s0dMHCTpd9z7LzsDGBPCQ76YJ2La3ErByMcV1mdcbDDreNwQk48B8ur/C0N0RwzPtJjaHgJ9G6TAKBPd4Lex4Z86PJqGZPQeBj9cE8Ll3r8bS8hKvkfsJzAABGY1656ia14I2HXN8IMQruNzbr/nH+WhA+vszjyC2TPE6SeY6JOXyu0arS/tsAbxB4CbpO20rI9SJ6JzXGtG/rRvfqwAeoEftcaeJhE45oL56nUtgfu+CZbj4vDOBgRiDyTVoIRV19RoCJDKMxEOhlhZbVWUEHK16UIIiwOSuB5br+igyH0AfRAEO9+/n2Jb8ARffuPhuypMZXcwy0rBJ/Hnmt7Sqqie5XT20JWDL6ezFVUBrN/D9zTg4xPGFWuDf+IkOqNCe1D7n9QK//Mx1S6vXr3awZY+D+iXLMHcWgWqpSBsK0imb1J4Jw7BhmWT40hZBIYylCkcYQ9uV+6QxNMVnk0Bx4LgEOhlX8d2x0rIziH+uY0mkXE4GlPStY5l0La8drHRafredrHRnVHs47IHb0kmGlpTt1SuAFYuBrz0OvNmL784APin6zgkJKPPs5UX9wP/74m3rtFOX1uCf7n8BNbVh1M/QEB9MUUM6ZLeo0UkfmoZFK+lY1yaAHARDnDqEK1VmQM+qWnFhcQshsWIrAMhImbiny0eqYp75TeZY5vf+M+Y2j1DLhiFtqWRPTW3A7RcDawnUWx8FXu3BUw3Ae4TQn1CA+mp2bSuw5f7bLlZuumUdbv/br6K6IYESAkhoxFDIt2W+dGh6js3z1aywoRxZlevykQBkiA9HlvQwHzBx7YyyyBAtcV1ho4XaZrnGPecjH0YaGCT18tJLwN3vISpOKviTj5Ck9uP3dcBl7gkGaGUTsOu2a9bW3fPgR3HjhjtgDMZx6qnkE6S8RhMslvskSIDhSRYjFasSKxXICZuqSRWqke+iE9VVSb06DvfOp614N9vOAiqO2Y5Lx0g1Wy6BTZ/l+7vy+orCSUXTPRUu94vzuQ9iRgVnCJiwqWLpIEpeR37Mj+8MIEEAf+LbJnpN/EslcOeLJ4jbohK3+NlV559Td+8vv4v+pt1YsW4DqkjV2rYQPVNaR00PUMO6KCnRSVrDZL8CCOoMwQDZQBJHlbn0mS4mfmKnwNw0nc+keHEproIlOfJa3P8strZlSxUubKxYxWeH0HIc73fCHjPqKJYt7LEl7bZBv5H22+LyvDSp/CTZbNEphMboT7rYMxjGRasCuOvGIdz7WO8daYs/S+/623e8hK5g7Pq0qv7s33+4EasvPAkde3sxo0aVhIaRfXTSfZKSCkbrpGNwzLgkT+IxHaKY3Ex4qs8VkQGPwrqkoyVTdbO2kwmyxH2KwrPGk/nuDZMqlskLsxxGK6wfU8Tz5ByD/3umSSLG6CZMMmnZ9eSzH+yzEQ2TviCEb30whr397v49nM97x0so3XBrwOWbv/qF/3vBnUQqSkqBRsKwLCpUnafKhG20fNsnVG8i4bsdtCNleKAJYcz4ohm7mHE+xXFxDDwn0ODm2NDcaIAPWED1CZTfKUqCni8q7klKwjtOPwwoWYYeoJch4UWSzEQ1PX+KVO59vwL29aOnjHzqEyKwcIYfmzsAPHXhElz0pS94oP3gx0B3r0eCTIMhbXIYpkaqTthBZ9ifzAAF5tszdwR3ge9aDktqfiQnn+xkdqo5JCkToFBYFmxwUv0EclnIli6OTn7wYJJhxRwXN51Htp863b0/A55uw+uzgCvpcs0vnQg2NPOKM4ENT+3BizMfwelf3ORFaH63Q8WCEKk00nOCoDiuTg1nIxx0hn+n61lg2BhhPaZmWSz3GfDwvfkYYarMdXx17PpBCnGNJPnCKTMAlrDRRsAq9HyGraAr5eCKla6U3P/5c2BzG3YQmOvo1oNTFQ6csliu0GZE7zf853N4Y/kvMOuOTxPlf8tFW6dGNlWoWGK0skEV6bYMg8ZypMz/LNVkTguKzqHqvrTa2bBgRh3ngsnyOlo+4EJKU6aOiOIQAxbEidg1iXNzp4tPnWvj6rOAT5G78lQrXiMw108lmBlTMCWLPyQyQO7m1d8gp7yji/y4mzlMEblxmR9j5fIRM36j4vugwtYJv1RIK5FhBELevhGr5m0luIr3PROnlat/DQH88LnKyFUGIxQPeU31DLK4Z2c/sHKOjVsvA+4nNftEI9pJ41yqTjGYUwpoBtQK8s17Oe647wHgnLOB889y0HXQlbFaRoCKNR+sDMACEC2QXTNAMJYFSazICe9mgJMdgnpUIOj9Vs0An3MfYUe5bCJFdi5xfCjNEFYsfOEGjse3Ao9uIz8UuJxO7ZoOoy5TPsAtNGAt8PXNe/GXX/yaHPObiVWGHBnh0dQsCIeAykeCGgyPBDEjuSKwEB/0JHtoyANbgBgu9Y5rQQ/IjOSPAFQXHcF7CE3jMhbcH7Nx+xUuEsS2v/RbGai/gW716nQZQpsWGQvCkFP7fvih70MyyRuuctHZ40hQmOqNtEiwtJEq0bWz0qiHPFCFVIlOMEhqsbUVMIh93rZpJb72+2vw/hvK0doExGIElOKBLv1MJ0/Var46VrNuToDOPdDDsXGlg3NPBe76kRxY+Aa5Jz+fTuOh02KAWzTIfU9j720X4qFvfRufvuvviP4/51DDqyiJQIb3RDgOvu0TAMTIxTHT5EZUUWeoJmPc5xEewTgtkp5zL6lESf0MLH9XBGuvVAmcRfjYP59ByHwbrb1JNO7oQ5wQ0RXP5xXgChAVapFQJAozmZRRBtlZ6Lo9gwoayix86nLgW6RJXo9hx3eexufuvxDTaplWOUVki/7x1y/D3LMX+OgHOQaGPFsaCHFPajRPCkXwYdGyKpx/7anSRWmj88+/cgkuvG6RdPKv+vBy3P7oVfjIplOw5vKTYTcSM91N+lZbhg99cRHu/NYy/N0/zIFN53aQQxwiMFPUORTdu/6shYup4zielIrgATHboSEbd1/jYjvd6wevAg3ANZiGy7RKQfnC04h/9kJ848FHcPcjXyeSdHoQ23c6qK72SI0Yg+xpBlacWY5/euwWlFWXYffv/oyWXa3Y+PmryL3owbvXVWPpKTOhpgbAW3qlx8uqrodiPQO7+2E4gwegRM7Ayhs+j8/ENlFn2Ilzr1+G155pwr9/bxDdPQzLz1mBxte3SzUOVyFXysEt5ztYSCheS2aBML+HnnVfEdACFnJBv/KXdnzmD5sRvuk6C93xeWDOHqRIwM44bwnK583HmrPDiER3wd4TxOKNH8cp7/09lLdfQqjiWpx8cRJKrAtKiwoWWA6X7YM68CxYzQoYfZvB9FUIiRht51a8+7KYDN2x0CJc8pm7cNLZjTCSLnTNwo4/MSSGOJKGiwtOcfCRDcAXfww0m3jzfz2NL2KaLtMujXMb57Eo8J2H/g3Y/qqBefNm4ZUDtaiYPQ93ffc6/LdNc7HmnPVQuuaSZQ3A6WpG+kAAplIGNbEHod4qWO29sKNXg5UQB028Tb22HBY5SK4dR7j8HLBgBEbvK0SYToZrXQ/eYUGJV2HJSX/CirUhLLvgKvz9d74GvXQNemNhVIRdPPEi+Zs7ZfLYZzCNl+kGKLv8VBZOq1h13ruBeSdXYf4SA/c9/CVcefNKOtoGvNECJbUEgfpPIBixETj4U3DtUiRLlyEZe4Je6GSEQjNhuCSlRpyI0nyw2g2w03sQVueTm9SHxOAumEYKSvQWBEpOo/MHoXfeB6WdKLBN9+l+EgvKH8UnbtqG2z+VwFsxht4B4GFyqRaX497PbsTaUSLC06MBp0PWn1j+/mnyAa5Dbcsgfvs3F+CsD24EKt+1DvUXvI/sH1FZ3gBG9kzkgPB0N6lOGyz1MpDuBI+cCcfugp08CDuyGAHzv+DGyF8pPYO+vwsBfpBavx4uiZfZ8RVirbMRqCG7yojepsi3qZhP9vbz4CUkrTUb4Bx4gNyVErCZFUDUwhMPb8UTPwHuvIpuT+Tpnp/Der4Fn3v4T3j4KxeOncZ5Qmb9ZcKyPIgGke9643qcfNengRe3R3HahrNRv2oxWPxkqHWfgB37E5yOH4CXLiWyQpyk5w2yjddJ1ap0/JJAPo3o55Vwkq/D7X2O9GMN3BmXIKgGYXUTm3H6oKVNsplL4ZbOgdv3QzmgzcPL4CZ2QilZSeQrDSXZAaXsAqmaud2J9MEn0ZlU8MaT7ZhNtnw+kaOv/Ar42av4Pvmht5IPbU6XNM4pV7kCTJKTOgLzvz5wLk7+8ibg1+TnPftGPRrWLIQySCqw7HzYA8RIkiRNNVcT+m+C9+2AGzkbtj4Dpr0PafY20rwJxiABa+2FPvd26gTXIuDYBJJI6iUfZZCOV1+BlLUN6f4/w2J1sIOryI5q4LW3wnXJlioVYBrBFF1E9vd5WjtQMvMmLLrwLtQsBn68hfoRse1N7wduX49byOV9pp+o9HSxXco0ALP2IPBnAnPJpruoV79E0rm7mnzKNWB2EIhvJrW6Faz3l+T010JTA9AthaRuMULRNSgpYYj0PolIxc0Ih0ugp1rgGNtgt91NPqoCtfoyMBH+ESG80BwEUltR4ugoLdtAv7keJdFzESApDNLT6NwihjsDGqltt/9pJLu3QQ3WkMS3ge3bgjNX1+I9fwP8YhtwsBu45RJSv+/FWSGGl3qAM5UTGVABJnkMM6hdtnyQwPzHzwOd5OR/5QHg+k+vx4Yby6D02aQG50Dt2Qo1ehEU5ynyL1+G6tZBqTsTSvpp8CECz0wj7ZQhaYdgORECYQ3ZtU6Srn1w0/vAzd0IzPwytJrbYGqzkaSbp41dcGK/oxYIkG3uhz74MvSydeBWL1RnABpTEaq5nFRuP9LdT8BNddOpq3D5jYtRf2YUjz4BGWl6zxrg/g9gZoWGLZ3ewPaJB6g/gFxCDbDlvauw+LP/g7TpIPDCzjrc8fV1uORSUpGtDmCRVLnkepBkQiPl1vcMNXAZnIo1sFKbkU7sQqqvE2btzeDGcwi5AXJLFsHqfwGs9KPEYlfAPvAwAfc6jLav0j27SaKXknRXwNEqkU6+hBSda1dfT+r3ANnRLbCHdtF9O6EFQ9BDJSSlf0D5jFPpvh3USYTGmIOrLnfQHWF4/AUvBWUVaeevfgDq3Ah+Qx30RuVElFAC808XnIxFd33Oi8/+K/mdL++qx/qPnkqsk0CcQ7bzJLJO1VvAZ6XhRF+EXReCWdUGK0AgVK0GnzcfSnkjSd8pKKFz1LKXkQzSbxZfhUBtA0y2E2qFBXvWOQiVPk629lGk4w9CX7ARkbo6BDQFLNoGt2E57Npq6j+7werCsJZ9gsjUHOoUQ4jWhIhcxQjcDgTLxLBLGnXnXoYvP1iO3zeT+n0WGCJJXb4AuO96MvEBPEYm9oapatjjznLPJJZLvfinC6N4/7/cT3yH+McgSedvHieyQVhc9b5SmKFa2CkXNtk9JmpY1JTM6TE52U8lAV014LDZcO0YGWERsQ+Tm9EBVxkkKaohYnMq5pxyJlr3PkNSR78tDZJNfAmO5chR9UD0HJgDjUjHehCtrIUTXoh4z/OkbjkiERWByrORiu2BMXBQjrjYaa8ijYkEcPoerSqBayTxJJn3CJGAa8/2ErrrqR9uJQH/5z/KV71wB+eb3/GALmfs9lBE++YD95Rh2TIHB/ZTgxO7LI1wGEPekFeKAE7ESZ05frql5mf4Of5oC+lrK+knYLuentEiMveaVCY1culs6FUKBjv2w6JrBcq9ezuEvxrxzmfid4aoZYFM4xeB+UCJn9VgeuOkUL0sPzEoIKRZxEmDIh/GNEjio6ir0xEuDZDtJkolyFoohJkNUdzzrUb8bGv79v2cr37Hx3KpfW9dMX8WLrrjYVi9aZQu7yf7RL4ftbBjDGC+zKu0iMjERFmRjMpbhDS34jJfVgQXxD/XSpGUDIqcd9jMlknSKkm0zsWQTBVSxgFobgN0V4fBDJmcHRQNL7LpJUqCDHE6R4ci0kLJV2WEqC1yg6mnMDoukr1FEraql1Bn0b0RAjqHOYzOFSDq1KE4yvxUQ4WQD1eGSSOQr4z2KdG6xx1Q6vRNiaSxxOojNyFURg0Shq5rUEQ1L9e9DHcx9skUasRMDYTl5YTJFCM/44vOs+04rQlZii2OB8l/ZCSmhhVDmPYHVHJjWAgGqWbbSZG0ed+p68BwhuR1xPlinypEVCQQcS8zW3YY26t34CLbXiSC037H8rLOOPm3IrlbhUgccxAfSsnUzv5Bjqa3O0TMd+CEADQANA90D6Dj7d2Yu7gBGvX6ph378P2v/4QQIbXmelxNZCooTNSukC9JkqKQdIpseoUkR5Q0qEGRxeCSZDFPuk2dJJ1JXaqGDa8O1NAIDPpNgNwfjaTeZXBSAVnzAtUiNWv7mfWkCywG24CUZJFRb9uiZMKWuUSi7NAU5dz0e5v2iWPy+tSRUqaL2fVl+MhNa6kDKWQyBtDTNSTes/NEAbSxL55G1/52zF1URT4lvXlLF17f+hZOWuLZxUwydaZAaNhWikZ0ZUWCl0ztC5SoghDERb6QID0RzzdKD3ppKmrA38ez+1yetZmZhG1ZNpqp5GZZe53JHOReEuJwaYYY/B4YENkT/XDSp5FdVdGyrxNdaRshb46Gdz6g1N6NouseaDyAM85bDCdu0EPYIC8D1XV5jM1PlB7OgPc08fAK5gNh5Phhwawz5qS8EgrRAVQ/t1eU1TtW1iFWAv5nnxvKkgs7W56YuW+GO7o5OcAyw5DAXjSnkjRLHDylYn9LL4jPgTzpt08IQKkNd4tty94DxJAGYCctCaiQPJELJNI+3BwQMyUrrp/lh9wCJMVrfOYDmwEZmXpRJ1uA5PpS7/KRoMh7ZVI93ay0cif7zIdk5rORpfq15SEEeBKJARuNjf1QvVu9Oa0BXbBgwaTcsBrYS+3e17y3s8oiQIVvSB4mevpCaNmfltl1qt/7RWNrmTzcnIkucjPyFJat1Fb9HNtMBbeVyja8Xup3AsdXmb5Uyqw+PVvslCmHcP0OMawZRhn1E+6MyCCMBl1oThzdxNr3Ng6KRhWTNrw5GW3W1NQ0vSVUDHvQTXe2NHav6+/qQTiswo4P4rTTT8Li1fORGDRl7Ygov3fE0JYsUvIqldIpC6lEShYvCXdBlgy6liQ5wsVRNL/OU9SI0veAwWTZoXBFVN2rDzUNLjuRbXli54prwZ9dBR5BEkXBVub+roe8Y3N5z1zpFjY+nWaoCBNJMofQtj+Ojm5D2M83ICd1eWerXNnHe+fPR0lz886O9sF1zfvaIeZWCBMQId1AWbgb5QFHzk4iGK1LQNh+qbSYoUQAJ2Yw4b5xEw2cTpkSFM484AUQYhYTr+aFYCYxM0QNIvOqsR1RtEtAOZnaUpdnJVBqBa8TCCbmyhOytjMXTFllTt/NIQWVQRN2wkbz/gS6HZl8vYPe85Cymb92QMdM0aAevKObGrStpRsrlpQgFODob2/HM7/eg7JSn8niULWXmdAi164x5VD7hrxzpO1Vc5qXH2oXh+12Zi4jni2K4jxbD5OBR5ybIvZTSUy5MhAn+8mxu8mQM6DRqVvGaQf+1wYoO9x+krZtpvA/9/bCPqsWKklVSA8iQUxR5MUO14DmNGg+QSl03/BnngULfOzf55KlMa/l28+BIWK4tS6ielKWWzR1ePbZVZTnMUphW1478OkOKCtgn/xuBwJvKYbRt6elvao3HZOJrhWVpK72kyDVehLKMT5Ihe7jo5QR8sOAdbjjmTcRGfdVES5i/2hsB1p75KvsS1ZWvp1D0NkY0nlMgNWOA5gsf1+soSGpkx1tPWCu6yQSNGcm2Z0q8mJ2eK6LLLPPKenLMF6eW0bPc1oj5zPPlURkP2eqz3JbMBcgNoomGG3N2NI0gRmi38ys9MxsczfQZUr/c0tfNMrHULVsDInl0wXQw0klG2tbwtjLHd18XSf17MXzgFKyRQkjjJYOTRIhMTuJZTmSvWZIC8txISTIbvZ7prUUdSRw3vwLzJ9CThlGz7uWT64cPkyOXMmcfVXvjgQzM5eDWONkLCvocg3UEU3qgLsPyMEbRBl7/jBgsmMprZNtQ8eSSpb/WWNs6wC1khgus04HygjQVWvn45wrzsZQX0xOOWMYludikA5WwGU8VbgbMkWIPH/hxki2KWcZs8j18GKBguVmFi8m63juS2YqG9dzYeQUccLBccSUc955cso41x1JspCtO9X8GhuFbOZsYndlEWAo5YW/5N017RnkuLqjgDqetE6phLLDgJkP4ojvZEe3O+m01dgEXdRwVlJPT8U60LFnOzTFkqdx0r8KNbCYDFfML6SYJoJCFzvCXUkj4IuNrpLbE/TEyhFAqc6w+nRURw6xuUz+D666/pxE47xZjprOV78CawGoqOJuIP9kBq3b9gJtvcDFa+vbbrzzw+99e9t//vC+n6ixMUDLl1Y+mepXO45gjlgH6+s7lObmXfv34zRRiFtbR93aGsDzT2xHdZU/lRsbnfjkx3eRo47HNAJ8pEszFukZ7V65LS2uIUibCAEvmOHti4UjeORrNhZsmDsnsmzwq+dds+7uZ//y5zXPNmqdBYA5qaBqx0DNssMAmom4Cjv6SusBflob2Z/TV1OPbwC6qedX1HgZ6mMRE84nxkrzt7ktlhvSy48fZ7bD8wi6XkcT8yaJUaLZ1cCBpI5rbgrJsVxrZi2Sb76GUGVV1b1fW7z5omubl42vB8YE9bhK6OEY7WhgKqN91xTlhT7bubmVAH33Wd4kjV2kuso7PdU2PF+CmsN4cyYtHsttGVOq/eG33Dn7MsRKguUHMjJbOXynaJg/V0NNtYZaWsUUdSitQSSskJlIoXfIRdNBC3qAoao/AT24DEqwFgtXt8y/96Otn733fzvfRM6UqwXa0iMGeDJZ7mhESBnvsx0Ov5iOx809byMg7GhNtZcW2d4+cqhqmMn629wpyTNsd4Qk+g/h5AQobD8/KTMRZMYeygmQXe++GXYrh/nIufzYexkuWx9GUOdQxfSgoVJg3kKisrQ1CNgQPfCMkExwSrfvg0U9TQQYamvDYOlFuP5DBzc99NjuR/qsQDJnnAgjwyajfsZ0ULnj2UwlZzv8OVFT06EkEm82NvKVPSSZM+uBRbOpjWZ6g9BO3gB3ZvCb58RVM/tzt8MqQs22nuIPUA9PXJVhr2xkK4rzojX12HRlJxoW1qCtKSVLvJlqoKxOhdvYTETLRYgeMhSqBOtVwYIN9FmFMvQmoiuSsDu6oDkzULJ4QeCKCxqv/dEf8dhhwoBTpnLZBIBUxgBTWTHTqF53mrV84Ry+0hwqi5aTd56srEYDAfq+aELm8qRtht7GXnS1kQtju+OSl/yB8BGBhQLDhbnHVp23jGx5J9KNDrlXiq/6vVdgWhCK5tJ3MeOZJnsNFyM25DtzkQIhnyMNJ9UCFTouOafyQz/648B/+NKp5KlfTLbEHqvAAhtF9SrLo4lLP3td4r8vOzm0UiWlFgrp0KpnQ4nUwEqTS1I3A4tWVsoRkXjzWyi5YSECDdX46QOv4bc/3uUNk7HsnELClmZSQw6JseVFkjgfGRd23axrwn3bKiRczLVww8YXMP+cenTtEzN/BhCgA0IFcxZAKFIPFo2SpgjCSTtQa1KwjW4YLvku3ETPz3egculiuEYPSssW4MxVdetXLOgtea1JTYwTWJhylTuedB6yL2xa875zU/dv164Kze0ZoMbotRGoEF2VmKFIvlJaSIXNIF9RF5OXQg0EUbHqbJhtjYjv3IMP/MMZIrMTzz3uJQGIuIHM06Vt2hrZGq6b1+15diA89/vwHEjMW3V/bqKLbrgYTvNTKFtfjZLTohjoMcBkhMmGyWNw+naAOTVSN8eJBKHRJkAtWD0JpJsH4cR0VMythtk/CDPiIBAxcfrsoY2vNVX8chQyNOnqVztKaTycG8PqdXfpQx9s33rSkkp0tHEEiR/wgI5kLI2KiAoHcbhpDcn2LoTnlVLjcFnSp6gmtHAIRtx7zHfNj+OsWz37Kf7shiBRYqjU8JPDWB7RyR0qG+5pTtZn1X2WnAE0qHpz18eje8DmVeDNVxJoqNMQ0UR2IYNtubDExMnpNHXIfpll76Rd2HFHJmvbInPQVTDUUEfqqArM7ILduR+BWhvRoLqGbvWrI3BTJgzusQz9yfXTf7vxat76CGJJkj07ARbwphUXtQViTj/RKEqZg8isBnIVaqCXVxIwCoz+g9R4rYgsW4T4lmfR+3YbODnyuj8plGj8aMSb09ab8BjZ3N08QLmb5ZgSdD8LP/N3XwTDJSFDyhQS3461H29A+1/SGKR9QwRSup9IkPjTIgSV0AquTerW9GbKTgnZ1TgCzEa61YJ9KjnTAwfBqGMm+w6gRA2hoUadmae1pmXoryBJrprBYtZgiCQvgVC0BA61Pr0/wqWkXvUQSuacBIcHkGhPIlQbR7o7BhaxoFSrMJs60PW9J6H1c2z+SwCv7TJRUQZvanLVM8yCtapK9o/ncD6GIvNVrZBsywcybXhAirJAocaFOxOl62+ancTSRaq02SmSzITC5Z8PkTNoM+5N/6qKVBYXGtFxzXRkNr++chZMei+zv4M0kCnjw6XtBhrK3epjOcJyPMZDh3tjzyuPpS76cBW6exwMdFsos1IIlodhKipsl2xO5xtwq2dArytB0m4k9TuE9J4uGM29cOKKsKgyob6pX//N671Ki9vtVogEApKOSsFY5J/U4FzsC2eV6vihGd+kJoi5xpjXD0zqESLTnbO4Evv1H+2zb/+ktnqwz5uK3CJpYySNOvPSV8R3kZvEifFqNWHqpAp4eRm5Lxq017cjUReR8eaAzmAkTJHsHRxFQo8JsNpRqtXDLkkzlFKJDdaSc149U4OBchgpGzo3PYdf/JEcAi+ddKT6ddK+rwlqrIAr/v6Y8R9bo//6596yX6A+G5xg2e14seTxsB0mw06ekh50kt3hKFsdJhsf66FnECM1JtlRclcEeCJB3xZVcWECMEhb14Ia6wA7mMYQPX/CJdtLBM+IGaicFURPjBsTaNujUsfHPEnsqde1Jxc9Z/3hwvXapZxUlBEnhiuHrsRfRPL+EIAsYbBVWfYggqSkFlPdMdb+Wkvoucd3lv7qrW69B8dxGpmfbivZHPlmInrDpfjAotl8VnmZ59s4KU4kzJNSRTw3mRGrz5FzDiZMBX1WmJdVa8wmVdtDnbMqEkQonMTe/YGu4/XsBZcTLliwgI1HfkYLIOSuV5wUX3buafyDDbWYpym8NqDyWbrOqzXivI7D46kU2roH2c7WHmXnjjb9ra3NoZaBtGKPEmFi47hKE2HjfJTtIevly1LvWlzvLJxRwWdWRnllNOSWKowzUrvOYILF+uPojSXY/uZe/c2QzsN3Xmf8MAALrf0Eck+aNA9w9/9p2NhqBrf6QYXcNTdtnI/yTCIvl08VoIeE9nJWNe+zmrdfHeU8ZYxo01g+7xGp3Dww84F1R9nmrk7+9mNrhy6+eLnxvq7u9MFebenex18Jb3+1uXvrGEC6o3SiaQfomFJaALDKEQI6ETvKC9gWCuhowDqj7HcLlM6jBnSybeiIYcRRVjfvuFtA4yt52+MJ6ERAdcf4HT8caFPFcnmB9qlQUMcKUueuuazPzZPQIwFzoqC6YwCbC6BToOQdCZjHLThfaJB5PFBHW5S8c5Q8IN0CAS1EQo9WSnmBkjoeqPn7jlpytUlSseMFmXmB0jgaiO4othMTAPVIpbRQSeXj2MbRAMYoAGIyVbB2lJI5Xj7paODk20YUAOZEXRV2BOqsIBdmAhLLx1DB7jgSi8mQ1MkgReMBy0cBN196R7OTxxrMyQR1LMAKtaeTSpC0SQaTjQIkywMJeTHNfPZ6vMCcDFDHY7XuOMcmTSInA9BC6jbyY5GjAZs/lDQeeEcKZqGlfIWCerQgj2WnJ82eTqbKLSSo7BYI3JGQn8mQ0ImSpSMBerx7TJnKHa1MjhUALi8QuCPxMycL0In4qRMFuhAwp8xtKQTUw9nbw2Xd4yilcqLV04eTVhxGbfICPh8zMI916A8orFhnIgGCyVKzEwV0IgEJFCiN0zJjgY/SsPlgTqQCa6KSeKwBPVLJRYHHp53bMhHmW0in4EcpiWySADxSyZ3IsWMiqdox6N3jzSnAjyI+PJ0AnQhA/CjvPaU2FONIWSHgjjWiUyjAfJLf4UjP4ZPQiaYNoIWAwMeRsKNtTDbJ0nksgf+rArSQF2NT+PL8r+SaE1r+vwADACeJff1qqoqzAAAAAElFTkSuQmCC"

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQjUwMkFGRDQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQjUwMkFGRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZCNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQUZDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+L33IaQAAMdZJREFU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"

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzNjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzNzQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQjAwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+56FGOgAAQAZJREFU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"

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAAxCAYAAAABf+HvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNDBFMThBMjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNDBFMThBMzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEEwM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE0MEUxOEExM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gmaSkAAACUhJREFU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"

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4NDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4NTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjgyM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjgzM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+aqH0aAAAKFxJREFU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"

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFFRjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGMDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEE0M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUVFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CibruAAACphJREFU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"

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<img class=\"recharge-record\" v-bind:src=\"recordImg\" v-bind:style=\"recordImgStyle\"/><div class=\"recharge\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\" v-html=\"item.goodname\"></div><div class=\"bonus-money bonus-sub\" v-if=\"item.sub\" v-bind:style=\"bonusSub\" v-html=\"item.sub\"></div><img class=\"recharge\" v-bind:src=\"dorecharge\" v-bind:style=\"rechargeBtn\"/></div></div></div></div><div class=\"my-money\" v-bind:style=\"footer\">我的金币: {{userinfo.money}}</div>";

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(155)
	__vue_script__ = __webpack_require__(157)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\ruleIntroduce.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(159)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-41af1aed/ruleIntroduce.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(156);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/ruleIntroduce.vue?482cbdbb"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA","file":"ruleIntroduce.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.introduce(v-bind:style=\"content\",v-html=\"rule\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n            console.log(this.rule)\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                rule: require('./../../data/ruleIntro.html')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.rule);
	    },
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            rule: __webpack_require__(158)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n";

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "<div class=\"introduce\" v-bind:style=\"content\" v-html=\"rule\"></div>";

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<div class=\"model\" v-show=\"dialogShow\" transition=\"message\"><div class=\"dialog\" v-bind:style=\"dialog\"><div class=\"close\" v-bind:style=\"close\" @touchend=\"dialogShow = false\"></div><div class=\"content\" v-bind:style=\"content\"></div><div v-bind:is=\"dialogImg[currentIndex].type\" v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\"></div><img v-bind:src=\"dialogImg[currentIndex].background\"/></div></div>";

/***/ },
/* 161 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    notice: {
	        'content': '?????',
	        'createdAt': 1469543980000,
	        'id': 6,
	        'title': 'title'
	    },
	    options: ['投注记录', '开奖记录', '游戏规则', '兑换礼品', '赠送好友']
	};

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {};

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    'createdAt': 1469548675000,
	    'money': 10000,
	    'code': 0,
	    'nickname': '测试用户222',
	    'openid': 'xxxxxxxxxxxx'
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(165)
	__vue_script__ = __webpack_require__(167)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\tip-modal.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(168)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-691c031b/tip-modal.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /* 否则 scale 动画不起作用 */\r\n}\r\n\r\n.bounce-enter {\r\n    -webkit-animation: bounce-in .5s;\r\n            animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    -webkit-animation: bounce-out .5s;\r\n            animation: bounce-out .5s;\r\n}\r\n\r\n@-webkit-keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@-webkit-keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n", "", {"version":3,"sources":["/./src/components/tip-modal.vue?79187cbe"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;IACA,oBAAA;IACA,mBAAA;IACA,WAAA;IACA,aAAA;IACA,+BAAA;IACA,aAAA;IACA,mBAAA;IACA,mBAAA;IACA,mBAAA;CACA;;AAEA;IACA,sBAAA;IACA,qBAAA;CACA;;AAEA;IACA,iCAAA;YAAA,yBAAA;CACA;;AAEA;IACA,kCAAA;YAAA,0BAAA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA","file":"tip-modal.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.tip-content(transition=\"bounce\",v-show=\"isShow\",v-html=\"content\")\r\n</template>\r\n<script>\r\nexport default {\r\n    props: [],\r\n    data() {\r\n        return {\r\n            isShow: false,\r\n            content: ''\r\n        }\r\n    },\r\n    methods: {\r\n        showTip(content) {\r\n            this.content = content\r\n            this.isShow = true\r\n            setTimeout(() => this.isShow = false, 3000)\r\n        }\r\n    },\r\n    events: {\r\n        showTip(event) {\r\n            this.showTip(event)\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /* 否则 scale 动画不起作用 */\r\n}\r\n\r\n.bounce-enter {\r\n    animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    animation: bounce-out .5s;\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        transform: scale(0);\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        transform: scale(1);\r\n    }\r\n    100% {\r\n        transform: scale(0);\r\n    }\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: [],
	    data: function data() {
	        return {
	            isShow: false,
	            content: ''
	        };
	    },
	
	    methods: {
	        showTip: function showTip(content) {
	            var _this = this;
	
	            this.content = content;
	            this.isShow = true;
	            setTimeout(function () {
	                return _this.isShow = false;
	            }, 3000);
	        }
	    },
	    events: {
	        showTip: function showTip(event) {
	            this.showTip(event);
	        }
	    }
	};

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tip-content\" transition=\"bounce\" v-show=\"isShow\" v-html=\"content\"></div>";

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<background></background><menu-bar v-bind:game-data=\"gameData\" v-bind:notice=\"notice\" v-bind:zoom-rate=\"zoomRate\"></menu-bar><bet-and-bonus v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></bet-and-bonus><play-panel v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></play-panel><state v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></state><message v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></message><modal class=\"modal\" v-if=\"error\"></modal><tip-modal></tip-modal>";

/***/ },
/* 170 */
/***/ function(module, exports) {

	!function (a, b) {
	    module.exports = b(a)
	}(window, function (a, b) {
	    function c(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.invoke(b, e(c), function (a) {
	            g(b, a, d)
	        }) : j(b, d)
	    }
	
	    function d(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.on(b, function (a) {
	            d && d.trigger && d.trigger(a), g(b, a, c)
	        }) : d ? j(b, d) : j(b, c)
	    }
	
	    function e(a) {
	        return a = a || {}, a.appId = z.appId, a.verifyAppId = z.appId, a.verifySignType = "sha1", a.verifyTimestamp = z.timestamp + "", a.verifyNonceStr = z.nonceStr, a.verifySignature = z.signature, a
	    }
	
	    function f(a) {
	        return {
	            timeStamp: a.timestamp + "",
	            nonceStr: a.nonceStr,
	            "package": a.package,
	            paySign: a.paySign,
	            signType: a.signType || "SHA1"
	        }
	    }
	
	    function g(a, b, c) {
	        var d, e, f;
	        switch (delete b.err_code, delete b.err_desc, delete b.err_detail, d = b.errMsg, d || (d = b.err_msg, delete b.err_msg, d = h(a, d, c), b.errMsg = d), c = c || {}, c._complete && (c._complete(b), delete c._complete), d = b.errMsg || "", z.debug && !c.isInnerInvoke && alert(JSON.stringify(b)), e = d.indexOf(":"), f = d.substring(e + 1)) {
	            case"ok":
	                c.success && c.success(b);
	                break;
	            case"cancel":
	                c.cancel && c.cancel(b);
	                break;
	            default:
	                c.fail && c.fail(b)
	        }
	        c.complete && c.complete(b)
	    }
	
	    function h(a, b) {
	        var d, e, f, g;
	        if (b) {
	            switch (d = b.indexOf(":"), a) {
	                case o.config:
	                    e = "config";
	                    break;
	                case o.openProductSpecificView:
	                    e = "openProductSpecificView";
	                    break;
	                default:
	                    e = b.substring(0, d), e = e.replace(/_/g, " "), e = e.replace(/\b\w+\b/g, function (a) {
	                        return a.substring(0, 1).toUpperCase() + a.substring(1)
	                    }), e = e.substring(0, 1).toLowerCase() + e.substring(1), e = e.replace(/ /g, ""), -1 != e.indexOf("Wcpay") && (e = e.replace("Wcpay", "WCPay")), f = p[e], f && (e = f)
	            }
	            g = b.substring(d + 1), "confirm" == g && (g = "ok"), "failed" == g && (g = "fail"), -1 != g.indexOf("failed_") && (g = g.substring(7)), -1 != g.indexOf("fail_") && (g = g.substring(5)), g = g.replace(/_/g, " "), g = g.toLowerCase(), ("access denied" == g || "no permission to execute" == g) && (g = "permission denied"), "config" == e && "function not exist" == g && (g = "ok"), b = e + ":" + g
	        }
	        return b
	    }
	
	    function i(a) {
	        var b, c, d, e;
	        if (a) {
	            for (b = 0, c = a.length; c > b; ++b)d = a[b], e = o[d], e && (a[b] = e);
	            return a
	        }
	    }
	
	    function j(a, b) {
	        if (!(!z.debug || b && b.isInnerInvoke)) {
	            var c = p[a];
	            c && (a = c), b && b._complete && delete b._complete, console.log('"' + a + '",', b || "")
	        }
	    }
	
	    function k() {
	        if (!("6.0.2" > w || y.systemType < 0)) {
	            var b = new Image;
	            y.appId = z.appId, y.initTime = x.initEndTime - x.initStartTime, y.preVerifyTime = x.preVerifyEndTime - x.preVerifyStartTime, C.getNetworkType({
	                isInnerInvoke: !0,
	                success: function (a) {
	                    y.networkType = a.networkType;
	                    var c = "https://open.weixin.qq.com/sdk/report?v=" + y.version + "&o=" + y.isPreVerifyOk + "&s=" + y.systemType + "&c=" + y.clientVersion + "&a=" + y.appId + "&n=" + y.networkType + "&i=" + y.initTime + "&p=" + y.preVerifyTime + "&u=" + y.url;
	                    b.src = c
	                }
	            })
	        }
	    }
	
	    function l() {
	        return (new Date).getTime()
	    }
	
	    function m(b) {
	        t && (a.WeixinJSBridge ? b() : q.addEventListener && q.addEventListener("WeixinJSBridgeReady", b, !1))
	    }
	
	    function n() {
	        C.invoke || (C.invoke = function (b, c, d) {
	            a.WeixinJSBridge && WeixinJSBridge.invoke(b, e(c), d)
	        }, C.on = function (b, c) {
	            a.WeixinJSBridge && WeixinJSBridge.on(b, c)
	        })
	    }
	
	    var o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
	    if (!a.jWeixin)return o = {
	        config: "preVerifyJSAPI",
	        onMenuShareTimeline: "menu:share:timeline",
	        onMenuShareAppMessage: "menu:share:appmessage",
	        onMenuShareQQ: "menu:share:qq",
	        onMenuShareWeibo: "menu:share:weiboApp",
	        onMenuShareQZone: "menu:share:QZone",
	        previewImage: "imagePreview",
	        getLocation: "geoLocation",
	        openProductSpecificView: "openProductViewWithPid",
	        addCard: "batchAddCard",
	        openCard: "batchViewCard",
	        chooseWXPay: "getBrandWCPayRequest"
	    }, p = function () {
	        var b, a = {};
	        for (b in o)a[o[b]] = b;
	        return a
	    }(), q = a.document,
	        r = q.title,
	        s = navigator.userAgent.toLowerCase(), t = -1 != s.indexOf("micromessenger"), u = -1 != s.indexOf("android"), v = -1 != s.indexOf("iphone") || -1 != s.indexOf("ipad"), w = function () {
	        var a = s.match(/micromessenger\/(\d+\.\d+\.\d+)/) || s.match(/micromessenger\/(\d+\.\d+)/);
	        return a ? a[1] : ""
	    }(), x = {initStartTime: l(), initEndTime: 0, preVerifyStartTime: 0, preVerifyEndTime: 0}, y = {
	        version: 1,
	        appId: "",
	        initTime: 0,
	        preVerifyTime: 0,
	        networkType: "",
	        isPreVerifyOk: 1,
	        systemType: v ? 1 : u ? 2 : -1,
	        clientVersion: w,
	        url: encodeURIComponent(location.href)
	    }, z = {}, A = {_completes: []}, B = {state: 0, res: {}}, m(function () {
	        x.initEndTime = l()
	    }), C = {
	        config: function (a) {
	            z = a, j("config", a);
	            var b = z.check === !1 ? !1 : !0;
	            m(function () {
	                var a, d, e;
	                if (b)c(o.config, {verifyJsApiList: i(z.jsApiList)}, function () {
	                    A._complete = function (a) {
	                        x.preVerifyEndTime = l(), B.state = 1, B.res = a
	                    }, A.success = function () {
	                        y.isPreVerifyOk = 0
	                    }, A.fail = function (a) {
	                        A._fail ? A._fail(a) : B.state = -1
	                    };
	                    var a = A._completes;
	                    return a.push(function () {
	                        z.debug || k()
	                    }), A.complete = function () {
	                        for (var c = 0, d = a.length; d > c; ++c)a[c]();
	                        A._completes = []
	                    }, A
	                }()), x.preVerifyStartTime = l(); else {
	                    for (B.state = 1, a = A._completes, d = 0, e = a.length; e > d; ++d)a[d]();
	                    A._completes = []
	                }
	            }), z.beta && n()
	        }, ready: function (a) {
	            0 != B.state ? a() : (A._completes.push(a), !t && z.debug && a())
	        }, error: function (a) {
	            "6.0.2" > w || (-1 == B.state ? a(B.res) : A._fail = a)
	        }, checkJsApi: function (a) {
	            var b = function (a) {
	                var c, d, b = a.checkResult;
	                for (c in b)d = p[c], d && (b[d] = b[c], delete b[c]);
	                return a
	            };
	            c("checkJsApi", {jsApiList: i(a.jsApiList)}, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var c = a.checkResult;
	                        c && (a.checkResult = JSON.parse(c))
	                    }
	                    a = b(a)
	                }, a
	            }())
	        }, onMenuShareTimeline: function (a) {
	            d(o.onMenuShareTimeline, {
	                complete: function () {
	                    c("shareTimeline", {
	                        title: a.title || r,
	                        desc: a.title || r,
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareAppMessage: function (a) {
	            d(o.onMenuShareAppMessage, {
	                complete: function () {
	                    c("sendAppMessage", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        link: a.link || location.href,
	                        img_url: a.imgUrl || "",
	                        type: a.type || "link",
	                        data_url: a.dataUrl || ""
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQQ: function (a) {
	            d(o.onMenuShareQQ, {
	                complete: function () {
	                    c("shareQQ", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareWeibo: function (a) {
	            d(o.onMenuShareWeibo, {
	                complete: function () {
	                    c("shareWeiboApp", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQZone: function (a) {
	            d(o.onMenuShareQZone, {
	                complete: function () {
	                    c("shareQZone", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, startRecord: function (a) {
	            c("startRecord", {}, a)
	        }, stopRecord: function (a) {
	            c("stopRecord", {}, a)
	        }, onVoiceRecordEnd: function (a) {
	            d("onVoiceRecordEnd", a)
	        }, playVoice: function (a) {
	            c("playVoice", {localId: a.localId}, a)
	        }, pauseVoice: function (a) {
	            c("pauseVoice", {localId: a.localId}, a)
	        }, stopVoice: function (a) {
	            c("stopVoice", {localId: a.localId}, a)
	        }, onVoicePlayEnd: function (a) {
	            d("onVoicePlayEnd", a)
	        }, uploadVoice: function (a) {
	            c("uploadVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadVoice: function (a) {
	            c("downloadVoice", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, translateVoice: function (a) {
	            c("translateVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, chooseImage: function (a) {
	            c("chooseImage", {
	                scene: "1|2",
	                count: a.count || 9,
	                sizeType: a.sizeType || ["original", "compressed"],
	                sourceType: a.sourceType || ["album", "camera"]
	            }, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var b = a.localIds;
	                        b && (a.localIds = JSON.parse(b))
	                    }
	                }, a
	            }())
	        }, previewImage: function (a) {
	            c(o.previewImage, {current: a.current, urls: a.urls}, a)
	        }, uploadImage: function (a) {
	            c("uploadImage", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadImage: function (a) {
	            c("downloadImage", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, getNetworkType: function (a) {
	            var b = function (a) {
	                var c, d, e, b = a.errMsg;
	                if (a.errMsg = "getNetworkType:ok", c = a.subtype, delete a.subtype, c)a.networkType = c; else switch (d = b.indexOf(":"), e = b.substring(d + 1)) {
	                    case"wifi":
	                    case"edge":
	                    case"wwan":
	                        a.networkType = e;
	                        break;
	                    default:
	                        a.errMsg = "getNetworkType:fail"
	                }
	                return a
	            };
	            c("getNetworkType", {}, function () {
	                return a._complete = function (a) {
	                    a = b(a)
	                }, a
	            }())
	        }, openLocation: function (a) {
	            c("openLocation", {
	                latitude: a.latitude,
	                longitude: a.longitude,
	                name: a.name || "",
	                address: a.address || "",
	                scale: a.scale || 28,
	                infoUrl: a.infoUrl || ""
	            }, a)
	        }, getLocation: function (a) {
	            a = a || {}, c(o.getLocation, {type: a.type || "wgs84"}, function () {
	                return a._complete = function (a) {
	                    delete a.type
	                }, a
	            }())
	        }, hideOptionMenu: function (a) {
	            c("hideOptionMenu", {}, a)
	        }, showOptionMenu: function (a) {
	            c("showOptionMenu", {}, a)
	        }, closeWindow: function (a) {
	            a = a || {}, c("closeWindow", {immediate_close: a.immediateClose || 0}, a)
	        }, hideMenuItems: function (a) {
	            c("hideMenuItems", {menuList: a.menuList}, a)
	        }, showMenuItems: function (a) {
	            c("showMenuItems", {menuList: a.menuList}, a)
	        }, hideAllNonBaseMenuItem: function (a) {
	            c("hideAllNonBaseMenuItem", {}, a)
	        }, showAllNonBaseMenuItem: function (a) {
	            c("showAllNonBaseMenuItem", {}, a)
	        }, scanQRCode: function (a) {
	            a = a || {}, c("scanQRCode", {
	                needResult: a.needResult || 0,
	                scanType: a.scanType || ["qrCode", "barCode"]
	            }, function () {
	                return a._complete = function (a) {
	                    var b, c;
	                    v && (b = a.resultStr, b && (c = JSON.parse(b), a.resultStr = c && c.scan_code && c.scan_code.scan_result))
	                }, a
	            }())
	        }, openProductSpecificView: function (a) {
	            c(o.openProductSpecificView, {pid: a.productId, view_type: a.viewType || 0}, a)
	        }, addCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, card_ext: g.cardExt}, d.push(h);
	            c(o.addCard, {card_list: d}, function () {
	                return a._complete = function (a) {
	                    var c, d, e, b = a.card_list;
	                    if (b) {
	                        for (b = JSON.parse(b), c = 0, d = b.length; d > c; ++c)e = b[c], e.cardId = e.card_id, e.cardExt = e.card_ext, e.isSuccess = e.is_succ ? !0 : !1, delete e.card_id, delete e.card_ext, delete e.is_succ;
	                        a.cardList = b, delete a.card_list
	                    }
	                }, a
	            }())
	        }, chooseCard: function (a) {
	            c("chooseCard", {
	                app_id: z.appId,
	                location_id: a.shopId || "",
	                sign_type: a.signType || "SHA1",
	                card_id: a.cardId || "",
	                card_type: a.cardType || "",
	                card_sign: a.cardSign,
	                time_stamp: a.timestamp + "",
	                nonce_str: a.nonceStr
	            }, function () {
	                return a._complete = function (a) {
	                    a.cardList = a.choose_card_info, delete a.choose_card_info
	                }, a
	            }())
	        }, openCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, code: g.code}, d.push(h);
	            c(o.openCard, {card_list: d}, a)
	        }, chooseWXPay: function (a) {
	            c(o.chooseWXPay, f(a), a)
	        }
	    }, b && (a.wx = a.jWeixin = C), C
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzEzMjgxM2FjMzE3MGVmNWU2MGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC92dWUvMS4wLjI2L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2U2MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/N2YwMSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvYmFiZWwtcnVudGltZS82LjkuMi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT81ZDVmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlPzM4MTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL0JHLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWU/Mzk3ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lNzQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlPzhhZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmciLCJ3ZWJwYWNrOi8vL01lbnVCYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzgyMTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/NmI3NyIsIndlYnBhY2s6Ly8vT3B0aW9uc0RpYWxvZy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/MGVkZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lZDM4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/NmIzNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MzBlMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmciLCJ3ZWJwYWNrOi8vL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlPzU1NjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzM5MWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9jYmRlIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZyIsIndlYnBhY2s6Ly8vUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzhjMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9iMjdjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9lNWUxIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvdGguanBnIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nIiwid2VicGFjazovLy9TdGF0ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT81MzhjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/YTFhMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/NWZmYyIsIndlYnBhY2s6Ly8vQmV0TXVsdGlwbGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT84MDgxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlP2RmYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/ZjRiYiIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mmpfoibLmjKHmnb8ucG5nIiwid2VicGFjazovLy9NZXNzYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWU/ZWRkMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlP2M5MGQiLCJ3ZWJwYWNrOi8vL2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2JldFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/YjU4MSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9hZDBlIiwid2VicGFjazovLy9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/ZGUyYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZT81NjMyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlP2QzM2UiLCJ3ZWJwYWNrOi8vL0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzkwZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NzM3OSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT9jOTEzIiwid2VicGFjazovLy9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlP2Q0ZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2Q4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT9mYzVkIiwid2VicGFjazovLy9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2E5ZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/OGJiNCIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL25vdGljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT9kZmFhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWU/YzkzOCIsIndlYnBhY2s6Ly8vdGlwLW1vZGFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlP2NiZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/ZDExZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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LFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLO0FBQ2hCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGdEQUErQztBQUMvQyxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLG9DQUFtQztBQUNuQztBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHNDQUFxQyxPQUFP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsS0FBSztBQUNsQixjQUFhLElBQUk7QUFDakIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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LGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsSUFBSTtBQUNqQixjQUFhLFFBQVE7QUFDckIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixFQUFFOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN0SHRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRSx1Q0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFD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QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxXQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakIsMkJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsMkNBQTBDO0FBQzFDLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0Msc0NBQXNDO0FBQzlFLHFDQUFvQyx1Q0FBdUM7QUFDM0UscUNBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLFFBQU87QUFDUDtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDLHNDQUFxQztBQUNyQyxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixhQUFhO0FBQ3BDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixrREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FB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QTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7O0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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O0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsMkJBQTJCLFFBQVEsaUJBQWlCO0FBQzlFOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLEtBQUssRUFBRSxLQUFLLE1BQU0sRUFBRTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLDRCQUEyQjtBQUMzQjtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUEsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFh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QixjQUFhO0FBQ2IsVUFBUztBQUNULDJDQUEwQyw2Q0FBNkM7QUFDdkYsVUFBUztBQUNUO0FBQ0Esc0NBQXFDLE9BQU8sb0JBQW9CLHVDQUF1QztBQUN2RywyQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxxRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLHNDQUFxQyxPQUFPLG9CQUFvQixnQ0FBZ0M7QUFDaEcsNEJBQTJCLGFBQWE7QUFDeEMsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQyxFIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImJ1aWxkL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMzEzMjgxM2FjMzE3MGVmNWU2MGJcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnXG5pbXBvcnQgd3ggZnJvbSAnd2VpeGluLWpzLXNkaydcbmltcG9ydCBWdWVSZXNvdXJjZSBmcm9tICd2dWUtcmVzb3VyY2UnXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXG5WdWUudXNlKFZ1ZVJlc291cmNlKVxuVnVlLmZpbHRlcigndGltZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgbGV0IGhvdXIgPSBNYXRoLmZsb29yKHZhbHVlIC8gMzYwMClcbiAgICBsZXQgbWluID0gTWF0aC5mbG9vcigodmFsdWUgJSAzNjAwKSAvIDYwKVxuICAgIGlmIChob3VyIDwgMTApIHtcbiAgICAgICAgaG91ciA9ICcwJyArIGhvdXJcbiAgICB9XG4gICAgaWYgKG1pbiA8IDEwKSB7XG4gICAgICAgIG1pbiA9ICcwJyArIG1pblxuICAgIH1cbiAgICBsZXQgc2VjID0gdmFsdWUgJSA2MFxuICAgIGlmIChzZWMgPCAxMCkge1xuICAgICAgICBzZWMgPSAnMCcgKyBzZWNcbiAgICB9XG4gICAgcmV0dXJuIChob3VyID4gMCA/IGhvdXIgKyAnOicgOiAnJykgKyBtaW4gKyAnOicgKyBzZWNcbn0pXG5WdWUuZmlsdGVyKCdkYXRldGltZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLnRvTG9jYWxlU3RyaW5nKClcbn0pXG5sZXQgY29uZmlnID0ge31cblJlcXVlc3RMaXN0LmdldE1haW5Db25maWcoKS50aGVuKChyZXMpID0+IHsgLy/ku47lkI7lj7Dojrflj5bphY3nva7mlofku7ZcbiAgICBjb25maWcgPSByZXMuZGF0YVxuICAgIGNvbnNvbGUubG9nKGNvbmZpZylcbiAgICAgICAgLy8gd3guY29uZmlnKHtcbiAgICAgICAgLy8gICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAvLyAgICAgYXBwSWQ6ICc8P3BocCBlY2hvICRzaWduUGFja2FnZVtcImFwcElkXCJdOz8+JyxcbiAgICAgICAgLy8gICAgIHRpbWVzdGFtcDogPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJ0aW1lc3RhbXBcIl07Pz4sXG4gICAgICAgIC8vICAgICBub25jZVN0cjogJzw/cGhwIGVjaG8gJHNpZ25QYWNrYWdlW1wibm9uY2VTdHJcIl07Pz4nLFxuICAgICAgICAvLyAgICAgc2lnbmF0dXJlOiAnPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJzaWduYXR1cmVcIl07Pz4nLFxuICAgICAgICAvLyAgICAganNBcGlMaXN0OiBbXG4gICAgICAgIC8vICAgICAgICAgLy8g5omA5pyJ6KaB6LCD55So55qEIEFQSSDpg73opoHliqDliLDov5nkuKrliJfooajkuK1cbiAgICAgICAgLy8gICAgICAgICAnb25NZW51U2hhcmVUaW1lbGluZScsXG4gICAgICAgIC8vICAgICAgICAgJ29uTWVudVNoYXJlQXBwTWVzc2FnZScsXG4gICAgICAgIC8vICAgICAgICAgJ2Nob29zZUltYWdlJ1xuICAgICAgICAvLyAgICAgXVxuICAgICAgICAvLyB9KTtcbn0sIChyZXMpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKHJlcylcbn0pXG5cbi8vaHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20vY29ubmVjdC9vYXV0aDIvYXV0aG9yaXplP2FwcGlkPXd4ZmZlMTkwZGVjMzI3MWExYyZyZWRpcmVjdF91cmk9aHR0cDovL2xzd2VpeGludGVzdC5hcHBsaW56aS5jb20vcGhwL3VybG9wZW5pZC5waHAmcmVzcG9uc2VfdHlwZT1jb2RlJnNjb3BlPXNuc2FwaV91c2VyaW5mbyZzdGF0ZT0xMjNcbnZhciBtYWluID0gbmV3IFZ1ZSh7XG4gICAgZWw6ICdib2R5JyxcbiAgICBjb21wb25lbnRzOiB7IGFwcDogQXBwIH1cbn0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tYWluLmpzXG4gKiovIiwiLyohXG4gKiBWdWUuanMgdjEuMC4yNlxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgIHNldChvYmouX2RhdGEsIGtleSwgdmFsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBvYi5jb252ZXJ0KGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl9wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGRlbChvYmosIGtleSkge1xuICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVsZXRlIG9ialtrZXldO1xuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgaWYgKG9iai5faXNWdWUpIHtcbiAgICAgIGRlbGV0ZSBvYmouX2RhdGFba2V5XTtcbiAgICAgIG9iai5fZGlnZXN0KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3VucHJveHkoa2V5KTtcbiAgICAgIHZtLl9kaWdlc3QoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBsaXRlcmFsIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGxpdGVyYWxWYWx1ZVJFID0gL15cXHM/KHRydWV8ZmFsc2V8LT9bXFxkXFwuXSt8J1teJ10qJ3xcIlteXCJdKlwiKVxccz8kLztcblxuZnVuY3Rpb24gaXNMaXRlcmFsKGV4cCkge1xuICByZXR1cm4gbGl0ZXJhbFZhbHVlUkUudGVzdChleHApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUY7XG59XG5cbi8qKlxuICogR3VhcmQgdGV4dCBvdXRwdXQsIG1ha2Ugc3VyZSB1bmRlZmluZWQgb3V0cHV0c1xuICogZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIF90b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBDaGVjayBhbmQgY29udmVydCBwb3NzaWJsZSBudW1lcmljIHN0cmluZ3MgdG8gbnVtYmVyc1xuICogYmVmb3JlIHNldHRpbmcgYmFjayB0byBkYXRhXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxOdW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIGJvb2xlYW4gbGl0ZXJhbHMgaW50byByZWFsIGJvb2xlYW5zLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp8Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZScgPyB0cnVlIDogdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlO1xufVxuXG4vKipcbiAqIFN0cmlwIHF1b3RlcyBmcm9tIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nIHwgZmFsc2V9XG4gKi9cblxuZnVuY3Rpb24gc3RyaXBRdW90ZXMoc3RyKSB7XG4gIHZhciBhID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KSA/IHN0ci5zbGljZSgxLCAtMSkgOiBzdHI7XG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCB0b1VwcGVyKTtcbn1cblxuZnVuY3Rpb24gdG9VcHBlcihfLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGh5cGhlbi91bmRlcnNjb3JlL3NsYXNoIGRlbGltaXRlcmVkIG5hbWVzIGludG9cbiAqIGNhbWVsaXplZCBjbGFzc05hbWVzLlxuICpcbiAqIGUuZy4gbXktY29tcG9uZW50ID0+IE15Q29tcG9uZW50XG4gKiAgICAgIHNvbWVfZWxzZSAgICA9PiBTb21lRWxzZVxuICogICAgICBzb21lL2NvbXAgICAgPT4gU29tZUNvbXBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9cXC9dKShcXHcpL2c7XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgdG9VcHBlcik7XG59XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBiaW5kKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsID8gbCA+IDEgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cykgOiBmbi5jYWxsKGN0eCwgYSkgOiBmbi5jYWxsKGN0eCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheS1saWtlfSBsaXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XSAtIHN0YXJ0IGluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqL1xuXG5mdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbn1cblxuLyoqXG4gKiBBcnJheSB0eXBlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBbZW51bWVyYWJsZV1cbiAqL1xuXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gX2RlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBNYW51YWwgaW5kZXhPZiBiZWNhdXNlIGl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRoYW5cbiAqIG5hdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY2FuY2VsbGFibGUoZm4pIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGNiLmNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiBjYjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpID8gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpIDogZmFsc2UpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuXG52YXIgaGFzUHJvdG8gPSAoJ19fcHJvdG9fXycgaW4ge30pO1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLy8gVUEgc25pZmZpbmcgZm9yIHdvcmtpbmcgYXJvdW5kIGJyb3dzZXItc3BlY2lmaWMgcXVpcmtzXG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgVUEuaW5kZXhPZigndHJpZGVudCcpID4gMDtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJb3MgPSBVQSAmJiAvKGlwaG9uZXxpcGFkfGlwb2R8aW9zKS9pLnRlc3QoVUEpO1xudmFyIGlvc1ZlcnNpb25NYXRjaCA9IGlzSW9zICYmIFVBLm1hdGNoKC9vcyAoW1xcZF9dKykvKTtcbnZhciBpb3NWZXJzaW9uID0gaW9zVmVyc2lvbk1hdGNoICYmIGlvc1ZlcnNpb25NYXRjaFsxXS5zcGxpdCgnXycpO1xuXG4vLyBkZXRlY3RpbmcgaU9TIFVJV2ViVmlldyBieSBpbmRleGVkREJcbnZhciBoYXNNdXRhdGlvbk9ic2VydmVyQnVnID0gaW9zVmVyc2lvbiAmJiBOdW1iZXIoaW9zVmVyc2lvblswXSkgPj0gOSAmJiBOdW1iZXIoaW9zVmVyc2lvblsxXSkgPj0gMyAmJiAhd2luZG93LmluZGV4ZWREQjtcblxudmFyIHRyYW5zaXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9IHVuZGVmaW5lZDtcbnZhciBhbmltYXRpb25Qcm9wID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFOSkge1xuICB2YXIgaXNXZWJraXRUcmFucyA9IHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpc1dlYmtpdEFuaW0gPSB3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdHJhbnNpdGlvblByb3AgPSBpc1dlYmtpdFRyYW5zID8gJ1dlYmtpdFRyYW5zaXRpb24nIDogJ3RyYW5zaXRpb24nO1xuICB0cmFuc2l0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdFRyYW5zID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xuICBhbmltYXRpb25Qcm9wID0gaXNXZWJraXRBbmltID8gJ1dlYmtpdEFuaW1hdGlvbicgOiAnYW5pbWF0aW9uJztcbiAgYW5pbWF0aW9uRW5kRXZlbnQgPSBpc1dlYmtpdEFuaW0gPyAnd2Via2l0QW5pbWF0aW9uRW5kJyA6ICdhbmltYXRpb25lbmQnO1xufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAqIHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIG1pY3JvdGFzaywgc28gd2UgbGV2ZXJhZ2VcbiAqIE11dGF0aW9uT2JzZXJ2ZXIgaWYgaXQncyBhdmFpbGFibGUsIGFuZCBmYWxsYmFjayB0b1xuICogc2V0VGltZW91dCgwKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICovXG5cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAhaGFzTXV0YXRpb25PYnNlcnZlckJ1Zykge1xuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHdlYnBhY2sgYXR0ZW1wdHMgdG8gaW5qZWN0IGEgc2hpbSBmb3Igc2V0SW1tZWRpYXRlXG4gICAgLy8gaWYgaXQgaXMgdXNlZCBhcyBhIGdsb2JhbCwgc28gd2UgaGF2ZSB0byB3b3JrIGFyb3VuZCB0aGF0IHRvXG4gICAgLy8gYXZvaWQgYnVuZGxpbmcgdW5uZWNlc3NhcnkgY29kZS5cbiAgICB2YXIgY29udGV4dCA9IGluQnJvd3NlciA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG4gICAgdGltZXJGdW5jID0gY29udGV4dC5zZXRJbW1lZGlhdGUgfHwgc2V0VGltZW91dDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNiLCBjdHgpIHtcbiAgICB2YXIgZnVuYyA9IGN0eCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICB9IDogY2I7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuYyk7XG4gICAgaWYgKHBlbmRpbmcpIHJldHVybjtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgfTtcbn0pKCk7XG5cbnZhciBfU2V0ID0gdW5kZWZpbmVkO1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgU2V0LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLykpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgfTtcbiAgX1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuc2V0W2tleV0gPSAxO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIENhY2hlKGxpbWl0KSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xuICB0aGlzLl9rZXltYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG52YXIgcCA9IENhY2hlLnByb3RvdHlwZTtcblxuLyoqXG4gKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uXG4gKiBSZXR1cm5zIHRoZSBlbnRyeSB3aGljaCB3YXMgcmVtb3ZlZCB0byBtYWtlIHJvb20gZm9yXG4gKiB0aGUgbmV3IGVudHJ5LiBPdGhlcndpc2UgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICogKGkuZS4gaWYgdGhlcmUgd2FzIGVub3VnaCByb29tIGFscmVhZHkpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0VudHJ5fHVuZGVmaW5lZH1cbiAqL1xuXG5wLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciByZW1vdmVkO1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5zaGlmdCgpO1xuICAgIH1cbiAgICBlbnRyeSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICB0aGlzLl9rZXltYXBba2V5XSA9IGVudHJ5O1xuICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5O1xuICAgICAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLnNpemUrKztcbiAgfVxuICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuXG4gIHJldHVybiByZW1vdmVkO1xufTtcblxuLyoqXG4gKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZVxuICogY2FjaGUuIFJldHVybnMgdGhlIHJlbW92ZWQgZW50cnkgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICogY2FjaGUgd2FzIGVtcHR5LlxuICovXG5cbnAuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgaWYgKGVudHJ5KSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5ld2VyO1xuICAgIHRoaXMuaGVhZC5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICBlbnRyeS5uZXdlciA9IGVudHJ5Lm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2l6ZS0tO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8qKlxuICogR2V0IGFuZCByZWdpc3RlciByZWNlbnQgdXNlIG9mIDxrZXk+LiBSZXR1cm5zIHRoZSB2YWx1ZVxuICogYXNzb2NpYXRlZCB3aXRoIDxrZXk+IG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5FbnRyeVxuICogQHJldHVybiB7RW50cnl8Kn1cbiAqL1xuXG5wLmdldCA9IGZ1bmN0aW9uIChrZXksIHJldHVybkVudHJ5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX2tleW1hcFtrZXldO1xuICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG4gIH1cbiAgLy8gSEVBRC0tLS0tLS0tLS0tLS0tVEFJTFxuICAvLyAgIDwub2xkZXIgICAubmV3ZXI+XG4gIC8vICA8LS0tIGFkZCBkaXJlY3Rpb24gLS1cbiAgLy8gICBBICBCICBDICA8RD4gIEVcbiAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyOyAvLyBDIDwtLSBFLlxuICB9XG4gIGlmIChlbnRyeS5vbGRlcikge1xuICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7IC8vIEMuIC0tPiBFXG4gIH1cbiAgZW50cnkubmV3ZXIgPSB1bmRlZmluZWQ7IC8vIEQgLS14XG4gIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsOyAvLyBELiAtLT4gRVxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7IC8vIEUuIDwtLSBEXG4gIH1cbiAgdGhpcy50YWlsID0gZW50cnk7XG4gIHJldHVybiByZXR1cm5FbnRyeSA/IGVudHJ5IDogZW50cnkudmFsdWU7XG59O1xuXG52YXIgY2FjaGUkMSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBmaWx0ZXJUb2tlblJFID0gL1teXFxzJ1wiXSt8J1teJ10qJ3xcIlteXCJdKlwiL2c7XG52YXIgcmVzZXJ2ZWRBcmdSRSA9IC9eaW4kfF4tP1xcZCsvO1xuXG4vKipcbiAqIFBhcnNlciBzdGF0ZVxuICovXG5cbnZhciBzdHI7XG52YXIgZGlyO1xudmFyIGM7XG52YXIgcHJldjtcbnZhciBpO1xudmFyIGw7XG52YXIgbGFzdEZpbHRlckluZGV4O1xudmFyIGluU2luZ2xlO1xudmFyIGluRG91YmxlO1xudmFyIGN1cmx5O1xudmFyIHNxdWFyZTtcbnZhciBwYXJlbjtcbi8qKlxuICogUHVzaCBhIGZpbHRlciB0byB0aGUgY3VycmVudCBkaXJlY3RpdmUgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcbiAgdmFyIGV4cCA9IHN0ci5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKTtcbiAgdmFyIGZpbHRlcjtcbiAgaWYgKGV4cCkge1xuICAgIGZpbHRlciA9IHt9O1xuICAgIHZhciB0b2tlbnMgPSBleHAubWF0Y2goZmlsdGVyVG9rZW5SRSk7XG4gICAgZmlsdGVyLm5hbWUgPSB0b2tlbnNbMF07XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXIuYXJncyA9IHRva2Vucy5zbGljZSgxKS5tYXAocHJvY2Vzc0ZpbHRlckFyZyk7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIpIHtcbiAgICAoZGlyLmZpbHRlcnMgPSBkaXIuZmlsdGVycyB8fCBbXSkucHVzaChmaWx0ZXIpO1xuICB9XG4gIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGFyZ3VtZW50IGlzIGR5bmFtaWMgYW5kIHN0cmlwIHF1b3Rlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlckFyZyhhcmcpIHtcbiAgaWYgKHJlc2VydmVkQXJnUkUudGVzdChhcmcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0b051bWJlcihhcmcpLFxuICAgICAgZHluYW1pYzogZmFsc2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKGFyZyk7XG4gICAgdmFyIGR5bmFtaWMgPSBzdHJpcHBlZCA9PT0gYXJnO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZHluYW1pYyA/IGFyZyA6IHN0cmlwcGVkLFxuICAgICAgZHluYW1pYzogZHluYW1pY1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRpcmVjdGl2ZSB2YWx1ZSBhbmQgZXh0cmFjdCB0aGUgZXhwcmVzc2lvblxuICogYW5kIGl0cyBmaWx0ZXJzIGludG8gYSBkZXNjcmlwdG9yLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogXCJhICsgMSB8IHVwcGVyY2FzZVwiIHdpbGwgeWllbGQ6XG4gKiB7XG4gKiAgIGV4cHJlc3Npb246ICdhICsgMScsXG4gKiAgIGZpbHRlcnM6IFtcbiAqICAgICB7IG5hbWU6ICd1cHBlcmNhc2UnLCBhcmdzOiBudWxsIH1cbiAqICAgXVxuICogfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocykge1xuICB2YXIgaGl0ID0gY2FjaGUkMS5nZXQocyk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgLy8gcmVzZXQgcGFyc2VyIHN0YXRlXG4gIHN0ciA9IHM7XG4gIGluU2luZ2xlID0gaW5Eb3VibGUgPSBmYWxzZTtcbiAgY3VybHkgPSBzcXVhcmUgPSBwYXJlbiA9IDA7XG4gIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGRpciA9IHt9O1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgLy8gY2hlY2sgc2luZ2xlIHF1b3RlXG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9ICFpblNpbmdsZTtcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAvLyBjaGVjayBkb3VibGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gIWluRG91YmxlO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgc3RyLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmIHN0ci5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3Qykge1xuICAgICAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxyZWFkeSBoYXMgZmlsdGVyXG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7YnJlYWs7IC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICBpblNpbmdsZSA9IHRydWU7YnJlYWs7IC8vICdcbiAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgIHBhcmVuKys7YnJlYWs7IC8vIChcbiAgICAgICAgY2FzZSAweDI5OlxuICAgICAgICAgIHBhcmVuLS07YnJlYWs7IC8vIClcbiAgICAgICAgY2FzZSAweDVCOlxuICAgICAgICAgIHNxdWFyZSsrO2JyZWFrOyAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDpcbiAgICAgICAgICBzcXVhcmUtLTticmVhazsgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6XG4gICAgICAgICAgY3VybHkrKzticmVhazsgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6XG4gICAgICAgICAgY3VybHktLTticmVhazsgLy8gfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXIuZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgZGlyLmV4cHJlc3Npb24gPSBzdHIuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGNhY2hlJDEucHV0KHMsIGRpcik7XG4gIHJldHVybiBkaXI7XG59XG5cbnZhciBkaXJlY3RpdmUgPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VEaXJlY3RpdmU6IHBhcnNlRGlyZWN0aXZlXG59KTtcblxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xudmFyIGNhY2hlID0gdW5kZWZpbmVkO1xudmFyIHRhZ1JFID0gdW5kZWZpbmVkO1xudmFyIGh0bWxSRSA9IHVuZGVmaW5lZDtcbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGluIGEgUmVnRXhwXG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSZWdleCgpIHtcbiAgdmFyIG9wZW4gPSBlc2NhcGVSZWdleChjb25maWcuZGVsaW1pdGVyc1swXSk7XG4gIHZhciBjbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzFdKTtcbiAgdmFyIHVuc2FmZU9wZW4gPSBlc2NhcGVSZWdleChjb25maWcudW5zYWZlRGVsaW1pdGVyc1swXSk7XG4gIHZhciB1bnNhZmVDbG9zZSA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzFdKTtcbiAgdGFnUkUgPSBuZXcgUmVnRXhwKHVuc2FmZU9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIHVuc2FmZUNsb3NlICsgJ3wnICsgb3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJyk7XG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoJ14nICsgdW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnJCcpO1xuICAvLyByZXNldCBjYWNoZVxuICBjYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIHRleHQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+IHwgbnVsbH1cbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgIC0ge1N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2h0bWxdXG4gKiAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtvbmVUaW1lXVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0KSB7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjb21waWxlUmVnZXgoKTtcbiAgfVxuICB2YXIgaGl0ID0gY2FjaGUuZ2V0KHRleHQpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCBodG1sLCB2YWx1ZSwgZmlyc3QsIG9uZVRpbWU7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleClcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBodG1sID0gaHRtbFJFLnRlc3QobWF0Y2hbMF0pO1xuICAgIHZhbHVlID0gaHRtbCA/IG1hdGNoWzFdIDogbWF0Y2hbMl07XG4gICAgZmlyc3QgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgIG9uZVRpbWUgPSBmaXJzdCA9PT0gNDI7IC8vICpcbiAgICB2YWx1ZSA9IG9uZVRpbWUgPyB2YWx1ZS5zbGljZSgxKSA6IHZhbHVlO1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHRhZzogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZS50cmltKCksXG4gICAgICBodG1sOiBodG1sLFxuICAgICAgb25lVGltZTogb25lVGltZVxuICAgIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHZhbHVlOiB0ZXh0LnNsaWNlKGxhc3RJbmRleClcbiAgICB9KTtcbiAgfVxuICBjYWNoZS5wdXQodGV4dCwgdG9rZW5zKTtcbiAgcmV0dXJuIHRva2Vucztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBsaXN0IG9mIHRva2VucyBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKiBlLmcuIHRva2VucyBwYXJzZWQgZnJvbSAnYSB7e2J9fSBjJyBjYW4gYmUgc2VyaWFsaXplZFxuICogaW50byBvbmUgc2luZ2xlIGV4cHJlc3Npb24gYXMgJ1wiYSBcIiArIGIgKyBcIiBjXCInLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbnNUb0V4cCh0b2tlbnMsIHZtKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2VuLCB2bSk7XG4gICAgfSkuam9pbignKycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmb3JtYXRUb2tlbih0b2tlbnNbMF0sIHZtLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCBhIHNpbmdsZSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VG9rZW4odG9rZW4sIHZtLCBzaW5nbGUpIHtcbiAgcmV0dXJuIHRva2VuLnRhZyA/IHRva2VuLm9uZVRpbWUgJiYgdm0gPyAnXCInICsgdm0uJGV2YWwodG9rZW4udmFsdWUpICsgJ1wiJyA6IGlubGluZUZpbHRlcnModG9rZW4udmFsdWUsIHNpbmdsZSkgOiAnXCInICsgdG9rZW4udmFsdWUgKyAnXCInO1xufVxuXG4vKipcbiAqIEZvciBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBpbnRlcnBvbGF0aW9uIHRhZ3MsXG4gKiBlLmcuIGF0dHI9XCJzb21lLXt7dGhpbmcgfCBmaWx0ZXJ9fVwiLCBpbiBvcmRlciB0byBjb21iaW5lXG4gKiB0aGUgd2hvbGUgdGhpbmcgaW50byBhIHNpbmdsZSB3YXRjaGFibGUgZXhwcmVzc2lvbiwgd2VcbiAqIGhhdmUgdG8gaW5saW5lIHRob3NlIGZpbHRlcnMuIFRoaXMgZnVuY3Rpb24gZG9lcyBleGFjdGx5XG4gKiB0aGF0LiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCBpdCBhdm9pZHMgaGVhdnkgY2hhbmdlc1xuICogdG8gZGlyZWN0aXZlIHBhcnNlciBhbmQgd2F0Y2hlciBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBzaW5nbGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vO1xuZnVuY3Rpb24gaW5saW5lRmlsdGVycyhleHAsIHNpbmdsZSkge1xuICBpZiAoIWZpbHRlclJFLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGUgPyBleHAgOiAnKCcgKyBleHAgKyAnKSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKGV4cCk7XG4gICAgaWYgKCFkaXIuZmlsdGVycykge1xuICAgICAgcmV0dXJuICcoJyArIGV4cCArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICcsbnVsbCwnICsgLy8gb2xkVmFsdWUgKG51bGwgZm9yIHJlYWQpXG4gICAgICBKU09OLnN0cmluZ2lmeShkaXIuZmlsdGVycykgKyAvLyBmaWx0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICcsZmFsc2UpJzsgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbXBpbGVSZWdleDogY29tcGlsZVJlZ2V4LFxuICBwYXJzZVRleHQ6IHBhcnNlVGV4dCxcbiAgdG9rZW5zVG9FeHA6IHRva2Vuc1RvRXhwXG59KTtcblxudmFyIGRlbGltaXRlcnMgPSBbJ3t7JywgJ319J107XG52YXIgdW5zYWZlRGVsaW1pdGVycyA9IFsne3t7JywgJ319fSddO1xuXG52YXIgY29uZmlnID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzLlxuICAgKiBBbHNvIGVuYWJsZXMgc3RhY2sgdHJhY2UgZm9yIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZGVidWc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB1c2UgYXN5bmMgcmVuZGVyaW5nLlxuICAgKi9cblxuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byB3YXJuIGFnYWluc3QgZXJyb3JzIGNhdWdodCB3aGVuIGV2YWx1YXRpbmdcbiAgICogZXhwcmVzc2lvbnMuXG4gICAqL1xuXG4gIHdhcm5FeHByZXNzaW9uRXJyb3JzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFsbG93IGRldnRvb2xzIGluc3BlY3Rpb24uXG4gICAqIERpc2FibGVkIGJ5IGRlZmF1bHQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG4gICAqL1xuXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmbGFnIHRvIGluZGljYXRlIHRoZSBkZWxpbWl0ZXJzIGhhdmUgYmVlblxuICAgKiBjaGFuZ2VkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgX2RlbGltaXRlcnNDaGFuZ2VkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblxuICBfYXNzZXRUeXBlczogWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2VsZW1lbnREaXJlY3RpdmUnLCAnZmlsdGVyJywgJ3RyYW5zaXRpb24nLCAncGFydGlhbCddLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn0sIHtcbiAgZGVsaW1pdGVyczogeyAvKipcbiAgICAgICAgICAgICAgICAgKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCBwYXJzZXIgdG8gcmUtY29tcGlsZSB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgZGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgdW5zYWZlRGVsaW1pdGVyczoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIHVuc2FmZURlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgd2FybiA9IHVuZGVmaW5lZDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gdW5kZWZpbmVkO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVnVlIHdhcm5dOiAnICsgbXNnICsgKHZtID8gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkgOiAnJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9pc1Z1ZSA/IHZtLiRvcHRpb25zLm5hbWUgOiB2bS5uYW1lO1xuICAgICAgcmV0dXJuIG5hbWUgPyAnIChmb3VuZCBpbiBjb21wb25lbnQ6IDwnICsgaHlwaGVuYXRlKG5hbWUpICsgJz4pJyA6ICcnO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbi8qKlxuICogQXBwZW5kIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogSW5zZXJ0QmVmb3JlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlV2l0aFRyYW5zaXRpb24oZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgMSwgZnVuY3Rpb24gKCkge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVdpdGhUcmFuc2l0aW9uKGVsLCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAtMSwgZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZShlbCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogQXBwbHkgdHJhbnNpdGlvbnMgd2l0aCBhbiBvcGVyYXRpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogICAgICAgICAgICAgICAgICAxOiBlbnRlclxuICogICAgICAgICAgICAgICAgIC0xOiBsZWF2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSB0aGUgYWN0dWFsIERPTSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNpdGlvbihlbCwgZGlyZWN0aW9uLCBvcCwgdm0sIGNiKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZWwuX192X3RyYW5zO1xuICBpZiAoIXRyYW5zaXRpb24gfHxcbiAgLy8gc2tpcCBpZiB0aGVyZSBhcmUgbm8ganMgaG9va3MgYW5kIENTUyB0cmFuc2l0aW9uIGlzXG4gIC8vIG5vdCBzdXBwb3J0ZWRcbiAgIXRyYW5zaXRpb24uaG9va3MgJiYgIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIHRyYW5zaXRpb25zIGZvciBpbml0aWFsIGNvbXBpbGVcbiAgIXZtLl9pc0NvbXBpbGVkIHx8XG4gIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBhIHBhcmVudCBkaXJlY3RpdmVcbiAgLy8gZHVyaW5nIHRoZSBwYXJlbnQncyBjb21waWxhdGlvbiBwaGFzZSwgc2tpcCB0aGVcbiAgLy8gYW5pbWF0aW9uLlxuICB2bS4kcGFyZW50ICYmICF2bS4kcGFyZW50Ll9pc0NvbXBpbGVkKSB7XG4gICAgb3AoKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhY3Rpb24gPSBkaXJlY3Rpb24gPiAwID8gJ2VudGVyJyA6ICdsZWF2ZSc7XG4gIHRyYW5zaXRpb25bYWN0aW9uXShvcCwgY2IpO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuICBhcHBlbmRXaXRoVHJhbnNpdGlvbjogYXBwZW5kV2l0aFRyYW5zaXRpb24sXG4gIGJlZm9yZVdpdGhUcmFuc2l0aW9uOiBiZWZvcmVXaXRoVHJhbnNpdGlvbixcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb246IHJlbW92ZVdpdGhUcmFuc2l0aW9uLFxuICBhcHBseVRyYW5zaXRpb246IGFwcGx5VHJhbnNpdGlvblxufSk7XG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gcXVlcnkoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIHNlbGVjdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gKiBOb3RlOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgc2hvdWxkIHdvcmsgaGVyZVxuICogYnV0IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBjb21tZW50IG5vZGVzIGluIHBoYW50b21qcyxcbiAqIG1ha2luZyB1bml0IHRlc3RzIGRpZmZpY3VsdC4gVGhpcyBpcyBmaXhlZCBieSBkb2luZyB0aGVcbiAqIGNvbnRhaW5zKCkgY2hlY2sgb24gdGhlIG5vZGUncyBwYXJlbnROb2RlIGluc3RlYWQgb2ZcbiAqIHRoZSBub2RlIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaW5Eb2Mobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBkb2MgPT09IG5vZGUgfHwgZG9jID09PSBwYXJlbnQgfHwgISEocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiBkb2MuY29udGFpbnMocGFyZW50KSk7XG59XG5cbi8qKlxuICogR2V0IGFuZCByZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IF9hdHRyXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXR0cihub2RlLCBfYXR0cikge1xuICB2YXIgdmFsID0gbm9kZS5nZXRBdHRyaWJ1dGUoX2F0dHIpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogR2V0IGFuIGF0dHJpYnV0ZSB3aXRoIGNvbG9uIG9yIHYtYmluZDogcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG5cbmZ1bmN0aW9uIGdldEJpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHZhbCA9IGdldEF0dHIobm9kZSwgJzonICsgbmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICB2YWwgPSBnZXRBdHRyKG5vZGUsICd2LWJpbmQ6JyArIG5hbWUpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogQ2hlY2sgdGhlIHByZXNlbmNlIG9mIGEgYmluZCBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5kQXR0cihub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgnOicgKyBuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndi1iaW5kOicgKyBuYW1lKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgZWwgYmVmb3JlIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlKGVsLCB0YXJnZXQpIHtcbiAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBhZnRlciB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIGFmdGVyKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5uZXh0U2libGluZykge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0Lm5leHRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZWwgZnJvbSBET01cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xufVxuXG4vKipcbiAqIFByZXBlbmQgZWwgdG8gdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBwcmVwZW5kKGVsLCB0YXJnZXQpIHtcbiAgaWYgKHRhcmdldC5maXJzdENoaWxkKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcGxhY2UgdGFyZ2V0IHdpdGggZWxcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0LCBlbCkge1xuICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgY2IsIHVzZUNhcHR1cmUpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKTtcbn1cblxuLyoqXG4gKiBGb3IgSUU5IGNvbXBhdDogd2hlbiBib3RoIGNsYXNzIGFuZCA6Y2xhc3MgYXJlIHByZXNlbnRcbiAqIGdldEF0dHJpYnV0ZSgnY2xhc3MnKSByZXR1cm5zIHdyb25nIHZhbHVlLi4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XG4gIHZhciBjbGFzc25hbWUgPSBlbC5jbGFzc05hbWU7XG4gIGlmICh0eXBlb2YgY2xhc3NuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGNsYXNzbmFtZSA9IGNsYXNzbmFtZS5iYXNlVmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBjbGFzc25hbWU7XG59XG5cbi8qKlxuICogSW4gSUU5LCBzZXRBdHRyaWJ1dGUoJ2NsYXNzJykgd2lsbCByZXN1bHQgaW4gZW1wdHkgY2xhc3NcbiAqIGlmIHRoZSBlbGVtZW50IGFsc28gaGFzIHRoZSA6Y2xhc3MgYXR0cmlidXRlOyBIb3dldmVyIGluXG4gKiBQaGFudG9tSlMsIHNldHRpbmcgYGNsYXNzTmFtZWAgZG9lcyBub3Qgd29yayBvbiBTVkcgZWxlbWVudHMuLi5cbiAqIFNvIHdlIGhhdmUgdG8gZG8gYSBjb25kaXRpb25hbCBjaGVjayBoZXJlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBzZXRDbGFzcyhlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgIS9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbHM7XG4gIH0gZWxzZSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGdldENsYXNzKGVsKSArICcgJztcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIHNldENsYXNzKGVsLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBzZXRDbGFzcyhlbCwgY3VyLnRyaW0oKSk7XG4gIH1cbiAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IHJhdyBjb250ZW50IGluc2lkZSBhbiBlbGVtZW50IGludG8gYSB0ZW1wb3JhcnlcbiAqIGNvbnRhaW5lciBkaXZcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzRnJhZ21lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudChlbCwgYXNGcmFnbWVudCkge1xuICB2YXIgY2hpbGQ7XG4gIHZhciByYXdDb250ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzVGVtcGxhdGUoZWwpICYmIGlzRnJhZ21lbnQoZWwuY29udGVudCkpIHtcbiAgICBlbCA9IGVsLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRyaW1Ob2RlKGVsKTtcbiAgICByYXdDb250ZW50ID0gYXNGcmFnbWVudCA/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gZWwuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdDb250ZW50O1xufVxuXG4vKipcbiAqIFRyaW0gcG9zc2libGUgZW1wdHkgaGVhZC90YWlsIHRleHQgYW5kIGNvbW1lbnRcbiAqIG5vZGVzIGluc2lkZSBhIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiB0cmltTm9kZShub2RlKSB7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VxdWVuY2VzICovXG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICB3aGlsZSAoKGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQsIGlzVHJpbW1hYmxlKGNoaWxkKSkpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlcXVlbmNlcyAqL1xufVxuXG5mdW5jdGlvbiBpc1RyaW1tYWJsZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAzICYmICFub2RlLmRhdGEudHJpbSgpIHx8IG5vZGUubm9kZVR5cGUgPT09IDgpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWcuXG4gKiBOb3RlIGlmIHRoZSB0ZW1wbGF0ZSBhcHBlYXJzIGluc2lkZSBhbiBTVkcgaXRzIHRhZ05hbWVcbiAqIHdpbGwgYmUgaW4gbG93ZXJjYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gXCJhbmNob3JcIiBmb3IgcGVyZm9ybWluZyBkb20gaW5zZXJ0aW9uL3JlbW92YWxzLlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHNjZW5hcmlvczpcbiAqIC0gZnJhZ21lbnQgaW5zdGFuY2VcbiAqIC0gdi1odG1sXG4gKiAtIHYtaWZcbiAqIC0gdi1mb3JcbiAqIC0gY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyc2lzdCAtIElFIHRyYXNoZXMgZW1wdHkgdGV4dE5vZGVzIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZU5vZGUodHJ1ZSksIHNvIGluIGNlcnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzIHRoZSBhbmNob3IgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbi1lbXB0eSB0byBiZSBwZXJzaXN0ZWQgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5cbiAqIEByZXR1cm4ge0NvbW1lbnR8VGV4dH1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBbmNob3IoY29udGVudCwgcGVyc2lzdCkge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmRlYnVnID8gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBlcnNpc3QgPyAnICcgOiAnJyk7XG4gIGFuY2hvci5fX3ZfYW5jaG9yID0gdHJ1ZTtcbiAgcmV0dXJuIGFuY2hvcjtcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tcG9uZW50IHJlZiBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCAkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuXG52YXIgcmVmUkUgPSAvXnYtcmVmOi87XG5cbmZ1bmN0aW9uIGZpbmRSZWYobm9kZSkge1xuICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChyZWZSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjYW1lbGl6ZShuYW1lLnJlcGxhY2UocmVmUkUsICcnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFwIGEgZnVuY3Rpb24gdG8gYSByYW5nZSBvZiBub2RlcyAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3BcbiAqL1xuXG5mdW5jdGlvbiBtYXBOb2RlUmFuZ2Uobm9kZSwgZW5kLCBvcCkge1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKG5vZGUgIT09IGVuZCkge1xuICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG9wKG5vZGUpO1xuICAgIG5vZGUgPSBuZXh0O1xuICB9XG4gIG9wKGVuZCk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgcmFuZ2Ugb2Ygbm9kZXMgd2l0aCB0cmFuc2l0aW9uLCBzdG9yZVxuICogdGhlIG5vZGVzIGluIGEgZnJhZ21lbnQgd2l0aCBjb3JyZWN0IG9yZGVyaW5nLFxuICogYW5kIGNhbGwgY2FsbGJhY2sgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgdm0sIGZyYWcsIGNiKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZW1vdmVkID0gMDtcbiAgdmFyIG5vZGVzID0gW107XG4gIG1hcE5vZGVSYW5nZShzdGFydCwgZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbmQpIGRvbmUgPSB0cnVlO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgcmVtb3ZlV2l0aFRyYW5zaXRpb24obm9kZSwgdm0sIG9uUmVtb3ZlZCk7XG4gIH0pO1xuICBmdW5jdGlvbiBvblJlbW92ZWQoKSB7XG4gICAgcmVtb3ZlZCsrO1xuICAgIGlmIChkb25lICYmIHJlbW92ZWQgPj0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0ZyYWdtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xuICB9XG59XG5cbnZhciBjb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC9pO1xudmFyIHJlc2VydmVkVGFnUkUgPSAvXihzbG90fHBhcnRpYWx8Y29tcG9uZW50KSQvaTtcblxudmFyIGlzVW5rbm93bkVsZW1lbnQgPSB1bmRlZmluZWQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpc1Vua25vd25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCB0YWcpIHtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHwgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpICYmXG4gICAgICAgIC8vIENocm9tZSByZXR1cm5zIHVua25vd24gZm9yIHNldmVyYWwgSFRNTDUgZWxlbWVudHMuXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01NDA1MjZcbiAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIHVua25vd24gZm9yIHNvbWUgXCJJbnRlcmFjdGl2ZSBlbGVtZW50cy5cIlxuICAgICAgICAhL14oZGF0YXx0aW1lfHJ0Y3xyYnxkZXRhaWxzfGRpYWxvZ3xzdW1tYXJ5KSQvLnRlc3QodGFnKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudCwgaWYgeWVzIHJldHVybiBpdHNcbiAqIGNvbXBvbmVudCBpZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICBpZiAoIWNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiAhcmVzZXJ2ZWRUYWdSRS50ZXN0KHRhZykpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXMgPSBoYXNBdHRycyAmJiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIHJldHVybiBpcztcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUYWcgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwICYmIG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXBbdGFnXTtcbiAgICAgICAgaWYgKGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtICcgKyAnZGlkIHlvdSBtZWFuIDwnICsgZXhwZWN0ZWRUYWcgKyAnPj8gJyArICdIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSBrZWJhYi1jYXNlIGluIHRlbXBsYXRlcy4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Vua25vd25FbGVtZW50KGVsLCB0YWcpKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzQXR0cnMpIHtcbiAgICByZXR1cm4gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBcImlzXCIgYmluZGluZyBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsLCBvcHRpb25zKSB7XG4gIC8vIGR5bmFtaWMgc3ludGF4XG4gIHZhciBleHAgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lzJyk7XG4gIGlmIChleHAgIT0gbnVsbCkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCBleHApKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICByZXR1cm4geyBpZDogZXhwIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKlxuICogQWxsIHN0cmF0ZWd5IGZ1bmN0aW9ucyBmb2xsb3cgdGhlIHNhbWUgc2lnbmF0dXJlOlxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyZW50VmFsXG4gKiBAcGFyYW0geyp9IGNoaWxkVmFsXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICovXG5cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZURhdGEodG8sIGZyb20pIHtcbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIGZvciAoa2V5IGluIGZyb20pIHtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodG9WYWwpICYmIGlzT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogRGF0YVxuICovXG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoY2hpbGRWYWwuY2FsbCh0aGlzKSwgcGFyZW50VmFsLmNhbGwodGhpcykpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHZtKSA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHZtKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIEVsXG4gKi9cblxuc3RyYXRzLmVsID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gIGlmICghdm0gJiYgY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJlbFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXQgPSBjaGlsZFZhbCB8fCBwYXJlbnRWYWw7XG4gIC8vIGludm9rZSB0aGUgZWxlbWVudCBmYWN0b3J5IGlmIHRoaXMgaXMgaW5zdGFuY2UgbWVyZ2VcbiAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID0gc3RyYXRzLmNyZWF0ZWQgPSBzdHJhdHMucmVhZHkgPSBzdHJhdHMuYXR0YWNoZWQgPSBzdHJhdHMuZGV0YWNoZWQgPSBzdHJhdHMuYmVmb3JlQ29tcGlsZSA9IHN0cmF0cy5jb21waWxlZCA9IHN0cmF0cy5iZWZvcmVEZXN0cm95ID0gc3RyYXRzLmRlc3Ryb3llZCA9IHN0cmF0cy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG59O1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBndWFyZEFycmF5QXNzZXRzKGNoaWxkVmFsKSkgOiByZXM7XG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnQgPyBwYXJlbnQuY29uY2F0KGNoaWxkKSA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuXG5zdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cblxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICogY29uc3RydWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzID0gZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpO1xuICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnRzKTtcbiAgICB2YXIgZGVmO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFwID0gb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGlkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpZHNbaV07XG4gICAgICBpZiAoY29tbW9uVGFnUkUudGVzdChrZXkpIHx8IHJlc2VydmVkVGFnUkUudGVzdChrZXkpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyByZWNvcmQgYSBhbGwgbG93ZXJjYXNlIDwtPiBrZWJhYi1jYXNlIG1hcHBpbmcgZm9yXG4gICAgICAvLyBwb3NzaWJsZSBjdXN0b20gZWxlbWVudCBjYXNlIGVycm9yIHdhcm5pbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1hcFtrZXkucmVwbGFjZSgvLS9nLCAnJykudG9Mb3dlckNhc2UoKV0gPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgY29tcG9uZW50c1trZXldID0gVnVlLmV4dGVuZChkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICB2YXIgaSwgdmFsO1xuICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICBvcHRpb25zLnByb3BzID0ge307XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh2YWwubmFtZSkge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNba2V5c1tpXV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICogaW50byB0aGUga2V5LXZhbHVlIE9iamVjdCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gIGlmIChpc0FycmF5KGFzc2V0cykpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBhc3NldDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgIHZhciBpZCA9IHR5cGVvZiBhc3NldCA9PT0gJ2Z1bmN0aW9uJyA/IGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lIHx8IGFzc2V0LmlkIDogYXNzZXQubmFtZSB8fCBhc3NldC5pZDtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBcnJheS1zeW50YXggYXNzZXRzIG11c3QgcHJvdmlkZSBhIFwibmFtZVwiIG9yIFwiaWRcIiBmaWVsZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYXNzZXRzO1xufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXSAtIGlmIHZtIGlzIHByZXNlbnQsIGluZGljYXRlcyB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgIGFuIGluc3RhbnRpYXRpb24gbWVyZ2UuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gIGd1YXJkQ29tcG9uZW50cyhjaGlsZCk7XG4gIGd1YXJkUHJvcHMoY2hpbGQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjaGlsZC5wcm9wc0RhdGEgJiYgIXZtKSB7XG4gICAgICB3YXJuKCdwcm9wc0RhdGEgY2FuIG9ubHkgYmUgdXNlZCBhcyBhbiBpbnN0YW50aWF0aW9uIG9wdGlvbi4nKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgaWYgKGNoaWxkWydleHRlbmRzJ10pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgY2hpbGRbJ2V4dGVuZHMnXSA9PT0gJ2Z1bmN0aW9uJyA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkWydleHRlbmRzJ10ub3B0aW9ucywgdm0pIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIHZhciBtaXhpbk9wdGlvbnMgPSBtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUgPyBtaXhpbi5vcHRpb25zIDogbWl4aW47XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbk9wdGlvbnMsIHZtKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2Fybk1pc3NpbmdcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgdmFyIGNhbWVsaXplZElkO1xuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fFxuICAvLyBjYW1lbENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkID0gY2FtZWxpemUoaWQpXSB8fFxuICAvLyBQYXNjYWwgQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbGl6ZWRJZC5zbGljZSgxKV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEZXAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn1cblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLiRyZW1vdmUoc3ViKTtcbn07XG5cbi8qKlxuICogQWRkIHNlbGYgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0YXJnZXQgd2F0Y2hlci5cbiAqL1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG59O1xuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0b0FycmF5KHRoaXMuc3Vicyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pXG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cblxuO1sncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnLCAnc29ydCcsICdyZXZlcnNlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHNldCcsIGZ1bmN0aW9uICRzZXQoaW5kZXgsIHZhbCkge1xuICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IE51bWJlcihpbmRleCkgKyAxO1xuICB9XG4gIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXTtcbn0pO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgdGhlIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXggb3IgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaXRlbVxuICovXG5cbmRlZihhcnJheVByb3RvLCAnJHJlbW92ZScsIGZ1bmN0aW9uICRyZW1vdmUoaXRlbSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMsIGl0ZW0pO1xuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn0pO1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgaW4gY2VydGFpbiBjYXNlcywgZS5nLlxuICogdi1mb3Igc2NvcGUgYWxpYXMgYW5kIHByb3BzLCB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb25cbiAqIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZSB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBTbyB3aGVuZXZlciB3ZSB3YW50IHRvIHNldCBhIHJlYWN0aXZlIHByb3BlcnR5IHdpdGhvdXQgZm9yY2luZ1xuICogY29udmVyc2lvbiBvbiB0aGUgbmV3IHZhbHVlLCB3ZSB3cmFwIHRoYXQgY2FsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAqL1xuXG52YXIgc2hvdWxkQ29udmVydCA9IHRydWU7XG5cbmZ1bmN0aW9uIHdpdGhvdXRDb252ZXJzaW9uKGZuKSB7XG4gIHNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgZm4oKTtcbiAgc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvID8gcHJvdG9BdWdtZW50IDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59XG5cbi8vIEluc3RhbmNlIG1ldGhvZHNcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLmNvbnZlcnQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgaW50byBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBlbWl0XG4gKiB0aGUgZXZlbnRzIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkL2NoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBkZWZpbmVSZWFjdGl2ZSh0aGlzLnZhbHVlLCBrZXksIHZhbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gb3duZXIgdm0uIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIG9iamVjdCBpc1xuICogc3dhcHBlZCBvdXQgYXMgYW4gaW5zdGFuY2UncyAkZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLnJlbW92ZVZtID0gZnVuY3Rpb24gKHZtKSB7XG4gIHRoaXMudm1zLiRyZW1vdmUodm0pO1xufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXVnbWVudCh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHZtKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKHNob3VsZENvbnZlcnQgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJiAhdmFsdWUuX2lzVnVlKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKTtcbiAgfVxuICByZXR1cm4gb2I7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUob2JqLCBrZXksIHZhbCkge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlLFxuXHRzZXQ6IHNldCxcblx0ZGVsOiBkZWwsXG5cdGhhc093bjogaGFzT3duLFxuXHRpc0xpdGVyYWw6IGlzTGl0ZXJhbCxcblx0aXNSZXNlcnZlZDogaXNSZXNlcnZlZCxcblx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdHRvTnVtYmVyOiB0b051bWJlcixcblx0dG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG5cdHN0cmlwUXVvdGVzOiBzdHJpcFF1b3Rlcyxcblx0Y2FtZWxpemU6IGNhbWVsaXplLFxuXHRoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcblx0Y2xhc3NpZnk6IGNsYXNzaWZ5LFxuXHRiaW5kOiBiaW5kLFxuXHR0b0FycmF5OiB0b0FycmF5LFxuXHRleHRlbmQ6IGV4dGVuZCxcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuXHRkZWY6IGRlZixcblx0ZGVib3VuY2U6IF9kZWJvdW5jZSxcblx0aW5kZXhPZjogaW5kZXhPZixcblx0Y2FuY2VsbGFibGU6IGNhbmNlbGxhYmxlLFxuXHRsb29zZUVxdWFsOiBsb29zZUVxdWFsLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRoYXNQcm90bzogaGFzUHJvdG8sXG5cdGluQnJvd3NlcjogaW5Ccm93c2VyLFxuXHRkZXZ0b29sczogZGV2dG9vbHMsXG5cdGlzSUU6IGlzSUUsXG5cdGlzSUU5OiBpc0lFOSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGlzSW9zOiBpc0lvcyxcblx0aW9zVmVyc2lvbk1hdGNoOiBpb3NWZXJzaW9uTWF0Y2gsXG5cdGlvc1ZlcnNpb246IGlvc1ZlcnNpb24sXG5cdGhhc011dGF0aW9uT2JzZXJ2ZXJCdWc6IGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcsXG5cdGdldCB0cmFuc2l0aW9uUHJvcCAoKSB7IHJldHVybiB0cmFuc2l0aW9uUHJvcDsgfSxcblx0Z2V0IHRyYW5zaXRpb25FbmRFdmVudCAoKSB7IHJldHVybiB0cmFuc2l0aW9uRW5kRXZlbnQ7IH0sXG5cdGdldCBhbmltYXRpb25Qcm9wICgpIHsgcmV0dXJuIGFuaW1hdGlvblByb3A7IH0sXG5cdGdldCBhbmltYXRpb25FbmRFdmVudCAoKSB7IHJldHVybiBhbmltYXRpb25FbmRFdmVudDsgfSxcblx0bmV4dFRpY2s6IG5leHRUaWNrLFxuXHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuXHRxdWVyeTogcXVlcnksXG5cdGluRG9jOiBpbkRvYyxcblx0Z2V0QXR0cjogZ2V0QXR0cixcblx0Z2V0QmluZEF0dHI6IGdldEJpbmRBdHRyLFxuXHRoYXNCaW5kQXR0cjogaGFzQmluZEF0dHIsXG5cdGJlZm9yZTogYmVmb3JlLFxuXHRhZnRlcjogYWZ0ZXIsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRwcmVwZW5kOiBwcmVwZW5kLFxuXHRyZXBsYWNlOiByZXBsYWNlLFxuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRzZXRDbGFzczogc2V0Q2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHRleHRyYWN0Q29udGVudDogZXh0cmFjdENvbnRlbnQsXG5cdHRyaW1Ob2RlOiB0cmltTm9kZSxcblx0aXNUZW1wbGF0ZTogaXNUZW1wbGF0ZSxcblx0Y3JlYXRlQW5jaG9yOiBjcmVhdGVBbmNob3IsXG5cdGZpbmRSZWY6IGZpbmRSZWYsXG5cdG1hcE5vZGVSYW5nZTogbWFwTm9kZVJhbmdlLFxuXHRyZW1vdmVOb2RlUmFuZ2U6IHJlbW92ZU5vZGVSYW5nZSxcblx0aXNGcmFnbWVudDogaXNGcmFnbWVudCxcblx0Z2V0T3V0ZXJIVE1MOiBnZXRPdXRlckhUTUwsXG5cdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuXHRyZXNvbHZlQXNzZXQ6IHJlc29sdmVBc3NldCxcblx0Y2hlY2tDb21wb25lbnRBdHRyOiBjaGVja0NvbXBvbmVudEF0dHIsXG5cdGNvbW1vblRhZ1JFOiBjb21tb25UYWdSRSxcblx0cmVzZXJ2ZWRUYWdSRTogcmVzZXJ2ZWRUYWdSRSxcblx0Z2V0IHdhcm4gKCkgeyByZXR1cm4gd2FybjsgfVxufSk7XG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogVGhlIG1haW4gaW5pdCBzZXF1ZW5jZS4gVGhpcyBpcyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAqIGluc3RhbmNlLCBpbmNsdWRpbmcgb25lcyB0aGF0IGFyZSBjcmVhdGVkIGZyb20gZXh0ZW5kZWRcbiAgICogY29uc3RydWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoaXMgb3B0aW9ucyBvYmplY3Qgc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBhbmQgdGhlIG9wdGlvbnMgcGFzc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcztcbiAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuJHJlZnMgPSB7fTsgLy8gY2hpbGQgdm0gcmVmZXJlbmNlc1xuICAgIHRoaXMuJGVscyA9IHt9OyAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICB0aGlzLl9kaXJlY3RpdmVzID0gW107IC8vIGFsbCBkaXJlY3RpdmVzXG5cbiAgICAvLyBhIHVpZFxuICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB0aGlzLl9pc1Z1ZSA9IHRydWU7XG5cbiAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICB0aGlzLl9ldmVudHMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IHt9OyAvLyBmb3IgJGJyb2FkY2FzdCBvcHRpbWl6YXRpb25cblxuICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhZ21lbnQgPSAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGw7IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG5cbiAgICAvLyBsaWZlY3ljbGUgc3RhdGVcbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0aGlzLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl91bmxpbmtGbiA9IG51bGw7XG5cbiAgICAvLyBjb250ZXh0OlxuICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgLy8gc2NvcGU6XG4gICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAvLyBmcmFnbWVudDpcbiAgICAvLyBpZiB0aGlzIGluc3RhbmNlIGlzIGNvbXBpbGVkIGluc2lkZSBhIEZyYWdtZW50LCBpdFxuICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMuX2ZyYWcgPSBvcHRpb25zLl9mcmFnO1xuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuJGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucy5cbiAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gc2V0IHJlZlxuICAgIHRoaXMuX3VwZGF0ZVJlZigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIGFzIGVtcHR5IG9iamVjdC5cbiAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdERhdGEoKS5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAvLyBjYWxsIGluaXQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdpbml0Jyk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgb2JzZXJ2YXRpb24gYW5kIHNjb3BlIGluaGVyaXRhbmNlLlxuICAgIHRoaXMuX2luaXRTdGF0ZSgpO1xuXG4gICAgLy8gc2V0dXAgZXZlbnQgc3lzdGVtIGFuZCBvcHRpb24gZXZlbnRzLlxuICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgIC8vIGNhbGwgY3JlYXRlZCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgIC8vIGlmIGBlbGAgb3B0aW9uIGlzIHBhc3NlZCwgc3RhcnQgY29tcGlsYXRpb24uXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcblxuLy8gYWN0aW9uc1xudmFyIEFQUEVORCA9IDA7XG52YXIgUFVTSCA9IDE7XG52YXIgSU5DX1NVQl9QQVRIX0RFUFRIID0gMjtcbnZhciBQVVNIX1NVQl9QQVRIID0gMztcblxuLy8gc3RhdGVzXG52YXIgQkVGT1JFX1BBVEggPSAwO1xudmFyIElOX1BBVEggPSAxO1xudmFyIEJFRk9SRV9JREVOVCA9IDI7XG52YXIgSU5fSURFTlQgPSAzO1xudmFyIElOX1NVQl9QQVRIID0gNDtcbnZhciBJTl9TSU5HTEVfUVVPVEUgPSA1O1xudmFyIElOX0RPVUJMRV9RVU9URSA9IDY7XG52YXIgQUZURVJfUEFUSCA9IDc7XG52YXIgRVJST1IgPSA4O1xuXG52YXIgcGF0aFN0YXRlTWFjaGluZSA9IFtdO1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9QQVRIXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9QQVRIXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fUEFUSF0gPSB7XG4gICd3cyc6IFtJTl9QQVRIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5UXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0JFRk9SRV9JREVOVF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfSURFTlRdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fSURFTlRdID0ge1xuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICcwJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnbnVtYmVyJzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnd3MnOiBbSU5fUEFUSCwgUFVTSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVCwgUFVTSF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBQVVNIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRILCBQVVNIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TVUJfUEFUSF0gPSB7XG4gIFwiJ1wiOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdLFxuICAnXCInOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgSU5DX1NVQl9QQVRIX0RFUFRIXSxcbiAgJ10nOiBbSU5fUEFUSCwgUFVTSF9TVUJfUEFUSF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU1VCX1BBVEgsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU0lOR0xFX1FVT1RFXSA9IHtcbiAgXCInXCI6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fRE9VQkxFX1FVT1RFXSA9IHtcbiAgJ1wiJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBjaGFyYWN0ZXIgaW4gYSBrZXlwYXRoLlxuICpcbiAqIEBwYXJhbSB7Q2hhcn0gY2hcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhDaGFyVHlwZShjaCkge1xuICBpZiAoY2ggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnZW9mJztcbiAgfVxuXG4gIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcblxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4NUI6IC8vIFtcbiAgICBjYXNlIDB4NUQ6IC8vIF1cbiAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICBjYXNlIDB4MjI6IC8vIFwiXG4gICAgY2FzZSAweDI3OiAvLyAnXG4gICAgY2FzZSAweDMwOlxuICAgICAgLy8gMFxuICAgICAgcmV0dXJuIGNoO1xuXG4gICAgY2FzZSAweDVGOiAvLyBfXG4gICAgY2FzZSAweDI0OlxuICAgICAgLy8gJFxuICAgICAgcmV0dXJuICdpZGVudCc7XG5cbiAgICBjYXNlIDB4MjA6IC8vIFNwYWNlXG4gICAgY2FzZSAweDA5OiAvLyBUYWJcbiAgICBjYXNlIDB4MEE6IC8vIE5ld2xpbmVcbiAgICBjYXNlIDB4MEQ6IC8vIFJldHVyblxuICAgIGNhc2UgMHhBMDogLy8gTm8tYnJlYWsgc3BhY2VcbiAgICBjYXNlIDB4RkVGRjogLy8gQnl0ZSBPcmRlciBNYXJrXG4gICAgY2FzZSAweDIwMjg6IC8vIExpbmUgU2VwYXJhdG9yXG4gICAgY2FzZSAweDIwMjk6XG4gICAgICAvLyBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gICAgICByZXR1cm4gJ3dzJztcbiAgfVxuXG4gIC8vIGEteiwgQS1aXG4gIGlmIChjb2RlID49IDB4NjEgJiYgY29kZSA8PSAweDdBIHx8IGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NUEpIHtcbiAgICByZXR1cm4gJ2lkZW50JztcbiAgfVxuXG4gIC8vIDEtOVxuICBpZiAoY29kZSA+PSAweDMxICYmIGNvZGUgPD0gMHgzOSkge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIHJldHVybiAnZWxzZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc3ViUGF0aCwgcmV0dXJuIGl0cyBwbGFpbiBmb3JtIGlmIGl0IGlzXG4gKiBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci4gT3RoZXJ3aXNlIHByZXBlbmQgdGhlXG4gKiBkeW5hbWljIGluZGljYXRvciAoKikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRTdWJQYXRoKHBhdGgpIHtcbiAgdmFyIHRyaW1tZWQgPSBwYXRoLnRyaW0oKTtcbiAgLy8gaW52YWxpZCBsZWFkaW5nIDBcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnMCcgJiYgaXNOYU4ocGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTGl0ZXJhbCh0cmltbWVkKSA/IHN0cmlwUXVvdGVzKHRyaW1tZWQpIDogJyonICsgdHJpbW1lZDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBwYXRoIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBtb2RlID0gQkVGT1JFX1BBVEg7XG4gIHZhciBzdWJQYXRoRGVwdGggPSAwO1xuICB2YXIgYywgbmV3Q2hhciwga2V5LCB0eXBlLCB0cmFuc2l0aW9uLCBhY3Rpb24sIHR5cGVNYXA7XG5cbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICBhY3Rpb25zW1BVU0hdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbQVBQRU5EXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9IG5ld0NoYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSArPSBuZXdDaGFyO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0lOQ19TVUJfUEFUSF9ERVBUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgc3ViUGF0aERlcHRoKys7XG4gIH07XG5cbiAgYWN0aW9uc1tQVVNIX1NVQl9QQVRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3ViUGF0aERlcHRoID4gMCkge1xuICAgICAgc3ViUGF0aERlcHRoLS07XG4gICAgICBtb2RlID0gSU5fU1VCX1BBVEg7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViUGF0aERlcHRoID0gMDtcbiAgICAgIGtleSA9IGZvcm1hdFN1YlBhdGgoa2V5KTtcbiAgICAgIGlmIChrZXkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnNbUFVTSF0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF5YmVVbmVzY2FwZVF1b3RlKCkge1xuICAgIHZhciBuZXh0Q2hhciA9IHBhdGhbaW5kZXggKyAxXTtcbiAgICBpZiAobW9kZSA9PT0gSU5fU0lOR0xFX1FVT1RFICYmIG5leHRDaGFyID09PSBcIidcIiB8fCBtb2RlID09PSBJTl9ET1VCTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICBuZXdDaGFyID0gJ1xcXFwnICsgbmV4dENoYXI7XG4gICAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChtb2RlICE9IG51bGwpIHtcbiAgICBpbmRleCsrO1xuICAgIGMgPSBwYXRoW2luZGV4XTtcblxuICAgIGlmIChjID09PSAnXFxcXCcgJiYgbWF5YmVVbmVzY2FwZVF1b3RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBnZXRQYXRoQ2hhclR5cGUoYyk7XG4gICAgdHlwZU1hcCA9IHBhdGhTdGF0ZU1hY2hpbmVbbW9kZV07XG4gICAgdHJhbnNpdGlvbiA9IHR5cGVNYXBbdHlwZV0gfHwgdHlwZU1hcFsnZWxzZSddIHx8IEVSUk9SO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gPT09IEVSUk9SKSB7XG4gICAgICByZXR1cm47IC8vIHBhcnNlIGVycm9yXG4gICAgfVxuXG4gICAgbW9kZSA9IHRyYW5zaXRpb25bMF07XG4gICAgYWN0aW9uID0gYWN0aW9uc1t0cmFuc2l0aW9uWzFdXTtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBuZXdDaGFyID0gdHJhbnNpdGlvblsyXTtcbiAgICAgIG5ld0NoYXIgPSBuZXdDaGFyID09PSB1bmRlZmluZWQgPyBjIDogbmV3Q2hhcjtcbiAgICAgIGlmIChhY3Rpb24oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlID09PSBBRlRFUl9QQVRIKSB7XG4gICAgICBrZXlzLnJhdyA9IHBhdGg7XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRlcm5hbCBwYXJzZSB0aGF0IGNoZWNrIGZvciBhIGNhY2hlIGhpdCBmaXJzdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIGhpdCA9IHBhdGhDYWNoZS5nZXQocGF0aCk7XG4gIGlmICghaGl0KSB7XG4gICAgaGl0ID0gcGFyc2UocGF0aCk7XG4gICAgaWYgKGhpdCkge1xuICAgICAgcGF0aENhY2hlLnB1dChwYXRoLCBoaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGl0O1xufVxuXG4vKipcbiAqIEdldCBmcm9tIGFuIG9iamVjdCBmcm9tIGEgcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5cbmZ1bmN0aW9uIGdldFBhdGgob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXJzZUV4cHJlc3Npb24ocGF0aCkuZ2V0KG9iaik7XG59XG5cbi8qKlxuICogV2FybiBhZ2FpbnN0IHNldHRpbmcgbm9uLWV4aXN0ZW50IHJvb3QgcGF0aCBvbiBhIHZtLlxuICovXG5cbnZhciB3YXJuTm9uRXhpc3RlbnQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuTm9uRXhpc3RlbnQgPSBmdW5jdGlvbiAocGF0aCwgdm0pIHtcbiAgICB3YXJuKCdZb3UgYXJlIHNldHRpbmcgYSBub24tZXhpc3RlbnQgcGF0aCBcIicgKyBwYXRoLnJhdyArICdcIiAnICsgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgKyAnd2l0aCB0aGUgXCJkYXRhXCIgb3B0aW9uIGZvciBtb3JlIHJlbGlhYmxlIHJlYWN0aXZpdHkgJyArICdhbmQgYmV0dGVyIHBlcmZvcm1hbmNlLicsIHZtKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXQgb24gYW4gb2JqZWN0IGZyb20gYSBwYXRoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gcGF0aFxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBzZXRQYXRoKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9iajtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXJzZShwYXRoKTtcbiAgfVxuICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3QsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxhc3QgPSBvYmo7XG4gICAga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJyonKSB7XG4gICAgICBrZXkgPSBwYXJzZUV4cHJlc3Npb24oa2V5LnNsaWNlKDEpKS5nZXQuY2FsbChvcmlnaW5hbCwgb3JpZ2luYWwpO1xuICAgIH1cbiAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbGFzdC5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgbGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGxhc3QsIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmouJHNldChrZXksIHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvYmouX2lzVnVlKSB7XG4gICAgICAgICAgd2Fybk5vbkV4aXN0ZW50KHBhdGgsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KG9iaiwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHBhdGggPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VQYXRoOiBwYXJzZVBhdGgsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIHNldFBhdGg6IHNldFBhdGhcbn0pO1xuXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgYWxsb3dlZEtleXdvcmRzID0gJ01hdGgsRGF0ZSx0aGlzLHRydWUsZmFsc2UsbnVsbCx1bmRlZmluZWQsSW5maW5pdHksTmFOLCcgKyAnaXNOYU4saXNGaW5pdGUsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksJyArICdlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdCc7XG52YXIgYWxsb3dlZEtleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBhbGxvd2VkS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID0gJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICsgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgKyAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgKyAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArICdwcm90ZWN0ZWQsc3RhdGljLGludGVyZmFjZSxwcml2YXRlLHB1YmxpYyc7XG52YXIgaW1wcm9wZXJLZXl3b3Jkc1JFID0gbmV3IFJlZ0V4cCgnXignICsgaW1wcm9wZXJLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxudmFyIHdzUkUgPSAvXFxzL2c7XG52YXIgbmV3bGluZVJFID0gL1xcbi9nO1xudmFyIHNhdmVSRSA9IC9bXFx7LF1cXHMqW1xcd1xcJF9dK1xccyo6fCgnKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYCl8bmV3IHx0eXBlb2YgfHZvaWQgL2c7XG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbnZhciBwYXRoVGVzdFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC87XG52YXIgaWRlbnRSRSA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2c7XG52YXIgbGl0ZXJhbFZhbHVlUkUkMSA9IC9eKD86dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZHxJbmZpbml0eXxOYU4pJC87XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIFNhdmUgLyBSZXdyaXRlIC8gUmVzdG9yZVxuICpcbiAqIFdoZW4gcmV3cml0aW5nIHBhdGhzIGZvdW5kIGluIGFuIGV4cHJlc3Npb24sIGl0IGlzXG4gKiBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgbGV0dGVyIHNlcXVlbmNlcyB0byBiZSBmb3VuZCBpblxuICogc3RyaW5ncyBhbmQgT2JqZWN0IGxpdGVyYWwgcHJvcGVydHkga2V5cy4gVGhlcmVmb3JlIHdlXG4gKiByZW1vdmUgYW5kIHN0b3JlIHRoZXNlIHBhcnRzIGluIGEgdGVtcG9yYXJ5IGFycmF5LCBhbmRcbiAqIHJlc3RvcmUgdGhlbSBhZnRlciB0aGUgcGF0aCByZXdyaXRlLlxuICovXG5cbnZhciBzYXZlZCA9IFtdO1xuXG4vKipcbiAqIFNhdmUgcmVwbGFjZXJcbiAqXG4gKiBUaGUgc2F2ZSByZWdleCBjYW4gbWF0Y2ggdHdvIHBvc3NpYmxlIGNhc2VzOlxuICogMS4gQW4gb3BlbmluZyBvYmplY3QgbGl0ZXJhbFxuICogMi4gQSBzdHJpbmdcbiAqIElmIG1hdGNoZWQgYXMgYSBwbGFpbiBzdHJpbmcsIHdlIG5lZWQgdG8gZXNjYXBlIGl0c1xuICogbmV3bGluZXMsIHNpbmNlIHRoZSBzdHJpbmcgbmVlZHMgdG8gYmUgcHJlc2VydmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGlzU3RyaW5nIC0gc3RyIGlmIG1hdGNoZWQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBwbGFjZWhvbGRlciB3aXRoIGluZGV4XG4gKi9cblxuZnVuY3Rpb24gc2F2ZShzdHIsIGlzU3RyaW5nKSB7XG4gIHZhciBpID0gc2F2ZWQubGVuZ3RoO1xuICBzYXZlZFtpXSA9IGlzU3RyaW5nID8gc3RyLnJlcGxhY2UobmV3bGluZVJFLCAnXFxcXG4nKSA6IHN0cjtcbiAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbn1cblxuLyoqXG4gKiBQYXRoIHJld3JpdGUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmV3cml0ZShyYXcpIHtcbiAgdmFyIGMgPSByYXcuY2hhckF0KDApO1xuICB2YXIgcGF0aCA9IHJhdy5zbGljZSgxKTtcbiAgaWYgKGFsbG93ZWRLZXl3b3Jkc1JFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJ1wiJykgPiAtMSA/IHBhdGgucmVwbGFjZShyZXN0b3JlUkUsIHJlc3RvcmUpIDogcGF0aDtcbiAgICByZXR1cm4gYyArICdzY29wZS4nICsgcGF0aDtcbiAgfVxufVxuXG4vKipcbiAqIFJlc3RvcmUgcmVwbGFjZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaSAtIG1hdGNoZWQgc2F2ZSBpbmRleFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmUoc3RyLCBpKSB7XG4gIHJldHVybiBzYXZlZFtpXTtcbn1cblxuLyoqXG4gKiBSZXdyaXRlIGFuIGV4cHJlc3Npb24sIHByZWZpeGluZyBhbGwgcGF0aCBhY2Nlc3NvcnMgd2l0aFxuICogYHNjb3BlLmAgYW5kIGdlbmVyYXRlIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVHZXR0ZXIoZXhwKSB7XG4gIGlmIChpbXByb3BlcktleXdvcmRzUkUudGVzdChleHApKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBdm9pZCB1c2luZyByZXNlcnZlZCBrZXl3b3JkcyBpbiBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxuICAvLyByZXNldCBzdGF0ZVxuICBzYXZlZC5sZW5ndGggPSAwO1xuICAvLyBzYXZlIHN0cmluZ3MgYW5kIG9iamVjdCBsaXRlcmFsIGtleXNcbiAgdmFyIGJvZHkgPSBleHAucmVwbGFjZShzYXZlUkUsIHNhdmUpLnJlcGxhY2Uod3NSRSwgJycpO1xuICAvLyByZXdyaXRlIGFsbCBwYXRoc1xuICAvLyBwYWQgMSBzcGFjZSBoZXJlIGJlY2F1c2UgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSkucmVwbGFjZShpZGVudFJFLCByZXdyaXRlKS5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSk7XG4gIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gKlxuICogV2UgaXNvbGF0ZSB0aGUgdHJ5L2NhdGNoIHNvIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZVxuICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlR2V0dGVyRm4oYm9keSkge1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignc2NvcGUnLCAncmV0dXJuICcgKyBib2R5ICsgJzsnKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBkZWZhdWx0IGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiBlbnZpcm9ubWVudCAnICsgJ3dpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgKyAnVXNlIHRoZSBDU1AtY29tcGxpYW50IGJ1aWxkIGluc3RlYWQ6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbCNDU1AtY29tcGxpYW50LWJ1aWxkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGV4cHJlc3Npb24uICcgKyAnR2VuZXJhdGVkIGZ1bmN0aW9uIGJvZHk6ICcgKyBib2R5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVNldHRlcihleHApIHtcbiAgdmFyIHBhdGggPSBwYXJzZVBhdGgoZXhwKTtcbiAgaWYgKHBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCB2YWwpIHtcbiAgICAgIHNldFBhdGgoc2NvcGUsIHBhdGgsIHZhbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgc2V0dGVyIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBpbnRvIHJlLXdyaXR0ZW4gZ2V0dGVyL3NldHRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHBhcmFtIHtCb29sZWFufSBuZWVkU2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZXhwLCBuZWVkU2V0KSB7XG4gIGV4cCA9IGV4cC50cmltKCk7XG4gIC8vIHRyeSBjYWNoZVxuICB2YXIgaGl0ID0gZXhwcmVzc2lvbkNhY2hlLmdldChleHApO1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKG5lZWRTZXQgJiYgIWhpdC5zZXQpIHtcbiAgICAgIGhpdC5zZXQgPSBjb21waWxlU2V0dGVyKGhpdC5leHApO1xuICAgIH1cbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIHZhciByZXMgPSB7IGV4cDogZXhwIH07XG4gIHJlcy5nZXQgPSBpc1NpbXBsZVBhdGgoZXhwKSAmJiBleHAuaW5kZXhPZignWycpIDwgMFxuICAvLyBvcHRpbWl6ZWQgc3VwZXIgc2ltcGxlIGdldHRlclxuICA/IG1ha2VHZXR0ZXJGbignc2NvcGUuJyArIGV4cClcbiAgLy8gZHluYW1pYyBnZXR0ZXJcbiAgOiBjb21waWxlR2V0dGVyKGV4cCk7XG4gIGlmIChuZWVkU2V0KSB7XG4gICAgcmVzLnNldCA9IGNvbXBpbGVTZXR0ZXIoZXhwKTtcbiAgfVxuICBleHByZXNzaW9uQ2FjaGUucHV0KGV4cCwgcmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgc2ltcGxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1NpbXBsZVBhdGgoZXhwKSB7XG4gIHJldHVybiBwYXRoVGVzdFJFLnRlc3QoZXhwKSAmJlxuICAvLyBkb24ndCB0cmVhdCBsaXRlcmFsIHZhbHVlcyBhcyBwYXRoc1xuICAhbGl0ZXJhbFZhbHVlUkUkMS50ZXN0KGV4cCkgJiZcbiAgLy8gTWF0aCBjb25zdGFudHMgZS5nLiBNYXRoLlBJLCBNYXRoLkUgZXRjLlxuICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG59XG5cbnZhciBleHByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxufSk7XG5cbi8vIHdlIGhhdmUgdHdvIHNlcGFyYXRlIHF1ZXVlczogb25lIGZvciBkaXJlY3RpdmUgdXBkYXRlc1xuLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuLy8gd2Ugd2FudCB0byBndWFyYW50ZWUgZGlyZWN0aXZlIHVwZGF0ZXMgdG8gYmUgY2FsbGVkXG4vLyBiZWZvcmUgdXNlciB3YXRjaGVycyBzbyB0aGF0IHdoZW4gdXNlciB3YXRjaGVycyBhcmVcbi8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4vLyBzdGF0ZS5cblxudmFyIHF1ZXVlID0gW107XG52YXIgdXNlclF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogUmVzZXQgdGhlIGJhdGNoZXIncyBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiByZXNldEJhdGNoZXJTdGF0ZSgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgdXNlclF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBjaXJjdWxhciA9IHt9O1xuICB3YWl0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2hCYXRjaGVyUXVldWUoKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgcnVuQmF0Y2hlclF1ZXVlKHF1ZXVlKTtcbiAgICBydW5CYXRjaGVyUXVldWUodXNlclF1ZXVlKTtcbiAgICAvLyB1c2VyIHdhdGNoZXJzIHRyaWdnZXJlZCBtb3JlIHdhdGNoZXJzLFxuICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZGVwbGV0ZXNcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH1cbiAgICAvLyBkZXYgdG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG4gICAgcmVzZXRCYXRjaGVyU3RhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1biB0aGUgd2F0Y2hlcnMgaW4gYSBzaW5nbGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xuXG5mdW5jdGlvbiBydW5CYXRjaGVyUXVldWUocXVldWUpIHtcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgZm9yIHdhdGNoZXIgJyArICd3aXRoIGV4cHJlc3Npb24gXCInICsgd2F0Y2hlci5leHByZXNzaW9uICsgJ1wiJywgd2F0Y2hlci52bSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7V2F0Y2hlcn0gd2F0Y2hlclxuICogICBwcm9wZXJ0aWVzOlxuICogICAtIHtOdW1iZXJ9IGlkXG4gKiAgIC0ge0Z1bmN0aW9ufSBydW5cbiAqL1xuXG5mdW5jdGlvbiBwdXNoV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAvLyBwdXNoIHdhdGNoZXIgaW50byBhcHByb3ByaWF0ZSBxdWV1ZVxuICAgIHZhciBxID0gd2F0Y2hlci51c2VyID8gdXNlclF1ZXVlIDogcXVldWU7XG4gICAgaGFzW2lkXSA9IHEubGVuZ3RoO1xuICAgIHEucHVzaCh3YXRjaGVyKTtcbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hCYXRjaGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgIC0ge0FycmF5fSBmaWx0ZXJzXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdHdvV2F5XG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHVzZXJcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBzeW5jXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gbGF6eVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcHJlUHJvY2Vzc11cbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3Bvc3RQcm9jZXNzXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gIC8vIG1peCBpbiBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbic7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm47XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLnByZXZFcnJvciA9IG51bGw7IC8vIGZvciBhc3luYyBlcnJvciBzdGFja3NcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyL3NldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICB0aGlzLnNldHRlciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cE9yRm4sIHRoaXMudHdvV2F5KTtcbiAgICB0aGlzLmdldHRlciA9IHJlcy5nZXQ7XG4gICAgdGhpcy5zZXR0ZXIgPSByZXMuc2V0O1xuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAvLyBzdGF0ZSBmb3IgYXZvaWRpbmcgZmFsc2UgdHJpZ2dlcnMgZm9yIGRlZXAgYW5kIEFycmF5XG4gIC8vIHdhdGNoZXJzIGR1cmluZyB2bS5fZGlnZXN0KClcbiAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJlZm9yZUdldCgpO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIHZhciB2YWx1ZTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgd2FybignRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHRoaXMucHJlUHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wcmVQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgdmFsdWUgPSBzY29wZS5fYXBwbHlGaWx0ZXJzKHZhbHVlLCBudWxsLCB0aGlzLmZpbHRlcnMsIGZhbHNlKTtcbiAgfVxuICBpZiAodGhpcy5wb3N0UHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSk7XG4gIH1cbiAgdGhpcy5hZnRlckdldCgpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlIHx8IHRoaXMudm07XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIHRoaXMudmFsdWUsIHRoaXMuZmlsdGVycywgdHJ1ZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aGlzLnNldHRlci5jYWxsKHNjb3BlLCBzY29wZSwgdmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgc2V0dGVyICcgKyAnXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiOiAnICsgZS50b1N0cmluZygpLCB0aGlzLnZtKTtcbiAgICB9XG4gIH1cbiAgLy8gdHdvLXdheSBzeW5jIGZvciB2LWZvciBhbGlhc1xuICB2YXIgZm9yQ29udGV4dCA9IHNjb3BlLiRmb3JDb250ZXh0O1xuICBpZiAoZm9yQ29udGV4dCAmJiBmb3JDb250ZXh0LmFsaWFzID09PSB0aGlzLmV4cHJlc3Npb24pIHtcbiAgICBpZiAoZm9yQ29udGV4dC5maWx0ZXJzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdHdvLXdheSBiaW5kaW5nIG9uICcgKyAnYSB2LWZvciBhbGlhcyAoJyArIHRoaXMuZXhwcmVzc2lvbiArICcpLCBhbmQgdGhlICcgKyAndi1mb3IgaGFzIGZpbHRlcnMuIFRoaXMgd2lsbCBub3Qgd29yayBwcm9wZXJseS4gJyArICdFaXRoZXIgcmVtb3ZlIHRoZSBmaWx0ZXJzIG9yIHVzZSBhbiBhcnJheSBvZiAnICsgJ29iamVjdHMgYW5kIGJpbmQgdG8gb2JqZWN0IHByb3BlcnRpZXMgaW5zdGVhZC4nLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yQ29udGV4dC5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgICAgLy8gb3JpZ2luYWwgaXMgYW4gb2JqZWN0XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWVbc2NvcGUuJGtleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckNvbnRleHQucmF3VmFsdWUuJHNldChzY29wZS4kaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmVwYXJlIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYmVmb3JlR2V0ID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0ID0gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0RlcH0gZGVwXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaGFsbG93XG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYyB8fCAhY29uZmlnLmFzeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkID8gc2hhbGxvdyA/IHRoaXMuc2hhbGxvdyA6IGZhbHNlIDogISFzaGFsbG93O1xuICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcbiAgICAvLyByZWNvcmQgYmVmb3JlLXB1c2ggZXJyb3Igc3RhY2sgaW4gZGVidWcgbW9kZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgdGhpcy5wcmV2RXJyb3IgPSBuZXcgRXJyb3IoJ1t2dWVdIGFzeW5jIHN0YWNrIHRyYWNlJyk7XG4gICAgfVxuICAgIHB1c2hXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhdGNoZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBiYXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgLy8gaGF2ZSBtdXRhdGVkOyBidXQgb25seSBkbyBzbyBpZiB0aGlzIGlzIGFcbiAgICAvLyBub24tc2hhbGxvdyB1cGRhdGUgKGNhdXNlZCBieSBhIHZtIGRpZ2VzdCkuXG4gICAgKGlzT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBpbiBkZWJ1ZyArIGFzeW5jIG1vZGUsIHdoZW4gYSB3YXRjaGVyIGNhbGxiYWNrc1xuICAgICAgLy8gdGhyb3dzLCB3ZSBhbHNvIHRocm93IHRoZSBzYXZlZCBiZWZvcmUtcHVzaCBlcnJvclxuICAgICAgLy8gc28gdGhlIGZ1bGwgY3Jvc3MtdGljayBzdGFjayB0cmFjZSBpcyBhdmFpbGFibGUuXG4gICAgICB2YXIgcHJldkVycm9yID0gdGhpcy5wcmV2RXJyb3I7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1ZyAmJiBwcmV2RXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcmV2RXJyb3IgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcHJldkVycm9yO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICB2YXIgY3VycmVudCA9IERlcC50YXJnZXQ7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIERlcC50YXJnZXQgPSBjdXJyZW50O1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdGhpcy52bS5fdkZvclJlbW92aW5nKSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgdmFyIGkgPSB1bmRlZmluZWQsXG4gICAgICBrZXlzID0gdW5kZWZpbmVkO1xuICBpZiAoIXNlZW4pIHtcbiAgICBzZWVuID0gc2Vlbk9iamVjdHM7XG4gICAgc2Vlbi5jbGVhcigpO1xuICB9XG4gIHZhciBpc0EgPSBpc0FycmF5KHZhbCk7XG4gIHZhciBpc08gPSBpc09iamVjdCh2YWwpO1xuICBpZiAoKGlzQSB8fCBpc08pICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gICAgfSBlbHNlIGlmIChpc08pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQkMSA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHRoaXMuYXR0ciA9IHRoaXMuZWwubm9kZVR5cGUgPT09IDMgPyAnZGF0YScgOiAndGV4dENvbnRlbnQnO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5lbFt0aGlzLmF0dHJdID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIHRlbXBsYXRlQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgaWRTZWxlY3RvckNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgbWFwID0ge1xuICBlZmF1bHQ6IFswLCAnJywgJyddLFxuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J11cbn07XG5cbm1hcC50ZCA9IG1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAub3B0aW9uID0gbWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9IG1hcC50Ym9keSA9IG1hcC5jb2xncm91cCA9IG1hcC5jYXB0aW9uID0gbWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC5nID0gbWFwLmRlZnMgPSBtYXAuc3ltYm9sID0gbWFwLnVzZSA9IG1hcC5pbWFnZSA9IG1hcC50ZXh0ID0gbWFwLmNpcmNsZSA9IG1hcC5lbGxpcHNlID0gbWFwLmxpbmUgPSBtYXAucGF0aCA9IG1hcC5wb2x5Z29uID0gbWFwLnBvbHlsaW5lID0gbWFwLnJlY3QgPSBbMSwgJzxzdmcgJyArICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnICsgJ3htbG5zOmV2PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzXCInICsgJ3ZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J107XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgc3VwcG9ydGVkIHRlbXBsYXRlIG5vZGUgd2l0aCBhXG4gKiBEb2N1bWVudEZyYWdtZW50IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVhbFRlbXBsYXRlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVGVtcGxhdGUobm9kZSkgJiYgaXNGcmFnbWVudChub2RlLmNvbnRlbnQpO1xufVxuXG52YXIgdGFnUkUkMSA9IC88KFtcXHc6LV0rKS87XG52YXIgZW50aXR5UkUgPSAvJiM/XFx3Kz87LztcbnZhciBjb21tZW50UkUgPSAvPCEtLS87XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0ZW1wbGF0ZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKiBEZXRlcm1pbmVzIGNvcnJlY3Qgd3JhcHBpbmcgYnkgdGFnIHR5cGVzLiBXcmFwcGluZ1xuICogc3RyYXRlZ3kgZm91bmQgaW4galF1ZXJ5ICYgY29tcG9uZW50L2RvbWlmeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVTdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3XG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGVTdHJpbmcsIHJhdykge1xuICAvLyB0cnkgYSBjYWNoZSBoaXQgZmlyc3RcbiAgdmFyIGNhY2hlS2V5ID0gcmF3ID8gdGVtcGxhdGVTdHJpbmcgOiB0ZW1wbGF0ZVN0cmluZy50cmltKCk7XG4gIHZhciBoaXQgPSB0ZW1wbGF0ZUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciB0YWdNYXRjaCA9IHRlbXBsYXRlU3RyaW5nLm1hdGNoKHRhZ1JFJDEpO1xuICB2YXIgZW50aXR5TWF0Y2ggPSBlbnRpdHlSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcbiAgdmFyIGNvbW1lbnRNYXRjaCA9IGNvbW1lbnRSRS50ZXN0KHRlbXBsYXRlU3RyaW5nKTtcblxuICBpZiAoIXRhZ01hdGNoICYmICFlbnRpdHlNYXRjaCAmJiAhY29tbWVudE1hdGNoKSB7XG4gICAgLy8gdGV4dCBvbmx5LCByZXR1cm4gYSBzaW5nbGUgdGV4dCBub2RlLlxuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGVtcGxhdGVTdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gdGFnTWF0Y2ggJiYgdGFnTWF0Y2hbMV07XG4gICAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuZWZhdWx0O1xuICAgIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gICAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gICAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmcgKyBzdWZmaXg7XG4gICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdykge1xuICAgIHRyaW1Ob2RlKGZyYWcpO1xuICB9XG4gIHRlbXBsYXRlQ2FjaGUucHV0KGNhY2hlS2V5LCBmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHRlbXBsYXRlIG5vZGUgdG8gYSBEb2N1bWVudEZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBub2RlVG9GcmFnbWVudChub2RlKSB7XG4gIC8vIGlmIGl0cyBhIHRlbXBsYXRlIHRhZyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQsXG4gIC8vIGl0cyBjb250ZW50IGlzIGFscmVhZHkgYSBkb2N1bWVudCBmcmFnbWVudC4gSG93ZXZlciwgaU9TIFNhZmFyaSBoYXNcbiAgLy8gYnVnIHdoZW4gdXNpbmcgZGlyZWN0bHkgY2xvbmVkIHRlbXBsYXRlIGNvbnRlbnQgd2l0aCB0b3VjaFxuICAvLyBldmVudHMgYW5kIGNhbiBjYXVzZSBjcmFzaGVzIHdoZW4gdGhlIG5vZGVzIGFyZSByZW1vdmVkIGZyb20gRE9NLCBzbyB3ZVxuICAvLyBoYXZlIHRvIHRyZWF0IHRlbXBsYXRlIGVsZW1lbnRzIGFzIHN0cmluZyB0ZW1wbGF0ZXMuICgjMjgwNSlcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc1JlYWxUZW1wbGF0ZShub2RlKSkge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUuaW5uZXJIVE1MKTtcbiAgfVxuICAvLyBzY3JpcHQgdGVtcGxhdGVcbiAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1NDUklQVCcpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9GcmFnbWVudChub2RlLnRleHRDb250ZW50KTtcbiAgfVxuICAvLyBub3JtYWwgbm9kZSwgY2xvbmUgaXQgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsXG4gIHZhciBjbG9uZWROb2RlID0gY2xvbmVOb2RlKG5vZGUpO1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICB3aGlsZSAoY2hpbGQgPSBjbG9uZWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbiAgdHJpbU5vZGUoZnJhZyk7XG4gIHJldHVybiBmcmFnO1xufVxuXG4vLyBUZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIFNhZmFyaSB0ZW1wbGF0ZSBjbG9uaW5nIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd3VnLmNnaT9pZD0xMzc3NTVcbnZhciBoYXNCcm9rZW5UZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGEuaW5uZXJIVE1MID0gJzx0ZW1wbGF0ZT4xPC90ZW1wbGF0ZT4nO1xuICAgIHJldHVybiAhYS5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vLyBUZXN0IGZvciBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGNsb25lIGJ1Z1xudmFyIGhhc1RleHRhcmVhQ2xvbmVCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHQucGxhY2Vob2xkZXIgPSAndCc7XG4gICAgcmV0dXJuIHQuY2xvbmVOb2RlKHRydWUpLnZhbHVlID09PSAndCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIDEuIERlYWwgd2l0aCBTYWZhcmkgY2xvbmluZyBuZXN0ZWQgPHRlbXBsYXRlPiBidWcgYnlcbiAqICAgIG1hbnVhbGx5IGNsb25pbmcgYWxsIHRlbXBsYXRlIGluc3RhbmNlcy5cbiAqIDIuIERlYWwgd2l0aCBJRTEwLzExIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1ZyBieSBzZXR0aW5nXG4gKiAgICB0aGUgY29ycmVjdCB2YWx1ZSBhZnRlciBjbG9uaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICB2YXIgaSwgb3JpZ2luYWwsIGNsb25lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciB0ZW1wQ2xvbmUgPSByZXM7XG4gICAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgdGVtcENsb25lID0gcmVzLmNvbnRlbnQ7XG4gICAgfVxuICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IHRlbXBDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZU5vZGUob3JpZ2luYWxbaV0pLCBjbG9uZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgICAgY2xvbmVkID0gcmVzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY2xvbmVkW2ldLnZhbHVlID0gb3JpZ2luYWxbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlOlxuICogICAgICAgIC0gRG9jdW1lbnRGcmFnbWVudCBvYmplY3RcbiAqICAgICAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgICAgICAtIGlkIHNlbGVjdG9yOiAnI3NvbWUtdGVtcGxhdGUtaWQnXG4gKiAgICAgICAgLSB0ZW1wbGF0ZSBzdHJpbmc6ICc8ZGl2PjxzcGFuPnt7bXNnfX08L3NwYW4+PC9kaXY+J1xuICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRDbG9uZVxuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqICAgICAgICBpbmxpbmUgSFRNTCBpbnRlcnBvbGF0aW9uLiBEbyBub3QgY2hlY2sgZm9yIGlkXG4gKiAgICAgICAgc2VsZWN0b3IgYW5kIGtlZXAgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgc2hvdWxkQ2xvbmUsIHJhdykge1xuICB2YXIgbm9kZSwgZnJhZztcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmIChpc0ZyYWdtZW50KHRlbXBsYXRlKSkge1xuICAgIHRyaW1Ob2RlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUodGVtcGxhdGUpIDogdGVtcGxhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgaWYgKCFyYXcgJiYgdGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIC8vIGlkIHNlbGVjdG9yIGNhbiBiZSBjYWNoZWQgdG9vXG4gICAgICBmcmFnID0gaWRTZWxlY3RvckNhY2hlLmdldCh0ZW1wbGF0ZSk7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQobm9kZSk7XG4gICAgICAgICAgLy8gc2F2ZSBzZWxlY3RvciB0byBjYWNoZVxuICAgICAgICAgIGlkU2VsZWN0b3JDYWNoZS5wdXQodGVtcGxhdGUsIGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBzdHJpbmcgdGVtcGxhdGVcbiAgICAgIGZyYWcgPSBzdHJpbmdUb0ZyYWdtZW50KHRlbXBsYXRlLCByYXcpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgIC8vIGEgZGlyZWN0IG5vZGVcbiAgICBmcmFnID0gbm9kZVRvRnJhZ21lbnQodGVtcGxhdGUpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWcgJiYgc2hvdWxkQ2xvbmUgPyBjbG9uZU5vZGUoZnJhZykgOiBmcmFnO1xufVxuXG52YXIgdGVtcGxhdGUgPSBPYmplY3QuZnJlZXplKHtcbiAgY2xvbmVOb2RlOiBjbG9uZU5vZGUsXG4gIHBhcnNlVGVtcGxhdGU6IHBhcnNlVGVtcGxhdGVcbn0pO1xuXG52YXIgaHRtbCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGEgY29tbWVudCBub2RlIG1lYW5zIHRoaXMgaXMgYSBiaW5kaW5nIGZvclxuICAgIC8vIHt7eyBpbmxpbmUgdW5lc2NhcGVkIGh0bWwgfX19XG4gICAgaWYgKHRoaXMuZWwubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgIC8vIGhvbGQgbm9kZXNcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggcHJvcGVyIGFuY2hvclxuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaHRtbCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLnN3YXAodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBzd2FwOiBmdW5jdGlvbiBzd2FwKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVtb3ZlKHRoaXMubm9kZXNbaV0pO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IG5ldyB2YWx1ZSB0byBhIGZyYWdtZW50XG4gICAgLy8gZG8gbm90IGF0dGVtcHQgdG8gcmV0cmlldmUgZnJvbSBpZCBzZWxlY3RvclxuICAgIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGVzZSBub2RlcyBzbyB3ZSBjYW4gcmVtb3ZlIGxhdGVyXG4gICAgdGhpcy5ub2RlcyA9IHRvQXJyYXkoZnJhZy5jaGlsZE5vZGVzKTtcbiAgICBiZWZvcmUoZnJhZywgdGhpcy5hbmNob3IpO1xuICB9XG59O1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBhIHBhcnRpYWxseS1jb21waWxlZCBmcmFnbWVudC5cbiAqIENhbiBvcHRpb25hbGx5IGNvbXBpbGUgY29udGVudCB3aXRoIGEgY2hpbGQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtwYXJlbnRGcmFnXVxuICovXG5mdW5jdGlvbiBGcmFnbWVudChsaW5rZXIsIHZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZykge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuY2hpbGRGcmFncyA9IFtdO1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudEZyYWcgPSBwYXJlbnRGcmFnO1xuICBpZiAocGFyZW50RnJhZykge1xuICAgIHBhcmVudEZyYWcuY2hpbGRGcmFncy5wdXNoKHRoaXMpO1xuICB9XG4gIHRoaXMudW5saW5rID0gbGlua2VyKHZtLCBmcmFnLCBob3N0LCBzY29wZSwgdGhpcyk7XG4gIHZhciBzaW5nbGUgPSB0aGlzLnNpbmdsZSA9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiZcbiAgLy8gZG8gbm90IGdvIHNpbmdsZSBtb2RlIGlmIHRoZSBvbmx5IG5vZGUgaXMgYW4gYW5jaG9yXG4gICFmcmFnLmNoaWxkTm9kZXNbMF0uX192X2FuY2hvcjtcbiAgaWYgKHNpbmdsZSkge1xuICAgIHRoaXMubm9kZSA9IGZyYWcuY2hpbGROb2Rlc1swXTtcbiAgICB0aGlzLmJlZm9yZSA9IHNpbmdsZUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IHNpbmdsZVJlbW92ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LXN0YXJ0Jyk7XG4gICAgdGhpcy5lbmQgPSBjcmVhdGVBbmNob3IoJ2ZyYWdtZW50LWVuZCcpO1xuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgcHJlcGVuZCh0aGlzLm5vZGUsIGZyYWcpO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIHRoaXMuYmVmb3JlID0gbXVsdGlCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBtdWx0aVJlbW92ZTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSB0aGlzO1xufVxuXG4vKipcbiAqIENhbGwgYXR0YWNoL2RldGFjaCBmb3IgYWxsIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpblxuICogdGhpcyBmcmFnbWVudC4gQWxzbyBkbyBzbyByZWN1cnNpdmVseSBmb3IgYWxsIGNoaWxkXG4gKiBmcmFnbWVudHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gIHZhciBpLCBsO1xuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY2hpbGRGcmFnc1tpXS5jYWxsSG9vayhob29rKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBob29rKHRoaXMuY2hpbGRyZW5baV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBzaW5nbGVCZWZvcmUodGFyZ2V0LCB3aXRoVHJhbnNpdGlvbikge1xuICB0aGlzLmluc2VydGVkID0gdHJ1ZTtcbiAgdmFyIG1ldGhvZCA9IHdpdGhUcmFuc2l0aW9uICE9PSBmYWxzZSA/IGJlZm9yZVdpdGhUcmFuc2l0aW9uIDogYmVmb3JlO1xuICBtZXRob2QodGhpcy5ub2RlLCB0YXJnZXQsIHRoaXMudm0pO1xuICBpZiAoaW5Eb2ModGhpcy5ub2RlKSkge1xuICAgIHRoaXMuY2FsbEhvb2soYXR0YWNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBmcmFnbWVudCwgc2luZ2xlIG5vZGUgdmVyc2lvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlV2l0aFRyYW5zaXRpb24odGhpcy5ub2RlLCB0aGlzLnZtLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNob3VsZENhbGxSZW1vdmUpIHtcbiAgICAgIHNlbGYuY2FsbEhvb2soZGV0YWNoKTtcbiAgICB9XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEluc2VydCBmcmFnbWVudCBiZWZvcmUgdGFyZ2V0LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aFRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1hcE5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIG1ldGhvZChub2RlLCB0YXJnZXQsIHZtKTtcbiAgfSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBtdWx0aS1ub2RlcyB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlSZW1vdmUoKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2hvdWxkQ2FsbFJlbW92ZSA9IGluRG9jKHRoaXMubm9kZSk7XG4gIHRoaXMuYmVmb3JlUmVtb3ZlKCk7XG4gIHJlbW92ZU5vZGVSYW5nZSh0aGlzLm5vZGUsIHRoaXMuZW5kLCB0aGlzLnZtLCB0aGlzLmZyYWcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgZnJhZ21lbnQgZm9yIHJlbW92YWwuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmJlZm9yZVJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gY2FsbCB0aGUgc2FtZSBtZXRob2QgcmVjdXJzaXZlbHkgb24gY2hpbGRcbiAgICAvLyBmcmFnbWVudHMsIGRlcHRoLWZpcnN0XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmJlZm9yZVJlbW92ZShmYWxzZSk7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gQ2FsbCBkZXN0cm95IGZvciBhbGwgY29udGFpbmVkIGluc3RhbmNlcyxcbiAgICAvLyB3aXRoIHJlbW92ZTpmYWxzZSBhbmQgZGVmZXI6dHJ1ZS5cbiAgICAvLyBEZWZlciBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8ga2VlcCB0aGUgY2hpbGRyZW4gdG8gY2FsbCBkZXRhY2ggaG9va3NcbiAgICAvLyBvbiB0aGVtLlxuICAgIHRoaXMuY2hpbGRyZW5baV0uJGRlc3Ryb3koZmFsc2UsIHRydWUpO1xuICB9XG4gIHZhciBkaXJzID0gdGhpcy51bmxpbmsuZGlycztcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gZGlzYWJsZSB0aGUgd2F0Y2hlcnMgb24gYWxsIHRoZSBkaXJlY3RpdmVzXG4gICAgLy8gc28gdGhhdCB0aGUgcmVuZGVyZWQgY29udGVudCBzdGF5cyB0aGUgc2FtZVxuICAgIC8vIGR1cmluZyByZW1vdmFsLlxuICAgIGRpcnNbaV0uX3dhdGNoZXIgJiYgZGlyc1tpXS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGZyYWdtZW50LlxuICovXG5cbkZyYWdtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYXJlbnRGcmFnKSB7XG4gICAgdGhpcy5wYXJlbnRGcmFnLmNoaWxkRnJhZ3MuJHJlbW92ZSh0aGlzKTtcbiAgfVxuICB0aGlzLm5vZGUuX192X2ZyYWcgPSBudWxsO1xuICB0aGlzLnVubGluaygpO1xufTtcblxuLyoqXG4gKiBDYWxsIGF0dGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBhdHRhY2goY2hpbGQpIHtcbiAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbCBkZXRhY2ggaG9vayBmb3IgYSBWdWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gKi9cblxuZnVuY3Rpb24gZGV0YWNoKGNoaWxkKSB7XG4gIGlmIChjaGlsZC5faXNBdHRhY2hlZCAmJiAhaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgfVxufVxuXG52YXIgbGlua2VyQ2FjaGUgPSBuZXcgQ2FjaGUoNTAwMCk7XG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhXG4gKiBmcmFnbWVudC4gQ2FjaGVzIHRoZSBjb21waWxlZCBsaW5rZXIgaWYgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICovXG5mdW5jdGlvbiBGcmFnbWVudEZhY3Rvcnkodm0sIGVsKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdmFyIHRlbXBsYXRlO1xuICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNTdHJpbmcgfHwgaXNUZW1wbGF0ZShlbCkgJiYgIWVsLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGVsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlcjtcbiAgdmFyIGNpZCA9IHZtLmNvbnN0cnVjdG9yLmNpZDtcbiAgaWYgKGNpZCA+IDApIHtcbiAgICB2YXIgY2FjaGVJZCA9IGNpZCArIChpc1N0cmluZyA/IGVsIDogZ2V0T3V0ZXJIVE1MKGVsKSk7XG4gICAgbGlua2VyID0gbGlua2VyQ2FjaGUuZ2V0KGNhY2hlSWQpO1xuICAgIGlmICghbGlua2VyKSB7XG4gICAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBsaW5rZXJDYWNoZS5wdXQoY2FjaGVJZCwgbGlua2VyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlua2VyID0gY29tcGlsZSh0ZW1wbGF0ZSwgdm0uJG9wdGlvbnMsIHRydWUpO1xuICB9XG4gIHRoaXMubGlua2VyID0gbGlua2VyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZyYWdtZW50IGluc3RhbmNlIHdpdGggZ2l2ZW4gaG9zdCBhbmQgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IGhvc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gcGFyZW50RnJhZ1xuICovXG5cbkZyYWdtZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHZhciBmcmFnID0gY2xvbmVOb2RlKHRoaXMudGVtcGxhdGUpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMubGlua2VyLCB0aGlzLnZtLCBmcmFnLCBob3N0LCBzY29wZSwgcGFyZW50RnJhZyk7XG59O1xuXG52YXIgT04gPSA3MDA7XG52YXIgTU9ERUwgPSA4MDA7XG52YXIgQklORCA9IDg1MDtcbnZhciBUUkFOU0lUSU9OID0gMTEwMDtcbnZhciBFTCA9IDE1MDA7XG52YXIgQ09NUE9ORU5UID0gMTUwMDtcbnZhciBQQVJUSUFMID0gMTc1MDtcbnZhciBJRiA9IDIxMDA7XG52YXIgRk9SID0gMjIwMDtcbnZhciBTTE9UID0gMjMwMDtcblxudmFyIHVpZCQzID0gMDtcblxudmFyIHZGb3IgPSB7XG5cbiAgcHJpb3JpdHk6IEZPUixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgcGFyYW1zOiBbJ3RyYWNrLWJ5JywgJ3N0YWdnZXInLCAnZW50ZXItc3RhZ2dlcicsICdsZWF2ZS1zdGFnZ2VyJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBzdXBwb3J0IFwiaXRlbSBpbi9vZiBpdGVtc1wiIHN5bnRheFxuICAgIHZhciBpbk1hdGNoID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKC8oLiopICg/OmlufG9mKSAoLiopLyk7XG4gICAgaWYgKGluTWF0Y2gpIHtcbiAgICAgIHZhciBpdE1hdGNoID0gaW5NYXRjaFsxXS5tYXRjaCgvXFwoKC4qKSwoLiopXFwpLyk7XG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpdE1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFsaWFzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdi1mb3IgZXhwcmVzc2lvbiBcIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2FsaWFzIGlzIHJlcXVpcmVkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVpZCBhcyBhIGNhY2hlIGlkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gJ19fdi1mb3JfXycgKyArK3VpZCQzO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIDxzZWxlY3Q+J3NcbiAgICAvLyB2LW1vZGVsIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgIC8vIHRoZSB2LW1vZGVsIGlzIG5vdCBib3VuZCBoZXJlIHlldCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHJldHJpdmUgaXQgaW4gdGhlIGFjdHVhbCB1cGRhdGVNb2RlbCgpIGZ1bmN0aW9uLlxuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgdGhpcy5pc09wdGlvbiA9ICh0YWcgPT09ICdPUFRJT04nIHx8IHRhZyA9PT0gJ09QVEdST1VQJykgJiYgdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnO1xuXG4gICAgLy8gc2V0dXAgYW5jaG9yIG5vZGVzXG4gICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcigndi1mb3ItZW5kJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmVuZCk7XG4gICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5kaWZmKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlUmVmKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICogbWluaW11bSBhbW91bnQgb2YgRE9NIG1hbmlwdWxhdGlvbnMgbmVlZGVkIHRvIG1ha2UgdGhlXG4gICAqIERPTSByZWZsZWN0IHRoZSBuZXcgZGF0YSBBcnJheS5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBkaWZmcyB0aGUgbmV3IGRhdGEgQXJyYXkgYnkgc3RvcmluZyBhXG4gICAqIGhpZGRlbiByZWZlcmVuY2UgdG8gYW4gb3duZXIgdm0gaW5zdGFuY2Ugb24gcHJldmlvdXNseVxuICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgKiBiZXR0ZXIgdGhhbiBhIGxldmVuc2h0ZWluIGRpc3RhbmNlIGJhc2VkIGFsZ29yaXRobSxcbiAgICogd2hpY2ggaXMgTyhtICogbikuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICovXG5cbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF07XG4gICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBvbGRGcmFncyA9IHRoaXMuZnJhZ3M7XG4gICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpbkRvY3VtZW50ID0gaW5Eb2Moc3RhcnQpO1xuICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmU7XG5cbiAgICAvLyBGaXJzdCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBuZXcgQXJyYXkgYW5kIGZpbGwgdXBcbiAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgLy8gaW5zdGFuY2UgZm9yIGl0LCB3ZSByZXVzZSBpdC4gT3RoZXJ3aXNlIGJ1aWxkIGEgbmV3XG4gICAgLy8gaW5zdGFuY2UuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIGtleSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiRrZXkgOiBudWxsO1xuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGZyYWcgPSAhaW5pdCAmJiB0aGlzLmdldENhY2hlZEZyYWcodmFsdWUsIGksIGtleSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWU7XG4gICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgZnJhZy5zY29wZS4kaW5kZXggPSBpO1xuICAgICAgICAvLyB1cGRhdGUgJGtleVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZnJhZy5zY29wZS4ka2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgZm9yIHRyYWNrLWJ5LCBvYmplY3QgcmVwZWF0ICZcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmcmFnLnNjb3BlW2FsaWFzXSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaXNudGFuY2VcbiAgICAgICAgZnJhZyA9IHRoaXMuY3JlYXRlKHZhbHVlLCBhbGlhcywgaSwga2V5KTtcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgfVxuICAgICAgZnJhZ3NbaV0gPSBmcmFnO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgZnJhZy5iZWZvcmUoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcywgZ28gdGhyb3VnaCB0aGUgb2xkIGZyYWdtZW50cyBhbmRcbiAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgLy8gZnJvbSBjYWNoZSlcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gMDtcbiAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgIC8vIHdoZW4gcmVtb3ZpbmcgYSBsYXJnZSBudW1iZXIgb2YgZnJhZ21lbnRzLCB3YXRjaGVyIHJlbW92YWxcbiAgICAvLyB0dXJucyBvdXQgdG8gYmUgYSBwZXJmIGJvdHRsZW5lY2ssIHNvIHdlIGJhdGNoIHRoZSB3YXRjaGVyXG4gICAgLy8gcmVtb3ZhbHMgaW50byBhIHNpbmdsZSBmaWx0ZXIgY2FsbCFcbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSB0cnVlO1xuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgIGlmICghZnJhZy5yZXVzZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52bS5fdkZvclJlbW92aW5nID0gZmFsc2U7XG4gICAgaWYgKHJlbW92YWxJbmRleCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMgPSB0aGlzLnZtLl93YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHcuYWN0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgcGFzcywgbW92ZS9pbnNlcnQgbmV3IGZyYWdtZW50cyBpbnRvIHRoZVxuICAgIC8vIHJpZ2h0IHBsYWNlLlxuICAgIHZhciB0YXJnZXRQcmV2LCBwcmV2RWwsIGN1cnJlbnRQcmV2O1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IGZyYWdzW2ldO1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZnJhZyB0aGF0IHdlIHNob3VsZCBiZSBhZnRlclxuICAgICAgdGFyZ2V0UHJldiA9IGZyYWdzW2kgLSAxXTtcbiAgICAgIHByZXZFbCA9IHRhcmdldFByZXYgPyB0YXJnZXRQcmV2LnN0YWdnZXJDYiA/IHRhcmdldFByZXYuc3RhZ2dlckFuY2hvciA6IHRhcmdldFByZXYuZW5kIHx8IHRhcmdldFByZXYubm9kZSA6IHN0YXJ0O1xuICAgICAgaWYgKGZyYWcucmV1c2VkICYmICFmcmFnLnN0YWdnZXJDYikge1xuICAgICAgICBjdXJyZW50UHJldiA9IGZpbmRQcmV2RnJhZyhmcmFnLCBzdGFydCwgdGhpcy5pZCk7XG4gICAgICAgIGlmIChjdXJyZW50UHJldiAhPT0gdGFyZ2V0UHJldiAmJiAoIWN1cnJlbnRQcmV2IHx8XG4gICAgICAgIC8vIG9wdGltaXphdGlvbiBmb3IgbW92aW5nIGEgc2luZ2xlIGl0ZW0uXG4gICAgICAgIC8vIHRoYW5rcyB0byBzdWdnZXN0aW9ucyBieSBAbGl2b3JhcyBpbiAjMTgwN1xuICAgICAgICBmaW5kUHJldkZyYWcoY3VycmVudFByZXYsIHN0YXJ0LCB0aGlzLmlkKSAhPT0gdGFyZ2V0UHJldikpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoZnJhZywgcHJldkVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IGluc3RhbmNlLCBvciBzdGlsbCBpbiBzdGFnZ2VyLlxuICAgICAgICAvLyBpbnNlcnQgd2l0aCB1cGRhdGVkIHN0YWdnZXIgaW5kZXguXG4gICAgICAgIHRoaXMuaW5zZXJ0KGZyYWcsIGluc2VydGlvbkluZGV4KyssIHByZXZFbCwgaW5Eb2N1bWVudCk7XG4gICAgICB9XG4gICAgICBmcmFnLnJldXNlZCA9IGZyYWcuZnJlc2ggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxpYXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIGFsaWFzLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLl9ob3N0O1xuICAgIC8vIGNyZWF0ZSBpdGVyYXRpb24gc2NvcGVcbiAgICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLl9zY29wZSB8fCB0aGlzLnZtO1xuICAgIHZhciBzY29wZSA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUpO1xuICAgIC8vIHJlZiBob2xkZXIgZm9yIHRoZSBzY29wZVxuICAgIHNjb3BlLiRyZWZzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kcmVmcyk7XG4gICAgc2NvcGUuJGVscyA9IE9iamVjdC5jcmVhdGUocGFyZW50U2NvcGUuJGVscyk7XG4gICAgLy8gbWFrZSBzdXJlIHBvaW50ICRwYXJlbnQgdG8gcGFyZW50IHNjb3BlXG4gICAgc2NvcGUuJHBhcmVudCA9IHBhcmVudFNjb3BlO1xuICAgIC8vIGZvciB0d28td2F5IGJpbmRpbmcgb24gYWxpYXNcbiAgICBzY29wZS4kZm9yQ29udGV4dCA9IHRoaXM7XG4gICAgLy8gZGVmaW5lIHNjb3BlIHByb3BlcnRpZXNcbiAgICAvLyBpbXBvcnRhbnQ6IGRlZmluZSB0aGUgc2NvcGUgYWxpYXMgd2l0aG91dCBmb3JjZWQgY29udmVyc2lvblxuICAgIC8vIHNvIHRoYXQgZnJvemVuIGRhdGEgc3RydWN0dXJlcyByZW1haW4gbm9uLXJlYWN0aXZlLlxuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpO1xuICAgIH0pO1xuICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGluZGV4JywgaW5kZXgpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGtleScsIGtleSk7XG4gICAgfSBlbHNlIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAvLyBhdm9pZCBhY2NpZGVudGFsIGZhbGxiYWNrXG4gICAgICBkZWYoc2NvcGUsICcka2V5JywgbnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLml0ZXJhdG9yKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgdGhpcy5pdGVyYXRvciwga2V5ICE9PSBudWxsID8ga2V5IDogaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIGZyYWcuZm9ySWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KTtcbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2LXJlZiBvbiBvd25lciB2bS5cbiAgICovXG5cbiAgdXBkYXRlUmVmOiBmdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZGVzY3JpcHRvci5yZWY7XG4gICAgaWYgKCFyZWYpIHJldHVybjtcbiAgICB2YXIgaGFzaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmcztcbiAgICB2YXIgcmVmcztcbiAgICBpZiAoIXRoaXMuZnJvbU9iamVjdCkge1xuICAgICAgcmVmcyA9IHRoaXMuZnJhZ3MubWFwKGZpbmRWbUZyb21GcmFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmcyA9IHt9O1xuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhhc2hbcmVmXSA9IHJlZnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgIGlmICh0aGlzLmlzT3B0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5zdGFydC5wYXJlbnROb2RlO1xuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChmcmFnLCBpbmRleCwgcHJldkVsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIG51bGwsICdlbnRlcicpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBhbmNob3IgYW5kIGluc2VydCBpdCBzeW5jaHJvbm91c2x5LFxuICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gcmVzb2x2ZSB0aGUgY29ycmVjdCBvcmRlciB3aXRob3V0XG4gICAgICAvLyB3b3JyeWluZyBhYm91dCBzb21lIGVsZW1lbnRzIG5vdCBpbnNlcnRlZCB5ZXRcbiAgICAgIHZhciBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3I7XG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBjcmVhdGVBbmNob3IoJ3N0YWdnZXItYW5jaG9yJyk7XG4gICAgICAgIGFuY2hvci5fX3ZfZnJhZyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBhZnRlcihhbmNob3IsIHByZXZFbCk7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLmJlZm9yZShhbmNob3IpO1xuICAgICAgICByZW1vdmUoYW5jaG9yKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSBwcmV2RWwubmV4dFNpYmxpbmc7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIC8vIHJlc2V0IGVuZCBhbmNob3IgcG9zaXRpb24gaW4gY2FzZSB0aGUgcG9zaXRpb24gd2FzIG1lc3NlZCB1cFxuICAgICAgICAvLyBieSBhbiBleHRlcm5hbCBkcmFnLW4tZHJvcCBsaWJyYXJ5LlxuICAgICAgICBhZnRlcih0aGlzLmVuZCwgcHJldkVsKTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5lbmQ7XG4gICAgICB9XG4gICAgICBmcmFnLmJlZm9yZSh0YXJnZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgLy8gaXQncyBub3QgcG9zc2libGUgZm9yIHRoZSBzYW1lIGZyYWcgdG8gYmUgcmVtb3ZlZFxuICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAvLyBpdCBtZWFucyB0aGlzIGZyYWcgaXMgcXVldWVkIGZvciBlbnRlciBidXQgcmVtb3ZlZFxuICAgICAgLy8gYmVmb3JlIGl0cyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIFNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAvLyBmaXggYSBjb21tb24gaXNzdWUgd2l0aCBTb3J0YWJsZTpcbiAgICAvLyBpZiBwcmV2RWwgZG9lc24ndCBoYXZlIG5leHRTaWJsaW5nLCB0aGlzIG1lYW5zIGl0J3NcbiAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAvLyB0aGUgZW5kIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBjb250YWluZXIuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuZW5kLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIH1cbiAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICovXG5cbiAgY2FjaGVGcmFnOiBmdW5jdGlvbiBjYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICAgIGNhY2hlW2lkXSA9IGZyYWc7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrQnlLZXkgIT09ICckaW5kZXgnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGhhc093bih2YWx1ZSwgaWQpKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpZF0gPT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZVtpZF0gPSBmcmFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdGcm96ZW4gdi1mb3Igb2JqZWN0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSB0cmFja2VkLCBtYWtlIHN1cmUgdG8gJyArICdwcm92aWRlIGEgdHJhY2stYnkga2V5LicpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcmFnLnJhdyA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBjYWNoZWQgZnJhZ21lbnQgZnJvbSB0aGUgdmFsdWUvaW5kZXgva2V5XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7RnJhZ21lbnR9XG4gICAqL1xuXG4gIGdldENhY2hlZEZyYWc6IGZ1bmN0aW9uIGdldENhY2hlZEZyYWcodmFsdWUsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIHByaW1pdGl2ZSA9ICFpc09iamVjdCh2YWx1ZSk7XG4gICAgdmFyIGZyYWc7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgdmFyIGlkID0gZ2V0VHJhY2tCeUtleShpbmRleCwga2V5LCB2YWx1ZSwgdHJhY2tCeUtleSk7XG4gICAgICBmcmFnID0gdGhpcy5jYWNoZVtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICB9XG4gICAgaWYgKGZyYWcgJiYgKGZyYWcucmV1c2VkIHx8IGZyYWcuZnJlc2gpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqL1xuXG4gIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZEZyYWcoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3O1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgc2NvcGUgPSBmcmFnLnNjb3BlO1xuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgIC8vIGEgcGFyZW50IHJlcGVhdGVyIHdoaWNoIGhhcHBlbnMgdG8gaGF2ZSAka2V5LlxuICAgIHZhciBrZXkgPSBoYXNPd24oc2NvcGUsICcka2V5JykgJiYgc2NvcGUuJGtleTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAodHJhY2tCeUtleSB8fCBrZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVbdGhpcy5pZF0gPSBudWxsO1xuICAgICAgZnJhZy5yYXcgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFnZ2VyIGFtb3VudCBmb3IgYW4gaW5zZXJ0aW9uL3JlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKi9cblxuICBnZXRTdGFnZ2VyOiBmdW5jdGlvbiBnZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlICsgJ1N0YWdnZXInO1xuICAgIHZhciB0cmFucyA9IGZyYWcubm9kZS5fX3ZfdHJhbnM7XG4gICAgdmFyIGhvb2tzID0gdHJhbnMgJiYgdHJhbnMuaG9va3M7XG4gICAgdmFyIGhvb2sgPSBob29rcyAmJiAoaG9va3NbdHlwZV0gfHwgaG9va3Muc3RhZ2dlcik7XG4gICAgcmV0dXJuIGhvb2sgPyBob29rLmNhbGwoZnJhZywgaW5kZXgsIHRvdGFsKSA6IGluZGV4ICogcGFyc2VJbnQodGhpcy5wYXJhbXNbdHlwZV0gfHwgdGhpcy5wYXJhbXMuc3RhZ2dlciwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcmUtcHJvY2VzcyB0aGUgdmFsdWUgYmVmb3JlIHBpcGluZyBpdCB0aHJvdWdoIHRoZVxuICAgKiBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKi9cblxuICBfcHJlUHJvY2VzczogZnVuY3Rpb24gX3ByZVByb2Nlc3ModmFsdWUpIHtcbiAgICAvLyByZWdhcmRsZXNzIG9mIHR5cGUsIHN0b3JlIHRoZSB1bi1maWx0ZXJlZCByYXcgdmFsdWUuXG4gICAgdGhpcy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIHRoZSB2YWx1ZSBhZnRlciBpdCBoYXMgYmVlbiBwaXBlZCB0aHJvdWdoXG4gICAqIHRoZSBmaWx0ZXJzLiBUaGlzIGlzIHBhc3NlZCB0byBhbmQgY2FsbGVkIGJ5IHRoZSB3YXRjaGVyLlxuICAgKlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIHRoaXMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogd2F0Y2hlcidzIGRlcGVuZGVuY3kgY29sbGVjdGlvbiBwaGFzZSBiZWNhdXNlIHdlIHdhbnRcbiAgICogdGhlIHYtZm9yIHRvIHVwZGF0ZSB3aGVuIHRoZSBzb3VyY2UgT2JqZWN0IGlzIG11dGF0ZWQuXG4gICAqL1xuXG4gIF9wb3N0UHJvY2VzczogZnVuY3Rpb24gX3Bvc3RQcm9jZXNzKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gY29udmVydCBwbGFpbiBvYmplY3QgdG8gYXJyYXkuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGkpO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmVzW2ldID0ge1xuICAgICAgICAgICRrZXk6IGtleSxcbiAgICAgICAgICAkdmFsdWU6IHZhbHVlW2tleV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSByYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNbdGhpcy5kZXNjcmlwdG9yLnJlZl0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFncykge1xuICAgICAgdmFyIGkgPSB0aGlzLmZyYWdzLmxlbmd0aDtcbiAgICAgIHZhciBmcmFnO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICBmcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGZpbmQgdGhlIHByZXZpb3VzIGVsZW1lbnQgdGhhdCBpcyBhIGZyYWdtZW50XG4gKiBhbmNob3IuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBkZXN0cm95ZWQgZnJhZydzXG4gKiBlbGVtZW50IGNvdWxkIHN0aWxsIGJlIGxpbmdlcmluZyBpbiB0aGUgRE9NIGJlZm9yZSBpdHNcbiAqIGxlYXZpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcywgYnV0IGl0cyBpbnNlcnRlZCBmbGFnXG4gKiBzaG91bGQgaGF2ZSBiZWVuIHNldCB0byBmYWxzZSBzbyB3ZSBjYW4gc2tpcCB0aGVtLlxuICpcbiAqIElmIHRoaXMgaXMgYSBibG9jayByZXBlYXQsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIG9ubHlcbiAqIHJldHVybiBmcmFnIHRoYXQgaXMgYm91bmQgdG8gdGhpcyB2LWZvci4gKHNlZSAjOTI5KVxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7Q29tbWVudHxUZXh0fSBhbmNob3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHJldHVybiB7RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFByZXZGcmFnKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZztcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZWwpIHJldHVybjtcbiAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB3aGlsZSAoKCFmcmFnIHx8IGZyYWcuZm9ySWQgIT09IGlkIHx8ICFmcmFnLmluc2VydGVkKSAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGZyYWcgPSBlbC5fX3ZfZnJhZztcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBGaW5kIGEgdm0gZnJvbSBhIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFZtRnJvbUZyYWcoZnJhZykge1xuICB2YXIgbm9kZSA9IGZyYWcubm9kZTtcbiAgLy8gaGFuZGxlIG11bHRpLW5vZGUgZnJhZ1xuICBpZiAoZnJhZy5lbmQpIHtcbiAgICB3aGlsZSAoIW5vZGUuX192dWVfXyAmJiBub2RlICE9PSBmcmFnLmVuZCAmJiBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUuX192dWVfXztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByYW5nZSBhcnJheSBmcm9tIGdpdmVuIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KE1hdGguZmxvb3IobikpO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJldFtpXSA9IGk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRyYWNrIGJ5IGtleSBmb3IgYW4gaXRlbS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHJhY2tCeUtleV1cbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KSB7XG4gIHJldHVybiB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHRyYWNrQnlLZXkuY2hhckF0KDApLm1hdGNoKC9cXHcvKSA/IGdldFBhdGgodmFsdWUsIHRyYWNrQnlLZXkpIDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZGb3Iud2FybkR1cGxpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHdhcm4oJ0R1cGxpY2F0ZSB2YWx1ZSBmb3VuZCBpbiB2LWZvcj1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJy4gVXNlIHRyYWNrLWJ5PVwiJGluZGV4XCIgaWYgJyArICd5b3UgYXJlIGV4cGVjdGluZyBkdXBsaWNhdGUgdmFsdWVzLicsIHRoaXMudm0pO1xuICB9O1xufVxuXG52YXIgdklmID0ge1xuXG4gIHByaW9yaXR5OiBJRixcbiAgdGVybWluYWw6IHRydWUsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICghZWwuX192dWVfXykge1xuICAgICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUobmV4dCk7XG4gICAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIG1haW4gYmxvY2tcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICByZXBsYWNlKGVsLCB0aGlzLmFuY2hvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1pZj1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgY2Fubm90IGJlICcgKyAndXNlZCBvbiBhbiBpbnN0YW5jZSByb290IGVsZW1lbnQuJywgdGhpcy52bSk7XG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHJldHVybjtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbHNlRnJhZyA9IG51bGw7XG4gICAgfVxuICAgIC8vIGxhenkgaW5pdCBmYWN0b3J5XG4gICAgaWYgKCF0aGlzLmZhY3RvcnkpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgdGhpcy5lbCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUodGhpcy5faG9zdCwgdGhpcy5fc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIHRoaXMuZnJhZy5iZWZvcmUodGhpcy5hbmNob3IpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VFbCAmJiAhdGhpcy5lbHNlRnJhZykge1xuICAgICAgaWYgKCF0aGlzLmVsc2VGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZWxzZUZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMuZWxzZUVsLl9jb250ZXh0IHx8IHRoaXMudm0sIHRoaXMuZWxzZUVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsc2VGcmFnKSB7XG4gICAgICB0aGlzLmVsc2VGcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaG93ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gY2hlY2sgZWxzZSBibG9ja1xuICAgIHZhciBuZXh0ID0gdGhpcy5lbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWxzZUVsID0gbmV4dDtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmFwcGx5KHRoaXMuZWwsIHZhbHVlKTtcbiAgICBpZiAodGhpcy5lbHNlRWwpIHtcbiAgICAgIHRoaXMuYXBwbHkodGhpcy5lbHNlRWwsICF2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseShlbCwgdmFsdWUpIHtcbiAgICBpZiAoaW5Eb2MoZWwpKSB7XG4gICAgICBhcHBseVRyYW5zaXRpb24oZWwsIHZhbHVlID8gMSA6IC0xLCB0b2dnbGUsIHRoaXMudm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2dnbGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dCQyID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBsYXp5ID0gdGhpcy5wYXJhbXMubGF6eTtcbiAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJhbXMubnVtYmVyO1xuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgLy8gaGFuZGxlIGNvbXBvc2l0aW9uIGV2ZW50cy5cbiAgICAvLyAgIGh0dHA6Ly9ibG9nLmV2YW55b3UubWUvMjAxNC8wMS8wMy9jb21wb3NpdGlvbi1ldmVudC9cbiAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgLy8gZXZlbnRzIHF1aXRlIGRpZmZlcmVudGx5LiBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlclxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyBmb3IgbGFuZ3VhZ2UgaW5wdXQgbWV0aG9kcyBlLmcuXG4gICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAvLyBzdWdnZXN0aW9ucy4uLiAoc2VlIERpc2N1c3Npb24vIzE2MilcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBtZXNzaW5nIHdpdGggdGhlIGlucHV0IHdoZW4gdXNlciBpcyB0eXBpbmcsXG4gICAgLy8gYW5kIGZvcmNlIHVwZGF0ZSBvbiBibHVyLlxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICghaXNSYW5nZSAmJiAhbGF6eSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBkbyBub3Qgc3luYyB2YWx1ZSBhZnRlciBmcmFnbWVudCByZW1vdmFsICgjMjAxNylcbiAgICAgICAgaWYgKCFzZWxmLl9mcmFnIHx8IHNlbGYuX2ZyYWcuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdyBhdHRhY2ggdGhlIG1haW4gbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2JvdW5kICYmICFzZWxmLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IGRlYm91bmNlXG4gICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGpRdWVyeSBldmVudHMsIHNpbmNlIGpRdWVyeS50cmlnZ2VyKCkgZG9lc24ndFxuICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAvLyByZWx5IG9uICQudHJpZ2dlcigpXG4gICAgLy9cbiAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgLy8galF1ZXJ5LCBpdCBpcyBhbHNvIHJlbW92ZWQgd2l0aCBqUXVlcnksIHRoYXQncyB3aHlcbiAgICAvLyB3ZSBkbyB0aGUgY2hlY2sgZm9yIGVhY2ggZGlyZWN0aXZlIGluc3RhbmNlIGFuZFxuICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgIC8vIGVhc2llciB0ZXN0IGNvdmVyYWdlIGNvbnRyb2wgYnkgdW5zZXR0aW5nIHRoZSBnbG9iYWxcbiAgICAvLyBqUXVlcnkgdmFyaWFibGUgaW4gdGVzdHMuXG4gICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGpRdWVyeS5mbi5vbiA/ICdvbicgOiAnYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMucmF3TGlzdGVuZXIpO1xuICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgdGhpcy5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIGlzSUU5KSB7XG4gICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKHNlbGYubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiBlbC52YWx1ZS50cmltKCkpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICAvLyAjMzAyOSBvbmx5IHVwZGF0ZSB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBUaGlzIHByZXZlbnRcbiAgICAvLyBicm93c2VycyBmcm9tIG92ZXJ3cml0aW5nIHZhbHVlcyBsaWtlIHNlbGVjdGlvblN0YXJ0XG4gICAgdmFsdWUgPSBfdG9TdHJpbmcodmFsdWUpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5lbC52YWx1ZSkgdGhpcy5lbC52YWx1ZSA9IHZhbHVlO1xuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9mZiA/ICdvZmYnIDogJ3VuYmluZCc7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJhZGlvID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdmFsdWUgb3ZlcndyaXRlIHZpYSB2LWJpbmQ6dmFsdWVcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl92YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBlbC52YWx1ZTtcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gdG9OdW1iZXIodmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNldChzZWxmLmdldFZhbHVlKCkpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpO1xuICB9XG59O1xuXG52YXIgc2VsZWN0ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fd2F0Y2hlcikge1xuICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgIHZhciBtdWx0aXBsZSA9IHRoaXMubXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG5cbiAgICAvLyBhdHRhY2ggbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlKTtcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyID8gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodG9OdW1iZXIpIDogdG9OdW1iZXIodmFsdWUpIDogdmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSk7XG4gICAgaWYgKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGggfHwgIW11bHRpcGxlICYmIGluaXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8vIEFsbCBtYWpvciBicm93c2VycyBleGNlcHQgRmlyZWZveCByZXNldHNcbiAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gYSBuZXcgcGFyZW50LCB0aGVyZWZvcmUgd2UgaGF2ZSB0b1xuICAgIC8vIGZvcmNlIGEgRE9NIHVwZGF0ZSB3aGVuZXZlciB0aGF0IGhhcHBlbnMuLi5cbiAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG5leHRUaWNrKF90aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9KTtcbiAgICBpZiAoIWluRG9jKGVsKSkge1xuICAgICAgbmV4dFRpY2sodGhpcy5mb3JjZVVwZGF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdmFyIG11bHRpID0gdGhpcy5tdWx0aXBsZSAmJiBpc0FycmF5KHZhbHVlKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICB2YXIgb3AsIHZhbDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV07XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgb3Auc2VsZWN0ZWQgPSBtdWx0aSA/IGluZGV4T2YkMSh2YWx1ZSwgdmFsKSA+IC0xIDogbG9vc2VFcXVhbCh2YWx1ZSwgdmFsKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHNlbGVjdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2VsZWN0RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QXJyYXl8Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgdmFyIHJlcyA9IG11bHRpID8gW10gOiBudWxsO1xuICB2YXIgb3AsIHZhbCwgc2VsZWN0ZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV07XG4gICAgc2VsZWN0ZWQgPSBpbml0ID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpIDogb3Auc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAqIGNhc2Ugd2UgbmVlZCB0byBtYXRjaCBzdHJpbmcvbnVtYmVycyB3aXRoIGN1c3RvbSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIGNoZWNrYm94ID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IGVsLl92YWx1ZSA6IHNlbGYucGFyYW1zLm51bWJlciA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRCb29sZWFuVmFsdWUoKSB7XG4gICAgICB2YXIgdmFsID0gZWwuY2hlY2tlZDtcbiAgICAgIGlmICh2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3RydWVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsICYmIGVsLmhhc093blByb3BlcnR5KCdfZmFsc2VWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fZmFsc2VWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtb2RlbCA9IHNlbGYuX3dhdGNoZXIudmFsdWU7XG4gICAgICBpZiAoaXNBcnJheShtb2RlbCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihtb2RlbCwgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIG1vZGVsLnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwuJHJlbW92ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldChnZXRCb29sZWFuVmFsdWUoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBlbC5jaGVja2VkID0gaW5kZXhPZih2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpKSA+IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoJ190cnVlVmFsdWUnKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZWwuX3RydWVWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgdGV4dDogdGV4dCQyLFxuICByYWRpbzogcmFkaW8sXG4gIHNlbGVjdDogc2VsZWN0LFxuICBjaGVja2JveDogY2hlY2tib3hcbn07XG5cbnZhciBtb2RlbCA9IHtcblxuICBwcmlvcml0eTogTU9ERUwsXG4gIHR3b1dheTogdHJ1ZSxcbiAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICBwYXJhbXM6IFsnbGF6eScsICdudW1iZXInLCAnZGVib3VuY2UnXSxcblxuICAvKipcbiAgICogUG9zc2libGUgZWxlbWVudHM6XG4gICAqICAgPHNlbGVjdD5cbiAgICogICA8dGV4dGFyZWE+XG4gICAqICAgPGlucHV0IHR5cGU9XCIqXCI+XG4gICAqICAgICAtIHRleHRcbiAgICogICAgIC0gY2hlY2tib3hcbiAgICogICAgIC0gcmFkaW9cbiAgICogICAgIC0gbnVtYmVyXG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZnJpZW5kbHkgd2FybmluZy4uLlxuICAgIHRoaXMuY2hlY2tGaWx0ZXJzKCk7XG4gICAgaWYgKHRoaXMuaGFzUmVhZCAmJiAhdGhpcy5oYXNXcml0ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIGEgcmVhZC1vbmx5IGZpbHRlciB3aXRoICcgKyAndi1tb2RlbD1cIicgKyB0aGlzLmRlc2NyaXB0b3IucmF3ICsgJ1wiLiAnICsgJ1lvdSBtaWdodCB3YW50IHRvIHVzZSBhIHR3by13YXkgZmlsdGVyIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLicsIHRoaXMudm0pO1xuICAgIH1cbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lO1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmICh0YWcgPT09ICdJTlBVVCcpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tlbC50eXBlXSB8fCBoYW5kbGVycy50ZXh0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnU0VMRUNUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnNlbGVjdDtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGVsZW1lbnQgdHlwZTogJyArIHRhZywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLl9fdl9tb2RlbCA9IHRoaXM7XG4gICAgaGFuZGxlci5iaW5kLmNhbGwodGhpcyk7XG4gICAgdGhpcy51cGRhdGUgPSBoYW5kbGVyLnVwZGF0ZTtcbiAgICB0aGlzLl91bmJpbmQgPSBoYW5kbGVyLnVuYmluZDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgcmVhZC93cml0ZSBmaWx0ZXIgc3RhdHMuXG4gICAqL1xuXG4gIGNoZWNrRmlsdGVyczogZnVuY3Rpb24gY2hlY2tGaWx0ZXJzKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGlmICghZmlsdGVycykgcmV0dXJuO1xuICAgIHZhciBpID0gZmlsdGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGZpbHRlciA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlcnNbaV0ubmFtZSk7XG4gICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIucmVhZCkge1xuICAgICAgICB0aGlzLmhhc1JlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci53cml0ZSkge1xuICAgICAgICB0aGlzLmhhc1dyaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5lbC5fX3ZfbW9kZWwgPSBudWxsO1xuICAgIHRoaXMuX3VuYmluZCAmJiB0aGlzLl91bmJpbmQoKTtcbiAgfVxufTtcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiBbOCwgNDZdLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwXG59O1xuXG5mdW5jdGlvbiBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cykge1xuICB2YXIgY29kZXMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoYXJDb2RlID0ga2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGNoYXJDb2RlID4gNDcgJiYgY2hhckNvZGUgPCA1OCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2hhckNvZGUgPSBrZXkudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNoYXJDb2RlID4gNjQgJiYgY2hhckNvZGUgPCA5MSkge1xuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlDb2Rlc1trZXldO1xuICB9KTtcbiAgY29kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGNvZGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgIGlmIChjb2Rlcy5pbmRleE9mKGUua2V5Q29kZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0b3BGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcEhhbmRsZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJldmVudEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50SGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGZGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZkhhbmRsZXIoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG9uJDEgPSB7XG5cbiAgcHJpb3JpdHk6IE9OLFxuICBhY2NlcHRTdGF0ZW1lbnQ6IHRydWUsXG4gIGtleUNvZGVzOiBrZXlDb2RlcyxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGRlYWwgd2l0aCBpZnJhbWVzXG4gICAgaWYgKHRoaXMuZWwudGFnTmFtZSA9PT0gJ0lGUkFNRScgJiYgdGhpcy5hcmcgIT09ICdsb2FkJykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5pZnJhbWVCaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbihzZWxmLmVsLmNvbnRlbnRXaW5kb3csIHNlbGYuYXJnLCBzZWxmLmhhbmRsZXIsIHNlbGYubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCB0aGlzLmlmcmFtZUJpbmQpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShoYW5kbGVyKSB7XG4gICAgLy8gc3R1YiBhIG5vb3AgZm9yIHYtb24gd2l0aCBubyB2YWx1ZSxcbiAgICAvLyBlLmcuIEBtb3VzZWRvd24ucHJldmVudFxuICAgIGlmICghdGhpcy5kZXNjcmlwdG9yLnJhdykge1xuICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArICdnb3QgJyArIGhhbmRsZXIsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnByZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIgPSBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMuc2VsZikge1xuICAgICAgaGFuZGxlciA9IHNlbGZGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIGtleSBmaWx0ZXJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kaWZpZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleSAhPT0gJ3N0b3AnICYmIGtleSAhPT0gJ3ByZXZlbnQnICYmIGtleSAhPT0gJ3NlbGYnICYmIGtleSAhPT0gJ2NhcHR1cmUnO1xuICAgIH0pO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLmlmcmFtZUJpbmQpIHtcbiAgICAgIHRoaXMuaWZyYW1lQmluZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbih0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyLCB0aGlzLm1vZGlmaWVycy5jYXB0dXJlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZCA/IHRoaXMuZWwuY29udGVudFdpbmRvdyA6IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgb2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nXTtcbnZhciBjYW1lbFByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG52YXIgaW1wb3J0YW50UkUgPSAvIWltcG9ydGFudDs/JC87XG52YXIgcHJvcENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIHRlc3RFbCA9IG51bGw7XG5cbnZhciBzdHlsZSA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLnJlZHVjZShleHRlbmQsIHt9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0OiBmdW5jdGlvbiBoYW5kbGVPYmplY3QodmFsdWUpIHtcbiAgICAvLyBjYWNoZSBvYmplY3Qgc3R5bGVzIHNvIHRoYXQgb25seSBjaGFuZ2VkIHByb3BzXG4gICAgLy8gYXJlIGFjdHVhbGx5IHVwZGF0ZWQuXG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSB8fCAodGhpcy5jYWNoZSA9IHt9KTtcbiAgICB2YXIgbmFtZSwgdmFsO1xuICAgIGZvciAobmFtZSBpbiBjYWNoZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW5nbGUobmFtZSwgbnVsbCk7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICAgIGlmICh2YWwgIT09IGNhY2hlW25hbWVdKSB7XG4gICAgICAgIGNhY2hlW25hbWVdID0gdmFsO1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVTaW5nbGU6IGZ1bmN0aW9uIGhhbmRsZVNpbmdsZShwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBub3JtYWxpemUocHJvcCk7XG4gICAgaWYgKCFwcm9wKSByZXR1cm47IC8vIHVuc3VwcG9ydGVkIHByb3BcbiAgICAvLyBjYXN0IHBvc3NpYmxlIG51bWJlcnMvYm9vbGVhbnMgaW50byBzdHJpbmdzXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlICs9ICcnO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGlzSW1wb3J0YW50ID0gaW1wb3J0YW50UkUudGVzdCh2YWx1ZSkgPyAnaW1wb3J0YW50JyA6ICcnO1xuICAgICAgaWYgKGlzSW1wb3J0YW50KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ0l0XFwncyBwcm9iYWJseSBhIGJhZCBpZGVhIHRvIHVzZSAhaW1wb3J0YW50IHdpdGggaW5saW5lIHJ1bGVzLiAnICsgJ1RoaXMgZmVhdHVyZSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBWdWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3Aua2ViYWIsIHZhbHVlLCBpc0ltcG9ydGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsLnN0eWxlW3Byb3AuY2FtZWxdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSAnJztcbiAgICB9XG4gIH1cblxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBDU1MgcHJvcGVydHkgbmFtZS5cbiAqIC0gY2FjaGUgcmVzdWx0XG4gKiAtIGF1dG8gcHJlZml4XG4gKiAtIGNhbWVsQ2FzZSAtPiBkYXNoLWNhc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShwcm9wKSB7XG4gIGlmIChwcm9wQ2FjaGVbcHJvcF0pIHtcbiAgICByZXR1cm4gcHJvcENhY2hlW3Byb3BdO1xuICB9XG4gIHZhciByZXMgPSBwcmVmaXgocHJvcCk7XG4gIHByb3BDYWNoZVtwcm9wXSA9IHByb3BDYWNoZVtyZXNdID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEF1dG8gZGV0ZWN0IHRoZSBhcHByb3ByaWF0ZSBwcmVmaXggZm9yIGEgQ1NTIHByb3BlcnR5LlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzUyMzY5MlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcHJlZml4KHByb3ApIHtcbiAgcHJvcCA9IGh5cGhlbmF0ZShwcm9wKTtcbiAgdmFyIGNhbWVsID0gY2FtZWxpemUocHJvcCk7XG4gIHZhciB1cHBlciA9IGNhbWVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWwuc2xpY2UoMSk7XG4gIGlmICghdGVzdEVsKSB7XG4gICAgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cbiAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGg7XG4gIHZhciBwcmVmaXhlZDtcbiAgaWYgKGNhbWVsICE9PSAnZmlsdGVyJyAmJiBjYW1lbCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2ViYWI6IHByb3AsXG4gICAgICBjYW1lbDogY2FtZWxcbiAgICB9O1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBwcmVmaXhlZCA9IGNhbWVsUHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZWJhYjogcHJlZml4ZXNbaV0gKyBwcm9wLFxuICAgICAgICBjYW1lbDogcHJlZml4ZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHhsaW5rXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciB4bGlua1JFID0gL154bGluazovO1xuXG4vLyBjaGVjayBmb3IgYXR0cmlidXRlcyB0aGF0IHByb2hpYml0IGludGVycG9sYXRpb25zXG52YXIgZGlzYWxsb3dlZEludGVycEF0dHJSRSA9IC9edi18Xjp8XkB8Xig/OmlzfHRyYW5zaXRpb258dHJhbnNpdGlvbi1tb2RlfGRlYm91bmNlfHRyYWNrLWJ5fHN0YWdnZXJ8ZW50ZXItc3RhZ2dlcnxsZWF2ZS1zdGFnZ2VyKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4vLyBiZWNhdXNlIHRoZXkgb25seSBhZmZlY3QgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbnZhciBhdHRyV2l0aFByb3BzUkUgPSAvXig/OnZhbHVlfGNoZWNrZWR8c2VsZWN0ZWR8bXV0ZWQpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIGV4cGVjdCBlbnVtcmF0ZWQgdmFsdWVzIG9mIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIlxuLy8gYnV0IGFyZSBub3QgYm9vbGVhbiBhdHRyaWJ1dGVzXG52YXIgZW51bWVyYXRlZEF0dHJSRSA9IC9eKD86ZHJhZ2dhYmxlfGNvbnRlbnRlZGl0YWJsZXxzcGVsbGNoZWNrKSQvO1xuXG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBzZXQgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4vLyBiaW5kaW5nIHYtbW9kZWwgdG8gb2JqZWN0IHZhbHVlc1xudmFyIG1vZGVsUHJvcHMgPSB7XG4gIHZhbHVlOiAnX3ZhbHVlJyxcbiAgJ3RydWUtdmFsdWUnOiAnX3RydWVWYWx1ZScsXG4gICdmYWxzZS12YWx1ZSc6ICdfZmFsc2VWYWx1ZSdcbn07XG5cbnZhciBiaW5kJDEgPSB7XG5cbiAgcHJpb3JpdHk6IEJJTkQsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgLy8gc2hvdWxkIGJlIGRlZXAgd2F0Y2ggb24gb2JqZWN0IG1vZGVcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHRoaXMuZGVlcCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmdzXG4gICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgdmFyIHRva2VucyA9IGRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9ucyB3aXRoIG9uZS10aW1lIHRva2Vuc1xuICAgICAgaWYgKGRlc2NyaXB0b3IuaGFzT25lVGltZSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSB0b2tlbnNUb0V4cCh0b2tlbnMsIHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChkaXNhbGxvd2VkSW50ZXJwQXR0clJFLnRlc3QoYXR0cikgfHwgYXR0ciA9PT0gJ25hbWUnICYmICh0YWcgPT09ICdQQVJUSUFMJyB8fCB0YWcgPT09ICdTTE9UJykpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2F0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIFZ1ZS5qcyAnICsgJ2RpcmVjdGl2ZXMgYW5kIHNwZWNpYWwgYXR0cmlidXRlcy4nLCB0aGlzLnZtKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJhdyA9IGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnO1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3JjXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICdhIDQwNCByZXF1ZXN0LiBVc2Ugdi1iaW5kOnNyYyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FybiBzdHlsZVxuICAgICAgICBpZiAoYXR0ciA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzdHlsZVwiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgKyAnVXNlIHYtYmluZDpzdHlsZSBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIGlmICh0aGlzLmFyZykge1xuICAgICAgdGhpcy5oYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNoYXJlIG9iamVjdCBoYW5kbGVyIHdpdGggdi1iaW5kOmNsYXNzXG4gIGhhbmRsZU9iamVjdDogc3R5bGUuaGFuZGxlT2JqZWN0LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJwID0gdGhpcy5kZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAodGhpcy5tb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgIGF0dHIgPSBjYW1lbGl6ZShhdHRyKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnAgJiYgYXR0cldpdGhQcm9wc1JFLnRlc3QoYXR0cikgJiYgYXR0ciBpbiBlbCkge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgPyAnJyA6IHZhbHVlIDogdmFsdWU7XG5cbiAgICAgIGlmIChlbFthdHRyXSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgIGVsW2F0dHJdID0gYXR0clZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXQgbW9kZWwgcHJvcHNcbiAgICB2YXIgbW9kZWxQcm9wID0gbW9kZWxQcm9wc1thdHRyXTtcbiAgICBpZiAoIWludGVycCAmJiBtb2RlbFByb3ApIHtcbiAgICAgIGVsW21vZGVsUHJvcF0gPSB2YWx1ZTtcbiAgICAgIC8vIHVwZGF0ZSB2LW1vZGVsIGlmIHByZXNlbnRcbiAgICAgIHZhciBtb2RlbCA9IGVsLl9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5saXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyBub3Qgc2V0IHZhbHVlIGF0dHJpYnV0ZSBmb3IgdGV4dGFyZWFcbiAgICBpZiAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVcbiAgICBpZiAoZW51bWVyYXRlZEF0dHJSRS50ZXN0KGF0dHIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICAvLyBoYW5kbGUgZWRnZSBjYXNlICMxOTYwOlxuICAgICAgICAvLyBjbGFzcyBpbnRlcnBvbGF0aW9uIHNob3VsZCBub3Qgb3ZlcndyaXRlIFZ1ZSB0cmFuc2l0aW9uIGNsYXNzXG4gICAgICAgIGlmIChlbC5fX3ZfdHJhbnMpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnICcgKyBlbC5fX3ZfdHJhbnMuaWQgKyAnLXRyYW5zaXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIHNldENsYXNzKGVsLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhsaW5rUkUudGVzdChhdHRyKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbCA9IHtcblxuICBwcmlvcml0eTogRUwsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMuYXJnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZCA9IHRoaXMuaWQgPSBjYW1lbGl6ZSh0aGlzLmFyZyk7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAoaGFzT3duKHJlZnMsIGlkKSkge1xuICAgICAgcmVmc1tpZF0gPSB0aGlzLmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShyZWZzLCBpZCwgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKHJlZnNbdGhpcy5pZF0gPT09IHRoaXMuZWwpIHtcbiAgICAgIHJlZnNbdGhpcy5pZF0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJlZiA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3YtcmVmOicgKyB0aGlzLmFyZyArICcgbXVzdCBiZSB1c2VkIG9uIGEgY2hpbGQgJyArICdjb21wb25lbnQuIEZvdW5kIG9uIDwnICsgdGhpcy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPi4nLCB0aGlzLnZtKTtcbiAgfVxufTtcblxudmFyIGNsb2FrID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdGhpcy52bS4kb25jZSgncHJlLWhvb2s6Y29tcGlsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gbXVzdCBleHBvcnQgcGxhaW4gb2JqZWN0XG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgdGV4dDogdGV4dCQxLFxuICBodG1sOiBodG1sLFxuICAnZm9yJzogdkZvcixcbiAgJ2lmJzogdklmLFxuICBzaG93OiBzaG93LFxuICBtb2RlbDogbW9kZWwsXG4gIG9uOiBvbiQxLFxuICBiaW5kOiBiaW5kJDEsXG4gIGVsOiBlbCxcbiAgcmVmOiByZWYsXG4gIGNsb2FrOiBjbG9ha1xufTtcblxudmFyIHZDbGFzcyA9IHtcblxuICBkZWVwOiB0cnVlLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNldENsYXNzKHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDbGFzcyhub3JtYWxpemUkMSh2YWx1ZSkpO1xuICAgIH1cbiAgfSxcblxuICBzZXRDbGFzczogZnVuY3Rpb24gc2V0Q2xhc3ModmFsdWUpIHtcbiAgICB0aGlzLmNsZWFudXAodmFsdWUpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gdmFsdWVbaV07XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIHZhbCwgYWRkQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByZXZLZXlzID0gdmFsdWU7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cCh2YWx1ZSkge1xuICAgIHZhciBwcmV2S2V5cyA9IHRoaXMucHJldktleXM7XG4gICAgaWYgKCFwcmV2S2V5cykgcmV0dXJuO1xuICAgIHZhciBpID0gcHJldktleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBhcHBseSh0aGlzLmVsLCBrZXksIHJlbW92ZUNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIG9iamVjdHMgYW5kIGFycmF5cyAocG90ZW50aWFsbHkgY29udGFpbmluZyBvYmplY3RzKVxuICogaW50byBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PFN0cmluZ3xPYmplY3Q+fSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn1cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUkMSh2YWx1ZSkge1xuICB2YXIgcmVzID0gW107XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IHZhbHVlW2ldO1xuICAgICAgaWYgKF9rZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfa2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlcy5wdXNoKF9rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gX2tleSkge1xuICAgICAgICAgICAgaWYgKF9rZXlba10pIHJlcy5wdXNoKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEFkZCBvciByZW1vdmUgYSBjbGFzcy9jbGFzc2VzIG9uIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBjbGFzcyBuYW1lLiBUaGlzIG1heSBvciBtYXkgbm90XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW4gYSBzcGFjZSBjaGFyYWN0ZXIsIGluIHN1Y2ggYVxuICogICAgICAgICAgICAgICAgICAgICBjYXNlIHdlJ2xsIGRlYWwgd2l0aCBtdWx0aXBsZSBjbGFzc1xuICogICAgICAgICAgICAgICAgICAgICBuYW1lcyBhdCBvbmNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseShlbCwga2V5LCBmbikge1xuICBrZXkgPSBrZXkudHJpbSgpO1xuICBpZiAoa2V5LmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICBmbihlbCwga2V5KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhlIGtleSBjb250YWlucyBvbmUgb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzLlxuICAvLyBTaW5jZSBhIGNsYXNzIG5hbWUgZG9lc24ndCBhY2NlcHQgc3VjaCBjaGFyYWN0ZXJzLCB3ZVxuICAvLyB0cmVhdCBpdCBhcyBtdWx0aXBsZSBjbGFzc2VzLlxuICB2YXIga2V5cyA9IGtleS5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm4oZWwsIGtleXNbaV0pO1xuICB9XG59XG5cbnZhciBjb21wb25lbnQgPSB7XG5cbiAgcHJpb3JpdHk6IENPTVBPTkVOVCxcblxuICBwYXJhbXM6IFsna2VlcC1hbGl2ZScsICd0cmFuc2l0aW9uLW1vZGUnLCAnaW5saW5lLXRlbXBsYXRlJ10sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIGlmICghdGhpcy5lbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGVcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAvLyBleHRyYWN0IGlubGluZSB0ZW1wbGF0ZSBhcyBhIERvY3VtZW50RnJhZ21lbnRcbiAgICAgICAgdGhpcy5pbmxpbmVUZW1wbGF0ZSA9IGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gY29tcG9uZW50IHJlc29sdXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGw7XG4gICAgICAvLyB0cmFuc2l0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAvLyBjcmVhdGUgYSByZWYgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgLy8gcmVtb3ZlIGlzIGF0dHJpYnV0ZS5cbiAgICAgIC8vIHRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgY29tcGlsYXRpb24sIGJ1dCBiZWNhdXNlIGNvbXBpbGF0aW9uIGlzXG4gICAgICAvLyBjYWNoZWQsIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1c2VkIGVsc2V3aGVyZSB0aGlzIGF0dHJpYnV0ZVxuICAgICAgLy8gd2lsbCByZW1haW4gYXQgbGluayB0aW1lLlxuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnOmlzJyk7XG4gICAgICAvLyByZW1vdmUgcmVmLCBzYW1lIGFzIGFib3ZlXG4gICAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgndi1yZWY6JyArIGh5cGhlbmF0ZSh0aGlzLmRlc2NyaXB0b3IucmVmKSk7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGF0aWMsIGJ1aWxkIHJpZ2h0IG5vdy5cbiAgICAgIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnQodGhpcy5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICsgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdXBkYXRlLCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIgaW4gdGhlIGR5bmFtaWNcbiAgICogbGl0ZXJhbCBzY2VuYXJpbywgZS5nLiA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMubGl0ZXJhbCkge1xuICAgICAgdGhpcy5zZXRDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBjdXJyZW50XG4gICAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkVk0sIGNiKTtcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMucmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm1vdW50Q29tcG9uZW50KGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG4gICAqIHRoZSBjaGlsZCB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlc29sdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgc2VsZi5Db21wb25lbnROYW1lID0gQ29tcG9uZW50Lm9wdGlvbnMubmFtZSB8fCAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogbnVsbCk7XG4gICAgICBzZWxmLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgdGhpcy52bS5fcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgdXNpbmcgdGhlIGN1cnJlbnQgY29uc3RydWN0b3IgYW5kXG4gICAqIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBkb2Vzbid0IGNhcmVcbiAgICogd2hldGhlciB0aGUgbmV3IGNvbXBvbmVudCBhbmQgdGhlIG9sZCBvbmUgYXJlIGFjdHVhbGx5XG4gICAqIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiBtb3VudENvbXBvbmVudChjYikge1xuICAgIC8vIGFjdHVhbCBtb3VudFxuICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjdGl2YXRlSG9va3MgPSB0aGlzLkNvbXBvbmVudC5vcHRpb25zLmFjdGl2YXRlO1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKGFjdGl2YXRlSG9va3MgJiYgIWNhY2hlZCkge1xuICAgICAgdGhpcy53YWl0aW5nRm9yID0gbmV3Q29tcG9uZW50O1xuICAgICAgY2FsbEFjdGl2YXRlSG9va3MoYWN0aXZhdGVIb29rcywgbmV3Q29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLndhaXRpbmdGb3IgIT09IG5ld0NvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLndhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICBzZWxmLnRyYW5zaXRpb24obmV3Q29tcG9uZW50LCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIHJlZiBmb3Iga2VwdC1hbGl2ZSBjb21wb25lbnRcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgbmV3Q29tcG9uZW50Ll91cGRhdGVSZWYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2VzIG9yIHVuYmluZHMgYmVmb3JlIGFuIGFzeW5jXG4gICAqIGNvbnN0cnVjdG9yIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgaXRzXG4gICAqIHBlbmRpbmcgY2FsbGJhY2suXG4gICAqL1xuXG4gIGludmFsaWRhdGVQZW5kaW5nOiBmdW5jdGlvbiBpbnZhbGlkYXRlUGVuZGluZygpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NvbXBvbmVudENiLmNhbmNlbCgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUvaW5zZXJ0IGEgbmV3IGNoaWxkIHZtLlxuICAgKiBJZiBrZWVwIGFsaXZlIGFuZCBoYXMgY2FjaGVkIGluc3RhbmNlLCBpbnNlcnQgdGhhdFxuICAgKiBpbnN0YW5jZTsgb3RoZXJ3aXNlIGJ1aWxkIGEgbmV3IG9uZSBhbmQgY2FjaGUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFPcHRpb25zXVxuICAgKiBAcmV0dXJuIHtWdWV9IC0gdGhlIGNyZWF0ZWQgaW5zdGFuY2VcbiAgICovXG5cbiAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGV4dHJhT3B0aW9ucykge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLkNvbXBvbmVudCkge1xuICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5Db21wb25lbnROYW1lLFxuICAgICAgICBlbDogY2xvbmVOb2RlKHRoaXMuZWwpLFxuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGFkZCB0aGUgY2hpbGQgd2l0aCBjb3JyZWN0IHBhcmVudFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBpdHMgcGFyZW50XG4gICAgICAgIC8vIHNob3VsZCBiZSB0aGUgdHJhbnNjbHVzaW9uIGhvc3QuXG4gICAgICAgIHBhcmVudDogdGhpcy5faG9zdCB8fCB0aGlzLnZtLFxuICAgICAgICAvLyBpZiBubyBpbmxpbmUtdGVtcGxhdGUsIHRoZW4gdGhlIGNvbXBpbGVkXG4gICAgICAgIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIF9saW5rZXJDYWNoYWJsZTogIXRoaXMuaW5saW5lVGVtcGxhdGUsXG4gICAgICAgIF9yZWY6IHRoaXMuZGVzY3JpcHRvci5yZWYsXG4gICAgICAgIF9hc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgX2lzUm91dGVyVmlldzogdGhpcy5faXNSb3V0ZXJWaWV3LFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNjbHVkZWQgY29tcG9uZW50LCBjb250ZXh0XG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgICAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgICAgIF9jb250ZXh0OiB0aGlzLnZtLFxuICAgICAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgICAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgICAvLyByZXBlYXQgZnJhZ21lbnQuIHRoaXMgaXMgdXNlZCBmb3IgbGlua2luZyBwcm9wc1xuICAgICAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgICAgIF9zY29wZTogdGhpcy5fc2NvcGUsXG4gICAgICAgIC8vIHBhc3MgaW4gdGhlIG93bmVyIGZyYWdtZW50IG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBzbyB0aGF0IHRoZSBmcmFnbWVudCBjYW4ga2VlcFxuICAgICAgICAvLyB0cmFjayBvZiBpdHMgY29udGFpbmVkIGNvbXBvbmVudHMgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gY2FsbCBhdHRhY2gvZGV0YWNoIGhvb2tzIGZvciB0aGVtLlxuICAgICAgICBfZnJhZzogdGhpcy5fZnJhZ1xuICAgICAgfTtcbiAgICAgIC8vIGV4dHJhIG9wdGlvbnNcbiAgICAgIC8vIGluIDEuMC4wIHRoaXMgaXMgdXNlZCBieSB2dWUtcm91dGVyIG9ubHlcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGV4dHJhT3B0aW9ucykge1xuICAgICAgICBleHRlbmQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLkNvbXBvbmVudChvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF0gPSBjaGlsZDtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RyYW5zaXRpb24nKSAmJiBjaGlsZC5faXNGcmFnbWVudCkge1xuICAgICAgICB3YXJuKCdUcmFuc2l0aW9ucyB3aWxsIG5vdCB3b3JrIG9uIGEgZnJhZ21lbnQgaW5zdGFuY2UuICcgKyAnVGVtcGxhdGU6ICcgKyBjaGlsZC4kb3B0aW9ucy50ZW1wbGF0ZSwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJ5IHRvIGdldCBhIGNhY2hlZCBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Z1ZXx1bmRlZmluZWR9XG4gICAqL1xuXG4gIGdldENhY2hlZDogZnVuY3Rpb24gZ2V0Q2FjaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmtlZXBBbGl2ZSAmJiB0aGlzLmNhY2hlW3RoaXMuQ29tcG9uZW50LmNpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBjdXJyZW50IGNoaWxkLCBidXQgZGVmZXJzIGNsZWFudXAgc29cbiAgICogdGhhdCB3ZSBjYW4gc2VwYXJhdGUgdGhlIGRlc3Ryb3kgYW5kIHJlbW92YWwgc3RlcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJcbiAgICovXG5cbiAgdW5idWlsZDogZnVuY3Rpb24gdW5idWlsZChkZWZlcikge1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3IpIHtcbiAgICAgIGlmICghdGhpcy5rZWVwQWxpdmUpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkVk07XG4gICAgaWYgKCFjaGlsZCB8fCB0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIHJlbW92ZSByZWZcbiAgICAgICAgY2hpbGQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY2hpbGQuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdGhlIHNvbGUgcHVycG9zZSBvZiBgZGVmZXJDbGVhbnVwYCBpcyBzbyB0aGF0IHdlIGNhblxuICAgIC8vIFwiZGVhY3RpdmF0ZVwiIHRoZSB2bSByaWdodCBub3cgYW5kIHBlcmZvcm0gRE9NIHJlbW92YWxcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC4kZGVzdHJveShmYWxzZSwgZGVmZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3VycmVudCBkZXN0cm95ZWQgY2hpbGQgYW5kIG1hbnVhbGx5IGRvXG4gICAqIHRoZSBjbGVhbnVwIGFmdGVyIHJlbW92YWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNoaWxkLCBjYikge1xuICAgIHZhciBrZWVwQWxpdmUgPSB0aGlzLmtlZXBBbGl2ZTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIC8vIHdlIG1heSBoYXZlIGEgY29tcG9uZW50IHN3aXRjaCB3aGVuIGEgcHJldmlvdXNcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyB0cmFuc2l0aW9uZWQgb3V0LlxuICAgICAgLy8gd2Ugd2FudCB0byB0cmlnZ2VyIG9ubHkgb25lIGxhc3Rlc3QgaW5zZXJ0aW9uIGNiXG4gICAgICAvLyB3aGVuIHRoZSBleGlzdGluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLiAoIzExMTkpXG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFscysrO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gY2I7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbHMtLTtcbiAgICAgICAgaWYgKCFrZWVwQWxpdmUpIGNoaWxkLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2VsZi5wZW5kaW5nUmVtb3ZhbHMgJiYgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKSB7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiKCk7XG4gICAgICAgICAgc2VsZi5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHN3YXAgdGhlIGNvbXBvbmVudHMsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogdHJhbnNpdGlvbiBtb2RlLiBEZWZhdWx0cyB0byBzaW11bHRhbmVvdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKHRhcmdldCwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoaWxkVk07XG4gICAgLy8gZm9yIGRldnRvb2wgaW5zcGVjdGlvblxuICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9pbmFjdGl2ZSA9IHRydWU7XG4gICAgdGFyZ2V0Ll9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hpbGRWTSA9IHRhcmdldDtcbiAgICBzd2l0Y2ggKHNlbGYucGFyYW1zLnRyYW5zaXRpb25Nb2RlKSB7XG4gICAgICBjYXNlICdpbi1vdXQnOlxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0LWluJzpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kLlxuICAgKi9cblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgLy8gRG8gbm90IGRlZmVyIGNsZWFudXAgd2hlbiB1bmJpbmRpbmdcbiAgICB0aGlzLnVuYnVpbGQoKTtcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhY3RpdmF0ZSBob29rcyBpbiBvcmRlciAoYXN5bmNocm9ub3VzKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlSG9va3MoaG9va3MsIHZtLCBjYikge1xuICB2YXIgdG90YWwgPSBob29rcy5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSAwO1xuICBob29rc1swXS5jYWxsKHZtLCBuZXh0KTtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoKytjYWxsZWQgPj0gdG90YWwpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzW2NhbGxlZF0uY2FsbCh2bSwgbmV4dCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wQmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xudmFyIGVtcHR5ID0ge307XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFJDEgPSAvXlskX2EtekEtWl0rW1xcdyRdKiQvO1xudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokLztcblxuLyoqXG4gKiBDb21waWxlIHByb3BzIG9uIGEgcm9vdCBlbGVtZW50IGFuZCByZXR1cm5cbiAqIGEgcHJvcHMgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BPcHRpb25zXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVQcm9wcyhlbCwgcHJvcE9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucyk7XG4gIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcHJvcHMgY291bGQgY29udGFpbiBkYXNoZXMsIHdoaWNoIHdpbGwgYmVcbiAgICAvLyBpbnRlcnByZXRlZCBhcyBtaW51cyBjYWxjdWxhdGlvbnMgYnkgdGhlIHBhcnNlclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIHBhdGggaGVyZVxuICAgIHBhdGggPSBjYW1lbGl6ZShuYW1lKTtcbiAgICBpZiAoIWlkZW50UkUkMS50ZXN0KHBhdGgpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcCBrZXk6IFwiJyArIG5hbWUgKyAnXCIuIFByb3Aga2V5cyAnICsgJ211c3QgYmUgdmFsaWQgaWRlbnRpZmllcnMuJywgdm0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIG1vZGU6IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWSxcbiAgICAgIHJhdzogbnVsbFxuICAgIH07XG5cbiAgICBhdHRyID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgIC8vIGZpcnN0IGNoZWNrIGR5bmFtaWMgdmVyc2lvblxuICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0cikpID09PSBudWxsKSB7XG4gICAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLnN5bmMnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuICAgICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcub25jZScpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBkeW5hbWljIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgICAgdmFsdWUgPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICAgIHByb3AuZmlsdGVycyA9IHBhcnNlZC5maWx0ZXJzO1xuICAgICAgLy8gY2hlY2sgYmluZGluZyB0eXBlXG4gICAgICBpZiAoaXNMaXRlcmFsKHZhbHVlKSAmJiAhcGFyc2VkLmZpbHRlcnMpIHtcbiAgICAgICAgLy8gZm9yIGV4cHJlc3Npb25zIGNvbnRhaW5pbmcgbGl0ZXJhbCBudW1iZXJzIGFuZFxuICAgICAgICAvLyBib29sZWFucywgdGhlcmUncyBubyBuZWVkIHRvIHNldHVwIGEgcHJvcCBiaW5kaW5nLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gb3B0aW1pemUgdGhlbSBhcyBhIG9uZS10aW1lIHNldC5cbiAgICAgICAgcHJvcC5vcHRpbWl6ZWRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZHluYW1pYyA9IHRydWU7XG4gICAgICAgIC8vIGNoZWNrIG5vbi1zZXR0YWJsZSBwYXRoIGZvciB0d28td2F5IGJpbmRpbmdzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZICYmICFzZXR0YWJsZVBhdGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1dBWTtcbiAgICAgICAgICB3YXJuKCdDYW5ub3QgYmluZCB0d28td2F5IHByb3Agd2l0aCBub24tc2V0dGFibGUgJyArICdwYXJlbnQgcGF0aDogJyArIHZhbHVlLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AucGFyZW50UGF0aCA9IHZhbHVlO1xuXG4gICAgICAvLyB3YXJuIHJlcXVpcmVkIHR3by13YXlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMudHdvV2F5ICYmIHByb3AubW9kZSAhPT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZKSB7XG4gICAgICAgIHdhcm4oJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QXR0cihlbCwgYXR0cikpICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgbGl0ZXJhbCBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGNoZWNrIHBvc3NpYmxlIGNhbWVsQ2FzZSBwcm9wIHVzYWdlXG4gICAgICB2YXIgbG93ZXJDYXNlTmFtZSA9IHBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gL1tBLVpcXC1dLy50ZXN0KG5hbWUpICYmIChlbC5nZXRBdHRyaWJ1dGUobG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcub25jZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCc6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLnN5bmMnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3YtYmluZDonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuKCdQb3NzaWJsZSB1c2FnZSBlcnJvciBmb3IgcHJvcCBgJyArIGxvd2VyQ2FzZU5hbWUgKyAnYCAtICcgKyAnZGlkIHlvdSBtZWFuIGAnICsgYXR0ciArICdgPyBIVE1MIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHJlbWVtYmVyIHRvIHVzZSAnICsgJ2tlYmFiLWNhc2UgZm9yIHByb3BzIGluIHRlbXBsYXRlcy4nLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogJyArIG5hbWUsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVzaCBwcm9wXG4gICAgcHJvcHMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gbWFrZVByb3BzTGlua0ZuKHByb3BzKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBwcm9wcyB0byBhIHZtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3BzTGlua0ZuKHZtLCBzY29wZSkge1xuICAgIC8vIHN0b3JlIHJlc29sdmVkIHByb3BzIGluZm9cbiAgICB2bS5fcHJvcHMgPSB7fTtcbiAgICB2YXIgaW5saW5lUHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgdmFyIHByb3AsIHBhdGgsIG9wdGlvbnMsIHZhbHVlLCByYXc7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgcmF3ID0gcHJvcC5yYXc7XG4gICAgICBwYXRoID0gcHJvcC5wYXRoO1xuICAgICAgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgICAgIHZtLl9wcm9wc1twYXRoXSA9IHByb3A7XG4gICAgICBpZiAoaW5saW5lUHJvcHMgJiYgaGFzT3duKGlubGluZVByb3BzLCBwYXRoKSkge1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgaW5saW5lUHJvcHNbcGF0aF0pO1xuICAgICAgfWlmIChyYXcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhYnNlbnQgcHJvcFxuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIC8vIGR5bmFtaWMgcHJvcFxuICAgICAgICBpZiAocHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLk9ORV9USU1FKSB7XG4gICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgIHZhbHVlID0gKHNjb3BlIHx8IHZtLl9jb250ZXh0IHx8IHZtKS4kZ2V0KHByb3AucGFyZW50UGF0aCk7XG4gICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodm0uX2NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYmluZGluZ1xuICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICBuYW1lOiAncHJvcCcsXG4gICAgICAgICAgICAgIGRlZjogcHJvcERlZixcbiAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgfSwgbnVsbCwgbnVsbCwgc2NvcGUpOyAvLyBlbCwgaG9zdCwgc2NvcGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByb290IGluc3RhbmNlXG4gICAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2bS4kZ2V0KHByb3AucGFyZW50UGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3Aub3B0aW1pemVkTGl0ZXJhbCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgbGl0ZXJhbCwgY2FzdCBpdCBhbmQganVzdCBzZXQgb25jZVxuICAgICAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhyYXcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmlwcGVkID09PSByYXcgPyB0b0Jvb2xlYW4odG9OdW1iZXIocmF3KSkgOiBzdHJpcHBlZDtcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZyBsaXRlcmFsLCBidXQgd2UgbmVlZCB0byBjYXRlciBmb3JcbiAgICAgICAgLy8gQm9vbGVhbiBwcm9wcyB3aXRoIG5vIHZhbHVlLCBvciB3aXRoIHNhbWVcbiAgICAgICAgLy8gbGl0ZXJhbCB2YWx1ZSAoZS5nLiBkaXNhYmxlZD1cImRpc2FibGVkXCIpXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWxvYWRlci9pc3N1ZXMvMTgyXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy50eXBlID09PSBCb29sZWFuICYmIChyYXcgPT09ICcnIHx8IHJhdyA9PT0gaHlwaGVuYXRlKHByb3AubmFtZSkpID8gdHJ1ZSA6IHJhdztcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHByb3Agd2l0aCBhIHJhd1ZhbHVlLCBhcHBseWluZyBuZWNlc3NhcnkgY29lcnNpb25zLFxuICogZGVmYXVsdCB2YWx1ZXMgJiBhc3NlcnRpb25zIGFuZCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayB3aXRoXG4gKiBwcm9jZXNzZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSByYXdWYWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCByYXdWYWx1ZSwgZm4pIHtcbiAgdmFyIGlzU2ltcGxlID0gcHJvcC5keW5hbWljICYmIGlzU2ltcGxlUGF0aChwcm9wLnBhcmVudFBhdGgpO1xuICB2YXIgdmFsdWUgPSByYXdWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApO1xuICB9XG4gIHZhbHVlID0gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pO1xuICB2YXIgY29lcmNlZCA9IHZhbHVlICE9PSByYXdWYWx1ZTtcbiAgaWYgKCFhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkpIHtcbiAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNTaW1wbGUgJiYgIWNvZXJjZWQpIHtcbiAgICB3aXRob3V0Q29udmVyc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBmbih2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm4odmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcCdzIGluaXRpYWwgdmFsdWUgb24gYSB2bSBhbmQgaXRzIGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCBwcm9wLnBhdGgsIHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgcHJvcCdzIHZhbHVlIG9uIGEgdm0uXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3Aodm0sIHByb3AsIHZhbHVlKSB7XG4gIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2bVtwcm9wLnBhdGhdID0gdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wKSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIGlmICghaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0JykpIHtcbiAgICAvLyBhYnNlbnQgYm9vbGVhbiB2YWx1ZSBkZWZhdWx0cyB0byBmYWxzZVxuICAgIHJldHVybiBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGVmID0gb3B0aW9uc1snZGVmYXVsdCddO1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiAnICsgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLnR5cGUgIT09IEZ1bmN0aW9uID8gZGVmLmNhbGwodm0pIDogZGVmO1xufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFwcm9wLm9wdGlvbnMucmVxdWlyZWQgJiYgKCAvLyBub24tcmVxdWlyZWRcbiAgcHJvcC5yYXcgPT09IG51bGwgfHwgLy8gYWJzY2VudFxuICB2YWx1ZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgdmFyIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicgKyAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChmb3JtYXRUeXBlKS5qb2luKCcsICcpICsgJywgZ290ICcgKyBmb3JtYXRWYWx1ZSh2YWx1ZSkgKyAnLicsIHZtKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIHByb3AubmFtZSArICdcIi4nLCB2bSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEZvcmNlIHBhcnNpbmcgdmFsdWUgd2l0aCBjb2VyY2Ugb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZVByb3AocHJvcCwgdmFsdWUsIHZtKSB7XG4gIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICBpZiAoIWNvZXJjZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBjb2VyY2UgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiOiBleHBlY3RlZCBmdW5jdGlvbiwgZ290ICcgKyB0eXBlb2YgY29lcmNlICsgJy4nLCB2bSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGU7XG4gIGlmICh0eXBlID09PSBTdHJpbmcpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnc3RyaW5nJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdudW1iZXInO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZ1bmN0aW9uKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJztcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IE9iamVjdCkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdvYmplY3QnO1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQXJyYXkpIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnYXJyYXknO1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdHlwZSBmb3Igb3V0cHV0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgPyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSA6ICdjdXN0b20gdHlwZSc7XG59XG5cbi8qKlxuICogRm9ybWF0IHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufVxuXG52YXIgYmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xuXG52YXIgcHJvcERlZiA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMudm07XG4gICAgdmFyIHBhcmVudCA9IGNoaWxkLl9jb250ZXh0O1xuICAgIC8vIHBhc3NlZCBpbiBmcm9tIGNvbXBpbGVyIGRpcmVjdGx5XG4gICAgdmFyIHByb3AgPSB0aGlzLmRlc2NyaXB0b3IucHJvcDtcbiAgICB2YXIgY2hpbGRLZXkgPSBwcm9wLnBhdGg7XG4gICAgdmFyIHBhcmVudEtleSA9IHByb3AucGFyZW50UGF0aDtcbiAgICB2YXIgdHdvV2F5ID0gcHJvcC5tb2RlID09PSBiaW5kaW5nTW9kZXMuVFdPX1dBWTtcblxuICAgIHZhciBwYXJlbnRXYXRjaGVyID0gdGhpcy5wYXJlbnRXYXRjaGVyID0gbmV3IFdhdGNoZXIocGFyZW50LCBwYXJlbnRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHVwZGF0ZVByb3AoY2hpbGQsIHByb3AsIHZhbCk7XG4gICAgfSwge1xuICAgICAgdHdvV2F5OiB0d29XYXksXG4gICAgICBmaWx0ZXJzOiBwcm9wLmZpbHRlcnMsXG4gICAgICAvLyBpbXBvcnRhbnQ6IHByb3BzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgb24gdGhlXG4gICAgICAvLyB2LWZvciBzY29wZSBpZiBwcmVzZW50XG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcblxuICAgIC8vIHNldCB0aGUgY2hpbGQgaW5pdGlhbCB2YWx1ZS5cbiAgICBpbml0UHJvcChjaGlsZCwgcHJvcCwgcGFyZW50V2F0Y2hlci52YWx1ZSk7XG5cbiAgICAvLyBzZXR1cCB0d28td2F5IGJpbmRpbmdcbiAgICBpZiAodHdvV2F5KSB7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGRlZmVyIHRoZSBjaGlsZCB3YXRjaGVyIGNyZWF0aW9uIHVudGlsXG4gICAgICAvLyB0aGUgY3JlYXRlZCBob29rIChhZnRlciBkYXRhIG9ic2VydmF0aW9uKVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgY2hpbGQuJG9uY2UoJ3ByZS1ob29rOmNyZWF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2hpbGRXYXRjaGVyID0gbmV3IFdhdGNoZXIoY2hpbGQsIGNoaWxkS2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcGFyZW50V2F0Y2hlci5zZXQodmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIC8vIGVuc3VyZSBzeW5jIHVwd2FyZCBiZWZvcmUgcGFyZW50IHN5bmMgZG93bi5cbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBpbiBjYXNlcyBlLmcuIHRoZSBjaGlsZFxuICAgICAgICAgIC8vIG11dGF0ZXMgYSBwcm9wIGFycmF5LCB0aGVuIHJlcGxhY2VzIGl0LiAoIzE2ODMpXG4gICAgICAgICAgc3luYzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnBhcmVudFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICBpZiAodGhpcy5jaGlsZFdhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2hpbGRXYXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUkMSA9IFtdO1xudmFyIHF1ZXVlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFB1c2ggYSBqb2IgaW50byB0aGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gam9iXG4gKi9cblxuZnVuY3Rpb24gcHVzaEpvYihqb2IpIHtcbiAgcXVldWUkMS5wdXNoKGpvYik7XG4gIGlmICghcXVldWVkKSB7XG4gICAgcXVldWVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhmbHVzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCB0aGUgcXVldWUsIGFuZCBkbyBvbmUgZm9yY2VkIHJlZmxvdyBiZWZvcmVcbiAqIHRyaWdnZXJpbmcgdHJhbnNpdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIC8vIEZvcmNlIGxheW91dFxuICB2YXIgZiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUkMS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlJDFbaV0oKTtcbiAgfVxuICBxdWV1ZSQxID0gW107XG4gIHF1ZXVlZCA9IGZhbHNlO1xuICAvLyBkdW1teSByZXR1cm4sIHNvIGpzIGxpbnRlcnMgZG9uJ3QgY29tcGxhaW4gYWJvdXRcbiAgLy8gdW51c2VkIHZhcmlhYmxlIGZcbiAgcmV0dXJuIGY7XG59XG5cbnZhciBUWVBFX1RSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgVFlQRV9BTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbnZhciB0cmFuc0R1cmF0aW9uUHJvcCA9IHRyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcbnZhciBhbmltRHVyYXRpb25Qcm9wID0gYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbic7XG5cbi8qKlxuICogSWYgYSBqdXN0LWVudGVyZWQgZWxlbWVudCBpcyBhcHBsaWVkIHRoZVxuICogbGVhdmUgY2xhc3Mgd2hpbGUgaXRzIGVudGVyIHRyYW5zaXRpb24gaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICogYW5kIHRoZSB0cmFuc2l0aW9uZWQgcHJvcGVydHkgaGFzIHRoZSBzYW1lIHZhbHVlIGZvciBib3RoXG4gKiBlbnRlci9sZWF2ZSwgdGhlbiB0aGUgbGVhdmUgdHJhbnNpdGlvbiB3aWxsIGJlIHNraXBwZWQgYW5kXG4gKiB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gVGhpcyBmdW5jdGlvbiBlbnN1cmVzXG4gKiBpdHMgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIGEgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZFxuICogYnkgd2FpdGluZyBmb3IgZG91YmxlIHJhZi5cbiAqXG4gKiBJdCBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQgb24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgQ1NTXG4gKiB0cmFuc2l0aW9ucyBidXQgbm90IHJhZiAoZS5nLiBBbmRyb2lkIDQuMiBicm93c2VyKSAtIHNpbmNlXG4gKiB0aGVzZSBlbnZpcm9ubWVudHMgYXJlIHVzdWFsbHkgc2xvdywgd2UgYXJlIGdpdmluZyBpdCBhXG4gKiByZWxhdGl2ZWx5IGxhcmdlIHRpbWVvdXQuXG4gKi9cblxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQgPSByYWZcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4/IGZ1bmN0aW9uIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICBzZXRUaW1lb3V0KGZuLCA1MCk7XG59O1xuXG4vKipcbiAqIEEgVHJhbnNpdGlvbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIGFuZCBsb2dpY1xuICogb2YgdGhlIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHZtKSB7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLmVudGVyQ2xhc3MgPSBob29rcyAmJiBob29rcy5lbnRlckNsYXNzIHx8IGlkICsgJy1lbnRlcic7XG4gIHRoaXMubGVhdmVDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmxlYXZlQ2xhc3MgfHwgaWQgKyAnLWxlYXZlJztcbiAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICB0aGlzLnZtID0gdm07XG4gIC8vIGFzeW5jIHN0YXRlXG4gIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHRoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5lbnRlcmVkID0gdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMudHlwZUNhY2hlID0ge307XG4gIC8vIGNoZWNrIGNzcyB0cmFuc2l0aW9uIHR5cGVcbiAgdGhpcy50eXBlID0gaG9va3MgJiYgaG9va3MudHlwZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgIT09IFRZUEVfVFJBTlNJVElPTiAmJiB0aGlzLnR5cGUgIT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB3YXJuKCdpbnZhbGlkIENTUyB0cmFuc2l0aW9uIHR5cGUgZm9yIHRyYW5zaXRpb249XCInICsgdGhpcy5pZCArICdcIjogJyArIHRoaXMudHlwZSwgdm0pO1xuICAgIH1cbiAgfVxuICAvLyBiaW5kXG4gIHZhciBzZWxmID0gdGhpcztbJ2VudGVyTmV4dFRpY2snLCAnZW50ZXJEb25lJywgJ2xlYXZlTmV4dFRpY2snLCAnbGVhdmVEb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbbV0gPSBiaW5kKHNlbGZbbV0sIHNlbGYpO1xuICB9KTtcbn1cblxudmFyIHAkMSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gZW50ZXIgdHJhbnNpdGlvbiB0cmlnZ2VyZWRcbiAqIDIuIGNhbGwgYmVmb3JlRW50ZXIgaG9va1xuICogMy4gYWRkIGVudGVyIGNsYXNzXG4gKiA0LiBpbnNlcnQvc2hvdyBlbGVtZW50XG4gKiA1LiBjYWxsIGVudGVyIGhvb2sgKHdpdGggcG9zc2libGUgZXhwbGljaXQganMgY2FsbGJhY2spXG4gKiA2LiByZWZsb3dcbiAqIDcuIGJhc2VkIG9uIHRyYW5zaXRpb24gdHlwZTpcbiAqICAgIC0gdHJhbnNpdGlvbjpcbiAqICAgICAgICByZW1vdmUgY2xhc3Mgbm93LCB3YWl0IGZvciB0cmFuc2l0aW9uZW5kLFxuICogICAgICAgIHRoZW4gZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBhbmltYXRpb246XG4gKiAgICAgICAgd2FpdCBmb3IgYW5pbWF0aW9uZW5kLCByZW1vdmUgY2xhc3MsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIG5vIGNzcyB0cmFuc2l0aW9uOlxuICogICAgICAgIGRvbmUgbm93IGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA4LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckVudGVyIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSBpbnNlcnQvc2hvdyB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5lbnRlciA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUVudGVyJyk7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgb3AoKTtcbiAgdGhpcy5lbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2VudGVyJyk7XG4gIGlmICh0aGlzLmVudGVyZWQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5lbnRlckNhbmNlbGxlZDtcbiAgcHVzaEpvYih0aGlzLmVudGVyTmV4dFRpY2spO1xufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24sIHdoaWNoIGlzXG4gKiB0byBiZSBwdXNoZWQgaW50byBhIHF1ZXVlIGFuZCBleGVjdXRlZCBhZnRlciBhIHJlZmxvdyBzb1xuICogdGhhdCByZW1vdmluZyB0aGUgY2xhc3MgY2FuIHRyaWdnZXIgYSBDU1MgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuZW50ZXJOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICAvLyBwcmV2ZW50IHRyYW5zaXRpb24gc2tpcHBpbmdcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IHRydWU7XG4gIHdhaXRGb3JUcmFuc2l0aW9uU3RhcnQoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIH0pO1xuICB2YXIgZW50ZXJEb25lID0gdGhpcy5lbnRlckRvbmU7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRDc3NUcmFuc2l0aW9uVHlwZSh0aGlzLmVudGVyQ2xhc3MpO1xuICBpZiAoIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICBpZiAodHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OKSB7XG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gYnkgcmVtb3ZpbmcgZW50ZXIgY2xhc3Mgbm93XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgICAgdGhpcy5zZXR1cENzc0NiKHRyYW5zaXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfQU5JTUFUSU9OKSB7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IoYW5pbWF0aW9uRW5kRXZlbnQsIGVudGVyRG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyRG9uZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhbiBlbnRlcmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlckRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW50ZXJlZCA9IHRydWU7XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyRW50ZXInKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKlxuICogMS4gbGVhdmUgdHJhbnNpdGlvbiB0cmlnZ2VyZWQuXG4gKiAyLiBjYWxsIGJlZm9yZUxlYXZlIGhvb2tcbiAqIDMuIGFkZCBsZWF2ZSBjbGFzcyAodHJpZ2dlciBjc3MgdHJhbnNpdGlvbilcbiAqIDQuIGNhbGwgbGVhdmUgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDUuIHJlZmxvdyBpZiBubyBleHBsaWNpdCBqcyBjYWxsYmFjayBpcyBwcm92aWRlZFxuICogNi4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBlbmQgZXZlbnQsIHJlbW92ZSBjbGFzcywgdGhlbiBkb25lIGlmXG4gKiAgICAgICAgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBpZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogNy4gd2FpdCBmb3IgZWl0aGVyIGRvbmUgb3IganMgY2FsbGJhY2ssIHRoZW4gY2FsbFxuICogICAgYWZ0ZXJMZWF2ZSBob29rLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gcmVtb3ZlL2hpZGUgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5wJDEubGVhdmUgPSBmdW5jdGlvbiAob3AsIGNiKSB7XG4gIHRoaXMuY2FuY2VsUGVuZGluZygpO1xuICB0aGlzLmNhbGxIb29rKCdiZWZvcmVMZWF2ZScpO1xuICB0aGlzLm9wID0gb3A7XG4gIHRoaXMuY2IgPSBjYjtcbiAgYWRkQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgdGhpcy5sZWZ0ID0gZmFsc2U7XG4gIHRoaXMuY2FsbEhvb2tXaXRoQ2IoJ2xlYXZlJyk7XG4gIGlmICh0aGlzLmxlZnQpIHtcbiAgICByZXR1cm47IC8vIHVzZXIgY2FsbGVkIGRvbmUgc3luY2hyb25vdXNseS5cbiAgfVxuICB0aGlzLmNhbmNlbCA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5sZWF2ZUNhbmNlbGxlZDtcbiAgLy8gb25seSBuZWVkIHRvIGhhbmRsZSBsZWF2ZURvbmUgaWZcbiAgLy8gMS4gdGhlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBkb25lIChzeW5jaHJvbm91c2x5IGNhbGxlZFxuICAvLyAgICBieSB0aGUgdXNlciwgd2hpY2ggY2F1c2VzIHRoaXMub3Agc2V0IHRvIG51bGwpXG4gIC8vIDIuIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2tcbiAgaWYgKHRoaXMub3AgJiYgIXRoaXMucGVuZGluZ0pzQ2IpIHtcbiAgICAvLyBpZiBhIENTUyB0cmFuc2l0aW9uIGxlYXZlcyBpbW1lZGlhdGVseSBhZnRlciBlbnRlcixcbiAgICAvLyB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCBuZXZlciBmaXJlcy4gdGhlcmVmb3JlIHdlXG4gICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGVuZCB0aGUgbGVhdmUgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHRoaXMuanVzdEVudGVyZWQpIHtcbiAgICAgIHRoaXMubGVhdmVEb25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hKb2IodGhpcy5sZWF2ZU5leHRUaWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwibmV4dFRpY2tcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMubGVhdmVDbGFzcyk7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFlQRV9UUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgdGhpcy5zZXR1cENzc0NiKGV2ZW50LCB0aGlzLmxlYXZlRG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJjbGVhbnVwXCIgcGhhc2Ugb2YgYSBsZWF2aW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmxlYXZlRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZWZ0ID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgdGhpcy5vcCgpO1xuICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmNhbGxIb29rKCdhZnRlckxlYXZlJyk7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKCk7XG4gIHRoaXMub3AgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYW55IHBlbmRpbmcgY2FsbGJhY2tzIGZyb20gYSBwcmV2aW91c2x5IHJ1bm5pbmdcbiAqIGJ1dCBub3QgZmluaXNoZWQgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEuY2FuY2VsUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB2YXIgaGFzUGVuZGluZyA9IGZhbHNlO1xuICBpZiAodGhpcy5wZW5kaW5nQ3NzQ2IpIHtcbiAgICBoYXNQZW5kaW5nID0gdHJ1ZTtcbiAgICBvZmYodGhpcy5lbCwgdGhpcy5wZW5kaW5nQ3NzRXZlbnQsIHRoaXMucGVuZGluZ0Nzc0NiKTtcbiAgICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ0pzQ2IuY2FuY2VsKCk7XG4gICAgdGhpcy5wZW5kaW5nSnNDYiA9IG51bGw7XG4gIH1cbiAgaWYgKGhhc1BlbmRpbmcpIHtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIH1cbiAgaWYgKHRoaXMuY2FuY2VsKSB7XG4gICAgdGhpcy5jYW5jZWwuY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB0aGlzLmNhbmNlbCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQgc3luY2hyb25vdXMgaG9vayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5cbnAkMS5jYWxsSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV0pIHtcbiAgICB0aGlzLmhvb2tzW3R5cGVdLmNhbGwodGhpcy52bSwgdGhpcy5lbCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIHVzZXItcHJvdmlkZWQsIHBvdGVudGlhbGx5LWFzeW5jIGhvb2sgZnVuY3Rpb24uXG4gKiBXZSBjaGVjayBmb3IgdGhlIGxlbmd0aCBvZiBhcmd1bWVudHMgdG8gc2VlIGlmIHRoZSBob29rXG4gKiBleHBlY3RzIGEgYGRvbmVgIGNhbGxiYWNrLiBJZiB0cnVlLCB0aGUgdHJhbnNpdGlvbidzIGVuZFxuICogd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHdoZW4gdGhlIHVzZXIgY2FsbHMgdGhhdCBjYWxsYmFjaztcbiAqIG90aGVyd2lzZSwgdGhlIGVuZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDU1MgdHJhbnNpdGlvbiBvclxuICogYW5pbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rV2l0aENiID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGhvb2sgPSB0aGlzLmhvb2tzICYmIHRoaXMuaG9va3NbdHlwZV07XG4gIGlmIChob29rKSB7XG4gICAgaWYgKGhvb2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wZW5kaW5nSnNDYiA9IGNhbmNlbGxhYmxlKHRoaXNbdHlwZSArICdEb25lJ10pO1xuICAgIH1cbiAgICBob29rLmNhbGwodGhpcy52bSwgdGhpcy5lbCwgdGhpcy5wZW5kaW5nSnNDYik7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyB0cmFuc2l0aW9uIHR5cGUgYmFzZWQgb24gdGhlXG4gKiBjYWxjdWxhdGVkIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxucCQxLmdldENzc1RyYW5zaXRpb25UeXBlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCBDU1MgdHJhbnNpdGlvbnMgaWYgcGFnZSBpcyBub3QgdmlzaWJsZSAtXG4gIC8vIHRoaXMgc29sdmVzIHRoZSBpc3N1ZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50cyBub3RcbiAgLy8gZmlyaW5nIHVudGlsIHRoZSBwYWdlIGlzIHZpc2libGUgYWdhaW4uXG4gIC8vIHBhZ2VWaXNpYmlsaXR5IEFQSSBpcyBzdXBwb3J0ZWQgaW4gSUUxMCssIHNhbWUgYXNcbiAgLy8gQ1NTIHRyYW5zaXRpb25zLlxuICBkb2N1bWVudC5oaWRkZW4gfHxcbiAgLy8gZXhwbGljaXQganMtb25seSB0cmFuc2l0aW9uXG4gIHRoaXMuaG9va3MgJiYgdGhpcy5ob29rcy5jc3MgPT09IGZhbHNlIHx8XG4gIC8vIGVsZW1lbnQgaXMgaGlkZGVuXG4gIGlzSGlkZGVuKHRoaXMuZWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0eXBlID0gdGhpcy50eXBlIHx8IHRoaXMudHlwZUNhY2hlW2NsYXNzTmFtZV07XG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZTtcbiAgdmFyIGlubGluZVN0eWxlcyA9IHRoaXMuZWwuc3R5bGU7XG4gIHZhciBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpO1xuICB2YXIgdHJhbnNEdXJhdGlvbiA9IGlubGluZVN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbdHJhbnNEdXJhdGlvblByb3BdO1xuICBpZiAodHJhbnNEdXJhdGlvbiAmJiB0cmFuc0R1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgdHlwZSA9IFRZUEVfVFJBTlNJVElPTjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5pbUR1cmF0aW9uID0gaW5saW5lU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdIHx8IGNvbXB1dGVkU3R5bGVzW2FuaW1EdXJhdGlvblByb3BdO1xuICAgIGlmIChhbmltRHVyYXRpb24gJiYgYW5pbUR1cmF0aW9uICE9PSAnMHMnKSB7XG4gICAgICB0eXBlID0gVFlQRV9BTklNQVRJT047XG4gICAgfVxuICB9XG4gIGlmICh0eXBlKSB7XG4gICAgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXSA9IHR5cGU7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIFNldHVwIGEgQ1NTIHRyYW5zaXRpb25lbmQvYW5pbWF0aW9uZW5kIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5wJDEuc2V0dXBDc3NDYiA9IGZ1bmN0aW9uIChldmVudCwgY2IpIHtcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSBldmVudDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWwgPSB0aGlzLmVsO1xuICB2YXIgb25FbmQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgb2ZmKGVsLCBldmVudCwgb25FbmQpO1xuICAgICAgc2VsZi5wZW5kaW5nQ3NzRXZlbnQgPSBzZWxmLnBlbmRpbmdDc3NDYiA9IG51bGw7XG4gICAgICBpZiAoIXNlbGYucGVuZGluZ0pzQ2IgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG9uKGVsLCBldmVudCwgb25FbmQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGhpZGRlbiAtIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdFxuICogc2tpcCB0aGUgdHJhbnNpdGlvbiBhbGx0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlkZGVuKGVsKSB7XG4gIGlmICgvc3ZnJC8udGVzdChlbC5uYW1lc3BhY2VVUkkpKSB7XG4gICAgLy8gU1ZHIGVsZW1lbnRzIGRvIG5vdCBoYXZlIG9mZnNldChXaWR0aHxIZWlnaHQpXG4gICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0aGUgY2xpZW50IHJlY3RcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiAhKHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24kMSA9IHtcblxuICBwcmlvcml0eTogVFJBTlNJVElPTixcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShpZCwgb2xkSWQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3RyYW5zaXRpb25zJywgaWQpO1xuICAgIGlkID0gaWQgfHwgJ3YnO1xuICAgIG9sZElkID0gb2xkSWQgfHwgJ3YnO1xuICAgIGVsLl9fdl90cmFucyA9IG5ldyBUcmFuc2l0aW9uKGVsLCBpZCwgaG9va3MsIHRoaXMudm0pO1xuICAgIHJlbW92ZUNsYXNzKGVsLCBvbGRJZCArICctdHJhbnNpdGlvbicpO1xuICAgIGFkZENsYXNzKGVsLCBpZCArICctdHJhbnNpdGlvbicpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0ge1xuICBzdHlsZTogc3R5bGUsXG4gICdjbGFzcyc6IHZDbGFzcyxcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIHByb3A6IHByb3BEZWYsXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb24kMVxufTtcblxuLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG52YXIgYmluZFJFID0gL152LWJpbmQ6fF46LztcbnZhciBvblJFID0gL152LW9uOnxeQC87XG52YXIgZGlyQXR0clJFID0gL152LShbXjpdKykoPzokfDooLiopJCkvO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nO1xudmFyIHRyYW5zaXRpb25SRSA9IC9eKHYtYmluZDp8Oik/dHJhbnNpdGlvbiQvO1xuXG4vLyBkZWZhdWx0IGRpcmVjdGl2ZSBwcmlvcml0eVxudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAxMDAwO1xudmFyIERFRkFVTFRfVEVSTUlOQUxfUFJJT1JJVFkgPSAyMDAwO1xuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgcmV1c2FibGUgY29tcG9zaXRlIGxpbmtcbiAqIGZ1bmN0aW9uLCB3aGljaCByZWN1cnNpdmVseSBjb250YWlucyBtb3JlIGxpbmsgZnVuY3Rpb25zXG4gKiBpbnNpZGUuIFRoaXMgdG9wIGxldmVsIGNvbXBpbGUgZnVuY3Rpb24gd291bGQgbm9ybWFsbHlcbiAqIGJlIGNhbGxlZCBvbiBpbnN0YW5jZSByb290IG5vZGVzLCBidXQgY2FuIGFsc28gYmUgdXNlZFxuICogZm9yIHBhcnRpYWwgY29tcGlsYXRpb24gaWYgdGhlIHBhcnRpYWwgYXJndW1lbnQgaXMgdHJ1ZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY29tcG9zaXRlIGxpbmsgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsXG4gKiByZXR1cm4gYW4gdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzXG4gKiBjcmVhdGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcnRpYWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUoZWwsIG9wdGlvbnMsIHBhcnRpYWwpIHtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgaXRzZWxmLlxuICB2YXIgbm9kZUxpbmtGbiA9IHBhcnRpYWwgfHwgIW9wdGlvbnMuX2FzQ29tcG9uZW50ID8gY29tcGlsZU5vZGUoZWwsIG9wdGlvbnMpIDogbnVsbDtcbiAgLy8gbGluayBmdW5jdGlvbiBmb3IgdGhlIGNoaWxkTm9kZXNcbiAgdmFyIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmICFpc1NjcmlwdChlbCkgJiYgZWwuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KGVsLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcblxuICAvKipcbiAgICogQSBjb21wb3NpdGUgbGlua2VyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGFscmVhZHlcbiAgICogY29tcGlsZWQgcGllY2Ugb2YgRE9NLCB3aGljaCBpbnN0YW50aWF0ZXMgYWxsIGRpcmVjdGl2ZVxuICAgKiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIGhvc3Qgdm0gb2YgdHJhbnNjbHVkZWQgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIGxpbmsgY29udGV4dCBmcmFnbWVudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NpdGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShlbC5jaGlsZE5vZGVzKTtcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIoKSB7XG4gICAgICBpZiAobm9kZUxpbmtGbikgbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9LCB2bSk7XG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgZGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5rZXIgdG8gYSB2bS9lbGVtZW50IHBhaXIgYW5kIGNhcHR1cmUgdGhlXG4gKiBkaXJlY3RpdmVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gbGlua0FuZENhcHR1cmUobGlua2VyLCB2bSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyByZXNldCBkaXJlY3RpdmVzIGJlZm9yZSBldmVyeSBjYXB0dXJlIGluIHByb2R1Y3Rpb25cbiAgICAvLyBtb2RlLCBzbyB0aGF0IHdoZW4gdW5saW5raW5nIHdlIGRvbid0IG5lZWQgdG8gc3BsaWNlXG4gICAgLy8gdGhlbSBvdXQgKHdoaWNoIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgaGl0KS5cbiAgICAvLyB0aGV5IGFyZSBrZXB0IGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSB0aGV5IGFyZVxuICAgIC8vIHVzZWZ1bCBmb3IgVnVlJ3Mgb3duIHRlc3RzLlxuICAgIHZtLl9kaXJlY3RpdmVzID0gW107XG4gIH1cbiAgdmFyIG9yaWdpbmFsRGlyQ291bnQgPSB2bS5fZGlyZWN0aXZlcy5sZW5ndGg7XG4gIGxpbmtlcigpO1xuICB2YXIgZGlycyA9IHZtLl9kaXJlY3RpdmVzLnNsaWNlKG9yaWdpbmFsRGlyQ291bnQpO1xuICBkaXJzLnNvcnQoZGlyZWN0aXZlQ29tcGFyYXRvcik7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXJzW2ldLl9iaW5kKCk7XG4gIH1cbiAgcmV0dXJuIGRpcnM7XG59XG5cbi8qKlxuICogRGlyZWN0aXZlIHByaW9yaXR5IHNvcnQgY29tcGFyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICovXG5cbmZ1bmN0aW9uIGRpcmVjdGl2ZUNvbXBhcmF0b3IoYSwgYikge1xuICBhID0gYS5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICBiID0gYi5kZXNjcmlwdG9yLmRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1BSSU9SSVRZO1xuICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuLyoqXG4gKiBMaW5rZXIgZnVuY3Rpb25zIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdFxuICogdGVhcnNkb3duIGFsbCBkaXJlY3RpdmVzIGluc3RhbmNlcyBnZW5lcmF0ZWQgZHVyaW5nXG4gKiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBXZSBjcmVhdGUgdW5saW5rIGZ1bmN0aW9ucyB3aXRoIG9ubHkgdGhlIG5lY2Vzc2FyeVxuICogaW5mb3JtYXRpb24gdG8gYXZvaWQgcmV0YWluaW5nIGFkZGl0aW9uYWwgY2xvc3VyZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge1Z1ZX0gW2NvbnRleHRdXG4gKiBAcGFyYW0ge0FycmF5fSBbY29udGV4dERpcnNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVW5saW5rRm4odm0sIGRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKSB7XG4gIGZ1bmN0aW9uIHVubGluayhkZXN0cm95aW5nKSB7XG4gICAgdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0RGlycykge1xuICAgICAgdGVhcmRvd25EaXJzKGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIGxpbmtlZCBkaXJlY3RpdmVzXG4gIHVubGluay5kaXJzID0gZGlycztcbiAgcmV0dXJuIHVubGluaztcbn1cblxuLyoqXG4gKiBUZWFyZG93biBwYXJ0aWFsIGxpbmtlZCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtBcnJheX0gZGlyc1xuICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95aW5nXG4gKi9cblxuZnVuY3Rpb24gdGVhcmRvd25EaXJzKHZtLCBkaXJzLCBkZXN0cm95aW5nKSB7XG4gIHZhciBpID0gZGlycy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBkaXJzW2ldLl90ZWFyZG93bigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkZXN0cm95aW5nKSB7XG4gICAgICB2bS5fZGlyZWN0aXZlcy4kcmVtb3ZlKGRpcnNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMaW5rUHJvcHModm0sIGVsLCBwcm9wcywgc2NvcGUpIHtcbiAgdmFyIHByb3BzTGlua0ZuID0gY29tcGlsZVByb3BzKGVsLCBwcm9wcywgdm0pO1xuICB2YXIgcHJvcERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHNMaW5rRm4odm0sIHNjb3BlKTtcbiAgfSwgdm0pO1xuICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBwcm9wRGlycyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgcm9vdCBlbGVtZW50IG9mIGFuIGluc3RhbmNlLlxuICpcbiAqIDEuIGF0dHJzIG9uIGNvbnRleHQgY29udGFpbmVyIChjb250ZXh0IHNjb3BlKVxuICogMi4gYXR0cnMgb24gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSByb290IG5vZGUsIGlmXG4gKiAgICByZXBsYWNlOnRydWUgKGNoaWxkIHNjb3BlKVxuICpcbiAqIElmIHRoaXMgaXMgYSBmcmFnbWVudCBpbnN0YW5jZSwgd2Ugb25seSBuZWVkIHRvIGNvbXBpbGUgMS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fY29udGFpbmVyQXR0cnM7XG4gIHZhciByZXBsYWNlckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycztcbiAgdmFyIGNvbnRleHRMaW5rRm4sIHJlcGxhY2VyTGlua0ZuO1xuXG4gIC8vIG9ubHkgbmVlZCB0byBjb21waWxlIG90aGVyIGF0dHJpYnV0ZXMgZm9yXG4gIC8vIG5vbi1mcmFnbWVudCBpbnN0YW5jZXNcbiAgaWYgKGVsLm5vZGVUeXBlICE9PSAxMSkge1xuICAgIC8vIGZvciBjb21wb25lbnRzLCBjb250YWluZXIgYW5kIHJlcGxhY2VyIG5lZWQgdG8gYmVcbiAgICAvLyBjb21waWxlZCBzZXBhcmF0ZWx5IGFuZCBsaW5rZWQgaW4gZGlmZmVyZW50IHNjb3Blcy5cbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIC8vIDIuIGNvbnRhaW5lciBhdHRyaWJ1dGVzXG4gICAgICBpZiAoY29udGFpbmVyQXR0cnMgJiYgY29udGV4dE9wdGlvbnMpIHtcbiAgICAgICAgY29udGV4dExpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGNvbnRhaW5lckF0dHJzLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXJBdHRycykge1xuICAgICAgICAvLyAzLiByZXBsYWNlciBhdHRyaWJ1dGVzXG4gICAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMocmVwbGFjZXJBdHRycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vbi1jb21wb25lbnQsIGp1c3QgY29tcGlsZSBhcyBhIG5vcm1hbCBlbGVtZW50LlxuICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb250YWluZXJBdHRycykge1xuICAgIC8vIHdhcm4gY29udGFpbmVyIGRpcmVjdGl2ZXMgZm9yIGZyYWdtZW50IGluc3RhbmNlc1xuICAgIHZhciBuYW1lcyA9IGNvbnRhaW5lckF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gYWxsb3cgdnVlLWxvYWRlci92dWVpZnkgc2NvcGVkIGNzcyBhdHRyaWJ1dGVzXG4gICAgICByZXR1cm4gYXR0ci5uYW1lLmluZGV4T2YoJ192LScpIDwgMCAmJlxuICAgICAgLy8gYWxsb3cgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAhb25SRS50ZXN0KGF0dHIubmFtZSkgJiZcbiAgICAgIC8vIGFsbG93IHNsb3RzXG4gICAgICBhdHRyLm5hbWUgIT09ICdzbG90JztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiAnXCInICsgYXR0ci5uYW1lICsgJ1wiJztcbiAgICB9KTtcbiAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgcGx1cmFsID0gbmFtZXMubGVuZ3RoID4gMTtcbiAgICAgIHdhcm4oJ0F0dHJpYnV0ZScgKyAocGx1cmFsID8gJ3MgJyA6ICcgJykgKyBuYW1lcy5qb2luKCcsICcpICsgKHBsdXJhbCA/ICcgYXJlJyA6ICcgaXMnKSArICcgaWdub3JlZCBvbiBjb21wb25lbnQgJyArICc8JyArIG9wdGlvbnMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4gYmVjYXVzZSAnICsgJ3RoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudCBpbnN0YW5jZTogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNGcmFnbWVudC1JbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gb3B0aW9ucy5fcmVwbGFjZXJBdHRycyA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiByb290TGlua0ZuKHZtLCBlbCwgc2NvcGUpIHtcbiAgICAvLyBsaW5rIGNvbnRleHQgc2NvcGUgZGlyc1xuICAgIHZhciBjb250ZXh0ID0gdm0uX2NvbnRleHQ7XG4gICAgdmFyIGNvbnRleHREaXJzO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHRMaW5rRm4pIHtcbiAgICAgIGNvbnRleHREaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0TGlua0ZuKGNvbnRleHQsIGVsLCBudWxsLCBzY29wZSk7XG4gICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBsaW5rIHNlbGZcbiAgICB2YXIgc2VsZkRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVwbGFjZXJMaW5rRm4pIHJlcGxhY2VyTGlua0ZuKHZtLCBlbCk7XG4gICAgfSwgdm0pO1xuXG4gICAgLy8gcmV0dXJuIHRoZSB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gY29udGV4dFxuICAgIC8vIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHNlbGZEaXJzLCBjb250ZXh0LCBjb250ZXh0RGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4gYmFzZWQgb24gdGhlXG4gKiBub2RlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgaWYgKHR5cGUgPT09IDEgJiYgIWlzU2NyaXB0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVFbGVtZW50KG5vZGUsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgJiYgbm9kZS5kYXRhLnRyaW0oKSkge1xuICAgIHJldHVybiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21waWxlIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIG5vZGVMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUVsZW1lbnQoZWwsIG9wdGlvbnMpIHtcbiAgLy8gcHJlcHJvY2VzcyB0ZXh0YXJlYXMuXG4gIC8vIHRleHRhcmVhIHRyZWF0cyBpdHMgdGV4dCBjb250ZW50IGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAvLyBqdXN0IGJpbmQgaXQgYXMgYW4gYXR0ciBkaXJlY3RpdmUgZm9yIHZhbHVlLlxuICBpZiAoZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQoZWwudmFsdWUpO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnOnZhbHVlJywgdG9rZW5zVG9FeHAodG9rZW5zKSk7XG4gICAgICBlbC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxuICB2YXIgbGlua0ZuO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIHZhciBhdHRycyA9IGhhc0F0dHJzICYmIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIC8vIGNoZWNrIHRlcm1pbmFsIGRpcmVjdGl2ZXMgKGZvciAmIGlmKVxuICBpZiAoaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjaGVja1Rlcm1pbmFsRGlyZWN0aXZlcyhlbCwgYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGVsZW1lbnQgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIGNoZWNrIGNvbXBvbmVudFxuICBpZiAoIWxpbmtGbikge1xuICAgIGxpbmtGbiA9IGNoZWNrQ29tcG9uZW50KGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICBpZiAoIWxpbmtGbiAmJiBoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbGlua0ZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZXh0Tm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucykge1xuICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gIGlmIChub2RlLl9za2lwKSB7XG4gICAgcmV0dXJuIHJlbW92ZVRleHQ7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KG5vZGUud2hvbGVUZXh0KTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG1hcmsgYWRqYWNlbnQgdGV4dCBub2RlcyBhcyBza2lwcGVkLFxuICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gIC8vIGFsbCBhZGphY2VudCB0ZXh0IG5vZGVzIHRvZ2V0aGVyLiBUaGlzIGZpeGVzXG4gIC8vIGlzc3VlcyBpbiBJRSB3aGVyZSBzb21ldGltZXMgaXQgc3BsaXRzIHVwIGEgc2luZ2xlXG4gIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gMykge1xuICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBlbCwgdG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGVsID0gdG9rZW4udGFnID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtlciBmb3IgYW4gc2tpcHBlZCB0ZXh0IG5vZGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gIHJlbW92ZShub2RlKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSB7XG4gIHZhciBlbDtcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd2LWh0bWwnKTtcbiAgICAgIHNldFRva2VuVHlwZSgnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VG9rZW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh0b2tlbi52YWx1ZSk7XG4gICAgdG9rZW4uZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBkZWY6IGRpcmVjdGl2ZXNbdHlwZV0sXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdG9rZW5zXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgdmFyIGZyYWdDbG9uZSA9IGZyYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShmcmFnQ2xvbmUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGlmICh0b2tlbi50YWcpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZtLl9iaW5kRGlyKHRva2VuLmRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGVsLCBmcmFnQ2xvbmUpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGxpc3QgYW5kIHJldHVybiBhIGNoaWxkTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdChub2RlTGlzdCwgb3B0aW9ucykge1xuICB2YXIgbGlua0ZucyA9IFtdO1xuICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgIG5vZGVMaW5rRm4gPSBjb21waWxlTm9kZShub2RlLCBvcHRpb25zKTtcbiAgICBjaGlsZExpbmtGbiA9ICEobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsKSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIG5vZGUuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KG5vZGUuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuICAgIGxpbmtGbnMucHVzaChub2RlTGlua0ZuLCBjaGlsZExpbmtGbik7XG4gIH1cbiAgcmV0dXJuIGxpbmtGbnMubGVuZ3RoID8gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2hpbGQgbGluayBmdW5jdGlvbiBmb3IgYSBub2RlJ3MgY2hpbGROb2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gbGlua0Zuc1xuICogQHJldHVybiB7RnVuY3Rpb259IGNoaWxkTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZUNoaWxkTGlua0ZuKGxpbmtGbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoaWxkTGlua0ZuKHZtLCBub2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB2YXIgbm9kZSwgbm9kZUxpbmtGbiwgY2hpbGRyZW5MaW5rRm47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSAwLCBsID0gbGlua0Zucy5sZW5ndGg7IGkgPCBsOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIG5vZGVMaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICBjaGlsZHJlbkxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICBub2RlTGlua0ZuKHZtLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRyZW5MaW5rRm4pIHtcbiAgICAgICAgY2hpbGRyZW5MaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGVsZW1lbnQgZGlyZWN0aXZlcyAoY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2hvdWxkXG4gKiBiZSByZXNvdmxlZCBhcyB0ZXJtaW5hbCBkaXJlY3RpdmVzKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGNoZWNrRWxlbWVudERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGNvbW1vblRhZ1JFLnRlc3QodGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZyk7XG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQuIElmIHllcywgcmV0dXJuXG4gKiBhIGNvbXBvbmVudCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucyk7XG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgcmVmID0gZmluZFJlZihlbCk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudExpbmtGbiA9IGZ1bmN0aW9uIGNvbXBvbmVudExpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIHJlZiwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH07XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgICByZXR1cm4gY29tcG9uZW50TGlua0ZuO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYW4gZWxlbWVudCBmb3IgdGVybWluYWwgZGlyZWN0aXZlcyBpbiBmaXhlZCBvcmRlci5cbiAqIElmIGl0IGZpbmRzIG9uZSwgcmV0dXJuIGEgdGVybWluYWwgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5fSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucykge1xuICAvLyBza2lwIHYtcHJlXG4gIGlmIChnZXRBdHRyKGVsLCAndi1wcmUnKSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBza2lwO1xuICB9XG4gIC8vIHNraXAgdi1lbHNlIGJsb2NrLCBidXQgb25seSBpZiBmb2xsb3dpbmcgdi1pZlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd2LWVsc2UnKSkge1xuICAgIHZhciBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBpZiAocHJldiAmJiBwcmV2Lmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICByZXR1cm4gc2tpcDtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgbWF0Y2hlZCwgZGlyTmFtZSwgcmF3TmFtZSwgYXJnLCBkZWYsIHRlcm1EZWY7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gYXR0cnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgaWYgKG1hdGNoZWQgPSBuYW1lLm1hdGNoKGRpckF0dHJSRSkpIHtcbiAgICAgIGRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIG1hdGNoZWRbMV0pO1xuICAgICAgaWYgKGRlZiAmJiBkZWYudGVybWluYWwpIHtcbiAgICAgICAgaWYgKCF0ZXJtRGVmIHx8IChkZWYucHJpb3JpdHkgfHwgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSkgPiB0ZXJtRGVmLnByaW9yaXR5KSB7XG4gICAgICAgICAgdGVybURlZiA9IGRlZjtcbiAgICAgICAgICByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKGF0dHIubmFtZSk7XG4gICAgICAgICAgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgIGFyZyA9IG1hdGNoZWRbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGVybURlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgdGVybURlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNraXAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWU7XG5cbi8qKlxuICogQnVpbGQgYSBub2RlIGxpbmsgZnVuY3Rpb24gZm9yIGEgdGVybWluYWwgZGlyZWN0aXZlLlxuICogQSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgdGhlIGN1cnJlbnRcbiAqIGNvbXBpbGF0aW9uIHJlY3Vyc2lvbiBhbmQgaGFuZGxlcyBjb21waWxhdGlvbiBvZiB0aGVcbiAqIHN1YnRyZWUgaW4gdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGRlZlxuICogQHBhcmFtIHtTdHJpbmd9IFtyYXdOYW1lXVxuICogQHBhcmFtIHtTdHJpbmd9IFthcmddXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0ZXJtaW5hbExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCBkZWYsIHJhd05hbWUsIGFyZywgbW9kaWZpZXJzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgYXJnOiBhcmcsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICBhdHRyOiByYXdOYW1lLFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgIGRlZjogZGVmXG4gIH07XG4gIC8vIGNoZWNrIHJlZiBmb3Igdi1mb3IgYW5kIHJvdXRlci12aWV3XG4gIGlmIChkaXJOYW1lID09PSAnZm9yJyB8fCBkaXJOYW1lID09PSAncm91dGVyLXZpZXcnKSB7XG4gICAgZGVzY3JpcHRvci5yZWYgPSBmaW5kUmVmKGVsKTtcbiAgfVxuICB2YXIgZm4gPSBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIGlmIChkZXNjcmlwdG9yLnJlZikge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgZGVzY3JpcHRvci5yZWYsIG51bGwpO1xuICAgIH1cbiAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xuICBmbi50ZXJtaW5hbCA9IHRydWU7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSBkaXJlY3RpdmVzIG9uIGFuIGVsZW1lbnQgYW5kIHJldHVybiBhIGxpbmtlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5hbWVkTm9kZU1hcH0gYXR0cnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRGlyZWN0aXZlcyhhdHRycywgb3B0aW9ucykge1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIGRpcnMgPSBbXTtcbiAgdmFyIGF0dHIsIG5hbWUsIHZhbHVlLCByYXdOYW1lLCByYXdWYWx1ZSwgZGlyTmFtZSwgYXJnLCBtb2RpZmllcnMsIGRpckRlZiwgdG9rZW5zLCBtYXRjaGVkO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgIG5hbWUgPSByYXdOYW1lID0gYXR0ci5uYW1lO1xuICAgIHZhbHVlID0gcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIHRva2VucyA9IHBhcnNlVGV4dCh2YWx1ZSk7XG4gICAgLy8gcmVzZXQgYXJnXG4gICAgYXJnID0gbnVsbDtcbiAgICAvLyBjaGVjayBtb2RpZmllcnNcbiAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcblxuICAgIC8vIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uc1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHZhbHVlID0gdG9rZW5zVG9FeHAodG9rZW5zKTtcbiAgICAgIGFyZyA9IG5hbWU7XG4gICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kLCB0b2tlbnMpO1xuICAgICAgLy8gd2FybiBhZ2FpbnN0IG1peGluZyBtdXN0YWNoZXMgd2l0aCB2LWJpbmRcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnICYmIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIubmFtZSA9PT0gJzpjbGFzcycgfHwgYXR0ci5uYW1lID09PSAndi1iaW5kOmNsYXNzJztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3YXJuKCdjbGFzcz1cIicgKyByYXdWYWx1ZSArICdcIjogRG8gbm90IG1peCBtdXN0YWNoZSBpbnRlcnBvbGF0aW9uICcgKyAnYW5kIHYtYmluZCBmb3IgXCJjbGFzc1wiIG9uIHRoZSBzYW1lIGVsZW1lbnQuIFVzZSBvbmUgb3IgdGhlIG90aGVyLicsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlXG5cbiAgICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlOiB0cmFuc2l0aW9uXG4gICAgICBpZiAodHJhbnNpdGlvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbW9kaWZpZXJzLmxpdGVyYWwgPSAhYmluZFJFLnRlc3QobmFtZSk7XG4gICAgICAgIHB1c2hEaXIoJ3RyYW5zaXRpb24nLCBpbnRlcm5hbERpcmVjdGl2ZXMudHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2VcblxuICAgICAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgYXJnID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICBwdXNoRGlyKCdvbicsIGRpcmVjdGl2ZXMub24pO1xuICAgICAgICB9IGVsc2VcblxuICAgICAgICAgIC8vIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgZGlyTmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnc3R5bGUnIHx8IGRpck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBpbnRlcm5hbERpcmVjdGl2ZXNbZGlyTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJnID0gZGlyTmFtZTtcbiAgICAgICAgICAgICAgcHVzaERpcignYmluZCcsIGRpcmVjdGl2ZXMuYmluZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgICAgICAgICBkaXJOYW1lID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcblxuICAgICAgICAgICAgICAvLyBza2lwIHYtZWxzZSAod2hlbiB1c2VkIHdpdGggdi1zaG93KVxuICAgICAgICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaXJEZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXJOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGRpckRlZikge1xuICAgICAgICAgICAgICAgIHB1c2hEaXIoZGlyTmFtZSwgZGlyRGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBkZWZcbiAgICogQHBhcmFtIHtBcnJheX0gW2ludGVycFRva2Vuc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcHVzaERpcihkaXJOYW1lLCBkZWYsIGludGVycFRva2Vucykge1xuICAgIHZhciBoYXNPbmVUaW1lVG9rZW4gPSBpbnRlcnBUb2tlbnMgJiYgaGFzT25lVGltZShpbnRlcnBUb2tlbnMpO1xuICAgIHZhciBwYXJzZWQgPSAhaGFzT25lVGltZVRva2VuICYmIHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICBkaXJzLnB1c2goe1xuICAgICAgbmFtZTogZGlyTmFtZSxcbiAgICAgIGF0dHI6IHJhd05hbWUsXG4gICAgICByYXc6IHJhd1ZhbHVlLFxuICAgICAgZGVmOiBkZWYsXG4gICAgICBhcmc6IGFyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgLy8gY29udmVyc2lvbiBmcm9tIGludGVycG9sYXRpb24gc3RyaW5ncyB3aXRoIG9uZS10aW1lIHRva2VuXG4gICAgICAvLyB0byBleHByZXNzaW9uIGlzIGRpZmZlcmVkIHVudGlsIGRpcmVjdGl2ZSBiaW5kIHRpbWUgc28gdGhhdCB3ZVxuICAgICAgLy8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGFjdHVhbCB2bSBjb250ZXh0IGZvciBvbmUtdGltZSBiaW5kaW5ncy5cbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZCAmJiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZCAmJiBwYXJzZWQuZmlsdGVycyxcbiAgICAgIGludGVycDogaW50ZXJwVG9rZW5zLFxuICAgICAgaGFzT25lVGltZTogaGFzT25lVGltZVRva2VuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGlycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVMaW5rRm4oZGlycyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBtb2RpZmllcnMgZnJvbSBkaXJlY3RpdmUgYXR0cmlidXRlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXNbbWF0Y2hbaV0uc2xpY2UoMSldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGxpbmsgZnVuY3Rpb24gZm9yIGFsbCBkaXJlY3RpdmVzIG9uIGEgc2luZ2xlIG5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGlyZWN0aXZlc1xuICogQHJldHVybiB7RnVuY3Rpb259IGRpcmVjdGl2ZXNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTm9kZUxpbmtGbihkaXJlY3RpdmVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAvLyByZXZlcnNlIGFwcGx5IGJlY2F1c2UgaXQncyBzb3J0ZWQgbG93IHRvIGhpZ2hcbiAgICB2YXIgaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl9iaW5kRGlyKGRpcmVjdGl2ZXNbaV0sIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGludGVycG9sYXRpb24gc3RyaW5nIGNvbnRhaW5zIG9uZS10aW1lIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT25lVGltZSh0b2tlbnMpIHtcbiAgdmFyIGkgPSB0b2tlbnMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRva2Vuc1tpXS5vbmVUaW1lKSByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NjcmlwdChlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZSA9PT0gJ1NDUklQVCcgJiYgKCFlbC5oYXNBdHRyaWJ1dGUoJ3R5cGUnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpO1xufVxuXG52YXIgc3BlY2lhbENoYXJSRSA9IC9bXlxcd1xcLTpcXC5dLztcblxuLyoqXG4gKiBQcm9jZXNzIGFuIGVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IGJhc2VkIG9uIGFcbiAqIGluc3RhbmNlIG9wdGlvbiBvYmplY3QuIFRoaXMgYWxsb3dzIHVzIHRvIHRyYW5zY2x1ZGVcbiAqIGEgdGVtcGxhdGUgbm9kZS9mcmFnbWVudCBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQsXG4gKiBzbyB0aGUgcHJvY2Vzc2VkIGZyYWdtZW50IGNhbiB0aGVuIGJlIGNsb25lZCBhbmQgcmV1c2VkXG4gKiBpbiB2LWZvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zY2x1ZGUoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZXh0cmFjdCBjb250YWluZXIgYXR0cmlidXRlcyB0byBwYXNzIHRoZW0gZG93blxuICAvLyB0byBjb21waWxlciwgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgY29tcGlsZWQgaW5cbiAgLy8gcGFyZW50IHNjb3BlLiB3ZSBhcmUgbXV0YXRpbmcgdGhlIG9wdGlvbnMgb2JqZWN0IGhlcmVcbiAgLy8gYXNzdW1pbmcgdGhlIHNhbWUgb2JqZWN0IHdpbGwgYmUgdXNlZCBmb3IgY29tcGlsZVxuICAvLyByaWdodCBhZnRlciB0aGlzLlxuICBpZiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzID0gZXh0cmFjdEF0dHJzKGVsKTtcbiAgfVxuICAvLyBmb3IgdGVtcGxhdGUgdGFncywgd2hhdCB3ZSB3YW50IGlzIGl0cyBjb250ZW50IGFzXG4gIC8vIGEgZG9jdW1lbnRGcmFnbWVudCAoZm9yIGZyYWdtZW50IGluc3RhbmNlcylcbiAgaWYgKGlzVGVtcGxhdGUoZWwpKSB7XG4gICAgZWwgPSBwYXJzZVRlbXBsYXRlKGVsKTtcbiAgfVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCAmJiAhb3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9ICc8c2xvdD48L3Nsb3Q+JztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMuX2NvbnRlbnQgPSBleHRyYWN0Q29udGVudChlbCk7XG4gICAgICBlbCA9IHRyYW5zY2x1ZGVUZW1wbGF0ZShlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgIC8vIGFuY2hvcnMgZm9yIGZyYWdtZW50IGluc3RhbmNlXG4gICAgLy8gcGFzc2luZyBpbiBgcGVyc2lzdDogdHJ1ZWAgdG8gYXZvaWQgdGhlbSBiZWluZ1xuICAgIC8vIGRpc2NhcmRlZCBieSBJRSBkdXJpbmcgdGVtcGxhdGUgY2xvbmluZ1xuICAgIHByZXBlbmQoY3JlYXRlQW5jaG9yKCd2LXN0YXJ0JywgdHJ1ZSksIGVsKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjcmVhdGVBbmNob3IoJ3YtZW5kJywgdHJ1ZSkpO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24uXG4gKiBJZiB0aGUgcmVwbGFjZSBvcHRpb24gaXMgdHJ1ZSB0aGlzIHdpbGwgc3dhcCB0aGUgJGVsLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIHZhciBmcmFnID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSk7XG4gIGlmIChmcmFnKSB7XG4gICAgdmFyIHJlcGxhY2VyID0gZnJhZy5maXJzdENoaWxkO1xuICAgIHZhciB0YWcgPSByZXBsYWNlci50YWdOYW1lICYmIHJlcGxhY2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1lvdSBhcmUgbW91bnRpbmcgYW4gaW5zdGFuY2Ugd2l0aCBhIHRlbXBsYXRlIHRvICcgKyAnPGJvZHk+LiBUaGlzIHdpbGwgcmVwbGFjZSA8Ym9keT4gZW50aXJlbHkuIFlvdSAnICsgJ3Nob3VsZCBwcm9iYWJseSB1c2UgYHJlcGxhY2U6IGZhbHNlYCBoZXJlLicpO1xuICAgICAgfVxuICAgICAgLy8gdGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgdGhlIGluc3RhbmNlIG11c3RcbiAgICAgIC8vIGJlY29tZSBhIGZyYWdtZW50IGluc3RhbmNlOiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdFxuICAgICAgLy8gY2FuIGNyZWF0ZSBtb3JlIHRoYW4gMSByb290IG5vZGVzLlxuICAgICAgaWYgKFxuICAgICAgLy8gbXVsdGktY2hpbGRyZW4gdGVtcGxhdGVcbiAgICAgIGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggPiAxIHx8XG4gICAgICAvLyBub24tZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgcmVwbGFjZXIubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgIC8vIHNpbmdsZSBuZXN0ZWQgY29tcG9uZW50XG4gICAgICB0YWcgPT09ICdjb21wb25lbnQnIHx8IHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykgfHwgaGFzQmluZEF0dHIocmVwbGFjZXIsICdpcycpIHx8XG4gICAgICAvLyBlbGVtZW50IGRpcmVjdGl2ZVxuICAgICAgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZykgfHxcbiAgICAgIC8vIGZvciBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWZvcicpIHx8XG4gICAgICAvLyBpZiBibG9ja1xuICAgICAgcmVwbGFjZXIuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gZXh0cmFjdEF0dHJzKHJlcGxhY2VyKTtcbiAgICAgICAgbWVyZ2VBdHRycyhlbCwgcmVwbGFjZXIpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiAnICsgdGVtcGxhdGUpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGV4dHJhY3QgYSBjb21wb25lbnQgY29udGFpbmVyJ3MgYXR0cmlidXRlc1xuICogaW50byBhIHBsYWluIG9iamVjdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0QXR0cnMoZWwpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGVsLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHJldHVybiB0b0FycmF5KGVsLmF0dHJpYnV0ZXMpO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgb2YgdHdvIGVsZW1lbnRzLCBhbmQgbWFrZSBzdXJlXG4gKiB0aGUgY2xhc3MgbmFtZXMgYXJlIG1lcmdlZCBwcm9wZXJseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21cbiAqIEBwYXJhbSB7RWxlbWVudH0gdG9cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZUF0dHJzKGZyb20sIHRvKSB7XG4gIHZhciBhdHRycyA9IGZyb20uYXR0cmlidXRlcztcbiAgdmFyIGkgPSBhdHRycy5sZW5ndGg7XG4gIHZhciBuYW1lLCB2YWx1ZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgIHZhbHVlID0gYXR0cnNbaV0udmFsdWU7XG4gICAgaWYgKCF0by5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgIXNwZWNpYWxDaGFyUkUudGVzdChuYW1lKSkge1xuICAgICAgdG8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIXBhcnNlVGV4dCh2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUudHJpbSgpKSkge1xuICAgICAgdmFsdWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgYWRkQ2xhc3ModG8sIGNscyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTY2FuIGFuZCBkZXRlcm1pbmUgc2xvdCBjb250ZW50IGRpc3RyaWJ1dGlvbi5cbiAqIFdlIGRvIHRoaXMgZHVyaW5nIHRyYW5zY2x1c2lvbiBpbnN0ZWFkIGF0IGNvbXBpbGUgdGltZSBzbyB0aGF0XG4gKiB0aGUgZGlzdHJpYnV0aW9uIGlzIGRlY291cGxlZCBmcm9tIHRoZSBjb21waWxhdGlvbiBvcmRlciBvZlxuICogdGhlIHNsb3RzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZW50XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2xvdHModm0sIGNvbnRlbnQpIHtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb250ZW50cyA9IHZtLl9zbG90Q29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZWwsIG5hbWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY29udGVudC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlbCA9IGNvbnRlbnQuY2hpbGRyZW5baV07XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpZiAobmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAoY29udGVudHNbbmFtZV0gfHwgKGNvbnRlbnRzW25hbWVdID0gW10pKS5wdXNoKGVsKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldEJpbmRBdHRyKGVsLCAnc2xvdCcpKSB7XG4gICAgICB3YXJuKCdUaGUgXCJzbG90XCIgYXR0cmlidXRlIG11c3QgYmUgc3RhdGljLicsIHZtLiRwYXJlbnQpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gY29udGVudHMpIHtcbiAgICBjb250ZW50c1tuYW1lXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50c1tuYW1lXSwgY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdmFyIG5vZGVzID0gY29udGVudC5jaGlsZE5vZGVzO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0ubm9kZVR5cGUgPT09IDMgJiYgIW5vZGVzWzBdLmRhdGEudHJpbSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnRzWydkZWZhdWx0J10gPSBleHRyYWN0RnJhZ21lbnQoY29udGVudC5jaGlsZE5vZGVzLCBjb250ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcXVhbGlmaWVkIGNvbnRlbnQgbm9kZXMgZnJvbSBhIG5vZGUgbGlzdC5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2Rlc1xuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0RnJhZ21lbnQobm9kZXMsIHBhcmVudCkge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgbm9kZXMgPSB0b0FycmF5KG5vZGVzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChpc1RlbXBsYXRlKG5vZGUpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1pZicpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1mb3InKSkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcnNlVGVtcGxhdGUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIGZyYWc7XG59XG5cblxuXG52YXIgY29tcGlsZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Y29tcGlsZTogY29tcGlsZSxcblx0Y29tcGlsZUFuZExpbmtQcm9wczogY29tcGlsZUFuZExpbmtQcm9wcyxcblx0Y29tcGlsZVJvb3Q6IGNvbXBpbGVSb290LFxuXHR0cmFuc2NsdWRlOiB0cmFuc2NsdWRlLFxuXHRyZXNvbHZlU2xvdHM6IHJlc29sdmVTbG90c1xufSk7XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIGAkZGF0YWAgcHJvcGVydHksIHNpbmNlIHNldHRpbmcgJGRhdGFcbiAgICogcmVxdWlyZXMgb2JzZXJ2aW5nIHRoZSBuZXcgb2JqZWN0IGFuZCB1cGRhdGluZ1xuICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgIGlmIChuZXdEYXRhICE9PSB0aGlzLl9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAgICogLSBvYnNlcnZlZCBkYXRhXG4gICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgKiAtIHVzZXIgbWV0aG9kc1xuICAgKiAtIG1ldGEgcHJvcGVydGllc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKCk7XG4gICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgdmFyIGVsID0gb3B0aW9ucy5lbDtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArICdwcm92aWRlZCBhdCBpbnN0YW50aWF0aW9uLicsIHRoaXMpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gY29udmVydCBzdHJpbmcgc2VsZWN0b3JzIGludG8gZWxlbWVudCBub3dcbiAgICBlbCA9IG9wdGlvbnMuZWwgPSBxdWVyeShlbCk7XG4gICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgLy8gcHJvcHMgbXVzdCBiZSBsaW5rZWQgaW4gcHJvcGVyIHNjb3BlIGlmIGluc2lkZSB2LWZvclxuICAgID8gY29tcGlsZUFuZExpbmtQcm9wcyh0aGlzLCBlbCwgcHJvcHMsIHRoaXMuX3Njb3BlKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhRm4gPSB0aGlzLiRvcHRpb25zLmRhdGE7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhID0gZGF0YUZuID8gZGF0YUZuKCkgOiB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuJywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBpLCBrZXk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAvLyB0aGVyZSBhcmUgdHdvIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW4gcHJveHkgYSBkYXRhIGtleTpcbiAgICAgIC8vIDEuIGl0J3Mgbm90IGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3BcbiAgICAgIC8vIDIuIGl0J3MgcHJvdmlkZWQgdmlhIGEgaW5zdGFudGlhdGlvbiBvcHRpb24gQU5EIHRoZXJlIGFyZSBub1xuICAgICAgLy8gICAgdGVtcGxhdGUgcHJvcCBwcmVzZW50XG4gICAgICBpZiAoIXByb3BzIHx8ICFoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdEYXRhIGZpZWxkIFwiJyArIGtleSArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgJyArICdhcyBhIHByb3AuIFRvIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZSBmb3IgYSBwcm9wLCB1c2UgdGhlIFwiZGVmYXVsdFwiICcgKyAncHJvcCBvcHRpb247IGlmIHlvdSB3YW50IHRvIHBhc3MgcHJvcCB2YWx1ZXMgdG8gYW4gaW5zdGFudGlhdGlvbiAnICsgJ2NhbGwsIHVzZSB0aGUgXCJwcm9wc0RhdGFcIiBvcHRpb24uJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIGluc3RhbmNlJ3MgJGRhdGEuIENhbGxlZCBpbiAkZGF0YSdzIHNldHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld0RhdGFcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fc2V0RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHRoaXMuX2RhdGEgPSBuZXdEYXRhO1xuICAgIHZhciBrZXlzLCBrZXksIGk7XG4gICAgLy8gdW5wcm94eSBrZXlzIG5vdCBwcmVzZW50IGluIG5ldyBkYXRhXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKG9sZERhdGEpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKCEoa2V5IGluIG5ld0RhdGEpKSB7XG4gICAgICAgIHRoaXMuX3VucHJveHkoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuICAgIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZSBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobmV3RGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIC8vIG5ldyBwcm9wZXJ0eVxuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbGREYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICBvYnNlcnZlKG5ld0RhdGEsIHRoaXMpO1xuICAgIHRoaXMuX2RpZ2VzdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhIHByb3BlcnR5LCBzbyB0aGF0XG4gICAqIHZtLnByb3AgPT09IHZtLl9kYXRhLnByb3BcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgLy8gbmVlZCB0byBzdG9yZSByZWYgdG8gc2VsZiBoZXJlXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGdldHRlci9zZXR0ZXJzIG1pZ2h0XG4gICAgICAvLyBiZSBjYWxsZWQgYnkgY2hpbGQgc2NvcGVzIHZpYVxuICAgICAgLy8gcHJvdG90eXBlIGluaGVyaXRhbmNlLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcbiAgICAgICAgICBzZWxmLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5wcm94eSBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3VucHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSB1cGRhdGUgb24gZXZlcnkgd2F0Y2hlciBpbiBzY29wZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLl93YXRjaGVyc1tpXS51cGRhdGUodHJ1ZSk7IC8vIHNoYWxsb3cgdXBkYXRlc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgY29tcHV0ZWQgcHJvcGVydGllcy4gVGhleSBhcmUgZXNzZW50aWFsbHlcbiAgICogc3BlY2lhbCBnZXR0ZXIvc2V0dGVyc1xuICAgKi9cblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgVnVlLnByb3RvdHlwZS5faW5pdENvbXB1dGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgICB2YXIgZGVmID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdGhpcyk7XG4gICAgICAgICAgZGVmLnNldCA9IG5vb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmLmdldCA9IHVzZXJEZWYuZ2V0ID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2UgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHRoaXMpIDogYmluZCh1c2VyRGVmLmdldCwgdGhpcykgOiBub29wO1xuICAgICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldCA/IGJpbmQodXNlckRlZi5zZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoZ2V0dGVyLCBvd25lcikge1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIob3duZXIsIGdldHRlciwgbnVsbCwge1xuICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAgICogaW5zdGFuY2Ugc2luY2UgdGhleSBtaWdodCBiZSBwYXNzZWQgZG93biBhcyBhIHByb3AgdG9cbiAgICogY2hpbGQgY29tcG9uZW50cy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGJpbmQobWV0aG9kc1trZXldLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YTtcbiAgICBpZiAobWV0YXMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRhcykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh0aGlzLCBrZXksIG1ldGFzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGV2ZW50UkUgPSAvXnYtb246fF5ALztcblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICAvKipcbiAgICogU2V0dXAgdGhlIGluc3RhbmNlJ3Mgb3B0aW9uIGV2ZW50cyAmIHdhdGNoZXJzLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIHdlIHB1bGwgaXQgZnJvbSB0aGVcbiAgICogaW5zdGFuY2UncyBtZXRob2RzIGJ5IG5hbWUuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnRFdmVudHModGhpcywgb3B0aW9ucy5lbCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckb24nLCBvcHRpb25zLmV2ZW50cyk7XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyR3YXRjaCcsIG9wdGlvbnMud2F0Y2gpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB2LW9uIGV2ZW50cyBvbiBhIGNoaWxkIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh2bSwgZWwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgIHZhciBuYW1lLCB2YWx1ZSwgaGFuZGxlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZXZlbnRSRSwgJycpO1xuICAgICAgICAvLyBmb3JjZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGEgc3RhdGVtZW50IHNvIHRoYXRcbiAgICAgICAgLy8gaXQgYWx3YXlzIGR5bmFtaWNhbGx5IHJlc29sdmVzIHRoZSBtZXRob2QgdG8gY2FsbCAoIzI2NzApXG4gICAgICAgIC8vIGtpbmRhIHVnbHkgaGFjaywgYnV0IGRvZXMgdGhlIGpvYi5cbiAgICAgICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKGlzU2ltcGxlUGF0aCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSArPSAnLmFwcGx5KHRoaXMsICRhcmd1bWVudHMpJztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyID0gKHZtLl9zY29wZSB8fCB2bS5fY29udGV4dCkuJGV2YWwodmFsdWUsIHRydWUpO1xuICAgICAgICBoYW5kbGVyLl9mcm9tUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrcyBmb3Igb3B0aW9uIGV2ZW50cyBhbmQgd2F0Y2hlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tzKHZtLCBhY3Rpb24sIGhhc2gpIHtcbiAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgajtcbiAgICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgICBoYW5kbGVycyA9IGhhc2hba2V5XTtcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcmVnaXN0ZXIgYW4gZXZlbnQvd2F0Y2ggY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm1bYWN0aW9uXShrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzICYmIG1ldGhvZHNbaGFuZGxlcl07XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdVbmtub3duIG1ldGhvZDogXCInICsgaGFuZGxlciArICdcIiB3aGVuICcgKyAncmVnaXN0ZXJpbmcgY2FsbGJhY2sgZm9yICcgKyBhY3Rpb24gKyAnOiBcIicgKyBrZXkgKyAnXCIuJywgdm0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLmhhbmRsZXIsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCByZWN1cnNpdmUgYXR0YWNoZWQvZGV0YWNoZWQgY2FsbHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERPTUhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJG9uKCdob29rOmF0dGFjaGVkJywgb25BdHRhY2hlZCk7XG4gICAgdGhpcy4kb24oJ2hvb2s6ZGV0YWNoZWQnLCBvbkRldGFjaGVkKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gcmVjdXJzaXZlbHkgY2FsbCBhdHRhY2hlZCBob29rIG9uIGNoaWxkcmVuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQXR0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goY2FsbEF0dGFjaCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdG9yIHRvIGNhbGwgYXR0YWNoZWQgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsbEF0dGFjaChjaGlsZCkge1xuICAgIGlmICghY2hpbGQuX2lzQXR0YWNoZWQgJiYgaW5Eb2MoY2hpbGQuJGVsKSkge1xuICAgICAgY2hpbGQuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGRldGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25EZXRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsRGV0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBkZXRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsRGV0YWNoKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYWxsIGhhbmRsZXJzIGZvciBhIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvb2tcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHRoaXMuJGVtaXQoJ3ByZS1ob29rOicgKyBob29rKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLiRvcHRpb25zW2hvb2tdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gW21vZGlmaWVyc11cbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsaXRlcmFsXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhdHRyXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhcmdcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gW3JlZl1cbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheTxPYmplY3Q+fSBbaW50ZXJwXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtoYXNPbmVUaW1lXVxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge05vZGV9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gdHJhbnNjbHVzaW9uIGhvc3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGl2ZShkZXNjcmlwdG9yLCB2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5lbCA9IGVsO1xuICAvLyBjb3B5IGRlc2NyaXB0b3IgcHJvcGVydGllc1xuICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICB0aGlzLm5hbWUgPSBkZXNjcmlwdG9yLm5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGRlc2NyaXB0b3IuZXhwcmVzc2lvbjtcbiAgdGhpcy5hcmcgPSBkZXNjcmlwdG9yLmFyZztcbiAgdGhpcy5tb2RpZmllcnMgPSBkZXNjcmlwdG9yLm1vZGlmaWVycztcbiAgdGhpcy5maWx0ZXJzID0gZGVzY3JpcHRvci5maWx0ZXJzO1xuICB0aGlzLmxpdGVyYWwgPSB0aGlzLm1vZGlmaWVycyAmJiB0aGlzLm1vZGlmaWVycy5saXRlcmFsO1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAvLyBsaW5rIGNvbnRleHRcbiAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gIHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gIHRoaXMuX2ZyYWcgPSBmcmFnO1xuICAvLyBzdG9yZSBkaXJlY3RpdmVzIG9uIG5vZGUgaW4gZGV2IG1vZGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy5lbCkge1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzID0gdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgfHwgW107XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMucHVzaCh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGRpcmVjdGl2ZSwgbWl4aW4gZGVmaW5pdGlvbiBwcm9wZXJ0aWVzLFxuICogc2V0dXAgdGhlIHdhdGNoZXIsIGNhbGwgZGVmaW5pdGlvbiBiaW5kKCkgYW5kIHVwZGF0ZSgpXG4gKiBpZiBwcmVzZW50LlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2JpbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcblxuICAvLyByZW1vdmUgYXR0cmlidXRlXG4gIGlmICgobmFtZSAhPT0gJ2Nsb2FrJyB8fCB0aGlzLnZtLl9pc0NvbXBpbGVkKSAmJiB0aGlzLmVsICYmIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgdmFyIGF0dHIgPSBkZXNjcmlwdG9yLmF0dHIgfHwgJ3YtJyArIG5hbWU7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gIH1cblxuICAvLyBjb3B5IGRlZiBwcm9wZXJ0aWVzXG4gIHZhciBkZWYgPSBkZXNjcmlwdG9yLmRlZjtcbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IGRlZjtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQodGhpcywgZGVmKTtcbiAgfVxuXG4gIC8vIHNldHVwIGRpcmVjdGl2ZSBwYXJhbXNcbiAgdGhpcy5fc2V0dXBQYXJhbXMoKTtcblxuICAvLyBpbml0aWFsIGJpbmRcbiAgaWYgKHRoaXMuYmluZCkge1xuICAgIHRoaXMuYmluZCgpO1xuICB9XG4gIHRoaXMuX2JvdW5kID0gdHJ1ZTtcblxuICBpZiAodGhpcy5saXRlcmFsKSB7XG4gICAgdGhpcy51cGRhdGUgJiYgdGhpcy51cGRhdGUoZGVzY3JpcHRvci5yYXcpO1xuICB9IGVsc2UgaWYgKCh0aGlzLmV4cHJlc3Npb24gfHwgdGhpcy5tb2RpZmllcnMpICYmICh0aGlzLnVwZGF0ZSB8fCB0aGlzLnR3b1dheSkgJiYgIXRoaXMuX2NoZWNrU3RhdGVtZW50KCkpIHtcbiAgICAvLyB3cmFwcGVkIHVwZGF0ZXIgZm9yIGNvbnRleHRcbiAgICB2YXIgZGlyID0gdGhpcztcbiAgICBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgICAgICBpZiAoIWRpci5fbG9ja2VkKSB7XG4gICAgICAgICAgZGlyLnVwZGF0ZSh2YWwsIG9sZFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IG5vb3AkMTtcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzID8gYmluZCh0aGlzLl9wcmVQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHBvc3RQcm9jZXNzID0gdGhpcy5fcG9zdFByb2Nlc3MgPyBiaW5kKHRoaXMuX3Bvc3RQcm9jZXNzLCB0aGlzKSA6IG51bGw7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodGhpcy52bSwgdGhpcy5leHByZXNzaW9uLCB0aGlzLl91cGRhdGUsIC8vIGNhbGxiYWNrXG4gICAge1xuICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAgdHdvV2F5OiB0aGlzLnR3b1dheSxcbiAgICAgIGRlZXA6IHRoaXMuZGVlcCxcbiAgICAgIHByZVByb2Nlc3M6IHByZVByb2Nlc3MsXG4gICAgICBwb3N0UHJvY2VzczogcG9zdFByb2Nlc3MsXG4gICAgICBzY29wZTogdGhpcy5fc2NvcGVcbiAgICB9KTtcbiAgICAvLyB2LW1vZGVsIHdpdGggaW5pdGFsIGlubGluZSB2YWx1ZSBuZWVkIHRvIHN5bmMgYmFjayB0b1xuICAgIC8vIG1vZGVsIGluc3RlYWQgb2YgdXBkYXRlIHRvIERPTSBvbiBpbml0LiBUaGV5IHdvdWxkXG4gICAgLy8gc2V0IHRoZSBhZnRlckJpbmQgaG9vayB0byBpbmRpY2F0ZSB0aGF0LlxuICAgIGlmICh0aGlzLmFmdGVyQmluZCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZSh3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYWxsIHBhcmFtIGF0dHJpYnV0ZXMsIGUuZy4gdHJhY2stYnksXG4gKiB0cmFuc2l0aW9uLW1vZGUsIGV0Yy4uLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucGFyYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgLy8gc3dhcCB0aGUgcGFyYW1zIGFycmF5IHdpdGggYSBmcmVzaCBvYmplY3QuXG4gIHRoaXMucGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGkgPSBwYXJhbXMubGVuZ3RoO1xuICB2YXIga2V5LCB2YWwsIG1hcHBlZEtleTtcbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGh5cGhlbmF0ZShwYXJhbXNbaV0pO1xuICAgIG1hcHBlZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgdmFsID0gZ2V0QmluZEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIC8vIGR5bmFtaWNcbiAgICAgIHRoaXMuX3NldHVwUGFyYW1XYXRjaGVyKG1hcHBlZEtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhdGljXG4gICAgICB2YWwgPSBnZXRBdHRyKHRoaXMuZWwsIGtleSk7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJhbXNbbWFwcGVkS2V5XSA9IHZhbCA9PT0gJycgPyB0cnVlIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhIHdhdGNoZXIgZm9yIGEgZHluYW1pYyBwYXJhbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3NldHVwUGFyYW1XYXRjaGVyID0gZnVuY3Rpb24gKGtleSwgZXhwcmVzc2lvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHVud2F0Y2ggPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHdhdGNoKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xuICAgIHNlbGYucGFyYW1zW2tleV0gPSB2YWw7XG4gICAgLy8gc2luY2Ugd2UgYXJlIGluIGltbWVkaWF0ZSBtb2RlLFxuICAgIC8vIG9ubHkgY2FsbCB0aGUgcGFyYW0gY2hhbmdlIGNhbGxiYWNrcyBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgdXBkYXRlLlxuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYucGFyYW1XYXRjaGVycyAmJiBzZWxmLnBhcmFtV2F0Y2hlcnNba2V5XTtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhbCwgb2xkVmFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgdXNlcjogZmFsc2VcbiAgfSk7KHRoaXMuX3BhcmFtVW53YXRjaEZucyB8fCAodGhpcy5fcGFyYW1VbndhdGNoRm5zID0gW10pKS5wdXNoKHVud2F0Y2gpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGlyZWN0aXZlIGlzIGEgZnVuY3Rpb24gY2FsbGVyXG4gKiBhbmQgaWYgdGhlIGV4cHJlc3Npb24gaXMgYSBjYWxsYWJsZSBvbmUuIElmIGJvdGggdHJ1ZSxcbiAqIHdlIHdyYXAgdXAgdGhlIGV4cHJlc3Npb24gYW5kIHVzZSBpdCBhcyB0aGUgZXZlbnRcbiAqIGhhbmRsZXIuXG4gKlxuICogZS5nLiBvbi1jbGljaz1cImErK1wiXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb247XG4gIGlmIChleHByZXNzaW9uICYmIHRoaXMuYWNjZXB0U3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwcmVzc2lvbikpIHtcbiAgICB2YXIgZm4gPSBwYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbikuZ2V0O1xuICAgIHZhciBzY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIHNjb3BlLiRldmVudCA9IGU7XG4gICAgICBmbi5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgICBzY29wZS4kZXZlbnQgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgaGFuZGxlciA9IHNjb3BlLl9hcHBseUZpbHRlcnMoaGFuZGxlciwgbnVsbCwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0d28td2F5IGRpcmVjdGl2ZXNcbiAqIGUuZy4gdi1tb2RlbC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHVibGljXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMudHdvV2F5KSB7XG4gICAgdGhpcy5fd2l0aExvY2soZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fd2F0Y2hlci5zZXQodmFsdWUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKCdEaXJlY3RpdmUuc2V0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdHdvV2F5JyArICdkaXJlY3RpdmVzLicpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGlsZSBwcmV2ZW50aW5nIHRoYXQgZnVuY3Rpb24gZnJvbVxuICogdHJpZ2dlcmluZyB1cGRhdGVzIG9uIHRoaXMgZGlyZWN0aXZlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fd2l0aExvY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9sb2NrZWQgPSB0cnVlO1xuICBmbi5jYWxsKHNlbGYpO1xuICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fbG9ja2VkID0gZmFsc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdHRhY2hlcyBhIERPTSBldmVudCBsaXN0ZW5lclxuICogdG8gdGhlIGRpcmVjdGl2ZSBlbGVtZW50IGFuZCBhdXRvbWV0aWNhbGx5IHRlYXJzIGl0IGRvd25cbiAqIGR1cmluZyB1bmJpbmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgb24odGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpOyh0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSkucHVzaChbZXZlbnQsIGhhbmRsZXJdKTtcbn07XG5cbi8qKlxuICogVGVhcmRvd24gdGhlIHdhdGNoZXIgYW5kIGNhbGwgdW5iaW5kLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYm91bmQpIHtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgb2ZmKHRoaXMuZWwsIGxpc3RlbmVyc1tpXVswXSwgbGlzdGVuZXJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnM7XG4gICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgIGkgPSB1bndhdGNoRm5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdi1yZWYgZm9yIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlUmVmID0gZnVuY3Rpb24gKHJlbW92ZSkge1xuICAgIHZhciByZWYgPSB0aGlzLiRvcHRpb25zLl9yZWY7XG4gICAgaWYgKHJlZikge1xuICAgICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy5fY29udGV4dCkuJHJlZnM7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGlmIChyZWZzW3JlZl0gPT09IHRoaXMpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW3JlZl0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNjbHVkZSwgY29tcGlsZSBhbmQgbGluayBlbGVtZW50LlxuICAgKlxuICAgKiBJZiBhIHByZS1jb21waWxlZCBsaW5rZXIgaXMgYXZhaWxhYmxlLCB0aGF0IG1lYW5zIHRoZVxuICAgKiBwYXNzZWQgaW4gZWxlbWVudCB3aWxsIGJlIHByZS10cmFuc2NsdWRlZCBhbmQgY29tcGlsZWRcbiAgICogYXMgd2VsbCAtIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGNhbGwgdGhlIGxpbmtlci5cbiAgICpcbiAgICogT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2FsbCB0cmFuc2NsdWRlL2NvbXBpbGUvbGluayBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAvLyB0cmFuc2NsdWRlIGFuZCBpbml0IGVsZW1lbnRcbiAgICAvLyB0cmFuc2NsdWRlIGNhbiBwb3RlbnRpYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZTsgdGhpcyBzdGVwIGFsc28gaW5qZWN0c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgY2FjaGVzIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgLy8gb24gdGhlIGNvbnRhaW5lciBub2RlIGFuZCByZXBsYWNlciBub2RlLlxuICAgIHZhciBvcmlnaW5hbCA9IGVsO1xuICAgIGVsID0gdHJhbnNjbHVkZShlbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdEVsZW1lbnQoZWwpO1xuXG4gICAgLy8gaGFuZGxlIHYtcHJlIG9uIHJvb3Qgbm9kZSAoIzIwMjYpXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxICYmIGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm9vdCBpcyBhbHdheXMgY29tcGlsZWQgcGVyLWluc3RhbmNlLCBiZWNhdXNlXG4gICAgLy8gY29udGFpbmVyIGF0dHJzIGFuZCBwcm9wcyBjYW4gYmUgZGlmZmVyZW50IGV2ZXJ5IHRpbWUuXG4gICAgdmFyIGNvbnRleHRPcHRpb25zID0gdGhpcy5fY29udGV4dCAmJiB0aGlzLl9jb250ZXh0LiRvcHRpb25zO1xuICAgIHZhciByb290TGlua2VyID0gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdCBkaXN0cmlidXRpb25cbiAgICByZXNvbHZlU2xvdHModGhpcywgb3B0aW9ucy5fY29udGVudCk7XG5cbiAgICAvLyBjb21waWxlIGFuZCBsaW5rIHRoZSByZXN0XG4gICAgdmFyIGNvbnRlbnRMaW5rRm47XG4gICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNvbXBvbmVudCBjb21waWxhdGlvbiBjYW4gYmUgY2FjaGVkXG4gICAgLy8gYXMgbG9uZyBhcyBpdCdzIG5vdCB1c2luZyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAob3B0aW9ucy5fbGlua2VyQ2FjaGFibGUpIHtcbiAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlcjtcbiAgICAgIGlmICghY29udGVudExpbmtGbikge1xuICAgICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXIgPSBjb21waWxlKGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsaW5rIHBoYXNlXG4gICAgLy8gbWFrZSBzdXJlIHRvIGxpbmsgcm9vdCB3aXRoIHByb3Agc2NvcGUhXG4gICAgdmFyIHJvb3RVbmxpbmtGbiA9IHJvb3RMaW5rZXIodGhpcywgZWwsIHRoaXMuX3Njb3BlKTtcbiAgICB2YXIgY29udGVudFVubGlua0ZuID0gY29udGVudExpbmtGbiA/IGNvbnRlbnRMaW5rRm4odGhpcywgZWwpIDogY29tcGlsZShlbCwgb3B0aW9ucykodGhpcywgZWwpO1xuXG4gICAgLy8gcmVnaXN0ZXIgY29tcG9zaXRlIHVubGluayBmdW5jdGlvblxuICAgIC8vIHRvIGJlIGNhbGxlZCBkdXJpbmcgaW5zdGFuY2UgZGVzdHJ1Y3Rpb25cbiAgICB0aGlzLl91bmxpbmtGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3RVbmxpbmtGbigpO1xuICAgICAgLy8gcGFzc2luZyBkZXN0cm95aW5nOiB0cnVlIHRvIGF2b2lkIHNlYXJjaGluZyBhbmRcbiAgICAgIC8vIHNwbGljaW5nIHRoZSBkaXJlY3RpdmVzXG4gICAgICBjb250ZW50VW5saW5rRm4odHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIGZpbmFsbHkgcmVwbGFjZSBvcmlnaW5hbFxuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIHJlcGxhY2Uob3JpZ2luYWwsIGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnY29tcGlsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBpbnN0YW5jZSBlbGVtZW50LiBDYWxsZWQgaW4gdGhlIHB1YmxpY1xuICAgKiAkbW91bnQoKSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNGcmFnbWVudChlbCkpIHtcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gZWwubGFzdENoaWxkO1xuICAgICAgLy8gc2V0IHBlcnNpc3RlZCB0ZXh0IGFuY2hvcnMgdG8gZW1wdHlcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYmluZCBhIGRpcmVjdGl2ZSB0byBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciAtIHBhcnNlZCBkaXJlY3RpdmUgZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgICAtIHRhcmdldCBub2RlXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBbZnJhZ10gLSBvd25lciBmcmFnbWVudFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9iaW5kRGlyID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IsIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdGhpcy5fZGlyZWN0aXZlcy5wdXNoKG5ldyBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdGhpcywgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVhcmRvd24gYW4gaW5zdGFuY2UsIHVub2JzZXJ2ZXMgdGhlIGRhdGEsIHVuYmluZCBhbGwgdGhlXG4gICAqIGRpcmVjdGl2ZXMsIHR1cm4gb2ZmIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIC0gd2hldGhlciB0byByZW1vdmUgdGhlIERPTSBub2RlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cCAtIGlmIHRydWUsIGRlZmVyIGNsZWFudXAgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjYWxsZWQgbGF0ZXJcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIGlmICh0aGlzLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc3Ryb3lSZWFkeTtcbiAgICB2YXIgcGVuZGluZ1JlbW92YWw7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ2xlYW51cCBzaG91bGQgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm95c2x5IGFzXG4gICAgLy8gY2FsbGJhY2sgb2YgdGhpcy4kcmVtb3ZlKCksIG9yIGlmIHJlbW92ZSBhbmQgZGVmZXJDbGVhbnVwIGFyZSBmYWxzZS5cbiAgICAvLyBJbiBhbnkgY2FzZSBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsbCBvdGhlciByZW1vdmluZywgdW5iaW5kaW5nIGFuZFxuICAgIC8vIHR1cm5pbmcgb2YgaXMgZG9uZVxuICAgIHZhciBjbGVhbnVwSWZQb3NzaWJsZSA9IGZ1bmN0aW9uIGNsZWFudXBJZlBvc3NpYmxlKCkge1xuICAgICAgaWYgKGRlc3Ryb3lSZWFkeSAmJiAhcGVuZGluZ1JlbW92YWwgJiYgIWRlZmVyQ2xlYW51cCkge1xuICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHJlbW92ZSBET00gZWxlbWVudFxuICAgIGlmIChyZW1vdmUgJiYgdGhpcy4kZWwpIHtcbiAgICAgIHBlbmRpbmdSZW1vdmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuJHJlbW92ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmdSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgIGNsZWFudXBJZlBvc3NpYmxlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlRGVzdHJveScpO1xuICAgIHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIHZhciBpO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LiBvbmx5IG5lY2Vzc2FyeVxuICAgIC8vIGlmIHBhcmVudCBpcyBub3QgYmVpbmcgZGVzdHJveWVkIGFzIHdlbGwuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHBhcmVudC4kY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICAgIC8vIHVucmVnaXN0ZXIgcmVmIChyZW1vdmU6IHRydWUpXG4gICAgICB0aGlzLl91cGRhdGVSZWYodHJ1ZSk7XG4gICAgfVxuICAgIC8vIGRlc3Ryb3kgYWxsIGNoaWxkcmVuLlxuICAgIGkgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy4kY2hpbGRyZW5baV0uJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gcHJvcHNcbiAgICBpZiAodGhpcy5fcHJvcHNVbmxpbmtGbikge1xuICAgICAgdGhpcy5fcHJvcHNVbmxpbmtGbigpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBhbGwgZGlyZWN0aXZlcy4gdGhpcyBhbHNvIHRlYXJzZG93biBhbGxcbiAgICAvLyBkaXJlY3RpdmUtb3duZWQgd2F0Y2hlcnMuXG4gICAgaWYgKHRoaXMuX3VubGlua0ZuKSB7XG4gICAgICB0aGlzLl91bmxpbmtGbigpO1xuICAgIH1cbiAgICBpID0gdGhpcy5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gc2VsZiBvbiAkZWxcbiAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgIHRoaXMuJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3lSZWFkeSA9IHRydWU7XG4gICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgdG8gZW5zdXJlIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogVGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGxlYXZlIHRyYW5zaXRpb24gaWYgdGhlcmVcbiAgICogaXMgYW55LlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIG93bmVyIGZyYWdtZW50XG4gICAgLy8gZG8gaXQgaW4gY2xlYW51cCBzbyB0aGF0IHdlIGNhbiBjYWxsICRkZXN0cm95IHdpdGhcbiAgICAvLyBkZWZlciByaWdodCB3aGVuIGEgZnJhZ21lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5fZnJhZykge1xuICAgICAgdGhpcy5fZnJhZy5jaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEuX19vYl9fKSB7XG4gICAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlcyB0byBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgLy8gaW5zdGFuY2VzLiBwcmVzZXJ2ZSByZWZlcmVuY2UgdG8gX2RhdGEgc28gdGhhdCBwcm94eVxuICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAvLyBoZXJlIGlzIHRoYXQgbXV0YXRpbmcgdGhlIGluc3RhbmNlIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gICAgLy8gbWF5IGFmZmVjdCB0aGUgc3RhdGUgb2Ygb3RoZXIgY29tcG9uZW50cyB0aGF0IGFyZSBzdGlsbFxuICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAvLyByZWFzb25hYmxlIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXNlciByYXRoZXIgdGhhblxuICAgIC8vIGFsd2F5cyB0aHJvd2luZyBhbiBlcnJvciBvbiB0aGVtLlxuICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy4kb2ZmKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1pc2NNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBcHBseSBhIGxpc3Qgb2YgZmlsdGVyIChkZXNjcmlwdG9ycykgdG8gYSB2YWx1ZS5cbiAgICogVXNpbmcgcGxhaW4gZm9yIGxvb3BzIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gICAqIHRoZSBnZXR0ZXIgb2YgYW55IHdhdGNoZXIgd2l0aCBmaWx0ZXJzIHNvIGl0IGlzIHZlcnlcbiAgICogcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW29sZFZhbHVlXVxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd3JpdGVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSwgZmlsdGVycywgd3JpdGUpIHtcbiAgICB2YXIgZmlsdGVyLCBmbiwgYXJncywgYXJnLCBvZmZzZXQsIGksIGwsIGosIGs7XG4gICAgZm9yIChpID0gMCwgbCA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXJzW3dyaXRlID8gbCAtIGkgLSAxIDogaV07XG4gICAgICBmbiA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlci5uYW1lLCB0cnVlKTtcbiAgICAgIGlmICghZm4pIGNvbnRpbnVlO1xuICAgICAgZm4gPSB3cml0ZSA/IGZuLndyaXRlIDogZm4ucmVhZCB8fCBmbjtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgYXJncyA9IHdyaXRlID8gW3ZhbHVlLCBvbGRWYWx1ZV0gOiBbdmFsdWVdO1xuICAgICAgb2Zmc2V0ID0gd3JpdGUgPyAyIDogMTtcbiAgICAgIGlmIChmaWx0ZXIuYXJncykge1xuICAgICAgICBmb3IgKGogPSAwLCBrID0gZmlsdGVyLmFyZ3MubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgYXJnID0gZmlsdGVyLmFyZ3Nbal07XG4gICAgICAgICAgYXJnc1tqICsgb2Zmc2V0XSA9IGFyZy5keW5hbWljID8gdGhpcy4kZ2V0KGFyZy52YWx1ZSkgOiBhcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZSBhIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGNvbXBvbmVudFxuICAgKiBpcyBkZWZpbmVkIG5vcm1hbGx5IG9yIHVzaW5nIGFuIGFzeW5jIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIFJlc29sdmVzIHN5bmNocm9ub3VzbHkgaWYgYWxyZWFkeSByZXNvbHZlZCwgb3RoZXJ3aXNlXG4gICAqIHJlc29sdmVzIGFzeW5jaHJvbm91c2x5IGFuZCBjYWNoZXMgdGhlIHJlc29sdmVkXG4gICAqIGNvbnN0cnVjdG9yIG9uIHRoZSBmYWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgZmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmYWN0b3J5ID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvcnkgPSByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeVxuICAgIGlmICghZmFjdG9yeS5vcHRpb25zKSB7XG4gICAgICBpZiAoZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgICAvLyBjYWNoZWRcbiAgICAgICAgY2IoZmFjdG9yeS5yZXNvbHZlZCk7XG4gICAgICB9IGVsc2UgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgICAgIGZhY3RvcnkuY2FsbCh0aGlzLCBmdW5jdGlvbiByZXNvbHZlKHJlcykge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IFZ1ZS5leHRlbmQocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja3NcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50JyArICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJzogJyArIHZhbHVlIDogJycpICsgJy4gJyArIChyZWFzb24gPyAnXFxuUmVhc29uOiAnICsgcmVhc29uIDogJycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBjb21wb25lbnRcbiAgICAgIGNiKGZhY3RvcnkpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGZpbHRlclJFJDEgPSAvW158XVxcfFtefF0vO1xuXG5mdW5jdGlvbiBkYXRhQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uIChleHAsIGFzU3RhdGVtZW50KSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGlmIChhc1N0YXRlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5nZXQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAgICogZXhwcmVzc2lvbiBpbiBhbiBhc3NpZ25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwLCB0cnVlKTtcbiAgICBpZiAocmVzICYmIHJlcy5zZXQpIHtcbiAgICAgIHJlcy5zZXQuY2FsbCh0aGlzLCB0aGlzLCB2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgb24gdGhlIFZNXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbCh0aGlzLl9kYXRhLCBrZXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gICAqIHZhbHVlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGltbWVkaWF0ZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB1bndhdGNoRm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwYXJzZWQ7XG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUoZXhwT3JGbik7XG4gICAgICBleHBPckZuID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCB7XG4gICAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICAgIHN5bmM6IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgdXNlcjogIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VyICE9PSBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhIHRleHQgZGlyZWN0aXZlLCBpbmNsdWRpbmcgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZXZhbCA9IGZ1bmN0aW9uICh0ZXh0LCBhc1N0YXRlbWVudCkge1xuICAgIC8vIGNoZWNrIGZvciBmaWx0ZXJzLlxuICAgIGlmIChmaWx0ZXJSRSQxLnRlc3QodGV4dCkpIHtcbiAgICAgIHZhciBkaXIgPSBwYXJzZURpcmVjdGl2ZSh0ZXh0KTtcbiAgICAgIC8vIHRoZSBmaWx0ZXIgcmVnZXggY2hlY2sgbWlnaHQgZ2l2ZSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgLy8gZm9yIHBpcGVzIGluc2lkZSBzdHJpbmdzLCBzbyBpdCdzIHBvc3NpYmxlIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IGdldCBhbnkgZmlsdGVycyBoZXJlXG4gICAgICB2YXIgdmFsID0gdGhpcy4kZ2V0KGRpci5leHByZXNzaW9uLCBhc1N0YXRlbWVudCk7XG4gICAgICByZXR1cm4gZGlyLmZpbHRlcnMgPyB0aGlzLl9hcHBseUZpbHRlcnModmFsLCBudWxsLCBkaXIuZmlsdGVycykgOiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGZpbHRlclxuICAgICAgcmV0dXJuIHRoaXMuJGdldCh0ZXh0LCBhc1N0YXRlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBhIHBpZWNlIG9mIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZVRleHQodGV4dCk7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdm0uJGV2YWwodG9rZW5zWzBdLnZhbHVlKSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLnRhZyA/IHZtLiRldmFsKHRva2VuLnZhbHVlKSA6IHRva2VuLnZhbHVlO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2cgaW5zdGFuY2UgZGF0YSBhcyBhIHBsYWluIEpTIG9iamVjdFxuICAgKiBzbyB0aGF0IGl0IGlzIGVhc2llciB0byBpbnNwZWN0IGluIGNvbnNvbGUuXG4gICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgY29uc29sZSBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbG9nID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZGF0YSA9IHBhdGggPyBnZXRQYXRoKHRoaXMuX2RhdGEsIHBhdGgpIDogdGhpcy5fZGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGF0YSA9IGNsZWFuKGRhdGEpO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIGNvbXB1dGVkIGZpZWxkc1xuICAgIGlmICghcGF0aCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcm9wcykge1xuICAgICAgICBmb3IgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwiY2xlYW5cIiBhIGdldHRlci9zZXR0ZXIgY29udmVydGVkIG9iamVjdCBpbnRvIGEgcGxhaW5cbiAgICogb2JqZWN0IGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAtIG9ialxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBvbi1pbnN0YW5jZSBuZXh0VGljay4gVGhlIGNhbGxiYWNrIGlzXG4gICAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gICAqIG1vZHVsZXMgaGF2aW5nIHRvIHJlbHkgb24gdGhlIGdsb2JhbCBWdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgbmV4dFRpY2soZm4sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGFwcGVuZCwgYXBwZW5kV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcHJlcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5maXJzdENoaWxkLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYmVmb3JlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYmVmb3JlID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYmVmb3JlV2l0aENiLCBiZWZvcmVXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0Lm5leHRTaWJsaW5nLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpbnN0YW5jZSBmcm9tIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcmVtb3ZlID0gZnVuY3Rpb24gKGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIHZhciBpbkRvY3VtZW50ID0gdGhpcy5faXNBdHRhY2hlZCAmJiBpbkRvYyh0aGlzLiRlbCk7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBpbiBkb2N1bWVudCwgbm8gbmVlZCB0byBjaGVja1xuICAgIC8vIGZvciB0cmFuc2l0aW9uc1xuICAgIGlmICghaW5Eb2N1bWVudCkgd2l0aFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlYWxDYiA9IGZ1bmN0aW9uIHJlYWxDYigpIHtcbiAgICAgIGlmIChpbkRvY3VtZW50KSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgICByZW1vdmVOb2RlUmFuZ2UodGhpcy5fZnJhZ21lbnRTdGFydCwgdGhpcy5fZnJhZ21lbnRFbmQsIHRoaXMsIHRoaXMuX2ZyYWdtZW50LCByZWFsQ2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgPyByZW1vdmVXaXRoQ2IgOiByZW1vdmVXaXRoVHJhbnNpdGlvbjtcbiAgICAgIG9wKHRoaXMuJGVsLCB0aGlzLCByZWFsQ2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMiAtIG9wIGZvciB0cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcmV0dXJuIHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluc2VydCh2bSwgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIG9wMSwgb3AyKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFpbkRvYyh0YXJnZXQpO1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSB8fCB0YXJnZXRJc0RldGFjaGVkID8gb3AxIDogb3AyO1xuICAgIHZhciBzaG91bGRDYWxsSG9vayA9ICF0YXJnZXRJc0RldGFjaGVkICYmICF2bS5faXNBdHRhY2hlZCAmJiAhaW5Eb2Modm0uJGVsKTtcbiAgICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICAgIG1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvcChub2RlLCB0YXJnZXQsIHZtKTtcbiAgICAgIH0pO1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aodm0uJGVsLCB0YXJnZXQsIHZtLCBjYik7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgICAgdm0uX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHNlbGVjdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBlbmQoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmVmb3JlV2l0aENiKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlV2l0aENiKGVsLCB2bSwgY2IpIHtcbiAgICByZW1vdmUoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudHNBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICh0aGlzLl9ldmVudHNbZXZlbnRdIHx8ICh0aGlzLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gICAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHNlbGYuJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB0aGlzLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgY2JzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuJHBhcmVudCkge1xuICAgICAgICBmb3IgKGV2ZW50IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIC1jYnMubGVuZ3RoKTtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLTEpO1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnQgb24gc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBzaG91bGRQcm9wYWdhdGVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpc1NvdXJjZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZyc7XG4gICAgZXZlbnQgPSBpc1NvdXJjZSA/IGV2ZW50IDogZXZlbnQubmFtZTtcbiAgICB2YXIgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gaXNTb3VyY2UgfHwgIWNicztcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBoYWNreSBzb2x1dGlvbiB0byB0aGUgcXVlc3Rpb24gcmFpc2VkXG4gICAgICAvLyBpbiAjMjEwMjogZm9yIGFuIGlubGluZSBjb21wb25lbnQgbGlzdGVuZXIgbGlrZSA8Y29tcCBAdGVzdD1cImRvVGhpc1wiPixcbiAgICAgIC8vIHRoZSBwcm9wYWdhdGlvbiBoYW5kbGluZyBpcyBzb21ld2hhdCBicm9rZW4uIFRoZXJlZm9yZSB3ZVxuICAgICAgLy8gbmVlZCB0byB0cmVhdCB0aGVzZSBpbmxpbmUgY2FsbGJhY2tzIGRpZmZlcmVudGx5LlxuICAgICAgdmFyIGhhc1BhcmVudENicyA9IGlzU291cmNlICYmIGNicy5zb21lKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2IuX2Zyb21QYXJlbnQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNQYXJlbnRDYnMpIHtcbiAgICAgICAgc2hvdWxkUHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2IgPSBjYnNbaV07XG4gICAgICAgIHZhciByZXMgPSBjYi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSAmJiAoIWhhc1BhcmVudENicyB8fCBjYi5fZnJvbVBhcmVudCkpIHtcbiAgICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRQcm9wYWdhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGJyb2FkY2FzdCBhbiBldmVudCB0byBhbGwgY2hpbGRyZW4gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIC8vIGlmIG5vIGNoaWxkIGhhcyByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50LFxuICAgIC8vIHRoZW4gdGhlcmUncyBubyBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c0NvdW50W2V2ZW50XSkgcmV0dXJuO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGNoaWxkcmVuO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGlmIChpc1NvdXJjZSkge1xuICAgICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAgIC8vIG9uIGNoaWxkcmVuXG4gICAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBjaGlsZC4kZW1pdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICBpZiAoc2hvdWxkUHJvcGFnYXRlKSB7XG4gICAgICAgIGNoaWxkLiRicm9hZGNhc3QuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcHJvcGFnYXRlIGFuIGV2ZW50IHVwIHRoZSBwYXJlbnQgY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0gey4uLip9IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRpc3BhdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IHRoaXMuJGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXNob3VsZFByb3BhZ2F0ZSkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgLy8gdXNlIG9iamVjdCBldmVudCB0byBpbmRpY2F0ZSBub24tc291cmNlIGVtaXRcbiAgICAvLyBvbiBwYXJlbnRzXG4gICAgYXJnc1swXSA9IHsgbmFtZTogZXZlbnQsIHNvdXJjZTogdGhpcyB9O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHBhcmVudC4kZW1pdC5hcHBseShwYXJlbnQsIGFyZ3MpO1xuICAgICAgcGFyZW50ID0gc2hvdWxkUHJvcGFnYXRlID8gcGFyZW50LiRwYXJlbnQgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBsaXN0ZW5lciBjb3VudHMgb24gYWxsIHBhcmVudHMuXG4gICAqIFRoaXMgYm9va2tlZXBpbmcgYWxsb3dzICRicm9hZGNhc3QgdG8gcmV0dXJuIGVhcmx5IHdoZW5cbiAgICogbm8gY2hpbGQgaGFzIGxpc3RlbmVkIHRvIGEgY2VydGFpbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAgICovXG5cbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBmdW5jdGlvbiBtb2RpZnlMaXN0ZW5lckNvdW50KHZtLCBldmVudCwgY291bnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAvLyBob29rcyBkbyBub3QgZ2V0IGJyb2FkY2FzdGVkIHNvIG5vIG5lZWRcbiAgICAvLyB0byBkbyBib29ra2VlcGluZyBmb3IgdGhlbVxuICAgIGlmICghcGFyZW50IHx8ICFjb3VudCB8fCBob29rUkUudGVzdChldmVudCkpIHJldHVybjtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSA9IChwYXJlbnQuX2V2ZW50c0NvdW50W2V2ZW50XSB8fCAwKSArIGNvdW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZUFQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXQgaW5zdGFuY2UgdGFyZ2V0IGVsZW1lbnQgYW5kIGtpY2sgb2ZmIHRoZSBjb21waWxhdGlvblxuICAgKiBwcm9jZXNzLiBUaGUgcGFzc2VkIGluIGBlbGAgY2FuIGJlIGEgc2VsZWN0b3Igc3RyaW5nLCBhblxuICAgKiBleGlzdGluZyBFbGVtZW50LCBvciBhIERvY3VtZW50RnJhZ21lbnQgKGZvciBibG9ja1xuICAgKiBpbnN0YW5jZXMpLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxzdHJpbmd9IGVsXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCckbW91bnQoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwgPSBxdWVyeShlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgdGhpcy5fY29tcGlsZShlbCk7XG4gICAgdGhpcy5faW5pdERPTUhvb2tzKCk7XG4gICAgaWYgKGluRG9jKHRoaXMuJGVsKSkge1xuICAgICAgdGhpcy5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgICByZWFkeS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRvbmNlKCdob29rOmF0dGFjaGVkJywgcmVhZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWFyayBhbiBpbnN0YW5jZSBhcyByZWFkeS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ3JlYWR5Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGluc3RhbmNlLCBzaW1wbHkgZGVsZWdhdGUgdG8gdGhlIGludGVybmFsXG4gICAqIF9kZXN0cm95LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyQ2xlYW51cFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgdGhpcy5fZGVzdHJveShyZW1vdmUsIGRlZmVyQ2xlYW51cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBjb21waWxlIGEgcGllY2Ugb2YgRE9NIGFuZCByZXR1cm4gYVxuICAgKiBkZWNvbXBpbGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICByZXR1cm4gY29tcGlsZShlbCwgdGhpcy4kb3B0aW9ucywgdHJ1ZSkodGhpcywgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgJGBcbiAqIC0gaW50ZXJuYWwgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGBfYFxuICogLSBub24tcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgYXNzdW1lZCB0byBiZSBwcm94aWVkIHVzZXJcbiAqICAgZGF0YS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG4vLyBpbnN0YWxsIGludGVybmFsc1xuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbm1pc2NNaXhpbihWdWUpO1xuXG4vLyBpbnN0YWxsIGluc3RhbmNlIEFQSXNcbmRhdGFBUEkoVnVlKTtcbmRvbUFQSShWdWUpO1xuZXZlbnRzQVBJKFZ1ZSk7XG5saWZlY3ljbGVBUEkoVnVlKTtcblxudmFyIHNsb3QgPSB7XG5cbiAgcHJpb3JpdHk6IFNMT1QsXG4gIHBhcmFtczogWyduYW1lJ10sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyB0aGlzIHdhcyByZXNvbHZlZCBkdXJpbmcgY29tcG9uZW50IHRyYW5zY2x1c2lvblxuICAgIHZhciBuYW1lID0gdGhpcy5wYXJhbXMubmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnZtLl9zbG90Q29udGVudHMgJiYgdGhpcy52bS5fc2xvdENvbnRlbnRzW25hbWVdO1xuICAgIGlmICghY29udGVudCB8fCAhY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21waWxlKGNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLCB0aGlzLnZtLl9jb250ZXh0LCB0aGlzLnZtKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KSB7XG4gICAgaWYgKGNvbnRlbnQgJiYgY29udGV4dCkge1xuICAgICAgaWYgKHRoaXMuZWwuaGFzQ2hpbGROb2RlcygpICYmIGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09PSAxICYmIGNvbnRlbnQuY2hpbGROb2Rlc1swXS5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICAvLyBpZiB0aGUgaW5zZXJ0ZWQgc2xvdCBoYXMgdi1pZlxuICAgICAgICAvLyBpbmplY3QgZmFsbGJhY2sgY29udGVudCBhcyB0aGUgdi1lbHNlXG4gICAgICAgIHZhciBlbHNlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBlbHNlQmxvY2suc2V0QXR0cmlidXRlKCd2LWVsc2UnLCAnJyk7XG4gICAgICAgIGVsc2VCbG9jay5pbm5lckhUTUwgPSB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgICAgLy8gdGhlIGVsc2UgYmxvY2sgc2hvdWxkIGJlIGNvbXBpbGVkIGluIGNoaWxkIHNjb3BlXG4gICAgICAgIGVsc2VCbG9jay5fY29udGV4dCA9IHRoaXMudm07XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxzZUJsb2NrKTtcbiAgICAgIH1cbiAgICAgIHZhciBzY29wZSA9IGhvc3QgPyBob3N0Ll9zY29wZSA6IHRoaXMuX3Njb3BlO1xuICAgICAgdGhpcy51bmxpbmsgPSBjb250ZXh0LiRjb21waWxlKGNvbnRlbnQsIGhvc3QsIHNjb3BlLCB0aGlzLl9mcmFnKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSh0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgIHRoaXMuY29tcGlsZShleHRyYWN0Q29udGVudCh0aGlzLmVsLCB0cnVlKSwgdGhpcy52bSk7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMudW5saW5rKSB7XG4gICAgICB0aGlzLnVubGluaygpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBhcnRpYWwgPSB7XG5cbiAgcHJpb3JpdHk6IFBBUlRJQUwsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICAvLyB3YXRjaCBjaGFuZ2VzIHRvIG5hbWUgZm9yIGR5bmFtaWMgcGFydGlhbHNcbiAgcGFyYW1XYXRjaGVyczoge1xuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmluc2VydCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtcGFydGlhbCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMucGFyYW1zLm5hbWUpO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGlkKSB7XG4gICAgdmFyIHBhcnRpYWwgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQsIHRydWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHBhcnRpYWwpO1xuICAgICAgdklmLmluc2VydC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy5mcmFnKSB7XG4gICAgICB0aGlzLmZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsZW1lbnREaXJlY3RpdmVzID0ge1xuICBzbG90OiBzbG90LFxuICBwYXJ0aWFsOiBwYXJ0aWFsXG59O1xuXG52YXIgY29udmVydEFycmF5ID0gdkZvci5fcG9zdFByb2Nlc3M7XG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAqL1xuXG5mdW5jdGlvbiBsaW1pdEJ5KGFyciwgbiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgbiA9IHRvTnVtYmVyKG4pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikgOiBhcnI7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxpbWl0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJCeShhcnIsIHNlYXJjaCwgZGVsaW1pdGVyKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoc2VhcmNoKTtcbiAgfVxuICAvLyBjYXN0IHRvIGxvd2VyY2FzZSBzdHJpbmdcbiAgc2VhcmNoID0gKCcnICsgc2VhcmNoKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMjtcbiAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gIHZhciBrZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdG9BcnJheShhcmd1bWVudHMsIG4pKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaXRlbSwga2V5LCB2YWwsIGo7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgdmFsID0gaXRlbSAmJiBpdGVtLiR2YWx1ZSB8fCBpdGVtO1xuICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaikge1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoa2V5ID09PSAnJGtleScgJiYgY29udGFpbnMoaXRlbS4ka2V5LCBzZWFyY2gpIHx8IGNvbnRhaW5zKGdldFBhdGgodmFsLCBrZXkpLCBzZWFyY2gpKSB7XG4gICAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5PFN0cmluZz58RnVuY3Rpb259IC4uLnNvcnRLZXlzXG4gKiBAcGFyYW0ge051bWJlcn0gW29yZGVyXVxuICovXG5cbmZ1bmN0aW9uIG9yZGVyQnkoYXJyKSB7XG4gIHZhciBjb21wYXJhdG9yID0gbnVsbDtcbiAgdmFyIHNvcnRLZXlzID0gdW5kZWZpbmVkO1xuICBhcnIgPSBjb252ZXJ0QXJyYXkoYXJyKTtcblxuICAvLyBkZXRlcm1pbmUgb3JkZXIgKGxhc3QgYXJndW1lbnQpXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICB2YXIgb3JkZXIgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XG4gICAgb3JkZXIgPSBvcmRlciA8IDAgPyAtMSA6IDE7XG4gICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3Muc2xpY2UoMCwgLTEpIDogYXJncztcbiAgfSBlbHNlIHtcbiAgICBvcmRlciA9IDE7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgc29ydEtleXMgJiBjb21wYXJhdG9yXG4gIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGlmICghZmlyc3RBcmcpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGN1c3RvbSBjb21wYXJhdG9yXG4gICAgY29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZmlyc3RBcmcoYSwgYikgKiBvcmRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHN0cmluZyBrZXlzLiBmbGF0dGVuIGZpcnN0XG4gICAgc29ydEtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIsIGkpIHtcbiAgICAgIGkgPSBpIHx8IDA7XG4gICAgICByZXR1cm4gaSA+PSBzb3J0S2V5cy5sZW5ndGggLSAxID8gYmFzZUNvbXBhcmUoYSwgYiwgaSkgOiBiYXNlQ29tcGFyZShhLCBiLCBpKSB8fCBjb21wYXJhdG9yKGEsIGIsIGkgKyAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmUoYSwgYiwgc29ydEtleUluZGV4KSB7XG4gICAgdmFyIHNvcnRLZXkgPSBzb3J0S2V5c1tzb3J0S2V5SW5kZXhdO1xuICAgIGlmIChzb3J0S2V5KSB7XG4gICAgICBpZiAoc29ydEtleSAhPT0gJyRrZXknKSB7XG4gICAgICAgIGlmIChpc09iamVjdChhKSAmJiAnJHZhbHVlJyBpbiBhKSBhID0gYS4kdmFsdWU7XG4gICAgICAgIGlmIChpc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWU7XG4gICAgICB9XG4gICAgICBhID0gaXNPYmplY3QoYSkgPyBnZXRQYXRoKGEsIHNvcnRLZXkpIDogYTtcbiAgICAgIGIgPSBpc09iamVjdChiKSA/IGdldFBhdGgoYiwgc29ydEtleSkgOiBiO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IG9yZGVyIDogLW9yZGVyO1xuICB9XG5cbiAgLy8gc29ydCBvbiBhIGNvcHkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgYXJyYXlcbiAgcmV0dXJuIGFyci5zbGljZSgpLnNvcnQoY29tcGFyYXRvcik7XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnRhaW4gaGVscGVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcbiAqL1xuXG5mdW5jdGlvbiBjb250YWlucyh2YWwsIHNlYXJjaCkge1xuICB2YXIgaTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtrZXlzW2ldXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNvbnRhaW5zKHZhbFtpXSwgc2VhcmNoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaCkgPiAtMTtcbiAgfVxufVxuXG52YXIgZGlnaXRzUkUgPSAvKFxcZHszfSkoPz1cXGQpL2c7XG5cbi8vIGFzc2V0IGNvbGxlY3Rpb25zIG11c3QgYmUgYSBwbGFpbiBvYmplY3QuXG52YXIgZmlsdGVycyA9IHtcblxuICBvcmRlckJ5OiBvcmRlckJ5LFxuICBmaWx0ZXJCeTogZmlsdGVyQnksXG4gIGxpbWl0Qnk6IGxpbWl0QnksXG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGVudFxuICAgKi9cblxuICBqc29uOiB7XG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZCh2YWx1ZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gaW5kZW50IDogMik7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FiYydcbiAgICovXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdhYmMnID0+ICdBQkMnXG4gICAqL1xuXG4gIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdBYkMnID0+ICdhYmMnXG4gICAqL1xuXG4gIGxvd2VyY2FzZTogZnVuY3Rpb24gbG93ZXJjYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIDEyMzQ1ID0+ICQxMiwzNDUuMDBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxzIERlY2ltYWwgcGxhY2VzXG4gICAqL1xuXG4gIGN1cnJlbmN5OiBmdW5jdGlvbiBjdXJyZW5jeSh2YWx1ZSwgX2N1cnJlbmN5LCBkZWNpbWFscykge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgX2N1cnJlbmN5ID0gX2N1cnJlbmN5ICE9IG51bGwgPyBfY3VycmVuY3kgOiAnJCc7XG4gICAgZGVjaW1hbHMgPSBkZWNpbWFscyAhPSBudWxsID8gZGVjaW1hbHMgOiAyO1xuICAgIHZhciBzdHJpbmdpZmllZCA9IE1hdGguYWJzKHZhbHVlKS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICB2YXIgX2ludCA9IGRlY2ltYWxzID8gc3RyaW5naWZpZWQuc2xpY2UoMCwgLTEgLSBkZWNpbWFscykgOiBzdHJpbmdpZmllZDtcbiAgICB2YXIgaSA9IF9pbnQubGVuZ3RoICUgMztcbiAgICB2YXIgaGVhZCA9IGkgPiAwID8gX2ludC5zbGljZSgwLCBpKSArIChfaW50Lmxlbmd0aCA+IDMgPyAnLCcgOiAnJykgOiAnJztcbiAgICB2YXIgX2Zsb2F0ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgtMSAtIGRlY2ltYWxzKSA6ICcnO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgcmV0dXJuIHNpZ24gKyBfY3VycmVuY3kgKyBoZWFkICsgX2ludC5zbGljZShpKS5yZXBsYWNlKGRpZ2l0c1JFLCAnJDEsJykgKyBfZmxvYXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqICdpdGVtJyA9PiAnaXRlbXMnXG4gICAqXG4gICAqIEBwYXJhbXNcbiAgICogIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0b1xuICAgKiAgdGhlIHNpbmdsZSwgZG91YmxlLCB0cmlwbGUgLi4uIGZvcm1zIG9mIHRoZSB3b3JkIHRvXG4gICAqICBiZSBwbHVyYWxpemVkLiBXaGVuIHRoZSBudW1iZXIgdG8gYmUgcGx1cmFsaXplZFxuICAgKiAgZXhjZWVkcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcmdzLCBpdCB3aWxsIHVzZSB0aGUgbGFzdFxuICAgKiAgZW50cnkgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiAgZS5nLiBbJ3NpbmdsZScsICdkb3VibGUnLCAndHJpcGxlJywgJ211bHRpcGxlJ11cbiAgICovXG5cbiAgcGx1cmFsaXplOiBmdW5jdGlvbiBwbHVyYWxpemUodmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlICUgMTAgLSAxO1xuICAgICAgcmV0dXJuIGluZGV4IGluIGFyZ3MgPyBhcmdzW2luZGV4XSA6IGFyZ3NbbGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcmdzWzBdICsgKHZhbHVlID09PSAxID8gJycgOiAncycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVib3VuY2UgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSA9IDMwMFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZGVib3VuY2U6IGZ1bmN0aW9uIGRlYm91bmNlKGhhbmRsZXIsIGRlbGF5KSB7XG4gICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgaWYgKCFkZWxheSkge1xuICAgICAgZGVsYXkgPSAzMDA7XG4gICAgfVxuICAgIHJldHVybiBfZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFsQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFZ1ZSBhbmQgZXZlcnkgY29uc3RydWN0b3IgdGhhdCBleHRlbmRzIFZ1ZSBoYXMgYW5cbiAgICogYXNzb2NpYXRlZCBvcHRpb25zIG9iamVjdCwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIGR1cmluZ1xuICAgKiBjb21waWxhdGlvbiBzdGVwcyBhcyBgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zYC5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHNlZW4gYXMgdGhlIGRlZmF1bHQgb3B0aW9ucyBvZiBldmVyeVxuICAgKiBWdWUgaW5zdGFuY2UuXG4gICAqL1xuXG4gIFZ1ZS5vcHRpb25zID0ge1xuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgZWxlbWVudERpcmVjdGl2ZXM6IGVsZW1lbnREaXJlY3RpdmVzLFxuICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgdHJhbnNpdGlvbnM6IHt9LFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIHBhcnRpYWxzOiB7fSxcbiAgICByZXBsYWNlOiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gICAqL1xuXG4gIFZ1ZS51dGlsID0gdXRpbDtcbiAgVnVlLmNvbmZpZyA9IGNvbmZpZztcbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlWydkZWxldGUnXSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzYWdlIC8gcGx1Z2luc1xuICAgKi9cblxuICBWdWUuY29tcGlsZXIgPSBjb21waWxlcjtcbiAgVnVlLkZyYWdtZW50RmFjdG9yeSA9IEZyYWdtZW50RmFjdG9yeTtcbiAgVnVlLmludGVybmFsRGlyZWN0aXZlcyA9IGludGVybmFsRGlyZWN0aXZlcztcbiAgVnVlLnBhcnNlcnMgPSB7XG4gICAgcGF0aDogcGF0aCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBkaXJlY3RpdmU6IGRpcmVjdGl2ZSxcbiAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gIH07XG5cbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cblxuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbmRPcHRpb25zXG4gICAqL1xuXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIGlzRmlyc3RFeHRlbmQgPSBTdXBlci5jaWQgPT09IDA7XG4gICAgaWYgKGlzRmlyc3RFeHRlbmQgJiYgZXh0ZW5kT3B0aW9ucy5fQ3Rvcikge1xuICAgICAgcmV0dXJuIGV4dGVuZE9wdGlvbnMuX0N0b3I7XG4gICAgfVxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybignSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgKyAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjYXRlcnMgYW5kIHRoZSBoeXBoZW4uJyk7XG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50Jyk7XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvblxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc0ZpcnN0RXh0ZW5kKSB7XG4gICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgIH1cbiAgICByZXR1cm4gU3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN1Yi1jbGFzcyBjb25zdHJ1Y3RvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBuYW1lLiBUaGlzIGdpdmVzIHVzIG11Y2ggbmljZXIgb3V0cHV0IHdoZW5cbiAgICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhuYW1lKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24gJyArIGNsYXNzaWZ5KG5hbWUpICsgJyAob3B0aW9ucykgeyB0aGlzLl9pbml0KG9wdGlvbnMpIH0nKSgpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBQbHVnaW4gc3lzdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cbiAgICovXG5cbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gICAqIG9wdGlvbnMuXG4gICAqL1xuXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIFZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFZ1ZS5vcHRpb25zLCBtaXhpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogc2lnbmF0dXJlOlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHsqfSBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgKGNvbW1vblRhZ1JFLnRlc3QoaWQpIHx8IHJlc2VydmVkVGFnUkUudGVzdChpZCkpKSB7XG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgaWYgKCFkZWZpbml0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZpbml0aW9uID0gVnVlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZXhwb3NlIGludGVybmFsIHRyYW5zaXRpb24gQVBJXG4gIGV4dGVuZChWdWUudHJhbnNpdGlvbiwgdHJhbnNpdGlvbik7XG59XG5cbmluc3RhbGxHbG9iYWxBUEkoVnVlKTtcblxuVnVlLnZlcnNpb24gPSAnMS4wLjI2JztcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluQnJvd3NlciAmJiAvQ2hyb21lXFwvXFxkKy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgIH1cbiAgfVxufSwgMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS8xLjAuMjYvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjEuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA3LTA3VDIxOjQ0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMS4wXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjBcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTAxLTA0XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczpcblx0Ly8gSUU6ICpbZGlzYWJsZWRdOm5vdChidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBvcHRncm91cCwgb3B0aW9uLCBtZW51aXRlbSwgZmllbGRzZXQpXG5cdC8vIG5vdCBJRTogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIENoZWNrIGZvcm0gZWxlbWVudHMgYW5kIG9wdGlvbiBlbGVtZW50cyBmb3IgZXhwbGljaXQgZGlzYWJsaW5nXG5cdFx0cmV0dXJuIFwibGFiZWxcIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cdFx0XHRcImZvcm1cIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdC8vIENoZWNrIG5vbi1kaXNhYmxlZCBmb3JtIGVsZW1lbnRzIGZvciBmaWVsZHNldFtkaXNhYmxlZF0gYW5jZXN0b3JzXG5cdFx0XHRcImZvcm1cIiBpbiBlbGVtICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICYmIChcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2LTExK1xuXHRcdFx0XHQvLyBBbmNlc3RyeSBpcyBjb3ZlcmVkIGZvciB1c1xuXHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBhc3N1bWUgYW55IG5vbi08b3B0aW9uPiB1bmRlciBmaWVsZHNldFtkaXNhYmxlZF0gaXMgZGlzYWJsZWRcblx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0KFwibGFiZWxcIiBpbiBlbGVtIHx8ICFkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkpICE9PSBkaXNhYmxlZFxuXHRcdFx0KTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3QgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdFx0cmVzb2x2ZS5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8gSlNPTi5wYXJzZSggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApLFxuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBpbiBGRiBidXQgZG9uJ3QgYmxvY2sgSUUgcmFkaW8gZXZlbnRzICgjMzg2MSwgZ2gtMjM0Mylcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmXG5cdFx0XHQoIGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiB8fCBpc05hTiggZXZlbnQuYnV0dG9uICkgfHwgZXZlbnQuYnV0dG9uIDwgMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWwsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdHZhbCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbIG5hbWUgXTtcblx0fVxuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gcmFmKCkge1xuXHRpZiAoIHRpbWVySWQgKSB7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICk7XG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3R3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZiBvciBpZiBkb2N1bWVudCBpcyBoaWRkZW5cblx0aWYgKCBqUXVlcnkuZngub2ZmIHx8IGRvY3VtZW50LmhpZGRlbiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/XG5cdFx0XHRcdGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID9cblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApIDpcblx0XHRcdHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSApIHtcblx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRpbWVySWQgKTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR9XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2csXG5cdHJzcGFjZXMgPSAvW1xceDIwXFx0XFxyXFxuXFxmXSsvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKSA6XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICkucmVwbGFjZSggcnNwYWNlcywgXCIgXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1bmNhY2hlZCB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCJcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sIHJlY3QsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHQvLyBNYWtlIHN1cmUgZWxlbWVudCBpcyBub3QgaGlkZGVuIChkaXNwbGF5OiBub25lKVxuXHRcdGlmICggcmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCApIHtcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHRyZXR1cm4gcmVjdDtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXEFwcC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0wNjkyNTEwYi9BcHAudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0FwcC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxufVxcblxcbmRpdi5tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL0FwcC52dWU/MjIxOTRmZTJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNLQTtJQUNBLFVBQUE7Q0FDQTs7QUFFQTs7SUFFQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0Esb0NBQUE7SUFDQSxTQUFBO0lBQ0EsUUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxtQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJBcHAudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAgICAgYmFja2dyb3VuZFxcbiAgICAgICAgbWVudS1iYXIodi1iaW5kOmdhbWUtZGF0YT1cXFwiZ2FtZURhdGFcXFwiLHYtYmluZDpub3RpY2U9XFxcIm5vdGljZVxcXCIsdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiKVxcbiAgICAgICAgYmV0LWFuZC1ib251cyh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIix2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIix2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiLHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIsdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIix2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIilcXG4gICAgICAgIHBsYXktcGFuZWwodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiLHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCIpXFxuICAgICAgICBzdGF0ZSh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIix2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiKVxcbiAgICAgICAgLy8tIGJldC1tdWx0aXBsZVxcbiAgICAgICAgbWVzc2FnZSh2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIilcXG4gICAgICAgIG1vZGFsLm1vZGFsKHYtaWY9XFxcImVycm9yXFxcIilcXG4gICAgICAgIHRpcC1tb2RhbFxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWUnXFxuaW1wb3J0IE1lbnVCYXIgZnJvbSAnLi9jb21wb25lbnRzL01lbnVCYXIudnVlJ1xcbmltcG9ydCBCZXRBbmRCb251cyBmcm9tICcuL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlJ1xcbmltcG9ydCBQbGF5UGFuZWwgZnJvbSAnLi9jb21wb25lbnRzL1BsYXlQYW5lbC52dWUnXFxuaW1wb3J0IFN0YXRlIGZyb20gJy4vY29tcG9uZW50cy9TdGF0ZS52dWUnXFxuaW1wb3J0IEJldE11bHRpcGxlIGZyb20gJy4vY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWUnXFxuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9jb21wb25lbnRzL01lc3NhZ2UudnVlJ1xcbmltcG9ydCBnYW1lRGF0YSBmcm9tICcuL2RhdGEvZGF0YScgLy8gIOWKoOi9veaooeadv+aVsOaNrlxcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuL2pzL3JlcXVlc3QtbGlzdCdcXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcXG4gICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHRoYXQuc2NyZWVuU2l6ZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXFxuICAgICAgICAgICAgdGhhdC5zY3JlZW5TaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5pbml0KClcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdXNlckJldDoge1xcbiAgICAgICAgICAgICAgICBiZXRtb25leTogMTAwMCAvL+m7mOiupOS4i+azqOmHkemineS4ujEwMDBcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGdhbWVEYXRhOiBnYW1lRGF0YSxcXG4gICAgICAgICAgICBsb3R0ZXJ5bnVtOiB7IC8v5byA5aWW57uT5p6cXFxuICAgICAgICAgICAgICAgIGlkOiAnJyxcXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAwLFxcbiAgICAgICAgICAgICAgICBsb3R0ZXJ5bnVtczogJydcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvdW50RG93bjogMzAwLCAvLyDlgJLorqHml7bnp5LmlbBcXG4gICAgICAgICAgICBjb3VudE51bTogMzAwLCAvL+W8gOWlluaXtumXtOmXtOmalCDpu5jorqQz5YiG6ZKfXFxuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxcbiAgICAgICAgICAgIGJldHM6IFtdLCAvLyDkuIvms6jpm4blkIjvvIzlj6/ku6XljZXmrKHkuIvlpJrms6hcXG4gICAgICAgICAgICBub3RpY2U6IHJlcXVpcmUoJy4vZGF0YS9ub3RpY2UnKSxcXG4gICAgICAgICAgICB1c2VyaW5mbzogcmVxdWlyZSgnLi9kYXRhL3NpbmdsZXVzZXInKSxcXG4gICAgICAgICAgICBzdGFnZVNpemU6IHsgLy8g5pW05L2T55S75biD5aSn5bCPLOaJgOacieWPmOWMlue7hOS7tuWGjeasoeWfuuehgOS4iuS5mOS7peaUvuWkp+WAjeeOh1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMDhcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHNjcmVlblNpemU6IHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgaW5pdCgpIHtcXG4gICAgICAgICAgICAvLyDliJ3lp4vljJbor7vlj5bmlbDmja5cXG5cXG4gICAgICAgICAgICAvLyDor7vlj5blvIDlpZbmlbDmja5cXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4ocmVzID0+IHRoaXMubG90dGVyeW51bSA9IHJlcy5kYXRhKVxcbiAgICAgICAgICAgIHRoaXMuZ2V0VXNlckluZm9CeU5ldCgpXFxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluWFrOWRiuaVsOaNrlxcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2dldExhc3ROb3RpY2UnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIHNob3coKSB7fSxcXG4gICAgICAgIGdldFVzZXJJbmZvQnlOZXQoKSB7IC8v5LuO572R57uc6I635Y+WdXNlcuS/oeaBr1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldHVzZXJDb2RlRnJvbU5ldChSZXF1ZXN0TGlzdC5nZXRDb2RlKCkpLnRoZW4ocmVzID0+IHtcXG4gICAgICAgICAgICAgICAgLy8g6I635Y+W55So5oi35pWw5o2uXFxuICAgICAgICAgICAgICAgIHRoYXQudXNlcmluZm8gPSBPYmplY3QuYXNzaWduKHt9LCB0aGF0LnVzZXJpbmZvLCByZXMuZGF0YSlcXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIOeUqOaIt+S/oeaBr+aVsOaNruaooeadv1xcbiAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZWRBdCc6IDE0Njk1NDg2NzUwMDAsXFxuICAgICAgICAgICAgICAgICAgICAnbW9uZXknOiAxMDAwMCxcXG4gICAgICAgICAgICAgICAgICAgICdoZWFkaW1ndXJsJzogJ2h0dHA6Ly90c2UzLm1tLmJpbmcubmV0L3RoP2lkPU9JUC5NYzhjMDNlNjJmNzhjYmNhZDA5Njk3NjM2NDliNmY1MGZvMCZ3PTE1MSZoPTE1MSZjPTcmcnM9MSZxbHQ9OTAmbz00JnBpZD0xLjEnLFxcbiAgICAgICAgICAgICAgICAgICAgJ25pY2tuYW1lJzogJ+aIkeiHquW3sScsXFxuICAgICAgICAgICAgICAgICAgICAnb3BlbmlkJzogJ29nN1Vid0JwMGpoVUh2ZnFjc0tFWTNUN2RUTGsnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdGhhdC4kZW1pdCgnZ2V0VXNlckluZm8nKVxcbiAgICAgICAgICAgIH0sIHJlcyA9PiB7XFxuICAgICAgICAgICAgICAgIHRoYXQudXNlcmluZm8gPSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyDnlKjmiLfkv6Hmga/mlbDmja7mqKHmnb9cXG4gICAgICAgICAgICAgICAgICAgICdjcmVhdGVkQXQnOiAxNDY5NTQ4Njc1MDAwLFxcbiAgICAgICAgICAgICAgICAgICAgJ21vbmV5JzogMTAwMDAwMCxcXG4gICAgICAgICAgICAgICAgICAgICdoZWFkaW1ndXJsJzogJ2h0dHA6Ly90c2UzLm1tLmJpbmcubmV0L3RoP2lkPU9JUC5NYzhjMDNlNjJmNzhjYmNhZDA5Njk3NjM2NDliNmY1MGZvMCZ3PTE1MSZoPTE1MSZjPTcmcnM9MSZxbHQ9OTAmbz00JnBpZD0xLjEnLFxcbiAgICAgICAgICAgICAgICAgICAgJ25pY2tuYW1lJzogJ+aIkeiHquW3sScsXFxuICAgICAgICAgICAgICAgICAgICAnb3BlbmlkJzogJ29nN1Vid0JwMGpoVUh2ZnFjc0tFWTNUN2RUTGsnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZGF0YSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgem9vbVJhdGUoKSB7IC8vIOWIneWni+WMluaUvuWkp+WAjeeOh1xcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zY3JlZW5TaXplLndpZHRoIC8gdGhpcy5zdGFnZVNpemUud2lkdGhcXG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuc2NyZWVuU2l6ZS5oZWlnaHQgLyB0aGlzLnN0YWdlU2l6ZS5oZWlnaHRcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB4OiB4LFxcbiAgICAgICAgICAgICAgICB5OiB5XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGxvY2ttb25leSgpIHsgLy/plIHlrprph5Hpop1cXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iZXRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmJldHNbaV0uYmV0bW9uZXlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdzaG93TWVzc2FnZScsIGV2ZW50KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGdldFVzZXJJbmZvKGV2ZW50KSB7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0dXNlcmluZm8oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJpbmZvKSkpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlcy5kYXRhKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQudXNlcmluZm8gPSBPYmplY3QuYXNzaWduKHt9LCB0aGF0LnVzZXJpbmZvLCByZXMuZGF0YSlcXG4gICAgICAgICAgICAgICAgICAgIC8vIOaVsOaNruW6k+ayoeacieS/neWtmOWktOWDj+WxnuaAp++8jOaJgOS7peS4jeiuvue9ruWktOWDj+WxnuaAp1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mby5vcGVuaWQgPSByZXMuZGF0YS5vcGVuaWRcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXNlcmluZm8ubmlja25hbWUgPSByZXMuZGF0YS5uaWNrbmFtZVxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mby5tb25leSA9IHJlcy5kYXRhLm1vbmV5XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVzZXJCZXQudXNlcmluZm9PcGVuaWQgPSByZXMuZGF0YS5vcGVuaWRcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHt9XFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXRMYXN0Tm90aWNlKGV2ZW50KSB7XFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0TGFzdE5vdGljZSgpLnRoZW4ocmVzID0+IHRoaXMubm90aWNlID0gcmVzLmRhdGEsIHJlcyA9PiBjb25zb2xlLmVycm9yKHJlcykpXFxuICAgICAgICB9LFxcbiAgICAgICAgY2FuY2VsYmV0KGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjYW5jZWxCZXQnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIHJlbG9hZGluZm8oZXZlbnQpIHtcXG4gICAgICAgICAgICB0aGlzLmluaXQoKVxcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIOinpuWPkemUmeivr++8jOW5tuaJk+W8gOmBrue9qeWxglxcbiAgICAgICAgZXJyb3IoKSB7XFxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRydWVcXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdzaG93VGlwJywgZXZlbnQpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgICdtb2RhbCc6IHtcXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XFxcIm1vZGFsXFxcIj48L2Rpdj4nXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3RpcC1tb2RhbCc6IHJlcXVpcmUoJy4vY29tcG9uZW50cy90aXAtbW9kYWwudnVlJyksXFxuICAgICAgICAnYmFja2dyb3VuZCc6IEJhY2tncm91bmQsXFxuICAgICAgICAnbWVudS1iYXInOiBNZW51QmFyLFxcbiAgICAgICAgJ2JldC1hbmQtYm9udXMnOiBCZXRBbmRCb251cyxcXG4gICAgICAgICdwbGF5LXBhbmVsJzogUGxheVBhbmVsLFxcbiAgICAgICAgJ3N0YXRlJzogU3RhdGUsXFxuICAgICAgICAnYmV0LW11bHRpcGxlJzogQmV0TXVsdGlwbGUsXFxuICAgICAgICAnbWVzc2FnZSc6IE1lc3NhZ2VcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuYm9keSB7XFxuICAgIG1hcmdpbjogMDtcXG59XFxuXFxuaHRtbCxcXG5ib2R5IHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4udGFibGUge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG59XFxuXFxuZGl2Lm1vZGFsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC42KTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHotaW5kZXg6IDk5OTtcXG59XFxuXFxuLnRhYmxlLWNlbGwge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbztcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH07XG5cdH0sXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0aWYgKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcblx0XHQvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG5cdFx0Y3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nO1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICAgIG1lbnUtYmFyKHYtYmluZDpnYW1lLWRhdGE9XCJnYW1lRGF0YVwiLHYtYmluZDpub3RpY2U9XCJub3RpY2VcIix2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIilcbiAgICAgICAgYmV0LWFuZC1ib251cyh2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIix2LWJpbmQ6dXNlcmluZm89XCJ1c2VyaW5mb1wiLHYtYmluZDp1c2VyLWJldD1cInVzZXJCZXRcIix2LWJpbmQ6YmV0cy5zeW5jPVwiYmV0c1wiLHYtYmluZDpsb2NrbW9uZXk9XCJsb2NrbW9uZXlcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cImVycm9yXCIsdi1iaW5kOmxvdHRlcnludW0uc3luYz1cImxvdHRlcnludW1cIix2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVwiY291bnREb3duXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVwiY291bnROdW1cIilcbiAgICAgICAgcGxheS1wYW5lbCh2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIix2LWJpbmQ6dXNlcmluZm89XCJ1c2VyaW5mb1wiLHYtYmluZDp1c2VyLWJldD1cInVzZXJCZXRcIix2LWJpbmQ6YmV0cy5zeW5jPVwiYmV0c1wiLHYtYmluZDpsb2NrbW9uZXk9XCJsb2NrbW9uZXlcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cImVycm9yXCIsdi1iaW5kOmxvdHRlcnludW0uc3luYz1cImxvdHRlcnludW1cIix2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVwiY291bnREb3duXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVwiY291bnROdW1cIilcbiAgICAgICAgc3RhdGUodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cImVycm9yXCIpXG4gICAgICAgIC8vLSBiZXQtbXVsdGlwbGVcbiAgICAgICAgbWVzc2FnZSh2LWJpbmQ6em9vbS1yYXRlPVwiem9vbVJhdGVcIix2LWJpbmQ6dXNlcmluZm89XCJ1c2VyaW5mb1wiLHYtYmluZDpiZXRzLnN5bmM9XCJiZXRzXCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiKVxuICAgICAgICBtb2RhbC5tb2RhbCh2LWlmPVwiZXJyb3JcIilcbiAgICAgICAgdGlwLW1vZGFsXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gJy4vY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZSdcbmltcG9ydCBNZW51QmFyIGZyb20gJy4vY29tcG9uZW50cy9NZW51QmFyLnZ1ZSdcbmltcG9ydCBCZXRBbmRCb251cyBmcm9tICcuL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlJ1xuaW1wb3J0IFBsYXlQYW5lbCBmcm9tICcuL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZSdcbmltcG9ydCBTdGF0ZSBmcm9tICcuL2NvbXBvbmVudHMvU3RhdGUudnVlJ1xuaW1wb3J0IEJldE11bHRpcGxlIGZyb20gJy4vY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWUnXG5pbXBvcnQgTWVzc2FnZSBmcm9tICcuL2NvbXBvbmVudHMvTWVzc2FnZS52dWUnXG5pbXBvcnQgZ2FtZURhdGEgZnJvbSAnLi9kYXRhL2RhdGEnIC8vICDliqDovb3mqKHmnb/mlbDmja5cbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuL2pzL3JlcXVlc3QtbGlzdCdcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogW10sXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGxldCB0aGF0ID0gdGhpc1xuICAgICAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuc2NyZWVuU2l6ZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KClcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQmV0OiB7XG4gICAgICAgICAgICAgICAgYmV0bW9uZXk6IDEwMDAgLy/pu5jorqTkuIvms6jph5Hpop3kuLoxMDAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2FtZURhdGE6IGdhbWVEYXRhLFxuICAgICAgICAgICAgbG90dGVyeW51bTogeyAvL+W8gOWllue7k+aenFxuICAgICAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IDAsXG4gICAgICAgICAgICAgICAgbG90dGVyeW51bXM6ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY291bnREb3duOiAzMDAsIC8vIOWAkuiuoeaXtuenkuaVsFxuICAgICAgICAgICAgY291bnROdW06IDMwMCwgLy/lvIDlpZbml7bpl7Tpl7TpmpQg6buY6K6kM+WIhumSn1xuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgYmV0czogW10sIC8vIOS4i+azqOmbhuWQiO+8jOWPr+S7peWNleasoeS4i+WkmuazqFxuICAgICAgICAgICAgbm90aWNlOiByZXF1aXJlKCcuL2RhdGEvbm90aWNlJyksXG4gICAgICAgICAgICB1c2VyaW5mbzogcmVxdWlyZSgnLi9kYXRhL3NpbmdsZXVzZXInKSxcbiAgICAgICAgICAgIHN0YWdlU2l6ZTogeyAvLyDmlbTkvZPnlLvluIPlpKflsI8s5omA5pyJ5Y+Y5YyW57uE5Lu25YaN5qyh5Z+656GA5LiK5LmY5Lul5pS+5aSn5YCN546HXG4gICAgICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMDhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JlZW5TaXplOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIC8vIOWIneWni+WMluivu+WPluaVsOaNrlxuXG4gICAgICAgICAgICAvLyDor7vlj5blvIDlpZbmlbDmja5cbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzTnVtKCkudGhlbihyZXMgPT4gdGhpcy5sb3R0ZXJ5bnVtID0gcmVzLmRhdGEpXG4gICAgICAgICAgICB0aGlzLmdldFVzZXJJbmZvQnlOZXQoKVxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluWFrOWRiuaVsOaNrlxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZ2V0TGFzdE5vdGljZScpXG4gICAgICAgIH0sXG4gICAgICAgIHNob3coKSB7fSxcbiAgICAgICAgZ2V0VXNlckluZm9CeU5ldCgpIHsgLy/ku47nvZHnu5zojrflj5Z1c2Vy5L+h5oGvXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldHVzZXJDb2RlRnJvbU5ldChSZXF1ZXN0TGlzdC5nZXRDb2RlKCkpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAvLyDojrflj5bnlKjmiLfmlbDmja5cbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8g55So5oi35L+h5oGv5pWw5o2u5qih5p2/XG4gICAgICAgICAgICAgICAgICAgICdjcmVhdGVkQXQnOiAxNDY5NTQ4Njc1MDAwLFxuICAgICAgICAgICAgICAgICAgICAnbW9uZXknOiAxMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgJ2hlYWRpbWd1cmwnOiAnaHR0cDovL3RzZTMubW0uYmluZy5uZXQvdGg/aWQ9T0lQLk1jOGMwM2U2MmY3OGNiY2FkMDk2OTc2MzY0OWI2ZjUwZm8wJnc9MTUxJmg9MTUxJmM9NyZycz0xJnFsdD05MCZvPTQmcGlkPTEuMScsXG4gICAgICAgICAgICAgICAgICAgICduaWNrbmFtZSc6ICfmiJHoh6rlt7EnLFxuICAgICAgICAgICAgICAgICAgICAnb3BlbmlkJzogJ29nN1Vid0JwMGpoVUh2ZnFjc0tFWTNUN2RUTGsnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcbiAgICAgICAgICAgIH0sIHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8g55So5oi35L+h5oGv5pWw5o2u5qih5p2/XG4gICAgICAgICAgICAgICAgICAgICdjcmVhdGVkQXQnOiAxNDY5NTQ4Njc1MDAwLFxuICAgICAgICAgICAgICAgICAgICAnbW9uZXknOiAxMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICAnaGVhZGltZ3VybCc6ICdodHRwOi8vdHNlMy5tbS5iaW5nLm5ldC90aD9pZD1PSVAuTWM4YzAzZTYyZjc4Y2JjYWQwOTY5NzYzNjQ5YjZmNTBmbzAmdz0xNTEmaD0xNTEmYz03JnJzPTEmcWx0PTkwJm89NCZwaWQ9MS4xJyxcbiAgICAgICAgICAgICAgICAgICAgJ25pY2tuYW1lJzogJ+aIkeiHquW3sScsXG4gICAgICAgICAgICAgICAgICAgICdvcGVuaWQnOiAnb2c3VWJ3QnAwamhVSHZmcWNzS0VZM1Q3ZFRMaydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZGF0YSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHpvb21SYXRlKCkgeyAvLyDliJ3lp4vljJbmlL7lpKflgI3njodcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zY3JlZW5TaXplLndpZHRoIC8gdGhpcy5zdGFnZVNpemUud2lkdGhcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd01lc3NhZ2UnLCBldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0dXNlcmluZm8oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJpbmZvKSkpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC8vIOaVsOaNruW6k+ayoeacieS/neWtmOWktOWDj+WxnuaAp++8jOaJgOS7peS4jeiuvue9ruWktOWDj+WxnuaAp1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvLm9wZW5pZCA9IHJlcy5kYXRhLm9wZW5pZFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvLm5pY2tuYW1lID0gcmVzLmRhdGEubmlja25hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mby5tb25leSA9IHJlcy5kYXRhLm1vbmV5XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXNlckJldC51c2VyaW5mb09wZW5pZCA9IHJlcy5kYXRhLm9wZW5pZFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0TGFzdE5vdGljZSgpLnRoZW4ocmVzID0+IHRoaXMubm90aWNlID0gcmVzLmRhdGEsIHJlcyA9PiBjb25zb2xlLmVycm9yKHJlcykpXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdjYW5jZWxCZXQnKVxuICAgICAgICB9LFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKVxuICAgICAgICB9LFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcbiAgICAgICAgZXJyb3IoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBzaG93VGlwKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dUaXAnLCBldmVudClcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnbW9kYWwnOiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJtb2RhbFwiPjwvZGl2PidcbiAgICAgICAgfSxcbiAgICAgICAgJ3RpcC1tb2RhbCc6IHJlcXVpcmUoJy4vY29tcG9uZW50cy90aXAtbW9kYWwudnVlJyksXG4gICAgICAgICdiYWNrZ3JvdW5kJzogQmFja2dyb3VuZCxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcbiAgICAgICAgJ2JldC1hbmQtYm9udXMnOiBCZXRBbmRCb251cyxcbiAgICAgICAgJ3BsYXktcGFuZWwnOiBQbGF5UGFuZWwsXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxuICAgICAgICAnYmV0LW11bHRpcGxlJzogQmV0TXVsdGlwbGUsXG4gICAgICAgICdtZXNzYWdlJzogTWVzc2FnZVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuYm9keSB7XG4gICAgbWFyZ2luOiAwO1xufVxuXG5odG1sLFxuYm9keSB7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4udGFibGUge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xufVxuXG5kaXYubW9kYWwge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XG4gICAgdG9wOiAwcHg7XG4gICAgbGVmdDogMDtcbiAgICB6LWluZGV4OiA5OTk7XG59XG5cbi50YWJsZS1jZWxsIHtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEFwcC52dWU/MjIxOTRmZTJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9iYWJlbC1ydW50aW1lLzYuOS4yL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmFja2dyb3VuZC52dWVcIilcbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTc2NThkNmRlL0JhY2tncm91bmQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYudXAtYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDg5JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKSBzb2xpZDtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXCIpICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuYnV0dG9tLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiAxMSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKmJhY2tncm91bmQ6IHdoaXRlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT9iMjkwODVhZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7QUFNQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxZQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLGlEQUFBO0lBQ0EsMENBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSx1QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLHNCQUFBO0lBQ0EsdUJBQUE7SUFDQSw2QkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJCYWNrZ3JvdW5kLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgZGl2LmJhY2tncm91bmRcXG4gICAgXFx0ZGl2LnVwLWJhY2tncm91bmRcXG4gICAgXFx0ZGl2LmJ1dHRvbS1iYWNrZ3JvdW5kXFxuPC90ZW1wbGF0ZT5cXG48c3R5bGU+XFxuLmJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LnVwLWJhY2tncm91bmQge1xcbiAgICAvKnBvc2l0aW9uOiBhYnNvbHV0ZTsqL1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgaGVpZ2h0OiA4OSU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3JkZXItYm90dG9tOiAycHggcmdiYSgyNTUsIDI1NSwgMjU1LCAuMykgc29saWQ7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9kb2NrLnBuZyk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5idXR0b20tYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDExJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogd2hpdGU7Ki9cXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjRiNGE2NjA5Yjk4OTY1NWE0ZDY3ZjI0NWJkNTdlNDFkLnBuZ1wiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvQkcucG5nXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQmxDQUlBQUFBREVoNlNBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVSa015UkRrNVJqTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNVJrTXlSRGxCTUROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2psR1F6SkVPVGxFTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamxHUXpKRU9UbEZNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt5RGExSXdBQUFCeEpSRUZVZU5waXNBcnNaR0pnWUdCKy8vRWJpQjdGQTQ4QkFnd0FyN2dFdE9qSDlRUUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kXFxcIj48ZGl2IGNsYXNzPVxcXCJ1cC1iYWNrZ3JvdW5kXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJidXR0b20tYmFja2dyb3VuZFxcXCI+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZW51QmFyLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWVudUJhci52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcTWVudUJhci52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtYTVmYTUwOTgvTWVudUJhci52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVudUJhci52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ubWVudSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiA1JTtcXG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XFxuICAgIGJhY2tncm91bmQ6ICNlMTRmNTA7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbmRpdi5ub3RpY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA2MCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEuNWVtO1xcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xcbiAgICBjb2xvcjogIzc4M2EzZjtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lm9wdGlvbiB7XFxuICAgIHdpZHRoOiAxMiU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICAgIC8qIGJvcmRlcjouMTVlbSBzb2xpZCAjZmNkMTllO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xcbiAgICAvKmJhY2tncm91bmQ6ICNmZjllNDA7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWU/NTQyYjk2ZmFcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7SUFDQSxtQkFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxxQkFBQTtJQUNBLG9CQUFBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLGFBQUE7SUFDQTsyQkFDQTtJQUNBLHdCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1lbnVCYXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy3oj5zljZXpg6jliIZcXG4gICAgZGl2Lm1lbnVcXG4gICAgICAgIGRpdi5ub3RpY2VcXG4gICAgICAgICAgICB0YWJsZVxcbiAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgdGRcXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuKHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcXG4gICAgICAgIGRpdi5vcHRpb24oQHRvdWNoZW5kPVxcXCJ0cmlnZ2VyT3B0aW9uXFxcIilcXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIix2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBPcHRpb25zRGlhbG9nIGZyb20gJy4vT3B0aW9uc0RpYWxvZy52dWUnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZScsICdub3RpY2UnXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcXG4gICAgfSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgbmFtZTogJ2xpdScsXFxuICAgICAgICAgICAgaXNTaG93T3B0aW9uOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgndHJpZ2dlck9wdGlvbicpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgICdvcHRpb25zLWRpYWxvZyc6IE9wdGlvbnNEaWFsb2dcXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLm1lbnUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogNSU7XFxuICAgIHBhZGRpbmc6IDElIDMlIDElIDElO1xcbiAgICBiYWNrZ3JvdW5kOiAjZTE0ZjUwO1xcbiAgICB6LWluZGV4OiAxO1xcbn1cXG5cXG5kaXYubm90aWNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogNjAlO1xcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcXG4gICAgYmFja2dyb3VuZDogI2VlYmViZTtcXG4gICAgY29sb3I6ICM3ODNhM2Y7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmRpdi5vcHRpb24ge1xcbiAgICB3aWR0aDogMTIlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogYmxhY2s7Ki9cXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMC41ZW07Ki9cXG4gICAgLypiYWNrZ3JvdW5kOiAjZmY5ZTQwOyovXFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEMEFBQUEwQ0FZQUFBQTViVEFoQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSTVRek5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVJNVJETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qY3dNemcxTVVaR00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pjd016ZzFNakF3TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrbXJwNU1nQUFCa0pKUkVGVWVOcnNXMmxzVkZVVS91NTBZTHBDTnlpRnNwUkM2VmdzRmFSb0VJd1NqWWdvbUFJbDRoSmMvZ0FhLzJoaWpJa3g4WWNtR3FLb01XQVFrYUFnQ0NvcWFBeTdwVURaV2twWEtFc0RwUXVkbG5aS1o2N24zRGN6bmFtZGVhM08xSm5CazN6dGZlK2V6cDN2blh2UGN0K3RrTVhyMFlzTUppeHc0RjdDU01lOVlKZFd3aVZDTVdFN1lRZHluKzNzcVNSNkliMlE4QjVoQWtKZktnbXZGOHhldGMwYjZRakN1NFRYMUZWN0l6MjNxOEROZXFETENraDc4Rk0wR0FHakNZaE9CbUtHQTFHSnpoNDI0aHRFM3NZWFJyYy82U1o4dlF4b09oOTZkclhkMG1CdDFiNS8vRGhnV0JaY3ZNanE3cGJPSjJ4UnR5LytDWFEwSTJ3a01oNFlmWS96YWhGWmV5dVRaZ2RWUlVoRC9WbWcrVHpDVHBURnpkeTZUQmpQMDN1UklueXpnYVpFamU3Znk5U3BRT2Fqa0FrWm1sTm9vdWRWdmd1aTduandrbVpldk1hamswYlIxV0tqSXl3QmxqcW01SnR3OWhKSTgwTFBlOE95NlNrU3ptNkhLUGttZUlsYnJqQnBiaTFnMHRQVnpiWnJ4RUQ2dEhCUHdoNzkzTmRZQVhIbG1NdVR5cHhsa0dOblVZU1BEU3loemphSUMvc2dUbTBFN0YyOTY3VFZPMXQzRytqSENOWHNhbmRZMmdzeUg5TWZmT0k4bDc3TWVRcHk0dHpBRTFhcFZJd2FTMll2OXY3OUZUOGxxVXphcEpwMm0yWnBMNUNKNC9YWE8rczQ5Y2ZPSHZBWkxNZlA4YzdCYm5NOUlyYzRMZjB3clBEVDUvd3I2dm81VExldTlBblJXS1ZQdWJHeVcvLzgzZ0duSzZwLzg4M2piNlI5cldmR3VSLzBSMVU2bXI0NCtTVkUrVS9rWkZvRHo1Ykc0TEhFNlUwNlBEUXhlbGphMTFPOGZBUW8zUXA1UjM3di9kU25kTnhTUW5GOHJVS3dTYi9XdEFvSkRlWEFwUG5rdENZNnBuUUZXWGduRVM0S21RU3R6NVoyRWI5VVNCVnJvWEpab1NwKzl0NGhaMm43N1VpNmI1YVdvMllBNWdXUVNZNDEzVkNoNWQzdVRpeWNwcmVjOGd6azVBTFBleWs1QU9QTVpncFRHOExMMG16aG5vUTkrcm52ZXBubTZKd0Z4OVFYS0RWOGtCSy91TURINmVyZnRmRG9yZUQ0SnhrWmZGUllMc2xhMkoxN1QzMGVNdXVKd0JOVzJYU3NHa3RPZWJxL0dabmRKMlJTcHY3MFZ6b08vZlE1QTU5MVQ1aXJ3NlBmanF3UGprNzAzU0VHam5sL0NnNmQzRnR3SnFiSCtmcTVidjNxUFFOZmNGVHU2bS91clJPblM3Y0FJM0wxZFJ5Zkk0NStwbjFzeGtNRDRNZ3NFRlY3eUpHdDYxTyswZmVDby9ZUVFMazNid0Y1eTh1VmpudkJVZmlSUW1nWEhCd1NlSnM0T3g4eTJleVkwblJkc2dYaTRxRXdMamhxRHdDRThDZzQ1TzFZY09EL2dzTjdHQnd6RTZDVTAyTk5jOTVkZXpCTUM0NXBMMEhtUHVkNWoxL3pNRTZzaHpqMmVaZ1ZIR1Robm9ROStybnZXb25tNkZUYU13aHl4a3BLRFI4QlRFTUN5OEpLY2JyeVp3cVBIOU1xdmVYSGdtUHlVdjNCdWRKeUZoeDVLN1EzRG9FbXpHS0tVMlBKYVMvNmR3dFlhcTg2ZmM4R3BlUFE1MWM2QTUxMmMxWG56eTFnZnliOC8zbkJZZXV5ZGFoV3hDRGZCVWQ5cVg3aW9uUWMraFc3QnI3Z0tQdmVPd2VEd1ZGaXlDNURwL1ZXazdvYUZPMTdQWnphcEQ4cTZ6aGY2eHhlRFVHaEROYVd3TE9sTVhnc2NlUlQ3OS9mR0sycFdqdWJqVGVhTExWUk1aR3BHSkttblNqeTloUXY3QVdvaXVFZGtkN3o4bldhaml2WDZZUTQrTDVDVUVqOEdQV3J1YUdsT21KZWRrWnVlbVphbmpxT2RNMzNGRlp2TVhnZkxDb0ppRTVVKzFHaTdvUkdyblJyY0FmbnNmY0JrVU5SdFAvMERyRjhaRXJCSjkrOXM4WVVPVGdSTlg4QWRjWGhsM2VtM2dXa1B3QnJSMmZqeXZ5M1hqRzBXVzYyN3Z2MXlGZXFrem9RbDZvYnZrSUt6SWQ1a1RCUFMwdGJTOFJrazJsNDhlRVNTODUwc3lscGVFSW1VdTdVVGdqeXdaUlFsNUdVSGs5NlhEWEx6OVQ4K01HYmEzK2g1bFVtemI1ODlJRTlSMHR5ODh5eENjbERNNUNRRGd4TjA0NGRkbEZFczNVaEpONTFpUWhhdDVRQkptY0I0KzUzYlc5Vm43dTQrKzJYVjM5dHQ5bVpSS2xZRWhmSHBPY1RsRTlmL3VxaXZGa1A1eTBsajU0UzZvWnViK3U0dW45MzBlWXZQdnkyMEhtTHNGTWRreXlZdllyOStVeW5ja3hzbEhIWmlpZG5tS2RrVEk5UEdwSnVNZzFPRkFaK2pNRXRsSGpZS0E0M1VsaXFPWHV5cW1qam1tMkZiYTN0N3E4OHVQNnRkWjBDSnVJOEY4d0lYNkhDSHlmVUtxRHA3Vm9SQkZyNXlBeER3aFdFWTA3SHhJN012WlBQU3Q0Z0pNQjV2aXkweFVMZ2N5RmxIdjdPemRJOTYyeGU1K1RDd1NmRm96ekwwS0FWdThOWmNUN04vOVpRMjl2bTMxOENEQUFxOVd5Z3dnZEVaZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8t6I+c5Y2V6YOo5YiGXG4gICAgZGl2Lm1lbnVcbiAgICAgICAgZGl2Lm5vdGljZVxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICB0ZFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbih2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6MjYqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD0nbm90aWNlLnRpdGxlJylcbiAgICAgICAgZGl2Lm9wdGlvbihAdG91Y2hlbmQ9XCJ0cmlnZ2VyT3B0aW9uXCIpXG4gICAgICAgIG9wdGlvbnMtZGlhbG9nKHYtYmluZDpnYW1lLWRhdGE9XCJnYW1lRGF0YVwiLHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgT3B0aW9uc0RpYWxvZyBmcm9tICcuL09wdGlvbnNEaWFsb2cudnVlJ1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ2dhbWVEYXRhJywgJ3pvb21SYXRlJywgJ25vdGljZSddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhLm5vdGljZSlcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAnbGl1JyxcbiAgICAgICAgICAgIGlzU2hvd09wdGlvbjogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICB0cmlnZ2VyT3B0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd0cmlnZ2VyT3B0aW9uJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICAnb3B0aW9ucy1kaWFsb2cnOiBPcHRpb25zRGlhbG9nXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubWVudSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGhlaWdodDogNSU7XG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XG4gICAgYmFja2dyb3VuZDogI2UxNGY1MDtcbiAgICB6LWluZGV4OiAxO1xufVxuXG5kaXYubm90aWNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDYwJTtcbiAgICBib3JkZXItcmFkaXVzOiAxLjVlbTtcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xuICAgIGNvbG9yOiAjNzgzYTNmO1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuZGl2Lm9wdGlvbiB7XG4gICAgd2lkdGg6IDEyJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xuICAgIGZsb2F0OiByaWdodDtcbiAgICAvKiBib3JkZXI6LjE1ZW0gc29saWQgI2ZjZDE5ZTtcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xuICAgIC8qYmFja2dyb3VuZDogI2ZmOWU0MDsqL1xuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZUucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1lbnVCYXIudnVlPzU0MmI5NmZhXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9PcHRpb25zRGlhbG9nLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcT3B0aW9uc0RpYWxvZy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtM2QyNzE0MDYvT3B0aW9uc0RpYWxvZy52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9PcHRpb25zRGlhbG9nLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5kaXYucG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogMjAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKSByZ2JhKDAsIDAsIDAsIDApICNmZWQwOTUgcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuXFxuXFxuLyog5b+F6ZyAICovXFxuXFxuLmV4cGFuZC10cmFuc2l0aW9uIHtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzUzZGRlYThlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsaUJBQUE7SUFDQSxpQkFBQTtJQUNBLG1CQUFBO0lBQ0EseUVBQUE7Q0FDQTs7O0FBR0EsUUFBQTs7QUFFQTtJQUNBLGlDQUFBO0lBQUEseUJBQUE7SUFDQSxpQkFBQTtJQUNBLGtCQUFBO0lBQ0EsMkJBQUE7SUFDQSxpQkFBQTtDQUNBOzs7QUFHQSw2QkFBQTs7O0FBR0EsNkJBQUE7O0FBRUE7O0lBRUEsVUFBQTtJQUNBLG9CQUFBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLDZCQUFBO0lBQ0EsbUJBQUE7SUFDQSxtQkFBQTtJQUNBLHlFQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSxvQkFBQTtJQUNBLG1CQUFBO0lBQ0Esb0JBQUE7SUFDQSw0QkFBQTtDQUNBOztBQUVBO0lBQ0EsY0FBQTtJQUNBLG1DQUFBO0NBQ0FcIixcImZpbGVcIjpcIk9wdGlvbnNEaWFsb2cudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g5Y+z5LiK5L6n6YCJ6aG55YiX6KGoXFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XFxcImlzT3B0aW9uU2hvd1xcXCIsdHJhbnNpdGlvbj1cXFwiZXhwYW5kXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm9wdGlvblN0eWxlXFxcIilcXG4gICAgICAgIC8vLSBpbWcodi1iaW5kOnNyYz1cXFwibWVudUltZ1xcXCIpXFxuICAgICAgICBkaXYucG9pbnRlclxcbiAgICAgICAgZGl2LmlubmVyLXBvaW50ZXJcXG4gICAgICAgIGRpdi5vcHRpb24taXRlbSh2LWh0bWw9XFxcIm5cXFwiLHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiLEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEpXFxuICAgICAgICB9LFxcbiAgICAgICAgcHJvcHM6IFsnZ2FtZURhdGEnLCAnem9vbVJhdGUnXSxcXG4gICAgICAgIGRhdGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaXNPcHRpb25TaG93OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgbWVudUltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZycpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBpdGVtU3R5bGUoKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMjYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbWV0aG9kczoge1xcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gZmFsc2VcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGV2ZW50czoge1xcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25TaG93ID0gIXRoaXMuaXNPcHRpb25TaG93XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuZGl2LnBvaW50ZXIge1xcbiAgICBoZWlnaHQ6IDBweDtcXG4gICAgd2lkdGg6IDBweDtcXG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcXG4gICAgbWFyZ2luLWxlZnQ6IDIwJTtcXG4gICAgbWFyZ2luLXRvcDogLTFlbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmVkMDk1IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcblxcbi8qIOW/hemcgCAqL1xcblxcbi5leHBhbmQtdHJhbnNpdGlvbiB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgLypoZWlnaHQ6IDMwcHg7Ki9cXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXFxuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG5cXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xcblxcblxcbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXFxuXFxuLmV4cGFuZC1lbnRlcixcXG4uZXhwYW5kLWxlYXZlIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICAvKnBhZGRpbmc6IDAgMTBweDsqL1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cXG5kaXYuaW5uZXItcG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xcbiAgICBtYXJnaW4tdG9wOiAtMC45ZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5kaXYub3B0aW9uLWxpc3Qge1xcbiAgICAvKndpZHRoOiAzMCU7Ki9cXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xcbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XFxuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcXG59XFxuXFxuZGl2Lm9wdGlvbi1pdGVtIHtcXG4gICAgcGFkZGluZzogLjVlbTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0MjtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8tIOWPs+S4iuS+p+mAiemhueWIl+ihqFxuICAgIGRpdi5vcHRpb24tbGlzdCh2LXNob3c9XCJpc09wdGlvblNob3dcIix0cmFuc2l0aW9uPVwiZXhwYW5kXCIsdi1iaW5kOnN0eWxlPVwib3B0aW9uU3R5bGVcIilcbiAgICAgICAgLy8tIGltZyh2LWJpbmQ6c3JjPVwibWVudUltZ1wiKVxuICAgICAgICBkaXYucG9pbnRlclxuICAgICAgICBkaXYuaW5uZXItcG9pbnRlclxuICAgICAgICBkaXYub3B0aW9uLWl0ZW0odi1odG1sPVwiblwiLHYtZm9yPVwibiBpbiBnYW1lRGF0YS5vcHRpb25zXCIsQHRvdWNoZW5kPVwic2hvd01lc3NhZ2UoJGluZGV4KVwiLHYtYmluZDpzdHlsZT1cIml0ZW1TdHlsZVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVhZHkoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVEYXRhKVxuICAgICAgICB9LFxuICAgICAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZSddLFxuICAgICAgICBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc09wdGlvblNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lbnVJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmcnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZDoge1xuICAgICAgICAgICAgb3B0aW9uU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxMiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyNiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSAhdGhpcy5pc09wdGlvblNob3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5kaXYucG9pbnRlciB7XG4gICAgaGVpZ2h0OiAwcHg7XG4gICAgd2lkdGg6IDBweDtcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xuICAgIG1hcmdpbi1sZWZ0OiAyMCU7XG4gICAgbWFyZ2luLXRvcDogLTFlbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZlZDA5NSByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5cbi8qIOW/hemcgCAqL1xuXG4uZXhwYW5kLXRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcbiAgICAvKmhlaWdodDogMzBweDsqL1xuICAgIC8qcGFkZGluZzogMTBweDsqL1xuICAgIC8qYmFja2dyb3VuZC1jb2xvcjogI2VlZTsqL1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cblxuLyogLmV4cGFuZC1lbnRlciDlrprkuYnov5vlhaXnmoTlvIDlp4vnirbmgIEgKi9cblxuXG4vKiAuZXhwYW5kLWxlYXZlIOWumuS5ieemu+W8gOeahOe7k+adn+eKtuaAgSAqL1xuXG4uZXhwYW5kLWVudGVyLFxuLmV4cGFuZC1sZWF2ZSB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIC8qcGFkZGluZzogMCAxMHB4OyovXG4gICAgb3BhY2l0eTogMDtcbn1cblxuZGl2LmlubmVyLXBvaW50ZXIge1xuICAgIGhlaWdodDogMHB4O1xuICAgIHdpZHRoOiAwcHg7XG4gICAgYm9yZGVyOiAwLjVlbSBzb2xpZDtcbiAgICBtYXJnaW4tbGVmdDogY2FsYygyMCUgKyAwZW0pO1xuICAgIG1hcmdpbi10b3A6IC0wLjllbTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZmYTk1NiByZ2JhKDAsIDAsIDAsIDApO1xufVxuXG5kaXYub3B0aW9uLWxpc3Qge1xuICAgIC8qd2lkdGg6IDMwJTsqL1xuICAgIC8qaGVpZ2h0OiA3MCU7Ki9cbiAgICBtYXJnaW46IDEzJSAwIDAgNzAlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiAjZmZhOTU2O1xuICAgIGJvcmRlcjogMC4xZW0gc29saWQgI2ZlZDA5NTtcbn1cblxuZGl2Lm9wdGlvbi1pdGVtIHtcbiAgICBwYWRkaW5nOiAuNWVtO1xuICAgIGJvcmRlci1ib3R0b206IDAuMWVtIHNvbGlkICNlODkzNDI7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogT3B0aW9uc0RpYWxvZy52dWU/NTNkZGVhOGVcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUZjQ0FZQUFBQmhyWlJwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81TWpkQ1JVSkJNRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVNamRDUlVKQk1UTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qa3lOMEpGUWpsRk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2preU4wSkZRamxHTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrZVBnT3VnQUFLUk5KUkVGVWVOcnNuUXR3VmZXZHgvODg4eUFoUUJJQ0pJVkFKSVpFbmdHaENCUzNPZ2hVcFZoY2Q4RlJaMXVtTG5hRzdhelRkYmJhcVRyck9uYTZ6Q3hLaDdaYkhHSGFpa1hVSXJMaUZua0o4Z3FQQUEwbVBFd3dJVHdDaER3QXlaN3ZQL25kbm50eXpybm52c0s5eWZjemMrYmUzSHZ1ZVg3L3YvLzMvL3YvVC83ZFdnNnNVb1I0NU4rTnBadXh2QndyQi9UWWpCLzUvZDJUOTRnRUlXYXprRitPeFlQc3p2dEVRaER6UzIyZlVkQWtqc1ZjOVhucjhyY0kvZThVTklsZk1WK3JiVjFpV05RVU5QRXVaaUdHUlUxQmsrREVIT09pcHFCSjhHS09ZVkZUMENRME1jZW9xTDNrb2ZzYXkyQmpTZUg5N3RROFpDd3ZCQ1ZtcTZpejd4WlI5emFXOXlOOGZCZU41U3RqYVFwRjBNT001ZnZHOHJDeGpPYTk3a0lFSzJaN1ViL2dLeHlScDh4WTNqV1dGY1p5MnZwbE4wdlhkNCsyQS9tM3RsS20xSzJiU3Qxc2JuMGxuWmRHSXdCZXExR3E0VUo0MjBsT1Y2cFBsbEpKQXlKN2ZEMTZHZUUzMFZDc3p5VmZONWIvTkpZWEg1dnhvNi90Qkoxc0xHOGJ5MXo5MTVVcVkva3kvQk1rSkpJazlWY3F6VEFRZmJQbGt3K05aWUVoNmdaem94QURUbFpyTWQ5c1ZLcHlsMUxWSlJRemljR2E1RktyTnFIUkc0MzRaSTZ4clBuRDF2L3VaaGIwdnhqTGQ3VzErSElYaFV4aUgyZ1Vvb1ptbFpwbkxEOFd5OUhQZUQxbExHbnE3RDZsNnF0NXNVajhrREpJcVNIRmVIZlpXSElSb1JkcU1WODdSekdUK0FPYWhYYWhZYVVXZGI5MTY5YUR2a1lnSWZGSW0zYWg1ZTR0TFdwOHE5bSt5QXRENHJTaDJLcGRROHZqdW5mdjNpMWQvL1YxTXk4TWlVL2F0R3RvT2FON3QyN2Rlb2k4Q1lsTDJyUnJhTGs3QnllUlRnVUZUU2hvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNqcG9sdjU2aDE2aVNjbEpiODlTTmw2L3FUNHVxVlNydDV3SWVWL1lCb2s4Y2ZNZi9FOVdYdzRvZURlVy9lQWUxKzhoenJYYlRxaXhJekxWNGxtRktpZWpqK082U2IxN3FnMTdUdXRqdW12WUFEVnVlSHBRNTdKKzF5bTF2N3cyNEg3QzRlTFZablhtZkgzWTJ4bWFrYUlHcENaUTBMRW0rRUJBbUdWVm1lcGdSYTFhc3VKVE5YdGlybnJpMi9sYXZIWThlVitCK3RucTNXclY1dU1CQzR1VitxWWJlajgvZld1M2V2bnh5WDZpaHRoLzkvSFJvTGIzM3ZOejJuMjJ0ZlNyb0xkangxUDNGNnA1VTNJcDZOdUY5ZVkrL05LSG5uNkhLSXNGVm1MTlg4clV4cjJuMU5tTDE5U0xDeWM1cm85b0RtSGlOL2VQeS9GOGpJdG1qbFFwaWIyMDRPeEVIUWx5czFLMUdFTmx5K0dxc0lNRUJSMERRSmpUQ2dlcFArMDhxZTdPSCtpNjd2U2l3ZXBLdy9XUTlvT28xeWV4cDFyK3dTRS9VZU56cnhIUnJiQktBUTFIMEFESFNFRkhBRVE5K0ZRM3IvelBjKzlTK1VQU1ZObloxa2d5ZkZCYVJQWU5tNEVvS3Q1Njc0bHp0dXYxVFc3OTkzODRUcnRqblRoeW9HODdUb1ducGs3Lzl4K1YzamMyZldwbVdoSUZIUW11TmQyMHJmTE1uelUwdDJZSy91OWdhelFweU9rZjhlT0FtTU9wZXQwRUxkOGo0K0hrMWNQTkRNV2piZWlVZ3JaV3ZWSzlXajB5b2pQOEx2aTdzZG11clg1cHJWc0ZoTytTRW5yWWlzcXR3ZWQwVEtIVUNORUFOVVNvMU5VM3EwdjFUUlIwUjdMeldJMWErVkdwZnI5ZytraHRQNnhJdysycFpaLzRQb00xRWFGQzNNdmVQNlRPbkx1cTVuMXpSRlJiOUU2cHhXQ3pKTUhVRG9GcWlFQ0ZOVG1CSHJwRE1LZTNJR2FuRzRkYzcrKzNmcUdxTGpqblpQT3orMm5SWTN0b0REMDY3UTQxZFZSV3hJODVIcXQvdXlCQlFVZUJXUk55MVByUEt0Ujk0Ny9oR29XUU9YaDIvdGlBRGNBNXhVTjFwSWF3WDMxbm4zcm13VEZCcGVLODREV2xHRTZQS0N6WUd4dU9SS1ZXbVR0cFdNU3ZDUVZ0RXVLS0pUTWk1ai9ocjVGemhvMzVhUCtaMjNyandvbmthQ2hIc2lZd2J3c05kVWJvQ0NQcFBEUjQwRlVkRFAxVEV0WFNlV05kODdPd0d0R3dHNUdJNkU0KzF3ek9UWDRYS0h2aXBWRnJia3pUY29RSnFzL1RSbU90cE9Kdmc0YlFFU0hWSHhwM0VrSFErSFBxNUVDK0dGWUNyZmFNMU1TUXFsMjNxR2NuTEhQRE0xcTQ5UVJDaUxCUVlQN1VFYTZGMks2bkU0WGhsYlVIZEdONTRiMzVNVzgxWWw3UVRpTDZ5ZmVLMWZpOGRCMTVjSkZmV0xOSGl4VU5PeWN2alFZazFzSDRESzlkelBnTmZEcjI0NVQra3VPejY5QUpKMlhtRmJlTUROS1FFL0l5ZFVNWDU0Nkc4eU5UaDl0R2JIVDFvM2RVdnFzOGYwMnQzTlQ2T3dTS1VWSEk3M2M1UVNNQ3cxcmdkZGpBVlBYc2IzZjRMSUdmOEI4YW8zNzhteDNhZnRpTmZFT1V4MDJGM2NCZ0k2KzJCcitwdnRTZ2ZqaTcwREg5SlpFNTJwRTQxRFlHQkQveGprd3RUbHlmc3FvNjJ4RitxTGtRamRHR2tMRXMrTXl0RU1RcU1Uc2VHdEVYUXNHclcrb0kvbTd4QTBXdHdscC9VRmUxNW1yelAvNjRUNzlIdGVubHh1QTMwbzN0MWxFVEwwQzh6eTBZcjhVSiszRCthcE12Q2d1b3VSQ05VU3VLcFVOTmlFSWNUMktPYVVFSEE2STIvQ1NpQ253alJDa2VVQ0tOVncrNGFYK2x0aEs0eVIyZGd3MTEwRDh5TTRHaU5jU0pBVkFOVFRmVmErc082aUd5d3FQVDhyUzF3SG1qSmtQMktGWWF4cDAreStIbUp6SE9HRlVyaEF6RU8zcnRMVU4wUjI0Yk54VTMrWFprYjBLeEw4aWJ1elZDY1Y0WUgyMGVFanF0S0Z0dEw2M3kxWEtJNHJodXVHWnZmbExtT2hhY2d1NGdJRno0Uk53VXlYd0UwL1dMNkk2SWptamZrYWtxUkV5SUN3WEpiSm04NFBiWUdDTDNqbVBWUHVGaSs2aDVVRmh4ZnZLNVJIRVJOY2JHN0RwZXJhMWN2RVhxVGlGb1ZOWGJqMWI3SG92Q2pZTXdJV3hrUVI2WU1EVGdqY0hOeC9xSWRNaHVSQnV6aDRXd1VQalF3QTIySURWWU9qdHdMVENXMnp4S0VPZUV4clU1aytGa1RTQnEvQjQxSFNJL2pndmp2cG0yaXpLSVpQdkthM1dPMmh4cFJCam9NWlBVa3dnVnFUUU0ycmQ2WTRoQUJqbGhISWZjZEtjeDJWYmN1cXFkdW91M0hEbnJlMjk5ekVrS0pLS3ZXLzRZeDQxZVRUQnpkTFpQbFBXTk43U1ljUzI4RkdZN3Y0Mk1FUjR2ayt1SHpFYzg1S05qVnRDNFdVKy92dFZ2Q0tQa2U2V0tOZ3RnU3NFZ1gxVXF2bERTVU5zTS80aWJncHVNeUNNTkh4SHVoU3ZOdnNKZ3Z2bE9ZN0t0dUsxajExMk1jOXQ4NEV2SG5rdWNDNnA5UExQb0JXeG5oaEZGelkwODg3VXcrM1N2M2RjNEpuaHl1WDdJa0NEQ3h6cVlTYloxeHBXeURURjNjT2pja0VlQkVJRncwM0NURUxrUVBUQ2dmMHh1dXFjSWhIejA1MlhudE1lMnEwTEZ1M2FVZDhZNTNKbWRabXNCekJZcUVLaDFNTERLeTNIYlBZRHI5U0hZYUQyRUVESHk1OGErb0Vua2E3Mi9WbDMyaThLZGhqWkI4eUhaTGdRaWJLY1NzUTM4VjJDRWdpYUVnaWFFZ2lhRWdpWVVOQ0VVTkNFVU5DRVVOQ0VVTktHZ0NhR2dDYUdnQ2FHZ0NhR2dDUVZOQ0FWTkNBVk5TR1R4UFlLMXIrUXdyd2FKVzRxdHp4UVdqeHZOcTBKb09RaWhvQW1ob0FtaG9Ba0ZUUWdGVFFnRlRRZ0ZUUWdGVFNob1FpaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0ZIbFlkZitsQXZkbUNLTk13Zys2dU5SL1g3WUFubE55UXduTmF0RFV5RW1aR2FxSEl5K25oYUgvTmhZd1paVFA0WjdJU1VtQUJ6ZjNtdFdqeXIwUFArZ2dVVGlaNDVYeC8yZG9abXBIVFlaS1NkWHRBUW1kZnBnWVBodmVmbnRMdjV5OVlmMU8vTlV5WTdnZW1DTWNVeU9IdnhtdU5jM3hEN0U5L09iN2U5K3FZYmVxcm1uNzYxVzczOCtHUS9VZHZOOWhycytZQ3RwVjhGdlIwN3ZNNDBTMEY3SURtaHAyOStiek15dDdiZGQ4R3NJeUFDWVdMMjVSOGMwcEVYazdlN2lSbnJDUkNtMnpGZ3ptMnJvTEg5bE1SZVduQjJvbzRFdVZtcFdveWhnaW1wdmN4elRrRUhRZjZRTkQyQnVwMjNCWGJmQmJPT0djejlqVW5hRVhsbjNqV2tuY0RnZVNGMmZJL0o0dDFFS0tLZlBUSFhzYnBHMU91VDJGT3ZaeFkxUHZjYUVaMzhQY0NNc2VITUdpdHpyT01ZS2VnNDVZRUpRM1hFUFZaNXFaMVlsLys1VkcwdnJkSVIvOG43Q3RUZUwycFZldCtFZHRFWHdsL3psekw5L2p1VGhnVXNSRFYxamZvOXRoV0xaS1lsVWREeHl0UlJXZXIxcDcrbHhReGZiZWFmN2k5UWd3Y2txMGVtRGxmYmoxWnJ1NENHM1hNTHh2dUorcFcxQjlTbCtpWmQzWHV4RWJBZktBVEJOaXk5QUc4Zmo3YUJnbzRnaUpSb21LMy9yS0tkenhadmpjaXFvN1poRnlCZ2lGb3lINGp3QzZhUERLb2hGUTB4ZzRrakI0YjgyN3I2Wmwwd0tlZzRCVkZ5MC81S0xXVGNTRmdMdHh0cUZiVTBFTWVPeUhSc1ZEcGxRN3o2L0dEQmNiZzFjTDM0Y3pUTUtlZzRReUl5Qkl3R242U3EzQnBkNGkreHZtUTZFSm5kQkJTUDFUOGE1aFIwbkZGOXFjSG5lMmROeUhHMUFNaU5Iemw5VWUwOWNjNG5VRVJsTDUwazFueXhVNEZ4aXVSZUtEdDdXYjJ4NFVoRWZiZ3cxMmprU3MxRVFVZmh4bmk1OFhicndGdWFJeWx5eFZpY1VteVY1NitwbFp1T3RzczVJeTAzcFNBcnJQUllwQ041US9QTmlOWUU1bTFkYTRyOTd2cVlGYlNYRytQbHhqbXRZeFowb0s1ZFJONEplWm5xU3NOMVhSaEdaUFhWR1pGb1k5Y0RHQ2pDbzNESjd3SmxUK1QzYnZ0QnRvZGQzeEhBZkdOQ3VSRmUxZ2xHVVBEVWhVUDdxMmQvdTBOYmpJNFFkQ0RjZWdKMWQvNzdyVDJhODZlT2NLMUYwQkZrdFJJb0RHanNuamwzVmZlaXhyclZFT0p1dEIwOExQRFNwUjFwVGhzM0Z3d1owQ2Ntcm9WYnIySlNRZzlkcThBbVlUek02aTBuSEVmNG9TUEkvQjBzRnNTTTN3NGRtS3BHNWZSbmhJNFd0WmRiZTlZS0luaVJnKzJBMkxqM2xGNGlZUnVpQmF3R3hEN3hqa3p0LzlGbFgxWlZaOXQ0UllNWUFuNXg0U1FkclNGd2ZJYXNEVHFTb3BVbnA2QU5NTjRDNUEzdUc3RnRldTJBTUl2K2R0UVFvUUR4b3VNSG5UNmJEM3lwemw5dDBwOGhDcHNidHlpZ1VyQ1JpdnpKOTRwandsWjFha0hEYmtpbW9kaW9UaU9GbHc0SUdYQUUvNHhqNkp2Y1cwZTBTQkpxRi9qT1l6V3U0c00yY1g0WWRIV210bDY5dHU2Z0hwZGl6dkpnR0N6T0MyTDJNb1NXSGpvQ3JOdFo0WXNvSGRueVJqU1RBVWRvWUtFcXhzMkhMNDBVS0REUHZSbmEyTzlYMzlubm1zSkVBeEdkUjc5NHQwU3ZDekZQSzhyMnkvSWdpcU93d21xOCtVbFozRDVSRXpmRkVEZGNJZ2dpU2tlS0djTTd4Vk1pVzNCbmRwcjJvekxJUDF5ZktSRVQ1MllkRk9XMWtld1V1WGNjcS9aRlkyd2Z3VUJ5N3VZb2plT0hxT0dsWVQ5MkhhOVdpeDhvaWp2YjBUTmV4Q3lENnBGQzZvam9MR003NUtrUGM3ZTIrZVpEMU9nMURMWVh6ZXhoSVN4RXg2VVBqUW42M0Jvc25SMHlidHZja3dtL2orT2JWampJdGVESmVjbTRiMFJ6SE5mMG9zRnhrN2JyR1U5aWhxaWlmV0VSMVE2ZHVxQWpsSXp0c012RDR1YkRROE4yNE9iakdHRkxwaFFNVW1OeTA5WDR2SFJYOFd3NWN0YjMzdnFZRS9hSmZTUDZ1dVdQSWQ2UDlwL1I3MmVPenZZZFYzM2pEUzFtaUJGanZJT0pzdUszN3hvMlFLM2FmRnpYaWxod2J2R1FqNDVwUWVPSmFrbVBCUnI0RXc3d2w5WkhqaUFxTDJrckhOT2M0cUhxN2UzbHVoQ1lVM3BPaFFGQ1JNWUIzeStkTjdhZGFGRW9zQTJ2ejFOaU96T01LR3B1NU5sMTVTTTRlTzIreGpGaEZDQitnOHdTT2xnUTRSbWh3d0JQZkJ5dnZOUWhnMklrb3VWbjl3dTZheHZDK2VIc1F2MUE3SUh5QzZxaTVvcXU4clBUVTJ5UEd3VUVRb1lYdHlzczJBN1NraHYybkE2NGI2UWNVYURNNG5XeUxSQ3o5Y0haUU04ZDR2aXhST3NoaEVqVHJlWEFxaGI5cm15RDZxckV5ODJLeEhuK3RlcXlYeFR1TkZpblJ1N0tkQVV4eTNsMktoSGJ3UCtjUkNob1FpaG9RaWhvUWlob1FrRVRRa0VUUWtFVFFrRVRRa0VUQ3BvUUNwb1FDcG9RQ3BvUUNwcFEwSVJRMElSUTBJUlEwSVJRMElTQ0ppVHU4RDN1dksva01LOEdpVnVLcmYvR29IamNhRjRWUXN0QkNBVk5DQVZOQ0FWTktHaENLR2hDS0doQ0tHaENLR2hDUVJOQ1FSTkNRUk5DUVJOQ1FSTUttaEFLbWhBS21wQXVJbWpNZ0lvNXArMCt4enpkTDZ6Wm85L2JnY25sc1U0MHdIYXQyOGFFODE3Qk9TMzk5UTdiYzRzbExsNXQxdWVGMTFnbkxxWlFmV1h0QVhXd29sWlBvcjcwb1RHK3Vhd3hNMnA5MHczOTNadWZsT241dHEwM1l1MjJFM29PNzNsVGNpTitYREp2dG16N3RYVUgxZmJTS2ozcFBTYTFEd1RtM3NZYzQzWVR5cU1nWXI1d0wvenozTHRVL3BDMHFGMy9yY1oxeDdsaVh2Qm9YTWN1SjJpSWVObjdoN1J3Zi95YkhXcmh2Zm0rU2VFZm1UcGNiVDd3cGRxNDk1U2FVcERsTi9YdjhjbzYvWW9KNmFOQi81UkVkYW0reWZmM005OHBVbGNicit0Q0JMeUkyZ21JR1dMM1FrTnord0tCaVBxejFiczk3Kys5NStkMENzc1JGNEpHUkg1eDRTUmROYS81UzVtTzFOTUtCK2tJalFVQ3grZTFseHY5Zm5mbzFBVlhLM0JuZHBwdm5tOHZFWEh1cEdHK2dnVDZwU1JvUVplZHZhd2pKTGIxM0lMeHVrYUpoS2pCenhkTmRweWZHM1lsa09oUjZIQ2NUbGgvTHdWaCtLQTB0ZXdIOTFEUTBRUmlHcFhUWHgycnZLU2VlOU0vK2d3ZG1LbzI3RG10RnhIZmNXTTlBSEd0M2VZdUZpOFJzYVRpZ3ArZzdTS2tXZFJaL1pMODFvUHczOWh3cE4zdnR4eXUwZ3VZT0hKZzJJWEFETVRzSnN5SFgvcXdVelVLZThiYkFlZGs5RkY3djZnTktENElHK3ZBUDAvSXk3UmRaMmhHaXUrOTIwMUh6YkQ4ZzBOcXBFZWZLcUtXNkc4V3Z0MXhXeit6RTNRa0lpZk9BMzU5UnRGZ1h6dWtzOUV6SGc4YURSTnBuQ0RDMk4xa1pEN0EvS2tqSEt0c085SFlyVnRUMTJwbCtpVDZYNjRDbzdZd2l4R04wRFBuNjFXRElacHpodjFCZ3hXUlg0NE4yelo3VldSSU9yS3hKWVU4Tnl1VmdyNWRWSjYvcGkyR1hWWHZGb25RZ0VSMDlpcG1pY0xQUERpbTNiN0txbG9ibDhNTVd3UFJuNnE1cXY4K2UvR2FmZzNVK01JNW9HWWhGTFJhdWVtb0ZpZWl5NVAzRlhnU0tIdzJ4Q3dOSnp0bWpzNzJpNHBvWktKaENWRkR1SklHUTlURi9sRUw0RE03ejJsdWVHRzdBRkhRMnZBa0ZMUk8yYjI5dlZ5bjVSQUpJVlR4cDVLNVFFUEs2ck9SRlhITEF2Uk43cTFtVGNqeGlRMnZpeDhvVXErK3MwODMzRjU1WXJMK1RGSi9zQmNBOWdEV0l6TXRTVWRxV0lhaVllbnEyZmxqUGRrWDBzVUZEYStIRGhQa21GZHRQdTRUbjVuV0xNWUozOS9pcWEyK1dtd0Z2cmRydEUwZGxhVTdSYkN0UCswOHFSdG5rdm9iazV2dTgrOVdxaTdVdC9zTXg1cWRudUluZEtmVW9EbkxFYWlCU2pwSm94RFJEbEh6d3BYMjNhOFFxRlBHd0NwbWM0UzNBeDAxRUIxRWpiUWJhb2JXQ04yK2N5WWpOVkcvMXRVM3Q5c1hqc05hY3ppbEJyMTJvQUFVRXRKSnNod1FZVTVHKzBNMmQzZzQ1VlhkSXJOMUgvRHFzRGY0RFpnOU1kYzJLeUFOUFhOdm9XUVR0SisrYTRqZjU5YklLMW1PbjN5dldOY09ialMwZFkrUGpHSVhkMmNncmtmYlNiWUJmamFZUXVHbE5vQlhGbUIzbkpEYVFmeThSR2NVZ2tDWmpSTm52VWZtYzVmdFU0Y2tqaU0wUkdQT0dpRFA2MVF0TzQyd00zK09USVJUdzgwc0hHdVh1aG5ZQ2dnWTZ5QWpna3dKc2g2UFRzc0xlRDdpdlZkK1ZLb3RqVnR1V01TUGJuL1VBT0g0YkxGS0ZQUnRadDNPQ25YbTNGWDF5Ky9mbzIrK05MQkVsTWozZ3NFRGtuMGo0YXhlMWV4WEVZWHRCSTJocUJDbWdQZkZlWm0yZ3BQdWJYU0xRMnl3SDhobGUrbTR3TEhJQUNjTXZqTGJJYXRnUzArMzFnQklJWWJhZUJTdjM1bHo0bkVqYUloVk9rdEVMTGhCa204RzU2KzJldG1VeEY1Nm5JWVpTZm1oNTFBd2QzMmJRWVlESXNQNkdLbUhCaUlFaDFTZ2xWRnQ2VHdNR3dYNGpaZE9JTEVvVXdvR3FiekJmYlZmbDh5S1hZTldmRG9zVGpDTlNQUDFrM09pNVlnQk1INERUQzhhckY4eDBBYzNDSUp3OHNGV3JqUmNENWdiaG5na0JiaDRWcUZLNzV1Z2g2ZWlNT0U3cTFnUjdVUmtpTGFJc3VaSTcrVGJqNXkrcUY4aFptd1QwVjB5SzlaOVNDTVR2bHdHWE5rSjFoeDVVVmdsWjI2K2Z0YWh0T2EyQWh1RkhZamthU1VpSGoxenlTZUlTTllDWWpWZ0d5QVFHWjRxMXNQNlpJdzBBaVhhbXNYN3BiRTlqQXEwRzdxS1FnS0syd1pPb1FNSkJjSzZEM2grS1N4dXZuekppay9WcnpiK3pXYWhGa1BPSElWRFA5bnpXWVgrL083OGdYcWNpendsWXg0WEE5QkdRZTJHaHdZWW9hUFlHSlNSY3hLRlJPREZwcEYwa3RvS0pST0FmU3hiZjFCSGZYU3VtS09rUkZEVURtYkJTbTViUU03Nk81T0crWTVSUnRkWkc1VVFLZlpqVGdmaUZRVUhBNkZrSHpnbWFRdmdPeWRmTG85R09VVnZzVkRZWDdLeGJiUkRsaHMxRHZabHRUallkenozY01aRmhONTF2TWJQYnBoVFkrYWJMS210WU5KNFlsL2dzVVhNZGo0V1ZrSkVqb2lIYUFneEkzSWlqeXplRkdOUDNOS0tFSjlFUzRqZkRMYVBqaDJ3ODFpTkxtREFXc0NzWUlRZmtIRWtadEE3Q1N1RDQzemkyL202c0sxWU1rTWZMejdIZVRnOWo4a0lIYVhHSUNJZmJnZ0dFT0hpaTZlMDVvZjNsOWVHbEpiQ29DT0lCamdOcmtma3dyNjNINjNXdGdEaWgzZisxKytPMHlKQjJnMlBoOEZybzBwSDR4TzFDSTViSWg1K2o4WWxmZ3Z2YXBkdHdINmt3MFhFYkhkTUtCaFNtR3R0Y3RUWUY1NnpsR3YzOHVPVC9jYXR5RU1JK0I2akJ0MDZuSnpTb3hSMENCeHJxMGJGbnlLaVNIU0dVUEMzZEU5TEZnQkNRVUg0eGJzbGZ0dHk2emIyOHBTSTNIQ3B2aEh4NURPeERJamFFTFdrMTdDZXVlcVhUSTNkbUJDSVVCNEloZ2pOejA0S2lNSTQvNmVXZmVMM3VSUjRxY0hzQ3AzMVhFVFVhQ3czTm4vdE94Y1VTSE42VUJnWVpNMUhRZHVBRzRvcU96bWg5VkRSTUlKWGhKZ0FCZzJKZDRSZy8ySEdIWDY1Vm1sUTRjYktkK0VlRHhxbWR0RlZ2dnY5MWk5MEdnL0NsZU9VUW9PVUlrYjVPUlVZWkNHR0RPaWp6OVBPTTZNZ0lCSmJueFNmWWZMM01oVFdXdWpzOWdkUlkzeU1lVit3ZG1aQjQ5cWhJQVhxbm84RnVyVWNXTlhTYWlRM0tOSjVRTFR2VXVPdzI2Wkc1bjlPNnFSMDFZY0tLR2hDUVJOQ1FSTkNRUk5DUVJNS21oQUttaEFLbWhBS21oQUttbERRaEZEUWhGRFFoRkRRaEZEUWhJSW1oSUltaElJbWhJSW1oSUltRkRRaGNZZnYwZUI5SllkNU5VamNVdHoyYnd4OGdpNGVONXBYaGRCeUVFSkJFMEpCRTBKQkV3cWFFQXFhRUFxYUVBcWFFQXFhVU5DRVVOQ0VVTkNFVU5DRVVOQ0VnaWFFZ2lhRWdnNk1UQnFQeFF0TGY3MURyNHRwa3IydS8vQkxINnFTa3hjYzE4RjNXQWZ6Y1VmaWZEQkp2UnZZbjl2eEVIL2lhblpHVENhSmlkWXhiUyttUkhhYnFoZnpYV05hWkdDZW5qaGMxdTJzMEsrNVdhbGhpL201TjNlcnV2cG1OVFF6eFhhcVpmQ3oxYnYxNjN2UHp3bDVYeWlvb2JMc0IvZFEwTkZrNlVOajFJOS9zME90L0toVWpjOUx0NTB4RldMQlhOZmd5ZnNLSWphcktxS3B6SUc5YXZOeDIzVWVuWGFIcHpteGNVeFk5OVYzOXFtZnZyVmJyVmd5STJxenYwckJab1NPUVRESityeHZqbEMvKy9pbzJyUy9Vay9tYnVYTlQ4clVwZm9tdFdENlNEVnVlSHJFN003YjI3OElLSktQOXAveFBNazcxc014cnQxMlFoL3pEMmNYUnZYYUJSUGxZYXNvNkE1aTFvUWN0ZjZ6Q25YaTdHVmJxN0Z4N3lrMWRrU21XalJ6Wk1UMithZWRKN1dJWjAvTWJTZThpMWViZGEyQlFyVG8zdURzRFk2eHJLcE81UTN1U3dQY2xRUnQ5WUg5VWhKVTFZWDZkcC9Ea3pyOXhzNFBydDV5UXUwOWNjN3Z0L0RKc0JSekp3MVQ5NC9MMFlVRVViUi9TcUt0SDM5N2U3a1c4MVAzRjZyOElXa2hSVDVZbWVVZkhGTERCNldwRng2YnFHc2kwb2tGSGF3UEZLOGJDSWpadW0zNTdiV21tMXJNRUpvdUlQUEd0dk81NWhyQnp2NVlnV0RkemhHRmltTHVRcFlqbE5hK214ODBSMjFFZElqcTU0c21hKzhOMy96MDYxdmJaUnljQ3BEc0I2SjF5ZzQ0ZlM0RkIrMEQwc1U4ZEVlQmFQenk0NVBWeWsxSHRXQVJoU2ZrWmVydnFpODE2TWdNOGM0Y25lMzNXYkRBZ3lNcmcyMTVpZktoRXE4TlBRbzZnaUEvREJGRDBIZ1Z3YUd6UThScjkxa3cyWk5sN3gvU0hoeVdKaHE0MlJ3S21rUVVaRTlRV0NLWll2UnFjem9qSE12aEVqbWozZVdNREF1eUp3Q3BPK3lUZExFSUhVNDNiaUQ2SnZmV3IwamJpV2NPRkRXejAxTkNLaXl2ckQzZ2w0bkIrMGgxcnBTZHZhd2FtdDBMeDlDTUZGODJ4Y3Y2SUZvMVNKY1dkS1M3Y1pGZEtQL3FpdHAxdkZyN1dCSFh0S0pzTlc2RTh3MnN2ZHlvWDBjT0NjNmZJdW9qeHkyZE5PSzVrY05HNzJkS1VxK3dPNFRlMkhBazRIWEMvc1Q3ZTFrZmhET2VoSUlPY0RFbHpXVytNZWFXdk5lTHY2MzBLMStrUk1jSlJDMXBPMFF1YzQydzVYQ1ZYc3lZUDVNSWoxd3lmaWNkTXdKRy9vbUE0WmtoWEhQRHNyN3BocytDUktLWEV3Vm1VUDlrdjgvMmw5YzY1dWp0MWdjb2FMUWNVUWFkSG1CZ1dsSlkyNWxlTkZndjB3b0g2ZEZ2RXFVQnFtRno1TEtMWW5hZllSdFk1QmpOb05Bc2ZxRElkcnpISTFPSGF5K05KUkpNS2NpeXRRbE9nblphbjRMdUFDUXFacVFsaHJVZGN3UzE4NHgya2Q3Y2V3aUIvdkw3OTNqcTNmdU9FYkhSZGU0MHFnNmZZelJoTUdDc3Q5UFEwNjVJWEdZNTBCR0J5QWd4NVEvcDJCd3JHblFiOXB6Vzc1OTVjSXlPeEJqTDRRVUlMOUFRVVJTTVlMcStmL0Z1aVhwdDNVRXFPWjRGdmErOHRxMktIQlJTQmlBY2tJbEFZWUozUjNTSEY0WVBqc1FUTEtHeXZiU0tTbzVYUWFPS2xjSDdxTUpEeVFDOHNHWlBTSkVaZVdQclFDVDRYdndObndrcmNqdXlQbDJwSjdCVGVXaUlHVldzRE40UDFUdWVPWGMxNlAyYXgzTTh0MkI4TzkrTDhkRHcxVFYxalZya2tYNzZCRGJMYWtYa1dVbW5YRGhTaTliT0lZdzNjY0p1ZlFvNlNyNFZUNmRnVUwrSU9WQmF5NjZ4QkxzUlRFU1QvVW9yMzJtL0VCb2VvVUpuQ2RKdUdKSnFUZG1GQ2dvUUN0S0xmOWpyM0hoMXlKZEx3OVVyd2E1UFFRY0pudUhiY2F6YXp5TmE4ODVPQWxpeTRsUEhkZWFhckFvaTMxUExQdkg3UGlNMVVlOGJ6eTJpQUtFQUJIcFdFQkVaa1J0ak15QnFpS09rNG9KNmRuNTRBNDRXenlyMDFRNTJvSkE1RlJ6bW9XTU1QQVNMNS9pUXpVQUQ4TkZwZVFFekFLaitrWFU0WG5uSjluc005VFFMQU51REtCQlZDM0w2NjF3c0lqdVdpcG9yS3F0Zmt1ZElDMUVqZ3M4cEhxbyszSGRHVzQ5QUJLb3RjQnd2THB3VTB2V3p5eXYzU2V5cHJqUmMxNjllMWdmV3pxUllwbHZMZ1ZVdHJmWHhocGc4UUR2dlNFZzcybWFTamZrc0I4Vk1nb0hEUndrRlRRZ0ZUUWdGVFFnRlRTaG9RaWhvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNwb1FDcG9RQ3BwUTBJUlEwSVJRMElSRUNOKy96OWxYY3BoWGc4UXR4VzMvYU1ZbjZPSnhvM2xWQ0MwSElSUTBJUlEwSVJRMG9hQUpvYUFKb2FBSm9hQUpvYUFKQlUwSUJVMElCVTBJQlUwSUJVMG9hRUlvYUVJb2FFSW9hQi9yZDUxU1MzKzl3L2E3WDIwOHFwZkc2emNkZjE5eThvS3FQSC9OOGZ1eXM1ZlY2aTBuOU56amJyeTI3cUQ2dUtUU2RWOEE2K0NZc2QrT0JPZUJmUVk2dm5pbFp5d2ZIRzc2dFNibkN6K2phTERmWE9BbnF5L3IzOXcvTHNmM0dVUzZjZThwTlhaRXBrcnEzZFB4SnY5czlXN1ZQeVZSL2ZMNzk5ak9MMzcrY3BOYXUrMkVLcXVxVXk4dW5PUjR2TnRMcTlUVnh1dCt4MkFIenV0M0h4OVZQL2xlY1lkZTB6YzJITkhYNmVlTEpxdHh3OU1wNkk1a3c1N1QrdUk3a1p1VjZoUGZyQWs1YXYxbkZmbzMwd29IK2NTN2N0TlIvYnJvM256SDdlUVBTVk5QM1Yrb0JiYnMvVVBxdVFYajI0bC82cWdzWFNnT1Z0UzJLelRtNHdYenA0NEllRzViRGxmcDE0eTBSTnZ2VVJ2c1BYSE8wM1Y2OHI2Q1Rpbk9UaWRvTUh4UW1scjJnM3ZhMlFORVZHc1VIem93VlYxcHVLNDI3YS9VZjljMzNkQUNoQkNQbnJta0Z4UUN1NXMvYjBxdVhoOVIrSlcxQjJ4RnZYaFdvVnF5NGxPMTVpOWxmb1ZHamdPRmIvYkUzS0RFaGNKa0I4VHNWcGpOSERsOTBmTStaWnZKQ1QwcDZOc0p2T3VaOC9YdGJweGRGTGYrRFZGakFZakVUamYva2FuRHRhWEF1bi9hZVZJdG1qblM3L3VjakQ1cXdmU1JLaVd4bDkvbjhLTVFPU3pMRTkvTzkzUXVPRVlVVmllc2hkZ3VncVB3b2JCYWp6T2Nna1JCZHhCYlM3L1NsdUM5NStmWWZtLytYQ0s0M1dkdUlPSXVmV2lNZXZFUGUxVld2eVRYMytGWTdIanMxZi8xdlVmaFFlUVhwTkhhTjdtM2ZxMnJiMjdYa0owNGNtQkFnWnJGakpyRUNyWVpLTG8vL05LSEVha3RLZWdvZ2t4RzN1QytLak10cVYxalRmeHRJT0RKelRjTlZiTlRKQlhST0gzZko3R25hODF4cWI1SkwxYmNCSTF6TVl2WnJxR0xRbUVIQ2hKcUg5UWsvVklTZ3I2K1R0dWxvS1BFb1A3SmFwc1J5YTJOTW53V0txaWFuYUtTUkRtdlVVdHFES1Qya0ExNS9lbHZhUnNqbVpabmY3c2pZTlpuK1FlSFhNVXNCY0t1VU9EM0VQU1Vna0hxaDdNTE82WGw2RlFkSzhoMG5EbDNWWjJxdWVxWGtzTk5uRHRwV013Y1orbnBDenBLaXBoQlEzTnJ3M2JtNkd6SDMwSE0ybElZdHNoSnpHNlVmM1ZGdjZJV1k1WWpEc0JOUnZTUmxCajR2NE5WT3ZOZ3RTRm13U00zRzJ5akxGU1FGNGZOc05vVUtZUldtK0praTBMaDdNWFdqcU5oQTFNcDZIamg3OFptcXpHNTZlclZkL2JwdngrZGxxZGZrU0d4QTVIUmEzb3NFaHlydkdRYmlhc3ZOZWhYcDRJWGlTeVJaSG9DV1JzejA0cXkxYlB6eDFMUUhZMWRxOTFMU3g0cFBITTJ4UG9iTDl0d1c4ZmFJeWZWUHZMaFpvNjNDUjNyT25YaFc3TWx3V1JIOXBYWCt0NTdhUlFpQTRPYUpEV3BGeU4wUndKdjdOWTlic1VxcEVBNFpUQzhaZ3lzSFJobTRacHRDR29KTlBic3NpRk8yWlZnc2lOU2tDUzc4dkxqay8wOHZGMmh3WHBUQ3JJbzZJNGswSmlKY0hIeTBwSXh3RTFmZUcrK3ArT3dDdGRxUS9LeisvbGxRNXhxQXFmdm5VREh6NjdqMWZyOU13K08wWTNMUCs4NTdaanBrRjVQRk9aNDYxS1BLMEVqR29aUzdac0pWZ3hPQXBHOE5tNDZCRkpUMXhpd1E2VEIrQjNPQVFYaGhUVjdkRmM2b3FTa0ZlL09qMDZlZC92UmFsM3c0SWRSOExBL0ROaENXd05qVkp6T0RXTkUyQ2lNRXNoY0JQSjlFSmRUMmd1L2oxVGpEOTNpRW1tUkQ4YllEM1IyQktyMmtkTmVzV1NHWGgraS91bGJ1OVY5NDcraDMrUFlvOVVkTFFWbTNJaldhSXVCV3RqbnlvOUtWVUZPUDcrc2lmbmM0bkhBVTF6bG9RdHkrZ2RjQjEzTmRrdWtrSjQ2UkZySkIwUFVFQUErUjdlMEcxZ2Z3MDh4SmdSUlV3cEN0UExrNkxxWEFpTzJDQVVIMWdQN3graENHUnR0UGJkNEpLWWp0TnhrOFo3NEd4Zi96dXcwblQzQXE3V2g1alJnWHNaUGhHTXozdnlrVEZmVnVPRm9WRWxrRTFGTHBNWUFKN2VlUElua0dPUWtZMEpnV2FMQnFzM0hiUXNNeEkxOXl1akM2VVdEZlIwM2l4OG9Dam5YVFVGN2FQRGh5UTdoNmRlM09qYkN6S1BxSWdXRWpPR29HR3N0SFNMLyt0MXg3VElFWmxIakdKeUdvSnEzYSs0QThsb1FnZ0hYVFJwM2R0ZEw3QkgyTGRjTmtkdnFxeW5vQ0FzS1lwSUdEYUlLSWdsNnU2eWVFOVcrMCtENmRUc3JYTVV1RWRoY1ZjTkR3bE5LTll6UmMraGVkeEtjV2RUQitIQjQydi80NHo3SFlhdWhXZzJKL2s2Tk8zUzJvQkNad2ZYRnRZaFVvYUtnYlc0OEl1UERiVDVZeGl4REFHaGdtUzg4QnZjN05XU2s2blZLcDZHQkpoRVlRc09RVWZoYzdBOURTYTBEK3QwOHN2YldDVDBjMTVmaG55Z2tFcEZoWVhBTU9MZHdCWVh6V2JiK29INlBjN0JlRTJ1dGcwSUZ5NEV4M1RpdXpRZStWUE8rT2FMZEkyNFVkSVFhWUlpTUVvMXhveEhSMEgyTFNHaCt2czl1ZkxINXUwQml4czFIZEVUa1FtTkpiaTR5RVVoOW9WdmFyZVV2RHlFSXRaY2IvYXdUaENTV1JIeTRDQmNXWnVtOHNXcG9Sa3JZWXBiemdWQlJJTTFSZTlmeEd0ME9rRFNvZWN3MkNxMjBFeERkc2FCbVJIYWtPQzh6THNRZHM0TEcyR1pjV0lqTW1xV0F1UEg1aUt6d1I0M2htVU81K1ZMVjQ4YWhvTUNESW9wSkppSVVNRERxL25HdGc2QlFxOGkrRU1XdEFyRVdGcnZuQ3QxeThTQzliNEl1Z0dZL2pzQ0E2Q3RqcjdFTlJHQ3JmY0o3ZExaZy9NdmIyOHQxWnd5R3VXS1J0S2hkK3lHVzZOWnlZRldMZmxlMklhWU9ESkZtN3hlMW5sTnVpTXh1NHhuazJVUHI5ckNmWDd4Ym9sNTRiS0p0QkVKVVJYUkcxekc2clFQbHNxMWQ1WTlPdThQWHlKTEdyWnNQdHg2elpCNWsyK2J0QldwN21QZUI2NU9kbnFLamJUQzlxenVQMWFpS21pdTZnTUNXUkx0bk5tVGFacEtOV1VGM2RPR0o1YWhEdkF1YS96bXB6YitTemdFRlRTaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0VUUWtFVENwb1FDcG9RQ3BvUUNwcVFnSUp1dWRWeVE3L3JSbTJUT0tWTnU0YVdiM1p2YnI3ZStnaEd6d1JlR0JLZnRHblgwSEpkOTdvTFY4cjFYOGtEZVdGSWZKTGMrczh2b2VYdTVjZFB0ejRtblRxWUY0YkVKNmxEOUl1aDVaM2QzMXIrN3ArYm02NWZWTW5wU3ZVZnpvdEQ0Z3RvMXRBdU5HeG8rWVB1ZFJldm5QeDA0KzYzOUplWmhVb2w5ZWRGSXZFQnRKclorait1b1dGb3VjZGRDUWxYRHV3cTdUMTZZa0dmakt6K2Q2cTBieWgxNjZaU1RYVzhZQ1MySS9QZ0NmcnRYdzlYZlBCZnovLzJYZVB0NXoyTzdGN1o4czd2TmpiczJMeXZ2bWo4eUY1YTFIME1rNTFrV0pCdVBReHgzMUNxNVd0ajNSWmVSSEw3UUdxdVYxS3JYODRjcFZTLzF2K21XbmJrNUo5Zi9wZmxmN3oxOWExZHhwK1g4WDg1OUJlUHpmalJPT05sMUZOTEYweWFNZXZ1ZjB6cWs1akZxMGhpbGNaclRUWGIvdmZ6My8vUGY2MzkzUGp6bUxHVWFOMmJCTjNOZU1IOFhhUDZwQ1QxWExSay91UlJZL01tOVV2dk96d2hvZmVBYnQwUnJnbTVQYlRjYXZtNnVmbjZ4Ym9MVjA0ZU8xaStaL1hyNjNaZnEyKzgyU2JtZzJJaGZJSVdER0YvbzAzWXFieU1KSWE1Mmlia0wvMmN5ZCtuMnVvV2ZZbERqUVgveUd3QTJwT0s0ejdJN2VVV25JYXhYRFNXU21NNTAvYVpILzh2d0FDODFiNUhaZkt2dXdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZ1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwib3B0aW9uLWxpc3RcXFwiIHYtc2hvdz1cXFwiaXNPcHRpb25TaG93XFxcIiB0cmFuc2l0aW9uPVxcXCJleHBhbmRcXFwiIHYtYmluZDpzdHlsZT1cXFwib3B0aW9uU3R5bGVcXFwiPjxkaXYgY2xhc3M9XFxcInBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImlubmVyLXBvaW50ZXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm9wdGlvbi1pdGVtXFxcIiB2LWh0bWw9XFxcIm5cXFwiIHYtZm9yPVxcXCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcXFwiIEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2UoJGluZGV4KVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJpdGVtU3R5bGVcXFwiPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj48ZGl2IGNsYXNzPVxcXCJub3RpY2VcXFwiPjx0YWJsZT48dHI+PHRkPjxzcGFuIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjI2Knpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwibm90aWNlLnRpdGxlXFxcIj48L3NwYW4+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PGRpdiBjbGFzcz1cXFwib3B0aW9uXFxcIiBAdG91Y2hlbmQ9XFxcInRyaWdnZXJPcHRpb25cXFwiPjwvZGl2PjxvcHRpb25zLWRpYWxvZyB2LWJpbmQ6Z2FtZS1kYXRhPVxcXCJnYW1lRGF0YVxcXCIgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiPjwvb3B0aW9ucy1kaWFsb2c+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTWVudUJhci52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxCZXRBbmRCb251cy52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTcxMzhjMThlL0JldEFuZEJvbnVzLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CZXRBbmRCb251cy52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmZvcnplbiB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDgwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5iYWxhbmNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJvbnVzLWJhciB7XFxuICAgIGhlaWdodDogMjAlO1xcbn1cXG5cXG5kaXYuaXRlbS1iYWNrIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lml0ZW0tc2hvdyBkaXYge1xcbiAgICAvKmhlaWdodDogMzAlOyovXFxufVxcblxcbmRpdi5ib251cy1pdGVtIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5iZXQtbnVtIHtcXG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuZGl2LmJldCxcXG5kaXYuYm9udXMge1xcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duIHtcXG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1udW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93bi1iYWNrIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5jb3VudC1kb3duLXNob3cge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgaGVpZ2h0OiA5MiU7XFxuICAgIHdpZHRoOiA5MiU7XFxuICAgIG1hcmdpbjogNCU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/NjlkZjg0YTZcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUhBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7SUFDQSxXQUFBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsZ0JBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0Esa0JBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7O0lBRUEsdUJBQUE7SUFDQSxnQkFBQTtDQUNBOztBQUVBO0lBQ0EsdUJBQUE7SUFDQSxnQkFBQTtDQUNBOztBQUVBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiQmV0QW5kQm9udXMudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g5bGV56S655So5oi355qE5LiL5rOo6YeR6aKdIOS7peWPiiDlpZbph5Hph5Hpop0g5b2T54S26L+Y5pyJ5YCS6K6h5pe2XFxuICAgIGRpdi5ib251cy1iYXJcXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJldFxcbiAgICAgICAgICAgIGRpdi5pdGVtLWJhY2suZm9yemVuXFxuICAgICAgICAgICAgICAgIGRpdi5pdGVtLXNob3dcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5iZXQtbnVtKHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIix2LWh0bWw9XFxcImxvY2ttb25leVxcXCIpXFxuICAgICAgICBkaXYuYm9udXMtaXRlbS5jb3VudC1kb3duXFxuICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tYmFja1xcbiAgICAgICAgICAgICAgICBkaXYuY291bnQtZG93bi1zaG93XFxuICAgICAgICAgICAgICAgICAgICBkaXYuY291bnQtZG93bi1udW0odi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6NDAqem9vbVJhdGUueCsncHgnfVxcXCIsdi1odG1sPVxcXCJjb3VudERvd24gfCB0aW1lXFxcIilcXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmJvbnVzXFxuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5iYWxhbmNlXFxuICAgICAgICAgICAgICAgIGRpdi5pdGVtLXNob3coQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYmV0LW51bSh2LWJpbmQ6c3R5bGU9XFxcImJldE51bVxcXCIgdi1odG1sPVxcXCJ1c2VyaW5mby5tb25leS1sb2NrbW9uZXlcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi4vanMvcmVxdWVzdC1saXN0J1xcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nLCAndXNlckJldCcsICdjb3VudERvd24nLCAnY291bnROdW0nLCAnYmV0cycsICdsb2NrbW9uZXknLCAnbG90dGVyeW51bSddLFxcbiAgICByZWFkeSgpIHtcXG4gICAgICAgIHRoaXMuZ2V0Q291bnQodGhpcy5jb3VudCh0aGlzLmNvdW50RG93bikpXFxuICAgIH0sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgYmV0TnVtKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDMgKiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIC8v5q+P5qyh5byA5aWW6YO96YeN5paw6I635Y+WIOWAkuiuoeaXtlxcbiAgICAgICAgZ2V0Q291bnQoZm4pIHtcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRDb3VudCgpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50RG93biA9IHJlcy5kYXRhLmNvdW50RG93blxcbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50TnVtID0gcmVzLmRhdGEuY291bnROdW1cXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LmlkbnVtID0gcmVzLmRhdGEuaWRudW0gLy/lvIDlpZbmnJ/mlbBcXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnZXJyb3InKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZm4gPyBmbigpIDogbnVsbFxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDkubDlrprnprvmiYtcXG4gICAgICAgIGNyZWF0ZVVzZXJCZXRzKCkge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5kYXRhLmVycm1zZyAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdzaG93VGlwJywgcmVzLmRhdGEuZXJybXNnKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDlhZHlpZZcXG4gICAgICAgIGNhc2hQcml6ZSgpIHtcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5jYXNoUHJpemUoSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyaW5mbykpLnRoZW4ocmVzID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSwgcmVzID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcXG4gICAgICAgICAgICAgICAgdGhhdC5nZXRDb3VudCh0aGF0LmNvdW50KVxcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnY2FuY2VsYmV0JylcXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93biA9IHRoaXMuY291bnROdW1cXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcXG4gICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCA1KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvdW50KCkge1xcbiAgICAgICAgICAgIC8vIOi3neemu+W8gOWlluaXtumXtDMw56eS5pe2IOS5sOWumuemu+aJi1xcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA9PT0gMzAgJiYgdGhpcy5iZXRzICYmIHRoaXMuYmV0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyDlgJLorqHml7bkuI3mmK/mlbDlrZfml7bkuI3ov5vooYzlgJLorqHml7ZcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dUaXAnLCAn5YCS6K6h5pe26K+75Y+W6ZSZ6K+vLOivt+WIt+aWsOmhtemdoicpXFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvdW50RG93bilcXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93bi0tXFxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvdW50RG93biA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8g5YCS6K6h5pe25bCP5LqOMCDml7Yg6I635Y+W6I635aWW57uT5p6cIOW5tuWFkeWlllxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZXRCb251c051bSgpXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNhc2hQcml6ZSgpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LCAxMDAwKVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG5pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuZm9yemVuIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lhrvnu5MucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5iYWxhbmNlIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5ib251cy1iYXIge1xcbiAgICBoZWlnaHQ6IDIwJTtcXG59XFxuXFxuZGl2Lml0ZW0tYmFjayB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbmRpdi5pdGVtLXNob3cge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmRpdi5pdGVtLXNob3cgZGl2IHtcXG4gICAgLypoZWlnaHQ6IDMwJTsqL1xcbn1cXG5cXG5kaXYuYm9udXMtaXRlbSB7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuYmV0LW51bSB7XFxuICAgIG1hcmdpbjogMzAlIDAgMCAwO1xcbiAgICBjb2xvcjogd2hpdGU7XFxufVxcblxcbmRpdi5iZXQsXFxuZGl2LmJvbnVzIHtcXG4gICAgd2lkdGg6IGNhbGMoMzUlIC0gMWVtKTtcXG4gICAgcGFkZGluZzogMCAuNWVtO1xcbn1cXG5cXG5kaXYuY291bnQtZG93biB7XFxuICAgIHdpZHRoOiBjYWxjKDMwJSAtIDFlbSk7XFxuICAgIHBhZGRpbmc6IDAgLjVlbTtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24tbnVtIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBmb250LXNpemU6IDJlbTtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24tYmFjayB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24tc2hvdyB7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBoZWlnaHQ6IDkyJTtcXG4gICAgd2lkdGg6IDkyJTtcXG4gICAgbWFyZ2luOiA0JTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFOSUFBQUJ6Q0FZQUFBRHQyVndKQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG93UkRBNE5EUTJSVE5HTXpReE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3dSREE0TkRRMlJqTkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVTJRa05FTjBaQ00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tVMlFrTkVOMFpETTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgranFUZ0lBQUFHTEpKUkVGVWVOcnNYUWx3SEZlWi9ucDZiczJNcEpuUlpjbVNEemwySXRueENmaEtuTVFtSkU2NEtzRkFRWUFpcWMxaW9MWXF5d2FXS21wcmQxbVNiTEd3TExBc3g0WmtnWFVTU0VoQ3NvdnRISTRQSmZoY1IwcXdMVit5SlZtMzV0RGMzYjN2OVJ3YWpXWjZ4ckprWnpULzUzcnUxdlRyNjczM3ZmLzcvL2U2VzFCK2Z4Tnl3TWpTUnhOcExVdHpFcjhSQ0tVQ1Awc1hXVHJLMG5Nc1BjOVNKRDJEOE5rQmRhbUhrdlVBSDJQcE1aYWFxU3dKSlF3YlMwc1M2Vk1zZGJMME1FdlBabWJVWmZ3dHlvcEtvR2VKUkFUQ0pIQk8vQzdCRVRGOWd4NXBKaWttNFJHOWlMK204aUlRY2tNbjRHdU1Ld0xqeXRjbVdhUmdSTmxHSkNJUUNnUG5DdWRNaWtqY0hyMzJidFJzTkFqL3d0Y3BVYUpVV0dLYytkNnIzeWczcDRJTnkrYnFQNjNqVVRsRm00VzlZU2YyZTFyUTRXL0NZTlNCbUNKUzEwU1lQVlpHa09BMmVOQmk2OEw2OGc3VW1ZYTFKUjVRMTFvdmZvYXQvbHlBL1hyUjh4L081KzFtWVd1dUhUaGhmdHUvRWZ1OE4wSVFEUkQxT2dnNnJnb0ZLbjNDTElJQ1JaWWh4V1FvVWhUckhHL2ozdW8zWUJCaU9mZndoWlNYeS85aStNTjZ0bTR5NnJGU2kwUS83djRJT21NTFlYR1lZRFNiWVRBWm9OUHI0elFTaUV5RTJjQWhSUlZrY2l5R2FEaUtTQ2lFTjRPck1OQmRpZTMxdjFldFZUWXc3cXhnQ3pNbmtzVWdDdTVjeC8vZHdFMDRxeXlDdmNJR3M4MEtnNUdSU0JTaDB3bEVJc0tzSTVNc3MyU1ZFSTFZRVBJSGNNN1hqR2NIYjhJbnFsN0x1Z3ZqVGxXU1NFWW0wZ3paL0tQZWlBdC9DcStCcmNJQnE4TUdQU09SUU9RaHpGYXd0cTBUZWRKQk5PaWhaMG1uRi9IV3lCcHNEQjlIblhFb201K2tqeHNtZFdBcGU1U2hiV3daekE0N3JPVTIxUktSQlNLVURxY0UxWVd4Q21XUUpVbmx3c2VOcitiS0xtcEdERTRyaTFVNXB5Y1NFVXJVUXZHMnp6bkF1YUNWVXgrUFZlU0lTT2hyWVNVNVJ5aDF5OFE0d0xtZ05UcWtUenBaMmFBem1xRGpZVzVGS2FxYnYzVGhFZ2I3NG1NQTh4WTF3bFp1eTduZFhlTkU3ZHphYVRsdis2RjNjTDd6b3JyZTFOeUExdFUzWk0zMzBvNmRxZlcxdDYyQnM2cHlTdWVMaENQWTlkenJsN1dQMW5YbEE3L3U5cVBuMWZYV0ZVM1krc2tQWnQyV0MxdnZYVC9sYzE5TGNBNXdMbWp4UUs5NUFMMCtIcDByTW5DU3ZQVE0va1RsSVZWNXA5bzdFUTVGY09SQUIzcTdSMU1Ob3FrNTk4Q2J5V3pFb3RiODgzZjlIai8yN2p3TXJ5ZVVJa2dTano3OHM5emt5Mmg4bi92eTNRVVRlOS9PdHJ5Tk45djVMcWZ6eUVVUS9sdjcwWitsQ0RLYndUbkF1WUM4RmltWFdVdm94R0xEbkthNjFIcC83MEJxL1dUN21VbU5JdDRnY2pkR1RyUkNpSFQ4WUh1S1JCdTNMSjJ5bFNtRXNINnZYKzBzRHU0N21mcDk0ZUphV0t5bW5QdDFuZWxMWGQ5ei83VUxHeis0YWxxdGNlM2NxcXpuU3I4dTNpa1ZxNitVandXYTBxNVlBd3k4RVR2S3pXcGxubmk3QzdmZVBmTlNjdSt1dDlWMWZ0N1ZHMWZPMkxuT25lcEtXZHQwc3FmTHJGelgrTVFQWDFUWGVia2tqL0h3b3c4VWZHNXVMYk5aZlk1VjYxZGt0V0lidHF5Wk5ySmVhekpOV2RxcE5DelNPRVBqd2hxMEh6bXZOcHJod1JHVlhHczNyNEdsekpUcXlibmxXTEJrbnVaeGpHWlQzakk0Zk9CNGFuM2poMWJoWkVmbnVIVnNyTVBEajAxc3JJLyt6YmpVKzl4WDdyNjhocGJ4Qkptandvd3RIOStVOXhwckcydng4ZnR1d2JOUHZwWkZkdVRHZFVzWHFOWm05d3VIMVB1c2REbXdic3NIVkw5emEyTHVzN3ZhaWNQN2orTFN4YmoxN3pyYk55NC9keDFVeTF5OWhvWXFyTnF3b2tpSlZJQkZVakQ3MExTb1FTVVN4eDkrc3h0M2ZYcXpTcWJoQVc4cUR5ZVJ6V0ZUcFZLU05KY3J5WGhQbnp4UFhYMkYycWllK0xjWFU0Mzhpdzl0bTliN210ZmN5TWpuVkFNTjNOK3JZeVEwbWdxVFRGeWlidjltYmVwK0M0R2RFY1k3Nm92TFlIYWYvQjVIaHJ3VHBUVHJMRGlKa3VXUWp0TW5MczJhTmpYbHFGMHh6MG5sRFRvSkhsaUloTUtxZjVHc1dON0l1U1ZvUC93T1hub3FMbEZhVithWFNGcHcxWlJqMzg2RDQ5YnA5bFVwc3VVTWpQUlBESFE0MlhWckVZTmJnaDk5KzcrbnBZeTJibHVmMXhvbU80WDBza3dHYXNabDNUS1VCS1lzN2ZpT1NuSGFLMjVaMW15NERzRkFPRzV0V09NOGQzSzh4MXpjMmhpL04xa3B1TER5UnNUU2VtUk8xT3RhRm1LWUVTV3pNVTZJaWowMTBkOVJwVjVEemRVcEpMbncrdVgzcyszK3JXcTVIdGo5VnNvbjVHV2NmcjI4TTlyeTBadVo1UjlKMWNQM3Z2WGt0SlR2ZTVWRStZbFV4T0RFdWZYdWlXOUlPdmJtMjZuMWkyZjdXU1BlaGFFK3o0Um9FLzl0Z205Ujc1NlNydCs0WldYQmt1dXlMY205NjNKdU8zKzZld0todGZLNmExMTV6L1h3by9lcnd3WW5PODZpN2RWRENQcERPSDB5N2dNdHZLNEdHejc0Z1VuN2NCSWxPdy9lTVpRQ3RLWGRMSHZrS0dtZGNra1U3MmdvcTg3WEtvUGF1VFY0K0xIN1ZaL2xGOTk5V2oyRzZzc3NibEwzTTVxTmFpOWRjQWZBUThSNXl0eGRsNXNBWG8rdjRMemNQeXlrZmhjdGJjWkEzeEQyN2h6dmlPb2FLdkRoejk2ZXZiTVFOTXF1V051VGdNbnFwUlNrblJwTjIzY3NGVWxhdW5ySjFPNmx3REk0dE9kSWlrUWJON2ZDWnJlcSsvSGxxdlZMQ3o1ZGNqOU52K1VITHhaOFBLMjhXKzlaaTlZMTJqTU5YdG9SdDlCZHpJSlA4SlV1anVLRlgvMVJIU05hZTl2cThXdk9MSy9NOWRrczdaVFp5U084OVVZSGZLbVpCcXZWdERMRE1UN3o1M1BZdDdzOUxsVVcxMkQ5bGpVVHR2TkJ4SHhsTU9ZYnc5N0VNVGlXdmI4MXRjOVEvd2llL09FZkNyN20rNzU4MTlYemtRcHdXZHFQZGszNHUzVkZZK3EzMHlmaUVpK3pUSFB4cU5oZHBKS00ydkhHblNRUlI2VTdIdFllR1J4QjJ5dUgxUFdhaGlxVVY5aFRlWGp2Nmh2MTQxVEhtUlQ1a3Z0cFljL0xCeVpJbm5NbnppZGtta2w5SUhLNndjbVdDME9YaHZEU2I5dHlkZ3pwc0pmYkx2dGNuT1EzMzhuTDFqOGhzRk1TS01Xb0hXOVE2YjFvOGo1OEk3NVVqMXJoY3NDY29mRjVtRHk1dldsaFBTcGRGWnJuNGNSTTc3VzU1RWsyWkg3ZWxldVdUcEpUaytSVEluK2haYjUvMThHVU5YamdvWTlOSkh2YXZyeGpxSzJ2bnJEdlk5LzR6OVE2MzdmTVp0VTgxNUg5eC9QN1VEZk1SMG1ZcEZJTU5uRG5PSW1hZW5mcVBueHBnNUhsbGZaSis3bHF4c2VmUW94VStlNmZENHBlRGxwV1g2OU5wQUtVd0x4RjlTa2k3Zmo1LzZCcFFad3NpMXJtVDdZeVF0eFg3T3NlbkJCc1VhMTBBWllrVTlwbFExTnovY1JPTEcxc2pLK3JIVmxHUFpSV3NLR0l3UnRPRWxWcFlkNitudkhmWGRYT0NaV3VkWXhjNExMbXZ1M1pYOEJrc2hnUkRrYW0vZDRXTEduQ0szODRFdThZbUh4TldkQ01CcDErSDVtRTRMTHZjckgxM3JWcW1hbStKWk92KzlMOHdqdTNiV1lwTHFsLzlPMm54anVKWjlxdy9admJVR1l2bTlXcVQzdUtVQkZMdS9TRzQ2cXVUTjFIOTdueDZKUFRYWUdodnFFTUg2QTZyVGYxNUwxL284a3dZWjlNWExyUWQzblNwb0F5NTNMemsxL2N6S3p1OEFTeUcvbVR6Rm1rbEdvSk1yRDIxcFdYWGJjdTFta2s3M1ZDdWFWZDg1NlgyOUo4TUxOSzlMZGVQNEpiNzlwUTlQNVJ5UVViWG43NmxRbVZtZXdOZi9mTGw5SGJIUitBcmFzdng1aC9ESjRSWDg3ajhMeUg5LzhmVnEyL01XZWVqc1B2TW1uMlptNW4vVXQzNXJ5MnFRWlJ6cDJNZHhKbXM1SDVjWFBHL2J0d1JMVVU2UjBCdjc3TWZCdzk1eStwcVdYVjlZWDduV25XdTY5M2FGSTVoSmpNVFhaZ3Q5MjFVajB2TDV0RCswK2hwczZGT1UyMUJRVnZabCt3b1VpUmJvMFd0ODVOclNmOUNvNzZlZFZvZS9WSVZoOGdQY1JiaUx5YjZyWGxrb3BhNEZGRkxlSm1kZ1Q1OGw0T2tYSWRpL3RsTzM2eGUwTG50WlFkbHc4dUgybDdOM1VkdkZ6di9NUnRzMWZhYVl3a29Sam5ocmV1aUpPblpvNGJTMjVzVHQzRDFudkhwN01zYWxtSTNjKy9rZUUwejFIenJyMWxSV0lkaVpINzNHWEFneFBweDUzVXlDcktOTGRQa29wbWcrYjVUR3g3OHY2bXFac3RxQ3kxQWcyTi9QSDF0SHl0cXhhbjd1UG1POWFnL2ZDSlJIMjRVTHpQR21oemdiK3llRzc0SjlhczNlUjN4Ty9Ea2ljOFNpQ1VBb0wrQUw0aC9WWDJ6dTNCUUtPMlJTcjJxUTBFd3JUNlIvbDhKT0lLZ1hCRktsalRJc2xVZEFSQ1FVelN0RWhqWVVZbG84eGZGQTY5VHFDUHVCQkkyV2tSU1V2WlNXeWpGSXNmUmMvZkdNN2ZQS2tYU0E0U3lCNFZLdTB5Z3cweGlTV1dOeFRqMzlBVTFKMzVraXdWZ1lJTldsVFRlQjFYVEZhZ2ZzZU1MUm1YVk9uSExaYU8zaE5PbUkwOEVwU3BCeHNLaFNyLzJIOWhpZk5PVWEyVVNOYUtVT1F5THNiYXRKUllCaU5LNHRQbFU3RklVeGhINHJtanpLZUtxbWFMVzZpRXRXSkxrWnN1Q2dWcW9rTHN3M1hPVHRRNWgrRjJlR0czeHg5TzlQbk1HUFNXbzJlNEFxZUdGMkZVcXFIQ21rN280c2FBaHdPNDJwcjB4SVNpRkJKc21MbklBYitnQ0x0QTlXRUNkcFhjVW5GQ2NVNkpQQkpJUVFzVlR0MUZySi9iaGhzV0QvR1BrU1orSFdNcC9neVJ5VzZDZTA0UVM5Q0hXd1B0NkRqcHhQNnVkUmhSR3Fqd3BpVFZHSEZZNDB5cUtha2dJekhsQWRucG4ydkhMNWhmZUxvYnhpMldhcm40WndkTGtGaDEvdi9GZmZmOG1iSEZvUkpIOGwrQXY4c0RPY0JNZWl5YXFDazlkRllEYkhQTElkcXIwTExjaDViRnorQlh6eTFCZDltSGlCbjVPblFoUVJoT0hFWFJla1l2TnhkbTJrZTZVaTBhVGR4Vk9FR3dwTlhTSlplem1GelZ2WS9qdmdmNVU3dGxpUG5PWS9oWUYyUy96S3gxR1l3MkIwUmovRkY0S1J4QlpNaUhnWE1Yb0xOM3c3bThFWHA3QXo3ejZWTjQvQ2U5NksvN0FyRWxnelF5Q3JjMmhiZFdUU0pwNkxKck1OZE90VnF4eEhsaktRbXJTa0ZkUWhMT2hsZnV1YnFmd0JlMmUxUVMrVTkzd0hOc0FCWlhFeXB2YkliZ2Rrd3VlMEdBTXVqRnlNbE85TzNxUlBseUQyd0xXdkNGQjczNHhZOGV4MkQ5NTBzdUlLQ1NKZUhUcU11WjlGSEVmRDVTRVV4TTVRVWtKKzF4d25KeC8wcVhJRmV4RVN6YTlSYnUveXAvUHNvRjM0bWo4Qnoyb1diZDdUQTAxUUNCSUJDVTRwOFNpVW1xTmhjTWVyVVFoSElubkRmZmhPajVmdlR0M3cwbGVnejJ4U3Z4eGUwRCtNY2YvQW1HeHZmTmVzS29pZjJuWE9XS1ZxYjZZSi95SHAvQXdLOVBUbyttcFBsZUtya3dUakpkWW9xVER0ZitzMCtLTE9PckgzcUJyUzFFOEFLelJFZEdVYmZwd3hDcnl3SHYyTGdsMHNVUTlZdVFvd3BNTHY0aUZndGpJQ09ZTndCRFF6WHFidG1LbmowdlFHL3RnR1Z1Qzc1eXgvUDQ5NDQxUmZmTlgvVVY3RW5DcEpNRkdyNk1jUFhibWhhMEh6V1hpL2N4aW1SRlpLMERKWTFZUXB4WUU0ZzJ3MlF6ZE8rRTQyTnVLTUZlakJ6dGhhdGxJOFFxTzQ5eHgxc1RQN2VvaCtTTFFSRjk2bWNYWXg0RDlDNDFCQnJQd1BLSzFRNjRXOWF6WSt5RnVjcUo4a1Z1R0hiK0ViSDYyOTlUSkVsYWxDUlJrdDh1U1AwdEZFbUQwcFhnVzRUeTlTNVM2aFc3azYxWmttenBCT1ByeVlrZVF2STNKZTMzeTJnTWQ3VHlGMVJXd05OK0JnYXhCcGJtdVZDODNuaGw4YzhzcWljT0loWmdGdFhtaDJnS0l6TFdBSDJZV1N2QnpDeWFGRytoSHErNnIvOUNEVHh2bjBYRm1oVzRvK1VnWGh5OWZjYUpvUzRUaWtXUmxWUjhWMUVtRWlZdlNXYkppTDFleXlCbC9leEpDVG15aXBMbWx4V0FKS0dTSDdBV01uNVhmYVBSWHR5d0tRU0VoaEVaaXNKVzB3Z3dnZ2h5bEoxTWdoU1IyVUpCYkl6MTRTWVRUSlY4SENuSWZLUWd4cnBGR0IxZThBL042d3dpQkQzemZpTkFHVHVHZi9BWU8rWVFibGdSeGRQUFhJVEpXWjh6M3BUcVE0UTBjaVIrVEZmS3lXV0tGTk1iNkNxeUJxRm9palB0OEhkUzZ4QUtKeDhTZmx1T0JpWDZUekJqWkVTNGN3aEN6QVN6MHc0bEhFS3duLzF0WUlXdHhCaVpvaEROVGhpdGZmQWNQZ1ZGRXVCb05rQ3hWQ0hpR1ZiclJXKzJNSXNWZ1lWSk9vdlRBVitQQWVHTFF6QTF1eUQ3TytGMzFFM2ZqUlh4SjFDbnRReXU2QWxabWFZZVRDY3M4S2kxRWhvTlFZNkowSW5NazVOakNJK01JREI0SG5QV05hclNFUVkvUm81ZGhPK3NIM28rMDBIcVJNVlM1a09WTWJJWjllZzdlSUw1ZDA1WTNSVXN2OHpXR1pFOElmQ3Z0WnJnUTREcWJXWjZ5aHpRVGV4TE14TmgyclYwbFBsQ1kwT3NmektvTStXVlNBaVMzNGVLcGhxWXJYYjA3SGtYa2krZ2pwOUZSMk53ekt1QXRkNEJPY3lrQlpON0NyTlcvVzBub1lRRXVCWTFRQTRGSUVkRDZyRWttZldMRVI4N2g1OEtla1kxeDJTZXpObzNyYjVYSWNXWXRibDBGanF2aFVrNEd4UkdBb1U1UFZ5bXVWcGJNSHhjUm0vYktkUnZXZ3k5MVlEQVFBQ3hVSlRKTnl1VGZnTDYzanpOVklJRHRhdFdzTjlEYXQzcEpCbFNOQXA5Z0JHd3A0ZWRZem5WMjB6NFNFSStIMG5yVGF2MEhNUzBZZ3hPSUJCVExaTk8wU0hTdzRoaFpTVFJteEZtMXFXaTFvN1lLTXQzb2dkbW93NUJab0VNakVBV3E4TDhxbDRvL2pDY2l5b1FHUjFTclJsaVljaUJNV2FoZkRBRW1HeGtCaThnVkZDOXpZU1BwT1FlMU5KVENWMWRCS3pOVUFhWXIyVFJZY3diUTNCZ0JJWXlUMXhsQzR4WWlzUXNqd0hTYUFBR214NnVhbEVOTDR0U0dKSEJHRVM5SG9HZWJ1aU5BMnFVajArb2lvNHBFRVFGSml2TE82Z2dhSjRQTXhYMTFaWHNXaGFKaDBRVmNscW5GYWFxQlRoODBvN1Z5d1lCa1grdHdnUzlTWUxFNUJrUGtVZGpFdk41d3JEWWpQQjBCK0VQUk5WNnNKb05jTHBOaUREbktSTGtZNE1DWkZtR0tBS2hpQTZpTGNJT0Y4S2hZMjZZcWhkU3ZVMjNzcE8xNGdiNUxCSkp1eG5CaTkyYnNYcnBiMkRRQlJGZ1pBb09oYUV2VXljMEljWjhIY2tYUlc5L0JHRkdJSWZiQXAwb3dEdkk4bm9qME9zRmlBNEZSbEduRWluaWthR1lyZXhZSVQ3Z2d4ZDd0dkN4WHNLTVNMczhGaW4zWkR3S05zeUluOVQ0RVp4dGZ3cnpHL3dJUmMwSWhjd3dqbzVBYnpWQkNzWGc4VVJodG90d1ZWb2d4MWdWUkdVNHE4endlY1B3RDBkUnhzZ1VZK1NLalRHNVo2eUVrVm1pU3BNUDV6ck1HR3Y2Q0l4VVp6TVRiTkFvVnhwdXZRWXdsdG54cjJjZVVMczVhM1NReVRJRklaMGRvU0d2T2ltMXdtV0UxYVJIeU1PbkJvVVFEWVFSR0EzRHBCTlFXY1drSUt2UTRLQlgzVWUweWJCRUI5VmpmZi8wQXpCYWJWVEE3elVmaVN6U3pNRzY3RzQ4c3ZNb3ZuN2I2NGdOOWtBdXEwTlVyQVpHaHlINHhxQXpHS0RPQlVwcGE0WDVSakx6bjVqUFpMUkFLSytHYUZGZ0R2U2l2RXJDSTMvY0JPdjc3cWI2bWtHTE5QWHZJNUdQTktQd3Z2OWJlR1JYREY5ZnZ4Y0cvd1VNb1FxQ3k4VWZGVmJIaUJDTlFJbkYxRG9RUkZaVkJrWWdteG1Da1VmeWdpZ1BEY0RCRE5Bak96ZkF1L1piVktEWDBFZlN4ZnU2N1A4SVY0Rk1hLzhlRCsyNUYvNHhIZWFKQXpDT2RVTVdHSUVzQnVoY0ZSRGNMalh4ZGY2YndyWVpBOTFxWGgvYjU2RTk5N0JqL0FNVjVOVXdTaG84bWZiWGNSRXVINllOZjRtL2ExK08xWjIveE9hR1R0U1VEYWhWRW80Q01TSCtmTE5la1dCS1BEdlZGeER3MHhPTGNOaitlYmczcktVNnVtclNMcCtQUk5ibm1zUGR1aGJuc0JhUHR1K0grK3dCTEJBNlVHUHNoOE1ZZjR1UU4yeEdYN1FhWjVRV0RGV3VnM1B0ZXJpcDJLNjZUY29UYk5EYWtVaDJOZUZxWGNkS2ZCMDZ2S000TWpvSUpSei9XTFRndE1OVTdvSzV2SkpQTXFKNnVSWWt1cEt2VVJDdURjeU9DalVSaXNFZTVac2lKTk1VSVFJaHlRWFFnQ3lCTUxQSS82ZzVqU01SQ0ZmNHFEbUZ2d21FTkM3a3NVZzArRW9nRk1DbEs3SklGR3dnRUs1d1FKWmV4MFVnVElPUFJDQVEwclhkRkgwa21hUWRnWkRrZ3BhUFJNS05RSmdHMEZ3N0FxRlFYVWV6dndtRW1YV1NOQzBTamNjU0NPTmNtSHF3Z1poRUlLUzRRTUVHQW1HR29SMXNvRW1yQk1JNEY2WWNiQ0JwUnlBVTVDU1J0Q01RcGt2YUtXUjFDSVFDak5KVVh4QkowbzVBU0pOMitYd2tDallRQ05xNG9tQURnVUJJTjBzazdRaUVheWZ0Q0FSQ0lRYUozdGxBSUJUT0l4cEhJaEJtRkhtZlI2SXhKZ0loUVJLSzJoRUlNK3NrYVVvN0VSS1ZIWUhBWUVTNEFHbVhBeFhTQVB4S0daVWlvZVRoa0lZMHQ4Yy9mWm40OUhsbVdpaS9ReVZJSURETWwvK2NreWQ1cGQxeXFRMktGS05TSkpTMlo4UTRzSUp4SWErMGk4a0k2bld3Wkc2c1JpOXVqT3pCY2V0dFZKcUVrZ1huQU9kQ05zZ0tZaW1MRkl4Z05EVWRLQ050RGo2RnhrZ0hsU2FoSk5FWWVWZmxRQzUrcU54SldDUmxjRXgzM202UzZySWRpRWZ1N3ZIOUFLOVp0K0dZZVJNVW1nNU9LQUVJcktVdkM3K0JXOGQyYUVhdisvMjYwNXhEbkVpeEl6MzZBL09kMGdkeVpSYVo5ZG9jK0RXV2gxL0RjZE5OT0d0b3hhaFlCUmtpbFRoaDFzQ2doRkV1RDZFcCtnNGowVjY0cGU2OCszRHVzSVVrd0g2OXkxMG1yejY0ZldTSHphalExMzhKaEFJeEZoRkczLy9qeWsvMStYVUhSWmlxaEVCVXNOU1V5WVpWYzZKcnFIZ0loTUx3eEJIejR5KzhhM3FEcmZaeElzbGN2YjF5MmpqMnZybXhtcVpLYVQ0VkVZR2dqVDFuamE4KytIdkhyOW5xR1paR2RQM2ZIT0NlMUFoTEZ6N3p0T09KQTEyR2ZWUk1CRUp1dEhVWjlqT3VQTWs1aytDT0pINXRzeFgvdkxlTXg4S2praXpvZGh3M2QrbEZqQzZwaXMyMUdHQ2xZaU1RNGhnSkNrTS9QV2g5NWt2UE81NWpYRG1Wc0VaZWxoU2gveEdYbXFuNjI5VThndWRtcVptbCtYYVQ0bjVvNDlpYVRmTWpyZlVPcVlIOTdkQUpGS1lqbEE1a0JaSXZMSGk3dmVMRjE4OGEyNys3dCt3ZyszdVFiVHJMVWlkTGZGMGRrQlg2ditOSzdWajlUOVVHdHVDUnU0WkU0aHU1VlRKeFB3cjBUaUZDYVlGUHBPT3VENS82SFdDSnoxeTltRWlqL1gvYkgyV2NVVFB5OEhmbXpueTJBNTh1Vk1sU0ZVdE9sbXpnTThsQkZvbFFVdUFraXJEa1oybVlwWUdFVHhUa0JpczlZN2JIS0hpR01aWkNpWjNNYVNRaWkwUW9SWXNVU2ZBaGxQaDdFdjVmZ0FFQVZNVzN6TnRjYlM0QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFOSUFBQUJ6Q0FZQUFBRHQyVndKQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGTmtKRFJEZEdPVE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZOa0pEUkRkR1FUTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVTJRa05FTjBZM00wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tVMlFrTkVOMFk0TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrOE53djd3QUFGRDFKUkVGVWVOcnNYWG1VRk1kNS82cTc1OXJkMlowOVdFQ3dMRGRDTEFJV2VBS2hFMUNVaUNmWjByT003QUIrTDRsejJma3JzVW1NLzNXaStDVlI4bDdpSEphZENGbDZCc3VXZGFCbkNTVFozQUlKQkVJQ3hMRmM0bGhnZDVsbGo1bnA3a3A5TlQwOVBiTXpQYzB3eTdJNzMyOWYwWGYxVUZXLy9uN2ZWOVhWR3YvMUE1QUhmcEcrYktYRkl0MWg3U01ReWdYWFJUb24wbjZSWGhYcE5aSGl6aFBZNnN0eXFRSFBtY0dUSXYxUXBLbFVsb1F5UnBWSWQxcnBheUlkRjJtdFNML0tQbEhKMmxaTkxnbjBLeUlSZ1RBQXlJbGZXaHhSblFjMGNKZ2szWUJuTlJYK2hzcUxRTWdQaGNGM0JGZVk0TXAzQmxpa3ZqaGZTU1FpRUx3QnVZS2NzWW1FOXVqOXc0bWczOGYrQmRjcFVhTGtMUW5PUFBmZTM5VUU3V0REM1UzYTF4V015bkYzRmw3aTliRGJ1QnVPbUpPaEF5SmdaTXBFQW1GWVF4VXR1aDQ2WVliU0JvdlVnekNhWFhXWGVBQmpXOGFwcThUcTh3ekNNOVZyLzEzM1dqaklWdVM3QUFuem1yRVVkaHF0QUV3QnhwaWtKQzRJaEpFQ2pvWUVtemF1Y0JNV0tSL0RsN1Izd1FkNjNtdTYrL2xiTlgvVzhZUW0xZ04rRFZyZFNQUzgvalFjaDhtZ0tFZ2VpMGdtY29xbFl4WEVLc0t3Wlk5RklKTkxNNE5FNHB6QkJ6QWZMdXQxOEtmYVJtbXRja0Z3WjU1WUJKRklJWi9LR3ZMZDV6VjlHWnhBRW9tTUZVV1ZkeFJVU3BJSXlTTVhSQ0xDY09ZU3R5TUcrR2RLdWFXQWFSclF4aWJCNjhZeWVGSjlKK2UxZ2p1alVrVHlDeEw2Y3ZsSEYza0Q3T0h6UVdHcUlKRWlpWVJMTUFXWlZFV1NpcVhvVENBTVh5cFp6VitReURCQlZjWFNOR1hyTm9YRSs4Q2NENHZaUGhqRHJ1VHlrN1NrWVpJZFM3bWpESHY1WEdDcVQ1eXNpTXcxWU53aWs1cjJrNGhFaEpGQ0ppbnZoRlZDOGpCdWdLSXBZQmc2SUtXUUM0K3p6WG5qRkpvYkV6NkhhVWtTYVVnbVZaQkpsY0lPclZKU3pqR2lFV0drMENocG1ZVE1ZOElhU1JJSmFRZXFhT0ZHUW5JQklDK1JtSmJPWkNDNldMMjBSRWdpVFZnaUprNlhFZzhzRWpsOUkvS1RDTU01MkpEeWxaZ2drcW9rcFozUWJicUo5b1pEbDFIdjJqdWtaV2VXeVZKaGlZUS9wUHJRRWdtTGxMUkhralFNV0pvODNJV05aWVRPSzUydzY5MjlOM3pkdEZtVFlWckxqUTl0dkhqMklxei85emZzN1RYZmZoekdOSTNKZVN3ZnZ2dVAzeXp6V21PMkptT1FERGFvYUpYRUVpUFdHQXJnQ1VQSU8xOWVucVNKbEFlcEFBUGp5ZUFDQmgwdy9KMjBSa1NlN0ViOTZvdWJJWHF0LzRhdlBiVHZOS3g0T2c0Tm8rdWdxcm9LcW1xcVhPL3pRaDZDT0luekRVRXFqODJJNE96QzRVeGFKVVZKOG9ZYlF1WUpsNFlMQzRWZFBrVVJDVkxCQldiSnVaUmZSQ1FxMkxDbnpCZ0RvWXFBNjdWWDI2L0JoUys2NVBxbVgreVF5eFZQTDRHV0JYZmQ5Ty95QndQUU1xOVpydmYxeHVERTBZdHl2Ym9tQ0JNbWo2YUt5eGR2a0IyeXliYU9YVDVjTUlwekZRekRjTDNVVmRySkRsaUE5RWlHWkhpZFNGUUFUNjErMkpOVWk4Zmk4UHBMYjl1Ti9FWngveU96WWZLTWlmYjI5czE3N2J6cVJ0WENpbWQrenliN2lhTkpzaU9KVXZzSitjbUUxa2U2VE9qR2NEbmlXK3dyVXRyWlBoQ3pBZ3NLSXoyUWhUb2h4Nzd4VjQ5bldBSnN4TjZzaGgrZVdQVW9kTFIzMlB0UTJybVZMOHErRlN1WHdKR1BUOER4ejg1QzU5VW96Rjl5dC9TTjV0d3pFKzZjTzBXZTErSHcxL3A2WXZiMVo5b3V3YVlONmM3Rnhjc1dldjY5WlFYRmlnTUF5K1NDRzVHNEc0ODQ4Y2FWREFFL2ZISDZBbHc4ZDdraytYbXhGZzJOZFhENTBrY1E3ZXEzcFNIQVFmdjRtUEdqSU40Zms3NVhOdkFhNTM0a0lhR0FENW1TZk1WS3V3RVU0bVNOY3ZwSmdrUzVHbTF4UkhJL2Z1cjRHV0ZSZGd3SVZtUmpYUE5ZcXBoU0JDQ2NYQ2cyYXBjVWlVNmlrWE9VQzlOblRZTG1LZVB5SHQvMGk1MFpmazExSk94ZTVtNXc2SFRNNjk3bDkwREg1VTdZOFB3bWFXMmtYRnU2UVBwZkthRDBSTXVKKzNCNVhsaFE1MjhxZU0reUpCSzNtanYzVkVZYWxkak5vMUJnd2Rsb0o5ODVVVWl2NHFObUdOR2JQbnNxYkg5bnQvU1BObTNZREdkT1hySko5TlRxaDZUUGMvSGNwWXpyZHIzM29iUmNMYTNOcnFRbkZBZDNhY2NjQ2JMV0NVbW4vakk2OVI5NlBuLzdPM3NnVkJuTWUzenhzZ1VGblg4TVVzeGRQQnMyL0RodGhhUXNmUHBlbURaNzZrQlZ6Z280QVZTbmhSMGxCb1dsSFM4a003anpCVnVDRS9tYytudzRjZlNTNi9INVMyYTdWdGl4UXlmZzgwTW5aZCtRazBTSWJadjN3ZW5qNTJTd1lkekVzVmt5aFE5Y3o3Vk55Q3FYZExrVkRqYmtPU1dEUjR6S094Y3dYTDNpSzR2ZHBkMHJ1K3oxKzVhM1FJMkxqNFQ1dVpWenJFOFFkLzhaZXp0Y0U0VEdNVFdTb0RJaVp4Mjd3eEZzY011UGVPVEJodGpMUXNFR0tzaWlVUm11aEZtT2tRaG9NZEJLeVVZdUNETmhhbE1Ha2RCSEN0ZFV3YW1qcHkyWkZoQSsxaFRQOTVzNG94bldmTHZlUWFRcStSdWNQbEZBU0w5WWY1d3FwK1RzdXBsZ0E4K2VPNFhnaGkxdjdJWnVhN3pkazMvNDRNREh2ZGoyK1RUWXVubS9mZDYzdmpkYWtzRUx6cCs2QU1jK2F5dDRYdXU5czRGTTBzMmFKTzY1ZkxTQ0JaM3RzSkpqNnVxL2REc0dyVFpQYThwWlhoZ3NtTE53S216ZmNraHVIemw0RE9iZk45ZWJUeGFQWjBnN0wwVENzUGZwaysxeUhaZk5VOGRCeTd3SlNlc1Y4bE9kZXJWQ1JRY2JDRGVFczIzbk0zd2hKRXcrekp3N3pTYlNubTJmZVNhU0UxTm1qSVlseXhmWTIrdi9ZNU85UHFacE5IejMyVCtTNnp1MzdMRUpqc3RybmQzdzJNcmxWR0dsVTNidXdZWmNrUXRDSGtzaGZKSVBkeHl6dDhjM2o4bGRYbGFaMXRaSEpCRXdTSUNOKzlnbng3MzVTbzQ4Y1hUNW1QR05ydWRkUEh2Skppd0dKdkJldUQxenpsU29iYUF4ZHE3bHpCd2M0SnlDRFlPTnR6YStLMStKU0FjQWdqTElnUHZkY09mc1NYWTRmTXViZTRUdmN3b1dMMjMxM01BeEJJNUVTY2szSjNELzFmWU9PUEpKbS8yYm52bVQzNGMzZi80K1hQamlHcnozNWk1WXNteSs3TE55czV5RVVnVWJDQVdSN2JQTWFHbkt1VjgyNkVqNnBiMXBzNFFGZW1XM0xibncvTmJGTFo3dml5UThjZlN0bkpJUFNiVEp5aHZ4d0NOekpVRVhQVFFIWG4xcHEzM3Rtcjk4VE1wQXdzM0JQZGlRSGJHalFhczUwVEt2eVY2UDFGWERndnZueXZKeTdwZkJCK0hrVjRZcjdFZWJQK2dUVm1JNW5HdTdBRjBkMGFUekwvYTVQZnJRZW1UbjYwUXdGSUI1aTJiQmxmWk8reno4VFVuWnlNVnlNaXk0OXp6MDk4VTgzYSs4cFoyejdidEg3M0RLNHFiWWYxWGtEQVA5SVBCUG9HaytVSmtxSjBIQitleVlRa3dpbEFHUDVLeXJYRTdIWlhBRGREMEI2Mks1UDlZUytQUGVDWVdERFppaENqUzhnVkNlVmdsaFVyQ0JRTGlWd1liY1p4aUNoVnIyQ0hBQ29SekFZT0RiRDhWYXBPNllEbkd1UWtoVElLamhkRnc0QXBZWVJTZ1A4eU8vU21HbVUwR0w1S2JzREpGQnYyNUN3alRCaDdQdEt3cjRORVp5a0VES3pxdTBzNTBzSytrR0Y4UXlCYkh3RzVwTVhveExzbEdFa1JsbzRKa2NLRHJZb0dUcFJVZ3ZkWEVEM1NJYnpqT3VLWUpZQ3M1aVJMUXFCdFc5M1hEWG1hTXdvZjBzTkZ6cmdJcFlIeGpDK25lSHFpQmFXUTFuR3NmRDRhYnBjRTJzRTI2UmorVG9OelU0THo3WTRCWENVSUVoL29rWnlmbVQwVXFwWkswOEUrakJnOXRoNXRsandMSzZGbFRUZ1BydVRwa21YVHdORDN5eVU1QnBHdnp1N3ZzZ1doR213aHRFb0NGQ1l4RVRiazEvd29DRW5HbTEwT2h2dDltNFBBN2FjK3JJaE00aEljMVdjazVKYWEzRVVsV1o2L3pKNVlhcDUwL0M0M3ZlQnIrZThQYVFGSFZ3MTVuUHhYVnQ4SnZXcFhCNHdnd3F4RkpCU1JvRDNTSVF4Z2J3MjMzb3lxUys2TWNIMnlJVlluWmMvRUE1cEZMOFNyUlVTQ2prbEtva3A0TXRSOHcvOWpFc083aHRnQldTeGJSZ0FjUldyc1NhaGNEUGZnYmFvVU1aeDVGNFR3Z0NWdmIzd0lmVFc0a0V4YmhBTEJsSVM2a3A0eWJERGU0K2t2TXR3Uks5SVlzL0dIKzQwK2loeFpLV1M4V0p5MGQrSmM0UXZ0Q3lBMXR6eTE3aEY4VldyUUllU0U3QUgxdTlHclMxYTNQbXMxUkl3dTVnQlJ3bHkxVDRnYzRzd3ZDa3YyTnlMNlRoV1cvS0RxRkY4aVFGcmY5VnpDSll5bW9wcWVVSUlsZTRKd3FQZmZSK1h0K1JSeUkyaWVSMmRUWHdZQkJZZjM5TzVZMTVuYThmQzkwVWhCaEFHaE51eE5vTXRrVXlyVkd3cWVVdGdMUmF1blV2M1phd1Vnb3FsaVJVWVBnTnRrQ3QvY0NCN2VBM0VqZDJvVXNrRlBONjhNQTJlR1BSSDVUZDErV3hoVWl5bUVrTEk1ZWxxNngwTWoxYUpENE1lbGV4Z015VVBiWXNsL3pjaGtXdTRVQ3djSGNYekRwL3N1VDUzblcrRFg0cjhyNWVYVnNXaEpFSmd3SHNWditPSXVmKzVwWlRsbHJlamc2ajZYeFNPSHd2U1M1SWsweFJrcUY0QllibWM3ZG9qYWFmUGlLN0Iwb056QlB6L21qMm9tRnBsZVJEUDBVWUoxbkF4WmRoZzA5ZVo5c3ZWR3VGWCt3YkFtbFhFZ3RtVlVUT091QU9ZbGtmSXN3ZzJpQ1F6VFFNbU5CK0xuT25xb0paV3p2QVJ4cFFEZlgxd0xOOEpLV3pVMGIxVXNDODk0cHQvUEw4N1VhU2xFVkpFY1ZXU3pBMGxxVjRhVmZzMXloR3FyWm1WaysxMHo4MCtBQ3lPUW5HbUdNd2NHb2ZkK3d2MEJqMFJBSkc5NlRuZGRCYld5RzJaazFHWUNFZmV0ZXRHL2d3aU1VZ3NINDlhUHYyeVczTUcrOHgyRVJLRVVNdVUwOXNrNmZmbythWmhDbElraEhpMW1rcDJWR1FsYWxVSnY1c3FsR1lwbmNybkNLVVlyMUY3QnhWMWRzWGd5bzlQVUZKN0t0ZjlVU2l2TDlQWEl0OVRTa2lZZDZKV0J4OC9rREJlSlA5REdIT2F1WVpSSEZlWTVPaXRJR3UyMTl2UW1iYjUwVmJwRnhmb3FBeFArN2tBOHR2eTBKL1FzOXNVMFlKZ3JJWmVYQ0l4aEpnaGdaaDZFZzUxcnV6MjlURC83K3dqNVQ5RlFNaVVuSDFZcGpRcldoUVp5U3RVdkRsbDZFZnBWMTFjZjAvTEJxRjRFc3YyZHRSeFNmdkFTYTkzMUpTaTVTdHpNaEhHbnFjMFlJMmtkUlBQNFhLdFd1QlYxUmsxbDl0TGZSKy8vc1oreXJSUjhvS05yRGUzZ0Y1RTRhTGowUnY4OTJVT3ZvMFVBTnpZMUZYUWtBd0J5SDYrb0NKNUFiTW03bXBDOElnK2tqTW80K1U0MzBrd28xQjBWVFlVek1hdmg0OVcvSWl4T3JGdlBFZVZEK0Q1QjhXS0ZlRlN1b1dtWDZmRDY1VlJXQ2JyL1JqNGpEUGFMaFczb013aE5JdW54eEk5ZzlnaHhrSHU2ZUFubmhGQVNmWURGWlV3b3ZWVGJEdzZtRUkzY2lvTUJlNTFpZWVoWmhuSUZRaDc4RXAyRkFpWldlMS9ZekpUL0pMT3lVbERYS2xBZEtPVXRGSlVSVUlWVlpBYjZRZS9qVXdPcSszeWJxNlpHZXJ2UjJONWh6NW5hbzN6QXZ6eEx6eEhsVFdnNWZ5OGdTOGhyOHAyRkFTK0FNQkNFY2lzUGY2V1BqUHEzSDRDLzNxUUFOdm1oQjQrV1dJUGZWVThzVytqUnZ6a3VoL3RIcllHeGtMalNKUGY2cHpsNElOZ3hac29QRDNiU1B2Vktpc3JvWklRd084cmV0dzhab0dmNnRmaG9vc21hZnQyU05UZmpuSDREbXRBWFpYajRVR2tSZm1lYnVOc1NNZmlTelM0Rm9sbnc5cTZ1cmtJTllEb2t5LzJSMkFQOWF2d01POHQ2RDdpYVgvUHF1QW53Z1NkWWRyb0c3VUtKbVhQeFZrSUd0MG0xb2tDbitYSEV6NE1jR0tFTlEyamdKVlU2SHJpZzkrR0EzQTgvRStlTmk4RHZONFAwemtDWWhZVnFwTHVMR25tQS8yc3lCc1ZhcmdzajhFRmVHd3RFUTE5WFVRRElXQUtSUjhIYndLQSs5RGhEZzl5VzV0M1NoSXBnb3B4L3pCSUVRN09xR25Pd3EvN3ErQ1YvU0VjSTFNNEtacG42c0s4cW1hVDV3YmdQcHdOWVJySTFMTytmMStJdEV0anVRVlo1R3l4OW1SdEN2cGd3NkpvRVlpMHFyMDlkU0kxQU94dm43UUUzRXAvUkNLSUp2bTgwTWdGSVJRUmFXTXppSDVwRS9FNkRNN3QwVGFlWkROUXo3NVNYbXppUWxMbzBGSWtDSWd5RkVsckl5dTY1SkVxZjRnZlBkSmtrbWNoK2ZhQkNJTUJic0tCUnZ5SEpVZkdjc1ZOU2VVMmp4aEg1QmZEWUN3UFRkVm9ZUlNrc2FSekJFeStRbUJNUFRVS3RJaXBWOGpwaUZDaFBJTExHUU1FU29nQk1oSEloQUczVWVpZmlRQythL3BWTFNQWkgwaW5jTGZoRExVZHBBeHNzSGt4ZnRJQkFMQms3THowQ0ZyWm9VQlNkb1J5c2tpbVk0SklxSFlZRU8rZHpNSWhIS3dQank3M1pPMEl4QUdYOXJsZGFMS2VLWlZBa203QWJNSWtVVWlFRzVKc0lFWEVJbzAxbzVRcms2U3QvWlBMN01RQ0NXQUoybkhPYjMyUWlnL0Z5bjFSWkxTQlJ1QVJqWVFLTmhBd1FZQ1lVaUREZG5mUm5MdUl4REtBYW5CcXA0NlpBczVSelJvbFVEUzd1YUREUVFDQWVoVmN3S2hORHdpYVVjZzNBcHA1M0gwTndVYkNPVVliTERma0tXUkRRVENvSUtrSFlGUUttbEhjMzhUQ0Y2NFJkS09RQmhVRUpFSWhKTDVTUGsreG93RDlSeUpmQ1JDT2NrNCtlZHMveVR0Q0lRaGxIWXFHRlJDQklLQUgyTEZTN3RhNHdwMHNYSEpkekZNRG95UnRDT1VqYlpMeXptUklrWkhZV21YNyszMHFjYVJ6TE5wVkFPaFhKRFYxaWNieDF4bmNYQ1Zkdk9ORDhTWkpPOEk1VzZkRE1HRjNZV2xuVzVDbjZaQUtQdGdvM2xSWkxBVDlxc1BDWVphL0ZNWUJlOElJOThhNFRURkxDbnZrQVBJaFZ3UXArbTJSZXFMUTFmT3lTQkZlclR2bHpCUlAyeUZBNU1mSGlPSlJ4akpKRXA5V0F6YmZMTitSSElnSHo4a2R5eUx4Sy8wS0tmREFXTnNybnd4Y3ZkTXo0OWdTK2dyOEhFQUxaTXFMQjJUSHdrbXkwUVljU1F5VW1Qc0RKZ2Iyd3FQOUwzaUdyMXV2NjZjd0F1UVNQcSs4OXJPU1hYR29ud25ZMGFQOW0yQTF2aFdPT0MvSDlwOExYQU5Sb0hKNklOL2hKRVRXUEFaL1ZCdFhvWG14R2N3Sjc0ZFJobm5DMTZLM0JFTFlWckNNK3NiS3MwRmU3L1Y4Zk1xUDQ5UXFSSUkzdEFUWjEzMy9LanVhNWV1SzN0VkNJeGl2UWtXYXF3MGZhMTM2QXVwZUFnRWIvaS9mYUgvZmYxd1lLdFl2WVRCQnV5eXZiTHVuYXEzZjlmbWY0K0toMEFvRE9TSzRNeHZrRHNpOVN2dDZ5NmpKOVVwMHRsVkc2dGYySG5HdDUyS2lVRElqMTFuZkRzRVY5WWpaeXp1R0trTzJWN2NHZFBaaVMrL0dQbnBjenNxWHVqc1kxZXB5QWlFTkpBVC83YXo0b1V2dlJqNWllREtjWXRJdlRKZTBmNXN2VHlwOFFlTkdJSnJFR21xU0pQQ0FkN3cxL2YzTEh4b1VyeGxYTFV4WG14WEt3eFVLazVDdWNEa1lIVEhXUFNMcUhydXQyMytRLys4clhLdjJFWXAxeWJTY1V2VzZVa2kvVU85ZldIajN6ZjZ4QUlqZCtPdGhBY3JSQW9BU0JKUlZ5eWhuSUFkTzRZVlIwRExneXJ0bkpXNjJyL1huaENja1NkaStEdjdZcFI3T0Z5b1ZxUlJJdFdKVkFVNGtoeklJaEhLQ2tpaXVFalhSZW9RNmJMbEUvV2h3WEtlbUdzV0lUeWhCeU1SMWtWQkI0bklJaEhLMFNMRkxUNzBXOXNEOFA4Q0RBRHNFSWY3cmFCejFBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S9meminS5wbmdcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSklBQUFDVkNBWUFBQUN6ZnFNMkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd1JEQTRORFEzTWpOR016UXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93UkRBNE5EUTNNek5HTXpReE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakJFTURnME5EY3dNMFl6TkRFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQkVNRGcwTkRjeE0wWXpOREV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K2dPTm1Hd0FBTXZ4SlJFRlVlTnJzZld1MEpVZDEzcTd1ODdxUHVmTWVQWkI0Q2d3UndROWh4MkFyR0lOWmdINFFMSVRCeTlpeDF6SlJFdUpnSUY3SlNtd1Q0emc0VGdUQjRMREFDOGNtZ0FRSUl3Z1I1aVVrWWJBdDhSQklhUFIrekVoM1p1N01uZnM2OTU1bjc5VHVyajZucTJydjZqNzMzcEZtUm1xdFVwKzVwMCtmUHJXLy92YTM5NjZxVm5qTkZmQUUzUGJvOWp6ZG5sNW9CM1RiVzJnMTAzYVl6NnpxTmpEdFJLRWQwKzNCUXJ0VHQ4VW5Xb2ZXbmdDL2NiOXVMekx0eDNUN3g3bzlaUlBuMmVHY003UTlvdHNQZFB1ZWJ0OHliZUZKSUoxWjI2eHVMOVB0bGJxOXhERFBZNzA5eGJSWEZ2NUdUSFdqYmwvVTdhdTZyWjFObmE3T0V0ZEdydXExdXYyU0FVL2pOTC9lbmdIVk5icDkxcmpJSjRIME9HMEVsdGZvOXV1NnZWeTMraG42Ty9xNmZVVzN2OUR0YzdwMW4zUnRqODMyVE4zK2xXNXZNZ0w1VE4vb0JuaVZhU1RjUDZyYm4rbDIveE9La2E1Ym5uMU1MdlExTzlkZXJIZS9iVnhZZkpZSENFUGQvbHEzOStqKy9lWXA3dGNuQmlQcEgzcXAzcjNMYUo5dDJWQzNEWXhnTFlsaFEyTnlBMlBvUUFSOS9iZStvcjJDUk84eGpmV1Y2U2hNWDBXWVFGMGgxTk45QWkxSVlFb05ZVXJiZmpiU2UvMDN0ZlZMcEJ2bGRkVDA3eWN0OWJzYVVEYy82ZG8yQjZCL1lnRDBDMXM5RjRIbVpGS0RKYXpEaW03cnFnWkpGSUdLRkVTMFY3UW44eXY5V29ORjcyT0RocWJLWGlDaTJSTmRJQXowZmtQdmx4Sk0zMHVTSk4xSHd3U21jUUJ6cWc4N2Rkc1REVkp3YldHakcrZ20zUitrby82VEJ0VGZQd21rYWdBNlQrLytTTGRmU3kyN2lZMVk1TVN3QnNleEFZdXFDVjBObkRpT1UrREVjUVRORkVSUkNwNDRCNVRLOXZTVkdhaU03M2VBUkZ1U1lNcHJxUGVKWmliYUR6V1E2TytvOTMzZGptbEFIVTMvUG9SbU1vQTkySVY5cWdkNzQwSEticHZZS0tCNG1lNmZ2OUw3LzZBQk5mOGtrSGdBMGJXOG5lNDZrd3VhVUZRb2JidzZITVZXQ2g2Tm1CUTh4RGpUdFRnRlVCeG4reWpLVzhaSUJDS2lJZ0pOOWxKWklCcTV4QkVyWWNwTUJDQjZZWU1wYThNaHRXRzJId3poZURJRlIvVy85UjlTVUoyak9uQWc3bXNmTmhHb2xMbkJMdGY5OVlkNi96ODBvQVpQQW1rTW9oZnEzWWNoeXp4UHRDMXJuWE00YWVsd1owci9tanJFTmMwNEdqQzFtbWFoR3UwTm9EU0FhbEdjTVZHc0RBc1JlS0xVUFBRYWNnQ042Y2dSVnpqU1dQbS9reFJSOURKSlg2Y3NSY3hFQUVweU1BMWhvTUZFZ0JvTUJyQXliTURKd1F3Y0hQUjEyTGtCRjBRZDJCa05KL25aZEtPOVc3YzM2TDc3VFEybVc1L1FRTktkUUtIdkgrajJqa211aFF4NVJCdmpJWnlHZHR5RVdyTUdEUUpOdlFiMUFvQnFjUzBGVUZTTFJzeERBRW9kV0xwWEtXb3k1ckZCNDdLUnkwcjIzNUlNVE1iZHBZN1B1TDJVb1RTb2trRUdxcjRHRWdHSzlvTitIWTRQbW5CRXY1NFpkT0ZwYWgzT2pYdVQrSE82OGI2bCsvRy82LzN2YVVEMW4zQkEwai8rT1hyM01kMWVXUFV6SkZrUEQxc3BnQWExWmdxY0dkMVNBTkUrQlZBOWMyTXBlREpkbElwcHBVWWFLQVFVeTRrNDhNTDhjdzZXbEJwbkl6QWF2MGw2S1dXcEVWTU5vWkc2T21xREZFejlQZ0dLOWcwNDJKK0NldzJnTG9ncGpxeHN3Mzl2OU5PdmFERGQvWVFCa3Y3QmxFejhYN3JOVkdVZ0F0Q0RPQVBEUmpNRnpiUnVqVWJkQUtobVhGa0dIdEkrT1lCUzE4VUJSeFZCVW8wRFZQQndITHZEL0NVSmZFdFhhZmRLZ0tvVHFHb1pxUHJFVHYwVVVMMWVQMldwKy92Nlp1bDE0ZW1xblFLcUlrUDlwRzdmMFgzN0x6V1lQbnBXQThtNHNxdDBlMHZWenh4UDZuQTM3b0JldlpXQ3BrWGdNUUNxMSt1cEcwdGJJWnpQd25qWFZVMEdtazNrZHNmL1YyTncwWFVRbHJMcmlWTEdpdFBJTHdQVnNKNUFUVWVZRFEyb1prT0RxYTlCcFFIVjA3L3Z2bjRURHZVNzhCeTFDdnVpU2w2TGJzeS8wdjFNb0hyN1krbnFhbzhoaVBhYmJPM1BWTTM5M0RtY2hlWGFqQWFPWnFCbUkyTWdhalhheHlha3o2S3ZYT2NVQWFSVUZlQW9nSzFnRE1WL0ZOeW81UnpUVjhTYzVMc293VW0vQTJ1YW5mVHZyR2xHR21oQTFYdTlsS0Y2M1JoKzBHdkN6a0VibmhldlZjMUovUnZkZmtMMytTOXFNQjA3YTRDa2Y5Q1A2TjBYZEh0V0ZiczhyTjNZQTlFY3hGTU5tRzVvQUtVZ0lnWnFqQUFVbVRCK012QW9VZitJNENwRGtMSS9oeDZtMEhvL3Y5VFVBMkttcjVUQ05GMFJtUlRGc0o0RkRvMTZIN3FhZFh2ZEhyUjdNZng5cndYUEdLN0FVNnU1TzdwaHY2bjcvaklOcHJ2T2VDQ1pFZ2NObGRoVGhZVnVUK2FnWForR3BnWVB0VVl6WTZHR2NXT1RBMGdKd05tcWkxT0J2K0xvYlJ5L0VFQmxzMVRhSEVEVjliN2VyVUZYNjhBSDlQNVlmeDB1amxaZ3VweWRubVhBOU05T2RZbWxkb3BCUkFPN3J0VnR1dXpZUjVNbTNLTjJhaFpxd2t3ell5RUNFb0ZvTEtRZEFLVVlxUW9lVlZrOVQ4QkgvbCtRKzlZTVdEeW94aXlWdm8wMm9HZ2ZFNUJxOVZGYW82dmQzUzNkQmp3N1dZYnpvOUpSSjNRRGYxSGI0bklOcGkrZWNVRFNGMDVWK3F1aFpKQVozVk4zSmp0Z29iWWpZNkZXVSsvcnVtWGhmY3BDVGdSV0JpQVJQTW9SeFZ0d2JVclFRMkJsQjlBQ2xnY3FoNlh5dkZZUlVLcXVNb1lhQVlyNlJMT1RacXk3TlR1ZEhLekM4NkxWc2xRQjNjalhhWnU4UVlQcHI4OFlJQmtRZmJMcy9CM3R5cjZQTzZIVG1JSHBxZWJZbldsZFZOT2FLSS9FaWl6a3V6Q1hmWGp3cU8wVzJlNkhrQU9aS2dDTEFaVkNscVV5UU9VdWo5eGNsbm5QM1hwZTZxR2JiTEVUd2EwYVVDOVF5OUFLdXpxNm9UK2xiWFBGcVFCVGRBcEE5RXJEUkVFUXJXQU5ib1c5MEovYUFkTXpVekE5M1lJcDNWcFRPc3h2WmtsRmxWYm1JOE5HYmdaYW1mcFlmaE1yVzBYbnRiTVJpTlRvTTRVUEZZQzIrZjhBblBPTnlpM0ZLek0zZzFLV1N4MmRZZnkvZ3N0VFl6WTJBQ0pYMzlRMzNialBwdEkrdkVYM0pmVnB5VWFaaDZ1TmpVNWZJT2tML0RtamlZTHViQ0Zwd1BlaWZSQk56NlFkTVQyak8yUnFDbG90Y21kNVlUVTJIYytWTUlvdWpBRVFDNTRRYUJ3QVROVEdjSkhCNVlQS0JSUVVyOFA1cmNwazVYTTJvaHdhTVRmMTNRd0JTcmRZOXlYMUtmVnR5VVlIWEt0dDlaTFQwclhwQzd0STd6NVRKcXhUVVYzYm05NVZCSnhXSzNOcHBJZUl1dTFzTkpRQXlNNDJLajV0N1RzMlZTWDRWMEdwamNKM2pXSTFSM1NqS3JnN3pOMmYvbjkrQ0dJQlRPaHBLTXZkRWFETURSYmxRMkQwNjQ1Ky9jT05mZkNjd1FrNEx5ekN5VWFmTVdPKzdqMXRnR1NTamRmcnRqdDAzS0ZrQ3U2djc4a0FOSlcxVkErUnFJNGpSd3U1eGxlK2lQYjBqK3MyMk5RMkQ3Q0pkSkp6Ym5RaDVvQUxjZlFKTkVDeEFVVkFVNWFPVXBZb1p5STh5T3FKT1RPT1NrTDZ2N3M3KzJEWVA1R09LaWlKNXNobU5JUjU0WEVIa2daUncrU0pMaW9EMFFPTlBkcUZ0VklBVVZTV01WRnNSaWxLRVJuRFFnRUFLWWFwUFBPcnpTUWd5M1EzMnQrQkJXQVY4MTA0emh1aEI2aWNvUWhRYWlUY1VUbnNsTHZGTkk4WlcvcFJtVHJqL1J0N0FYdUxjR0cwRWJyeWk0enRYZ3JaRktuSGxaSGVaMUF0dXpOc0ZVRFUwaUYrSXdWU25oc0t1VEt2UnFZbUF4QVBIaVpCb0xZQUpnTU9LeUdnQ3NEaVFGVmtLUWxRSTNkbjJBa1Y2K3BJVDlhMEpWVXJEejZ5TXorZ1NTZld6SFMrQ2pJVDJlNVBkZnNYanllUWZxM3NBaGF3QWZmVjk2WWdvcWlNOGtTcE82dmxRendFRUNrVllLR0tBRklDY0txVVVhb2hTTkJvR2FPZ3cxZzVxS29DYXV6dWNuZVBqS3NiZzBuVlZLcWxpN0xnUGgzTjFmc0xzRjhGQ2VmTmxBSFg3UzhmRHlEUmVLSVBoQTVZMXVIb3dkbytMYXh6SnRMdVRJTW9Eb0tJYzJVY0N5bVdUVGdBS1pGeFZFQjdxd3A1YldYbkhhRlE4aWhlQmhieVJTb01xSkdHUWlXeWsrM3F4bUFpRVo0eWs3S3Y5Q0R1ZzhiZ0dPeFV3Vkc1WkV0YW8yQlQ0NWsyRy82VEx2bzRCTVlUVWJMeGgvRmVhQmhObEF2cnpZT29HRzZyTVRoR2JLREcycUVZYWhlT0dmMDl6ekdwNHZ0dUt4TkZ5a292Rk0rbmxIT2VVVTZybUpLQWtUaUd3bTlSVm9hN21CWlF0ck4yK20zMDNZVjhVNjVIeVFaa0M3SkpZQ05iZmd3Mk9kMTlzMEI2cDI2WHlHVVBCWGRFZTBCTlRZOUMvSEozcGdxcEZWWElDUW11YkVJQStVbE54dENiYkM1UStlK2JBRkNldGl2ZU9GRDRqVEtZcUs5VE1MVmFhZitUTGNnbUpXWGVGeHJiUGlaQUlnRDlUdWlBdTNBSGRGdXpvekEvWTZLb0ZFUlc1enA2YUpUb2MxaElCcEROUGtIZ2NDd0RRZ0tTT1M3L1hnbFkzalZJZ1BMWVNWbS9VWEcvT2NSTXVzK3BTcEF5azdZRjJlUXVuQ3V6NysrRVNHSzdOQklkLytjUW1ESTlUOU9CV3J2UzJ0bUlpWndRWHdhUkcvNHpIY3pvSUpmNncrS2R5MFZKOWJpSlNteUZJVXBqN1lQRlpLTVIzWWpLbG51NWh1TDBVNjZkVkM2NmkvOGVDKzV4UkdjTGNOSk1TR0F5czFzV2sxMHczK25CZVhJa0Z4c2IweWpMd2FsaUpKcDNKazRab3FuUGxIQk1SWFVyRzB1VVpxdzNBeUpWQnFKQ01WZjVkMlJ4a0w5Lzl4ZlpxRmhTQVptSldHWnl5aU1XSS9sczVicFpseUZGZHZKMEUzTXpDY3lVZ2FrR2pWWmRlNGRzZEFYWmlHd1YySDdNMlBxVXVMYnpJWnU4S01ZeEIrUGRVRTlyWmxrRlB4MVRIVWRDYVVJeDFROUpKL2dnVWxiMjIzVWZJTHVUb2g1eFFPT0RLL0JmRVRRZXVBUlFzWUJ5cnJtTWlVVm1sdnVYYkVCZ290d2QyWVpzUkxZcW1acEp0cjd3VkFDSnBsR0xNMkFQd3pSMG1yTm1WR01qSGRFWXhUa0xSV3hKUWxWeFg2cW9mUXAzbjVKWWpibTdtZWhvUEhKQU9mcXJTZ0hYTFJEbjRISStKd1VEREl2YTF3L090VmRqYU0rYnc3Z3Z5Qlpac1RlcktKQ3REb2ZMb3Zra3pHMEZFdm5MWHcyNXRNTU40OUpTRURYU1NZbmlkS0FxZDE2aFV1L2UxYXlJZFYyWUdGNHJYN2dYbU1PdTMwdURSb29WZm9mVnVQTXpnSElEQTVkQlBUYXQ0dlk4dlZnTUFxSU1URHFTYXhHWXRLM0laaVV1N28yNi9kUjJBdWtQUThtVmU2T2RVR3RtSXh2cFFtTldYTHVpVmpucVZRSVJnRCtwMGI2TGxaTnJDZ0dveURiS0dTdWtST1lCbHFtVU0rWkpnVHU4SkFRb0piaG8vdmVPQWFUOGdNVFplMk1oQ25xSjhuajFkQVJxUGJVWjJhNGt0SGpYZGdHSkJ1Ky9RbnJ6QkRSZ3JUV1h1Yk5tcG92RzA0UDR4Qm1mYkxRN1p4SVFpUkVlQXlEbHNvR1hnL0oxa0JMMEUxampqbXhXVkZBT3FNMy92akltVW55aTF3dzdxUmtYUi9ZaTI1MEk1eURKOXY5ME80RDBycERBZnJDMko0M08wa3ArTFJzT29oemh5WWJPQWZmbVptN1pUbWJkbWlvQmtHSkdMekxKeFVET2lHVWs1UUpMTWQvcEE4cGpKK3QxQ0V6VjNCbzNKb3U4QkExaHJwbkJjV1E3c21HSjhQNkRyUUxwcHlHd1V0cThGbXVEWmpaMWlNWlkxK0x4WEh2UHBYbkFrVFVTS0NXQXFLZ1paQkRLQUlJQ2VOemtKYkRBRWh0d3czN0hBaDRDMTZBY28vTmc4Q002SzlJc0ZkeWNYb0xSYU12WTZDV3lIZGx3UGl5OFgyS3dzR2tndlMxVUJubWt2aXR6WjJiMkt3bnNhbjVic1F6bGpUTHlRQ1F4bVN0SWxTM1VsUk51TTRKOWxOdVJtSWl0cnprWmJTYlY0QUtLdlQ0bWd3M1dBRDkvc0o5Mzh6bkoxVEk5R3BtVVFNTk1RQ1ZibGl4YStJN05Bb2tHUFYwdXNwR2FCbXhObVJtdzJid3pmNWhzaVVzcmFnbjN6dkxjbVYvQWRlOXlNVjBBZkk3SktzdUFtcmptNW9MT0x0b1d3T3VsSWtDNGJzVVdhbjAzeHpHeEVqTDlYb0ovWktlMGhOS29wVFlrVzVKTkE5dHJJVEI0TVFTa0s2WDN5Wi9PMTNlbWMvRnJXbHluNnhCRmtTeXd5MXlhQnlMZ05SRTRyMHZTQmNySjJmaDFOODVkUVRWR2NxSTk2Yngyc2JZOG5MZGNtK1htbVBKUHFBKzVNVnllOE00bkUyVHJLcEJOTVV3NlYwNEtwRVlvYjdTZ3BnQ2JVMlpWa05oemFjckxybkl1emRWRjdvOHVCMUV4T3ZMeU5BcGtBREhNWVF0b0tHRWpKK3B6cytrS0FvQmk4bHpGbVMrVndPU1BpZ0RGVlF4NE95akh4ZEY2Q21STHNpblpOckQ5cWpUTWhBWFNNRWxwVEh4d0N5RTNuMHJOc3hIL201UXcySXdiNWFpOFdiRjJ4QkppSnpteEJ4NHp1Qmx1NEtZU0tYOUtFMGdaYlZCeU5yc0lyaElXOGhuRmQvT2NYdkwreWptSlVkY1ZXS21XNVFESnRvRnR2OGJHTDFZR2toYjEvMXc2MHdyVW9kT1lOdXNUeGFNeUNJZDJTV0RMTHMxMUxZd21jRmpFZDNGRlFMbEpTMGNvQ3hscXQ1aXJtT0tzbUJHM0JxVDVXby9WTlE2WXJQY242UnV2VDJYaDdiRlNQWnN2UjdaZERUeU5ROElHQjZTOSt2cGVKcDNvYUR4cnRGRnR0THdNdTR4ZVFHRExMczIrNi96RkltekEySGV5cllXOFNNMEJrT2ZPQU9UU2lRcVZRbnczNXdIS2llRHNDRlF4THB0THpBSTdiVjEyY2VYQ096OW55a3BtRFU2eTdaRllYbFRZWU9OQUtaQU1kYkdRcENXSWx4cHpKa3JMVnN3QVA0S1hCKzl3ZDQ3azBwVFRtY1hQZTBrNUxseVcyRUF4dzFxTHJxdmlORzNGbDF0WVFFSGcycFE5OWx3NXY3TTRwQTA4dlNTNE9HNWtBR01QQzE5UmxnNGcyNUtOaDNJcWdCYWF1N3dLSTcxZU9zT2lhb0ZxNUJuc09GdG0ySjJQNy82a3dNeFlkbjVhNEU2enlncWNPK055TG83QUJjVk5tMWF5MjVJWVNYSFRzMTFBOGNLZno0MDV5VmpYbFUvWVZ4RFNTbTU5VTVuRjYydloyQ1d5OFFsdGE3R2lnYjVPY29FMHF6M1ZwV0pkalpiaE0yeFV5K2ZtODlkZVRSdFpIMmJ1TXVXNE1ZZWh3aUJTak92Z3l5aktHZm9CQUNXTFJvQmR6d3VjbTAwK2xvQkp1U0JSdG91VDJidWFWbUx2YVpVOUJTRm5wY1dhdkU2c3djaXNDS1RlRU1uL05TVzN0dHJjWVJaQXo1ZWJnVzFrSTkvdit6TnVuVHBjRUVSY05GTXlDOFhLZm9POGFJVEhTTURQQWdtVlFnUXcrZlUwRnlTS1hmOXBxNnlVejlMTkJzSEZxYTBEN3ExcHNNSURTVlBXWmRJbmx4VE5qSzJuaXp4RlZVVzJFSHVHMk1ncUs0aDNZK0Y0cjZRU3lCaXJrbkZDaWtzNnVoT1UzT0tzUE83SmZ5MkJxVmhVZGV0cGdvdXJ5RW9nVEJTVlJEZlpOazRYODZxbk5nKzR0OHRFSU1XUitqa1JTUEYwdGd3eExmQ2tva29pVzhvYmhkaUk3d3pYcFlHZDcrR1dBMlRHTkxINUppWFBCbEVxVU8yWHhvRkRXVTBRbUVqTW53M2ppZXhBdjRSWVNYSjZrdjNTWVNaeE5tNkpiQzV0OWRqR3lnZ1J4MWFUQTdWSXJxV3NObVl0dDFaRlpQTWpwYVJJTGN4R3ZFc0xpRllvZmxaMk1YWkdlcklTaVYyY0xSK053S1V3aXI5Yk9heHJ4UmFsckFRQlZoS2NCQ082TGZmV21BM2xreTVhV0V2TzhZRFVxcXRMSmZOM0lJWkJ2V2tpdGJpZ2o2cTVOWjVkL09namZOYzVQNTFaZk1zT283a2hLdTdvUkQvUk4xR0pCRlFnNGFtWTZOSk5tdnJwWnNXdDlUUngvekRIVjNCdkl4ZG5uaXhGTnUvSU04OVVzNll1OVlDa1FTZ3VwTDRTTlZPRWpoZkNVaE81TlY5aysyekV2UjlpSTFjWGVYVTVieVFtazlOeEpocDZFeW5GSHJkQjU1Wmd2TnlWT0RCTithd0trN0JTdFg2RUNkemJhSFU0dzBwayswRDA5bUlQU05xdHZVRDZ3Rm84TlY0a1hVbDEzZ25kbXVEZmczZWI2QUtaMFFWT3dUTTA0cEpmbTlKbklILzRDQUEzVDAwcHBsanFhQ3JsWEhmUVpZbXNOS25PRExrMysrYU1EU3VSN2NYTVpBRXpLU3FtMzNva3FrWHFZdWtERzdYV2FFWFZTRW42cUR4YWszNHVsNGRuMmFpME03bndHVVFqYzlPWXJBdzRTRk8wM1JHV0FLSGhzZDU0S3NXN0kvRW1rbGdwZUZNeTd3ZnY5RUp5Y2hUQlJhbnRaU0NwaXpWMjRoR1F2dnhiZTg3Um56bFhHbnZVcmJmU1pGVmE1WStyNktOUWJsSjVJMGhBbGEra3BxQ01qUlRiMlFwS2h1MHliQkdlMndaK2hNV09ObkMranluRytvekpzRkpKeVlsM2J6N1RpUmtoN2o3T0Z6N1ZqV3lQc21zNzkzTlg3ajR3QXRMNU8rTi9KSDFQUjlWQVVkbzhpdGhIVlZYU1J5V2FRNzRqbVk0dXBYWStzOHNtQUNFOHhqckFSK3dZY0wrbUJvR25GS2hxcmwzUWhuSWZsUFczS2xuUWZneW0xT2JhOW9RQmFidG9mKzM1SXlCTjFkVXpSTGVtNnFQbnY0WXZiL1A2aUQxU1FSQWtNaHR4K1NyR3pRanJEcFN1QWVBcUhlRjh5aHRJeHVSM0pGWUtnVTJWcmJxN0daM0V2ODZmK1VzWWtEYU5uWXRHUUdyRThFenB3RzZVQWFuNGFQUEtmcTNDendUZ0tpMUtjR3RDaENOMm9KdDNzYU0wRU1ZR0ZkZkE5bXBzQ3BqNWFmenlQRXI1MnFUS0RhVzg3RDJ2bThTVXkwUVc0U0s0OGJyZTFBZ0RjbUlTbnA0Q0tSWGFzWHE2ZEdBdnFwbTFuRlZGVmdrSjdVa1hBUTA5RDB2NTJHUENZOFhOUWhBbmFTb2VQQ0NCaWw5UmpWMjdrZzNMRllPSjZnL2Y0ZUozVmViaUtnanUvTGRHWmtJbFlVQVUzTEY2S21HSUdJbFU5ejdwd0g3Y0dDK1FOZUZUR0JWYkcxUkNDS29DSndpOHB4am00aEtnWE5sQVFXQkZ1SURZQm1sRk5mREtRZHpqdnhRSEdkRzlNU3pFNWJRZzNNOUJ3UzFFZUhtbW16QVEyUFptdWp0YjlVUUUwcEFlOTJSQUpENVFXRlduemJLalZJQ0JvT3k5b0RyZ3huKzdvSGFMdDFJbmwzeStyRUpmS1hRS3Y2ZTJLQ3JLTXpES1BNWStTakVRU0VydUd3Tkp5U3YySjFHMlRHcWsxS1NPZHhNL1NnR1VMakVocHRIS3M3NmN0SlRxYitBTUxXRVg1T0ltS2lvbU54UEtPaXZoaGxJUVdpb2l2R2pxOWhpSzNCcGQ0ekNna1F4MlVpQ1JSdG9oTWxKY2N4SnZZWEJVOGRTYklxK1FxRlFWSHl2cVpjQlp0V1dQY1BUcXVJb04yb0hWYStVL1RvNVFKKzJUU1E1VDFXUzVTZEltY1lpUlV1eGtRRkxDWUxhVWtWUU1Xd3pVcXRQNVJDZFhBdXVYcktkZFlqQi9QVXFoNmw4QzhMSVlTZ1UxNGJiZGNaTWJpeW41WWNDMWFmQTAwN1NUU1FHSU0yN0hEMHM1aGR2RW1tZ3JIUzJkVzNLbVlqSWl3QjVxaTljSEUydW1VMldXQ3Q0b1RyMGcvVS96MHJUTVNKRkZjNmY0MnJjTk1LcnlHVlI1MUtsVWFkU2pKZ3dxVHFXMjJZNGVMUUlvVVZGSWJFL2xRQ3E5ZXFWT0Q5aWNLdENGRHhQaUk3WE4zM3U2OWxvMTI2ZFFVOE1FMW1YZVFqZzdOdHprWWNpL2dkdjh2YWZ4RnNLQXhzNUdEaVQ3bVN3Vjd5Yzh6Y0dCbGM5UWNnNzZIMks0azByT1UvMjY4TFRzMFpMSCs2UlBwVWdaS1VHVW44R1VEQjhuUE9BVytoYXJ2WThoNWhrOUczdlVRc2ZaTDNHTDF4ZjZDRDcyK0F0Z1FHT25PMktrL2hEV3BBTnJPTlEzNUZZdkhpZnNUS3gyVHF6S0RDaWNGWGxzWVJFazZNTUpVYkFyQ21mSGF0ZUpFL3oyYmV2cjhLRmtlOEtBdEduc3RITkd3dDRBVjBRZzVXaWt6c1B5SDREQkR0MnUva0d2N3lzNXVjTEJ5Qm9WYlRDaFF6em9nR2gwUERKWXdDREl3dGVQMjNlL2xjSll1SzcwOTZPTkFXWXoyTWtlNE5YcHc1SW90SkpCZWxMY1ZnckZ3Tjh4Nkdnd3hDN291Q3p6YjJUcEErMWpSdFlzdWpUekgrTDR0Y09JNkp5SCt3NTByc2UrUGhTa1BUSVFkMjhoUEtWYUs4TVNRcFRJejdiSnNaTXlVbWVBSXBEcXd6N2dsbHorWkNJVU42V1pzSUw4ZFJqVEFnSFlZTUlTSTJISjU0VTdIaWR4UFNXYUNDZUdERzd1TGYxZVEyTkFCTklBbDNOR3dxWDFaRjQ2c0RIc1dUUTNNVGk4V3dvWlhHQ2dNMHZlUXhUdVpnZFVoZTlIenlCb2c4R0sxdHpHSEFjMlk2UEhoc2hDSEYyTGlUNjYvRDBQZHg3N2JRSjBSczRRQnFSdHRaTWN6WUdVSEY5TEhoRVpLZW1uSjB3UUt6T0JUQzNNZlZwQmQwa2RpS3d1Y1lESzNRQUlqSEJHeTgyNWpvejlPeGFNaUp6RjBOWWNuRnRETGs2Y2dKMmNmZ3lyVXl3NUY3b1JXWHJlRkFQQ2RtdzF4VTZTQXVtQkU4TkQwb0ZUR28wSkpsbkNBSk10KytSU1VjbXdrSDJUU2FLZnUrc2QxaWljR3owd1lWRVlXTXhqZzZkd3pNaWRvY044em5lZ0RjVlNLWXhvc1NpRzJBbXJ4b2tUeW5IRFJtVHpxUUFqUFhoaStQQUlTRjgrMkwxZk9yQ3AwYWlHbEFKSWdzbmRzcHVtU2dkYVI2TFFnWUo3c3o2RHJ0dEIzOFY1WUFKR1REUE5FZU1nbk05NjdSbWZ1MTRVc3VwU2hJb1ZiMVdzVFBib1NjRWt0WDB6d0VqWC83Qjd6OGkxZmVIMjdzSkdIMCtJT3FuWFNXa09TOHNFVWdvQUsvQVNDcmtWdnBQZHFJYnZlR1JjSERxdkhVTTdFWnJmY014Q0JhRGFJRUxuTmRqaVhBSUpTSDJNckFUZys2Q3N2d09oUDlwSGtjM0o5dEpHbUxuK2p1NXhvSUcwOUQ5S0J5eXQ0NE1pSy9YWEFSTWN0VW04RzNKdXk0dVlNUWhNMjcxeDFPNnlrdU42WEtPT3dJVDJaeTFBQmNRMk9pSzNjQzRXUkk2dXdxSTJFbjRQVnRFOFVwb0QvZEFPSjRqWVVyYzJ6R3hOdHBjMmc1bStCYVFqSzBQUnZjMzAxdE1INnlLRVNncFZCWGVGZEtYWDJieHI4KzlJUjhBeWtST3llbVljb1ZnTUZlSWtCQ2VheFpMdnNWMmFuek9UOUpQZER5aXdVN2srcWlxMHg5ZEVOcC91eVVBeW1PbGFRTHA5ZnZBRDZRUFRndzJOem1TVW1DdFZRWnZRU2FXZFdTUXVrWlU4QmVQYzhieVJFWjBVOWdoVUJYQVYvZzNPOGZreDNQazl4clN1RGNKc2hMSStsRjM3cFBxSVA0WkVOdGw4WnJBaEF1bU8rY0h0aEowVVNPdnZQWmRDc2Q0bnY3MXhtM1JXRWx0UnY2c1Jtbml1RGF2cXBMS3NNL00reTBxSWdRZ0htYnUrb0h0Y1l6c1JsdVh1U2pXSEN5QnpyWnorY29CVkJMZ1lpV0lKRzAzUWoxWDBVZkV3VEIvdG5xUTJEd2h0dk9iYkc5OGo3QkNHOHFGdmc2L2VwYjFiQjhYRTVNekdjbnJ5VkhSWDBrbVN5QVRlSFpVeUYvSmFpV1hFSWdpZG5FK0JVZEFSM2tWd29NZEtQa09Cbzcrd3FMa1F2ZHlVcjk4WUlleHBvODMwRDNNOFZxdmpwU0cvQWRMTWhsaUNCY0lLWVlhd2s1ZEl3UHhqNCtIRjRmZWxEODUyMXlBWkpueUNqOHNwVjNGdldPYXl3cXprM2Mzb2hQb0Y0Mkdvcm1hNUxBanFJMjhVQUtMbnl0QkpkdHFnOXZOUGJ0Nm9HaHN4TGhCeGsyN04wVWNFSm0zcjJlNnFDQ1NEbFk0TEpPS3ZqVnNlNnYyRDlNRWQvVGJnWURoS1VrM3Ezdmo4emlUKzNTM1kydHJIQzdQUkJoTXdZTEwxampHend6N0ZpTTFqSnVzNjBOYVFWc2JjVGpINGFRbjBJMEUzcVRxQnpnU3VIRlRWclJuN2txM0o1dEptc0xKdXNHTXowdnUrdm42clpqWFdLVWI2NU5QclN4cXB3NEsrcU83ZVFQaEo0R1p4QTZ6RUh1K1ZJUnhqWVRIdlk3KzJBV1dIOGVHQmJXZ1hiNW5NT1ArZERzZ1pCa0dtMUZQT1JoaGdvK3B1YmFTUHRJM0oxcEZReVNDTUVGWUlNeFlqYWJGRWtWdm5ycU9EeGZubDRVR1JsVGFXWURqTUJEY2lWbkp2WWRFZHJ0RDdIWUtDaTBNL0djaTRHT0JjblZ0ZlF3ZFlUQjRKMFI1YVlnTUlnaXpvZzhoMnpad2dENmM3WkRiaXFnVWh0NFpHLzVLTnlkYlNwakh5UThJS1ljWmd4NXJQUm1GYys5YUgremRMSjVqcnJXbktHN0JaYmw4NllWQjBoMWlKdXh1UmRYRmxZSElFTVBoTVliazRSTFpBNi81blhiY0xLbVMreTMwdGdBaUJTYUtLckZ6T1JyeklSdmErenJkaDZ0WUdxYTJsN2J1SEJuOUhXREdZQVE1SWErKzdZZjBtQXFYazNtWlhqNmZVWjZjQ3RvdVZtT2lEZFhGODBaUXZUVGpGVTRzMW5ESUgrTHBJYWpZanVlVVZzTStONEZ4aklFanczUFBtK21vemJFUUNtMnhMTnBiY0doMzJ3WnZiTnhGV0pDQ1JObXAvNjRIZXNjTW5oN2RMYU55MWZuTHMzcUJhVHNsMjExZ2hnbk15eHVBTGFYU0hUbmhnQ3RYVWtBRVVWMnNMc0pMai9ueDNHYXJCdVNEaWlybnUyQ2NNczNlUWpjcEZkcXA5TkRtUWJjbkcwdmJJOHZEMnI5M2RtemVNMVBlQVpCS1RKSjdhTjl6VCsyb295MTNmV0lPaHlYUlhFdDJJRTdFU3VvVldJWFMyRW5zdU0yRXg2MXlNckJoQUZVQ0ZVSkdSaW56a2pBNUFpNFhjYXdDR2llemZ3NlV3aXYyQkNCT3lVVFdSVFRZbDIwNEhzdGxmdmF2M0ZRT2lEWU1aajVIQTFFMVcvdVBuVm0vcUJpWUU3RjQ1cXBFN3pPcHY2SStxZHVLUWNxM0VDRkJSUENNeTRwdHhjd3diMkFsRGNGd1Q3N2E0eWo4eVEwdVFBNURJaXI0Nzg4UzE0OG9yOVUySk5rTEpUaVlKU1RZbDIwcWJ4c1NxeGdacDZCV0RGWkNBUkQ1dmRiR2RyTjUyZUhDVEtMbzdLeEIxVGYydFpKQ1NwSlU4QUVndUR0eHgxdUNOYW1UelExNDEzZzNWaThBQkh6YnNDQUMzOHUrQXh3VVFBbnNkR0FBUk1zVmRqcTFabDhibGphVDZ1ZWZXaHFsTnliYlNwakZ4STJHRE1GTFVSeDZRVENoSHRMWDYvaHZiMTZPUUhsWDZ6N3VXY2xieVJUY0NVN1NVOGtxc2l4UHFaNTRMS0xvNWRGeWFyWnRZUURuc0JqaGhpY1FkN0lZOGdDVGhqNFVjRTNvZzhndlA2Q1V0T1pjV2l0UUVOaG9tcVMzSnBrcWNuZ1JJbURBZ0lvd2tJVVlDay9aZS92UjNPdy9lZDN4NGkramVOaFlCT3h0WjJVUWFqT1ZTS2dxek9Ed1hCLzdRakJJV3NqUFpMak1JZ0FJM1V6MVppUVNkejNQbnRVb3B3S1Vsb0pTZHhOR1hvVDVrYjA1K2NCS0JDRHVkMUtiU3ByRndLMkdDaGlHWi9CR1dBWWtvaTZhWXJIM2tXK3VmazA2czlLL1pzelF2c3hKV0U5N0lGRGE1aUF0WWw4WmtqTEVvZ01IUktqYWdyTW85Q0dXUVFBTVBQRDdUb1FzYXROTURiQWJlVFdSeWtaK2t0MG9FdG4yVGp0bG96OUtqcVUybFRXUGhPaFB5TDd0dWpRV1NVZUpFWFV2di9Wcjc5dm5sNUdBb0ZhRFcyMk5Xd3JKaUx1ZmlIRzNFemJ4Z3cyVzNodVZvSDI1SUxBTUExMlg1WlJLaGNlT1VHRUM2T1NhUWtwUlNOcHdkY2NsTnpJUlNnYzMxUDRHSWJCZ0srUWtEaEFYRFJ1MWl0QlppcER4NlN6LzA0YjlkdjBaa0pYMGwrMDhlR3JGU3NKaUxGVnljV3lvQVlYZ3NDeWEvMnU1bnN3SDRFWTUydUYySmtVQWFEQ2VQQVMreWtPeWFuU0V2N0dBNWVaYXc1OUtLNEhPS3MwTXRzTWwyWkVNVm1IZGlNTkEybU9peXlXcmhzd01UNGkyOSswdHJ0eDFlQ2c4dmFhd3Naa2xLYTZ3U0Y1R0ZnSVZlVWk0NFBOYkxEMGtsQ21ETEkvYXdXYjdhTHpFUk94cUFPWVlIa1BNK0lqOVdLakRpc2h5RVhJMldyNm1SN2NpRzBxWnRmenRod0lCb0pTL1NWZ0tTRVZJMFJJQm1sclRmZDhQNkp5RXdmdnlBUm5UUzY1bHgzU1hDVzV5Y0NFSWlManpXT2pRV1NBYVVFM1Z4SVQzSVRNU25DdnprcGdRZ2FVeFU5ZDlYQmlLbm56bUJUUjVFMjR4c0Y5aFEyLzVxdzBha3hOZGRrVjNHU0huSmhJVFZrZzc3N3Z6aC9FQXM1dExjOEYwbkRzT1F4aXNsR0JiZUpYNWJHa3RVMXRub3VwZ1NRRm1nQW9HUldGSmlHQW40Y29zRUlIdVU1aVpBaEtIbEpmd3FnaXV3YVlZSTJZcHNGcHJYZitlUndUZkk5b2FObG9vbGtjcEFNc2hyNTZ6MDlzK3NYRE5JUUp6a3RIdHRBV3J0NVF6cDFtUktYeWlHM0Zvb25HY1RlNTU3WS9JMERLRFlVb2pITjN6dFg4cUlpK2QzeHoyNXJBaStZUGVuUzJIRi9uSjFrWE9qNnB0OG9MVVIyWXBzSm0xazY3ZGR1M0oxRVFNU0c1VXhVcDRLSUVwYnZQR2UzcEViN3VwK1ZoYmVBT2NzUEFCSnQ1dU4rYldFTjYrWEtvR0pDK2N4UU9NWXltYTdqQUpDSVJaS2FtM0FGM2pkenpFQUFzRGdOQ1krYVFuTUNpZ2hvZTNyb3JIQVRsSWJrYTFDUy9wOS9lN3VkV1R6M1A1Y3lGOFpTQVZXb3RtVXEyLzZ5NlhQbjF4UEhwSmRYQS8yTER3NGNuRVV5WVgwa2w5T1FUNFZJSFNhbDYvaHNzeGNqZ2o4akRZSU9rajhUeFRuakt2a2twVFNOWmZkWEd4L2xQZHZDaUlkb1pGdDltb2JoVllZSVJ2L3l2OWUrcHpKWWg4dlk2TXFqSlJySlVMa2laVU90dDkxL2RxSEtZOGxIYnh6L1NSTW56eVNaVXRSMGt2UzNlaUs1VENZcEx1YlRUNFdNOVlzYUlBRmw5aWtCYmtDNDhCdEFKV3dhSUNodWNJczM2OTJsRWI1UHJMTlhDQm5STFlsRzVPdGpVdGJER21qeWtBcVJIREhLUHo3NE0zcjkzenpnZDcvRFgyR0lvRm9iVVZNVkZZR1U2QlRRM3FEbmZnWUdMUXZEKzZYbVNpVUxyREFJd0tvb3E3aklyd0pRRlJNUEpKTlNxSTAwTGI5UE5uWWhQckhRcEhhcEl5VTU1V1d6SW5iVi96NTBxZU9yeVVQaE1vbjV4NjdGN0M3a2VZcWVQRXRnY2xKMmtIVkVGb0NGUG9USDBPelFZU2NVU2kzNU00K0FYYXVITW9BcXBLNkFIODhlQlVRcGVLYXZJTzJCZGtrVkFZaG0ycmJmdHJJbVdQRzVvTXFBS2tFSklQSURYUHl4YVgxWkYwcit2ZHJaZCtWUGtOTEJoNll2d2VHL2Q0NDYxMEJURlpWR3pHd29scEF6QUtJYklBWW5wKzJtY2JOaC9PL0QyUUFTU3pFWmFrdEZpNEhVWnE5MWpZZ1c5UURvVDdaa214S3RqWHViTUVNWHNOdEExSmhpQW5SSFNuNWxVOS90M1A0NmxzM1BoTDZ6RlJ2SGZiUDN3c0RtakJRRVV6ZUdHOTNSYlhRTEpBS2dMTHJhOEFXWDZ1dGs4MEplUWd6WUJtQW1CSVBtMndVRTcwK2lLanZ5UVpUZ2NVZ2FDTmJrazBMTmw3T1o0aHNLNUFLNlFBU1lEU01idjNOSDErKzZidUgrbDhLZldCMll4bjJ6dDgzR3VkZERVeklnTWxsSnlha0x3RVVWMXZ6eXlSUWNUd1M4T1VSci9aV0RVQkY1K1c3TXE2eUh3WlJQdjU2Ny96OXFRMUNHOW1RYkdtMDhGRmo0OTRrd0pnSVNJVjB3RkVURnZaZS9XY24vOC9SbGVUdTBPZm0yb3V3NjhqOW1hK3VCQ1lubjhLNk9rYzdoUUNGL0pJMDNEU2thbU9SMEIrYjRRS3Q0a1JLS0NZNE9SWnk5WkE3SmxzQUVmWDFidDNuYyswVFFadVM3Y2lHQmpqSGpXM2JWVjNhWmhrcGQzRWt3bWdtd2NubGphUnorWWRQWHFYRHhhT2h6KzFhWFVqQk5Dd0JFNExmVVdGMnFnQW9DMVNPbGhHbWFrL1VnRmxUYVlRaExMMDJGMEFjQ3lFelcxbG1JZ0xSZmJCemRTRm9TN0laMlk1c1NMWTBObDJheEtWdEdraUYzTkp4ODhXcjN6blVYN3J5RTh0LzNCL0NlaG1ZZHBObUdnNUVNTmxMdzNDdWpwbER4Z0FLUWNneWU3TnBKeGlEQktFUkFWQTZDeGU4MlNvQ2dNUVY0UXBsRDVHSkJyRG4wWHMwaUk2SERhaHRSVFlqMjVuRTQ3eXhhWDh6Z05nVWtBcFIzQkZ6QWUzUDN0YVovMjlmWHJ0cUdJamtVamUzZGdMMkg3NUxSeEo5UVlEN0E3cUtyZzdkZ1hIb3pFdGxKajJDQnlwL0dXUS9OeFRDVG1oRUFKUFU5T3B6TG9EQVdrblhZaUhrbDcyeCttb1VuZlhUdnQzUlhnemFqMnowN2krdFhVVTJNMUpsM3RoeVkxS1h0bFZHeWtkUzVraW10RURudjN4eDdZNzMzdEQrbjVTNkNIMlcxbG82NTlBZGdOME9BNmF3cS9QbXBvRmZ6ZmRZd2pVMVYwdno1ckJXbXJRdDVKdjhjN2pzNTQwV0FIdlFIVGZ2bjNzVVJnNGk2a3ZxMDVrU1lVMjJJUnY5MTc5WnV3T3k4Zm5IY3MvQ2pYdzg1VUJ5OU5Jakp1L1ErOTNQcjM3dlE5OVkvOU5RR1lXMmxnNUh6My80ZG9qV2xrZEpTN3MyNTdvNmY1NlQ5OVFBenVXQlA1V0lCVVpwb1ZZdTRITEFBK0JkcCsvQ1hEZm1qUURrWFJtT1JUWDFJZlZscXlURXA0K1FiY2hHUmx3dkdOdHRTaGNWdC9pZFYxeThsYy9EODE5MDd2RGFyeS9TUlJFSzZJbkxyYis1czN0a3oweDA2SktuMW45U0tSbXNOTDk4aC9ibGZSVkRyemt6ZXV5bENqenFYSGxQb2xiT3M0NjVSNGFxU2svWTN0Slcrcmd0ZmdvMXNnVlhOeUx6V1NpOThmUU5PSFh5Q0p4ejlGNklTNTZyUjB5a1FmUyt0MTI3Y2t0QjQ5Smk2OGMwaUhwYi9ma1JiTStXby90d1h1Ujd4MmRXYm5uUDE5cWxtb2xTOXZzWEhvVGRXaUJpcjhlSWNGYzc4ZTRPMkJWcEhVM2pyZk9Cb21zcWIzTHB4SW9KVVdJZmYyS2w3TVljRU5Hc0hkMVgxR2ZVZDZya3FVTmtBN0pGQVVTTHhsWUxrK2FMVGhrajNkVnR3T3RldWdjMEt3M01SZVhNMUx6aDd0NHgvWnZ2ZXZHejZwZkVrV3FFenRQc2JjRDA2Z25vMUtkaFVHK09PaS9FVHRsYnduUHV2U2V5aHg1enJpU3Vxa1pBYmdBZ3ZDZXpEL0REUWhnQTBYaWltblpsQng0NUNGT2QxZkk3ZklqdFAvcGkrMC9lZGYzYTdhWnVSbUgrSWFPTE5pMnVUeFVqd1NmKzgwWDVLSUY1YzZGMHdZTS8vdkxhd1RkL2JQbWRxMTA4Vm5hTytxQUw1ejF5Sit5Y3Z4K1MvamhGa0dvbjdnNzFTaElTUzNGclo4dnNVcm0reGs3bmx2SlVQUHVBbTQ1Z0lySTBJS0dtKzJUdXlQMXBIMUZmbFczVTU3cnZmNTlzd0lISTJBeE9LeUFaTUNVRk1EMmN1N2xQZnFmejZHVWZXUHk5c2d4NDNvazdWNDdDZVE5K0Qrckx4MGV6VTBMdWJoeTRDVXNiRjBFbEFxdHFuUzJjQVM4Q1J3YVBPNndrNE1Zd0szVlFYMUNmN0ZvK1d1a2FxYStwejZudkMrN3NZV09iZFdPcmJkc1VYblBGbGs1dzNmS3M5N2MzL3Y2OUJOQnAzYzdUN1VMZGR1dldtR3VwK1BwL3ZlZE5QMzVoL1JXVkk4T3BPVGg1NE9tUVRNMUFGR1c0aitoUnZLei9jVnlVcXVLb3RpaTZLenh1VkJiUWdvc3pzM0hTdGE0MzJyRDcySU13SFZpcW1LdWR2ZW9EaXg5ZDZhUVBvODFCZElnRDBXdDJycDIrUUNxQWFVcTNjM1c3UUxlOUJDYjZ6Zy85OHM1TDMvakNxZCtJbzFSTFZiQ1ZndFc1ZmJDNjl3SkltaTBiVUN3QW1CaE5iV2VJTmhuS3NNcFRMd3ZsRkFLUTZuWmc3c1JoMkxGeVBEaDUwUlhWSDd0bDR5TlhmbUw1WnZNRmVaSDljSjV3ZEpub3RBZVNBWk15WU5wdndFVDdGbjN2NjM2OGRkNVZsOCs5WmQ5czlJektadEZvV0puYkQydDdubUlCaXRJR3ZpZ3ZBWTRxRWVLYkJVMlFtUGlIK3VVVEpWSUcwZ0NhWFh3RTVsWVdTcU94NGthRDBtZzgwYWUvbTJhcjBTUWJGd3JSR2F1SnpnZ2dGY0RVTkl6MEZOME9VSEtiQ0lWYzNiVnYzbjNGaTUvUnVFeGpJWjRFVU8yWjNiQzY1M3pvVCszUWdGS2pISlRNVWhPQ1J2bEhWM21RWXlsd0hQYkpGN21xYjZ6Q2pzVkhZYVo5Y2lJQTBaaitiejdRKzhMbEh6cjVLZVBLOHJVYmpwbGtJekZTVnhMV1p3eVFDb0FpdDdiTDZDWnFPM1NyMFh0WFhqcjl6Tjk5MWV4djdwNk9uamJwOTNlYk03QzZjejlzYUthQ1dzMW5xY3JZVVZ0bW95cUhGTmtIQmdPWTBzeXpZM2tCbXQzMnhOOUtzejFvb1A0SGIxN1BuMnhGa1ZsZXRrb3IrUnBBd1R6UkdRY2tBNmJZQU9oY0E2YmR1VzZhYWFqNDQ3Kys2OVV2L1pIbWEydFI2djRtMmhMTlJPc3p1MkI5eHo3b3ptcTh4bkVHcGp4YlBqR3d0aWZUblFObkZPTFRFeG5YbG1CNjlUaE10K1ZGMFVNYlRWNmtPWWEvL0JkTFgyajNVaGJLOVJDRjl4U2xVV2kzcWtGVVd2WTRJNEhraVBCOUJrejdUSVNYdXJhZmVXWmoxM3V2bUh2RHhlZlZMdDJzeVpNb2hnMGQ3WFUwc0RxenUyRlliMnFYcDJFVUZVc3RoWExNWm9tSmVhcWx0ZlJNa2oyRk1lNTNvYlYyRWxvYU9GTTYrb3FTVFplMWtLYk8vOXRQclZ6OXQvZjM4aFhWaHlibGtnL3JPYzZKNnJNT1NBWGRWRGV1N2h6VDVuSjJvbVBlOHBLWmkzN3JwZE92djJCWC9QeXQvc2grclFuZHFWbmRka0N2TlF1RGhzWnRMUjRKZEtXNEtFOEpta1I0bUhGZW50R01VK3V1UTZPekJrMnRlNW9iYTVXU2gyVWJyUXBDaTNtOC84YjJ2UVVZRXd1dEdBYWlsczdQbnlUUmVFWUR5WEYxTTBhSWs3dmJZLzQ5RXQ3Lzd1VXp6NzN5MHBuWG43Y3pldTUyZXA2K1pxbCtmU290eDFBajFrcHFkUmpHZGNDb3BsdWtSWDJVN3RPT29wQ2NIaFpNKzJRQThiQVAwYUNmc2szTnRIcC9RN2Z1ZGw1bXVzalZCMjl1Zi9KUHZ0SXVMbmlXci9XNWFNTDZkRzUrRlZkMlZnS3B3RTROdzBnSFRJcGdwMGtUakRMdmIvMzVtZWY4eG91bUwzdld2dmlGU2oybXlhREhmQ001UldzMmZ1UmI2MTk0NzlmYXhXcEFZc0w2ZlBMaU1mTzZ0OWx5eDJrRHBPM2FwdDk2SkRiYWFaY0IwejRqekJ0RjVmS2FGN1RPK2UyZm4vbUZINzJnOXJQTm1wbzdtd0JFYTV2ZmRuandqZmQ4cmYzbDY3N2ZPZXFvc1I2TTUrSXZHRGUyc2RWeFJOdTFuVFpBTW1CU0ppVXdiZHpjdm9LN3N3QzFaeWFxdi9QVnM1ZTg0bm5ObDF5d08zNStORUVlNm5UYWFJQWpQYkxqUzNkMmIzem4vMXY3OW1MYmV2Wm5EcURjalIwM2V4TFhnKzJxM0o5MVFISUExU2dBYXE5SkZVeWJ2MXZGNWhjOHBUNzd0cGZOL05TTG4xbi82Zk4zeHMvVm9LcWQ1dUFaUExvOFBQak4rL3QvZDlWWDIvL3cvVWY2cm45SkRJRFdUVWgvb2dDZzN1a0VvTk1hU0F5Z1pvekwyMlAyOU85bVVaVG4yOVAyeEMwZDhWMzhzOCtxLytnejl0VXVubXVwODA2SDMwTFBnSDNnK09DT2I5elh2MDFIWG5jOHREamtGaTBqTjlXRjhjS2ZpMmJmUGwwQmRFWUF5UUZVM1REU25BRVR0VmtqeXVzZ0RJbjVpUXZyYzc5MFNldlpsenkxL3B3TGRzVlAyemNiWFRqZFVMdFA1Zld1OS9EazhiWGswQ1BMdzRkdWZhaC85elhmN3R6em5VTjlxWHhQN05NM0lub054c3ZzclJnRzZwL09BRHFqZ01Sb3FLWmhwWjJtN1RCQ3ZXWGVENDZ6SWxmNDh1YzJ6bi8yZ2RxQnArNk85eC9ZRWUzWDRKcWJycXZaVmgxMFU3TlUrNHVVcXRYTUNBVmFaQ0ZCSEZCdHE5UEh0VTRmMXRiMVhvTm01ZGhxc3ZEd3llSENQY2NHeDc1eXNQY280Nm80OEF3TWVEYU1pRjQyclcxWWFYQW1BT2lNQkpJRHFzaTR2WllCMVE3RFZqbExOUXhUeFFDUGU3b0FqZHZxRysyVHM4OEtqSi90MFRIdUt6a1Q3YUdtenJ2MGJJaWNZd09jcG1HbUhGalQ1dDg1cUdybTJPZ1VnZ3NONHd3TjYrVGcyVEN1S2dmT2htR2Vuam4yak41cWNIWnNRMk9ZRFhPWDF3MTRjc2FhTXFCcUZkaXFDS3A4SHhWQWxnTk5GUUNTNzNPd0pBWFFGTUdUczA3SGdHY2paeHpUK2dDUXdGbTAxZURzMnhKenAzY0xiRlVyTUZLdEFMS0d3MVkxQjFUS0FSSTY0Qms0ckZOc3hmY0dad1ByUE5HQXhMSFZFT3huYU9Rc1ZHeHFrNHlFaGU4WUZ0anBDYlg5ZndFR0FGakF3TXduZ05YSkFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmdcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g5bGV56S655So5oi355qE5LiL5rOo6YeR6aKdIOS7peWPiiDlpZbph5Hph5Hpop0g5b2T54S26L+Y5pyJ5YCS6K6h5pe2XG4gICAgZGl2LmJvbnVzLWJhclxuICAgICAgICBkaXYuYm9udXMtaXRlbS5iZXRcbiAgICAgICAgICAgIGRpdi5pdGVtLWJhY2suZm9yemVuXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvd1xuICAgICAgICAgICAgICAgICAgICBkaXYuYmV0LW51bSh2LWJpbmQ6c3R5bGU9XCJiZXROdW1cIix2LWh0bWw9XCJsb2NrbW9uZXlcIilcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uY291bnQtZG93blxuICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tYmFja1xuICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLXNob3dcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tbnVtKHYtYmluZDpzdHlsZT1cIntmb250U2l6ZTo0MCp6b29tUmF0ZS54KydweCd9XCIsdi1odG1sPVwiY291bnREb3duIHwgdGltZVwiKVxuICAgICAgICBkaXYuYm9udXMtaXRlbS5ib251c1xuICAgICAgICAgICAgZGl2Lml0ZW0tYmFjay5iYWxhbmNlXG4gICAgICAgICAgICAgICAgZGl2Lml0ZW0tc2hvdyhAdG91Y2hlbmQ9XCJzaG93TWVzc2FnZVwiKVxuICAgICAgICAgICAgICAgICAgICBkaXYuYmV0LW51bSh2LWJpbmQ6c3R5bGU9XCJiZXROdW1cIiB2LWh0bWw9XCJ1c2VyaW5mby5tb25leS1sb2NrbW9uZXlcIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uL2pzL3JlcXVlc3QtbGlzdCdcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICd1c2VyQmV0JywgJ2NvdW50RG93bicsICdjb3VudE51bScsICdiZXRzJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q291bnQodGhpcy5jb3VudCh0aGlzLmNvdW50RG93bikpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYmV0TnVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDMgKiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICAvL+avj+asoeW8gOWllumDvemHjeaWsOiOt+WPliDlgJLorqHml7ZcbiAgICAgICAgZ2V0Q291bnQoZm4pIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Q291bnQoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50RG93biA9IHJlcy5kYXRhLmNvdW50RG93blxuICAgICAgICAgICAgICAgIHRoYXQuY291bnROdW0gPSByZXMuZGF0YS5jb3VudE51bVxuICAgICAgICAgICAgICAgIHRoYXQudXNlckJldC5pZG51bSA9IHJlcy5kYXRhLmlkbnVtIC8v5byA5aWW5pyf5pWwXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LmNvdW50RG93bikgIT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbiA/IGZuKCkgOiBudWxsXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyDkubDlrprnprvmiYtcbiAgICAgICAgY3JlYXRlVXNlckJldHMoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmNyZWF0ZVVzZXJCZXRzKEpTT04uc3RyaW5naWZ5KHRoaXMuYmV0cykpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJybXNnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnc2hvd1RpcCcsIHJlcy5kYXRhLmVycm1zZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyDlhZHlpZZcbiAgICAgICAgY2FzaFByaXplKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5jYXNoUHJpemUoSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyaW5mbykpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSlcbiAgICAgICAgICAgIH0sIHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBnZXRCb251c051bSgpIHsgLy8g6I635Y+W5byA5aWW57uT5p6cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzTnVtKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5sb3R0ZXJ5bnVtID0gcmVzLmRhdGFcbiAgICAgICAgICAgICAgICB0aGF0LmdldENvdW50KHRoYXQuY291bnQpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXG4gICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3JlbG9hZGluZm8nKVxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duID0gdGhpcy5jb3VudE51bVxuICAgICAgICB9LFxuICAgICAgICBzaG93TWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpXG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50KCkge1xuICAgICAgICAgICAgLy8g6Led56a75byA5aWW5pe26Ze0MzDnp5Lml7Yg5Lmw5a6a56a75omLXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPT09IDMwICYmIHRoaXMuYmV0cyAmJiB0aGlzLmJldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVXNlckJldHMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5YCS6K6h5pe25LiN5piv5pWw5a2X5pe25LiN6L+b6KGM5YCS6K6h5pe2XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd1RpcCcsICflgJLorqHml7bor7vlj5bplJnor68s6K+35Yi35paw6aG16Z2iJylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY291bnREb3duKVxuICAgICAgICAgICAgdGhpcy5jb3VudERvd24tLVxuICAgICAgICAgICAgICAgIGxldCB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5jb3VudERvd24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY291bnQoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWAkuiuoeaXtuWwj+S6jjAg5pe2IOiOt+WPluiOt+Wllue7k+aenCDlubblhZHlpZZcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZXRCb251c051bSgpXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2FzaFByaXplKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5pbWcge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LmZvcnplbiB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiA4MCU7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5iYWxhbmNlIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDgwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuLmJvbnVzLWJhciB7XG4gICAgaGVpZ2h0OiAyMCU7XG59XG5cbmRpdi5pdGVtLWJhY2sge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuZGl2Lml0ZW0tc2hvdyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG5kaXYuaXRlbS1zaG93IGRpdiB7XG4gICAgLypoZWlnaHQ6IDMwJTsqL1xufVxuXG5kaXYuYm9udXMtaXRlbSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuYmV0LW51bSB7XG4gICAgbWFyZ2luOiAzMCUgMCAwIDA7XG4gICAgY29sb3I6IHdoaXRlO1xufVxuXG5kaXYuYmV0LFxuZGl2LmJvbnVzIHtcbiAgICB3aWR0aDogY2FsYygzNSUgLSAxZW0pO1xuICAgIHBhZGRpbmc6IDAgLjVlbTtcbn1cblxuZGl2LmNvdW50LWRvd24ge1xuICAgIHdpZHRoOiBjYWxjKDMwJSAtIDFlbSk7XG4gICAgcGFkZGluZzogMCAuNWVtO1xufVxuXG5kaXYuY291bnQtZG93bi1udW0ge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZm9udC1zaXplOiAyZW07XG59XG5cbmRpdi5jb3VudC1kb3duLWJhY2sge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG5cbmRpdi5jb3VudC1kb3duLXNob3cge1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgIGhlaWdodDogOTIlO1xuICAgIHdpZHRoOiA5MiU7XG4gICAgbWFyZ2luOiA0JTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBCZXRBbmRCb251cy52dWU/NjlkZjg0YTZcbiAqKi8iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IFZ1ZVJlc291cmNlIGZyb20gJ3Z1ZS1yZXNvdXJjZSdcclxuVnVlLnVzZShWdWVSZXNvdXJjZSlcclxuICAgIC8vIOiOt+WPluW8gOWlluiusOW9lVxyXG5tb2R1bGUuZXhwb3J0cy5nZXRCb251c1JlY29yZCA9ICgpID0+IFZ1ZS5odHRwLmdldCgnZ2V0Qm9udXNSZWNvcmQnKVxyXG4gICAgLy8g6I635Y+W5Li76YWN572u5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldE1haW5Db25maWcgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldE1haW5Db25maWcnLCB7IHBhcmFtczogeyB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF0gfSB9KVxyXG4gICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XHJcbm1vZHVsZS5leHBvcnRzLmdldENvdW50ID0gKCkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRDb3VudCcpXHJcbiAgICAvLyDojrflj5blvIDlpZbnu5PmnpxcclxubW9kdWxlLmV4cG9ydHMuZ2V0Qm9udXNOdW0gPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5nZXQoJ2dldEJvbnVzTnVtJywgcGFyYW1zKVxyXG4gICAgLy8g5Lmw5a6a56a75omLXHJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVVzZXJCZXRzID0gKHBhcmFtcykgPT4gVnVlLmh0dHAucG9zdCgnY3JlYXRlVXNlckJldHMnLCBwYXJhbXMpXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5nZXR1c2VyQ29kZUZyb21OZXQgPSAoY29kZSkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRVc2VyQ29kZScsIHsgcGFyYW1zOiB7IGNvZGU6IGNvZGUgfSB9KVxyXG4gICAgLy8g6I635Y+W55So5oi35L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldHVzZXJpbmZvID0gKHVzZXJpbmZvKSA9PiBWdWUuaHR0cC5wb3N0KCdnZXR1c2VyaW5mbycsIHVzZXJpbmZvKVxyXG4gICAgLy8g6I635Y+W5YWs5ZGK5L+h5oGvXHJcbm1vZHVsZS5leHBvcnRzLmdldExhc3ROb3RpY2UgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldExhc3ROb3RpY2UnKVxyXG4gICAgLy8g6K+35rGC5YWR5aWWXHJcbm1vZHVsZS5leHBvcnRzLmNhc2hQcml6ZSA9ICh1c2VyaW5mbykgPT4gVnVlLmh0dHAucG9zdCgnY2FzaFByaXplJywgdXNlcmluZm8pXHJcbiAgICAvLyDojrflj5blvq7kv6HnlKjmiLdjb2RlIOeUqOadpeWQjuWPsOiOt+WPlueUqOaIt29wZW5pZFxyXG5tb2R1bGUuZXhwb3J0cy5nZXRDb2RlID0gZnVuY3Rpb24oKSB7IC8vIOiOt+WPlueUqOaIt2NvZGXlgLxcclxuICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihefCYpXCIgKyAnY29kZScgKyBcIj0oW14mXSopKCZ8JClcIiwgXCJpXCIpO1xyXG4gICAgICAgIHZhciByID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkubWF0Y2gocmVnKTtcclxuICAgICAgICBpZiAociAhPSBudWxsKSByZXR1cm4gdW5lc2NhcGUoclsyXSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKioqKuWQjuWPsOeuoeeQhueUqCoqKi9cclxubW9kdWxlLmV4cG9ydHMudXBkYXRldXNlcmluZm8gPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5wb3N0KCd1cGRhdGV1c2VyaW5mbycsIHBhcmFtcylcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzXG4gKiovIiwiLyohXG4gKiB2dWUtcmVzb3VyY2UgdjAuOS4zXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJlc291cmNlXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb21pc2VzL0ErIHBvbHlmaWxsIHYxLjEuNCAoaHR0cHM6Ly9naXRodWIuY29tL2JyYW1zdGVpbi9wcm9taXMpXG4gKi9cblxudmFyIFJFU09MVkVEID0gMDtcbnZhciBSRUpFQ1RFRCA9IDE7XG52YXIgUEVORElORyA9IDI7XG5cbmZ1bmN0aW9uIFByb21pc2UkMihleGVjdXRvcikge1xuXG4gICAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XG4gICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlJDIucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChyKTtcbiAgICB9KTtcbn07XG5cblByb21pc2UkMi5yZXNvbHZlID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoeCk7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDIuYWxsID0gZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGl0ZXJhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0geDtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBQcm9taXNlJDIucmVzb2x2ZShpdGVyYWJsZVtpXSkudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuUHJvbWlzZSQyLnJhY2UgPSBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBQcm9taXNlJDIucmVzb2x2ZShpdGVyYWJsZVtpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG52YXIgcCQxID0gUHJvbWlzZSQyLnByb3RvdHlwZTtcblxucCQxLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgICBpZiAoeCA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHggJiYgeFsndGhlbiddO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGVuLmNhbGwoeCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRVNPTFZFRDtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHg7XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfVxufTtcblxucCQxLnJlamVjdCA9IGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgICBpZiAocmVhc29uID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVKRUNURUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSByZWFzb247XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfVxufTtcblxucCQxLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9taXNlLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgICAgICB3aGlsZSAocHJvbWlzZS5kZWZlcnJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBwcm9taXNlLmRlZmVycmVkLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZWQgPSBkZWZlcnJlZFswXSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWplY3RlZCA9IGRlZmVycmVkWzFdLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gZGVmZXJyZWRbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCA9IGRlZmVycmVkWzNdO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQuY2FsbCh1bmRlZmluZWQsIHByb21pc2UudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlamVjdGVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxucCQxLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb21pc2UuZGVmZXJyZWQucHVzaChbb25SZXNvbHZlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfSk7XG59O1xuXG5wJDEuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbn07XG5cbnZhciBQcm9taXNlT2JqID0gd2luZG93LlByb21pc2UgfHwgUHJvbWlzZSQyO1xuXG5mdW5jdGlvbiBQcm9taXNlJDEoZXhlY3V0b3IsIGNvbnRleHQpIHtcblxuICAgIGlmIChleGVjdXRvciBpbnN0YW5jZW9mIFByb21pc2VPYmopIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gZXhlY3V0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2VPYmooZXhlY3V0b3IuYmluZChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUHJvbWlzZSQxLmFsbCA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmouYWxsKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlJDEucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmoucmVzb2x2ZSh2YWx1ZSksIGNvbnRleHQpO1xufTtcblxuUHJvbWlzZSQxLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLnJlamVjdChyZWFzb24pLCBjb250ZXh0KTtcbn07XG5cblByb21pc2UkMS5yYWNlID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoUHJvbWlzZU9iai5yYWNlKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG52YXIgcCA9IFByb21pc2UkMS5wcm90b3R5cGU7XG5cbnAuYmluZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnAudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cbiAgICBpZiAoZnVsZmlsbGVkICYmIGZ1bGZpbGxlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICBmdWxmaWxsZWQgPSBmdWxmaWxsZWQuYmluZCh0aGlzLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMSh0aGlzLnByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKSwgdGhpcy5jb250ZXh0KTtcbn07XG5cbnAuY2F0Y2ggPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMSh0aGlzLnByb21pc2UuY2F0Y2gocmVqZWN0ZWQpLCB0aGlzLmNvbnRleHQpO1xufTtcblxucC5maW5hbGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZU9iai5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbn07XG5cbnZhciBkZWJ1ZyA9IGZhbHNlO1xudmFyIHV0aWwgPSB7fTtcbnZhciBhcnJheSA9IFtdO1xuZnVuY3Rpb24gVXRpbCAoVnVlKSB7XG4gICAgdXRpbCA9IFZ1ZS51dGlsO1xuICAgIGRlYnVnID0gVnVlLmNvbmZpZy5kZWJ1ZyB8fCAhVnVlLmNvbmZpZy5zaWxlbnQ7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tWdWVSZXNvdXJjZSB3YXJuXTogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGNiLCBjdHgpIHtcbiAgICByZXR1cm4gdXRpbC5uZXh0VGljayhjYiwgY3R4KTtcbn1cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRGF0YShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cblxuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucyhmbiwgb2JqLCBvcHRzKSB7XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzLmNhbGwob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2UoZm4uYmluZCh7ICR2bTogb2JqLCAkb3B0aW9uczogb3B0cyB9KSwgZm4sIHsgJG9wdGlvbnM6IG9wdHMgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvcikge1xuXG4gICAgdmFyIGksIGtleTtcblxuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwob2JqW2tleV0sIG9ialtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgX2Fzc2lnbjtcblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcblxuICAgIHZhciBhcmdzID0gYXJyYXkuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByb290IChvcHRpb25zLCBuZXh0KSB7XG5cbiAgICB2YXIgdXJsID0gbmV4dChvcHRpb25zKTtcblxuICAgIGlmIChpc1N0cmluZyhvcHRpb25zLnJvb3QpICYmICF1cmwubWF0Y2goL14oaHR0cHM/Oik/XFwvLykpIHtcbiAgICAgICAgdXJsID0gb3B0aW9ucy5yb290ICsgJy8nICsgdXJsO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5IChvcHRpb25zLCBuZXh0KSB7XG5cbiAgICB2YXIgdXJsUGFyYW1zID0gT2JqZWN0LmtleXMoVXJsLm9wdGlvbnMucGFyYW1zKSxcbiAgICAgICAgcXVlcnkgPSB7fSxcbiAgICAgICAgdXJsID0gbmV4dChvcHRpb25zKTtcblxuICAgIGVhY2gob3B0aW9ucy5wYXJhbXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh1cmxQYXJhbXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBxdWVyeSA9IFVybC5wYXJhbXMocXVlcnkpO1xuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PSAtMSA/ICc/JyA6ICcmJykgKyBxdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFVSTCBUZW1wbGF0ZSB2Mi4wLjYgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vdXJsLXRlbXBsYXRlKVxuICovXG5cbmZ1bmN0aW9uIGV4cGFuZCh1cmwsIHBhcmFtcywgdmFyaWFibGVzKSB7XG5cbiAgICB2YXIgdG1wbCA9IHBhcnNlKHVybCksXG4gICAgICAgIGV4cGFuZGVkID0gdG1wbC5leHBhbmQocGFyYW1zKTtcblxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyaWFibGVzLnB1c2guYXBwbHkodmFyaWFibGVzLCB0bXBsLnZhcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUpIHtcblxuICAgIHZhciBvcGVyYXRvcnMgPSBbJysnLCAnIycsICcuJywgJy8nLCAnOycsICc/JywgJyYnXSxcbiAgICAgICAgdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiB2YXJpYWJsZXMsXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csIGZ1bmN0aW9uIChfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gZXhwcmVzc2lvbi5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godG1wWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yICYmIG9wZXJhdG9yICE9PSAnKycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICcsJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSAnJic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiAnJykgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlUmVzZXJ2ZWQobGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIGtleSwgbW9kaWZpZXIpIHtcblxuICAgIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgJiYgbW9kaWZpZXIgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHBhcnNlSW50KG1vZGlmaWVyLCAxMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIoaXNEZWZpbmVkKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdG1wLmpvaW4oJywnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJzsnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnICYmIChvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPycpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNLZXlPcGVyYXRvcihvcGVyYXRvcikge1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gJzsnIHx8IG9wZXJhdG9yID09PSAnJicgfHwgb3BlcmF0b3IgPT09ICc/Jztcbn1cblxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcblxuICAgIHZhbHVlID0gb3BlcmF0b3IgPT09ICcrJyB8fCBvcGVyYXRvciA9PT0gJyMnID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9KS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUgKG9wdGlvbnMpIHtcblxuICAgIHZhciB2YXJpYWJsZXMgPSBbXSxcbiAgICAgICAgdXJsID0gZXhwYW5kKG9wdGlvbnMudXJsLCBvcHRpb25zLnBhcmFtcywgdmFyaWFibGVzKTtcblxuICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlcnZpY2UgZm9yIFVSTCB0ZW1wbGF0aW5nLlxuICovXG5cbnZhciBpZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbnZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuZnVuY3Rpb24gVXJsKHVybCwgcGFyYW1zKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMgfHwge30sXG4gICAgICAgIG9wdGlvbnMgPSB1cmwsXG4gICAgICAgIHRyYW5zZm9ybTtcblxuICAgIGlmIChpc1N0cmluZyh1cmwpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVybDogdXJsLCBwYXJhbXM6IHBhcmFtcyB9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZSh7fSwgVXJsLm9wdGlvbnMsIHNlbGYuJG9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgVXJsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB0cmFuc2Zvcm0gPSBmYWN0b3J5KGhhbmRsZXIsIHRyYW5zZm9ybSwgc2VsZi4kdm0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybShvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBVcmwgb3B0aW9ucy5cbiAqL1xuXG5Vcmwub3B0aW9ucyA9IHtcbiAgICB1cmw6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcGFyYW1zOiB7fVxufTtcblxuLyoqXG4gKiBVcmwgdHJhbnNmb3Jtcy5cbiAqL1xuXG5VcmwudHJhbnNmb3JtcyA9IFt0ZW1wbGF0ZSwgcXVlcnksIHJvb3RdO1xuXG4vKipcbiAqIEVuY29kZXMgYSBVcmwgcGFyYW1ldGVyIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuVXJsLnBhcmFtcyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgcGFyYW1zLmFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB1c2goZXNjYXBlKGtleSkgKyAnPScgKyBlc2NhcGUodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgc2VyaWFsaXplKHBhcmFtcywgb2JqKTtcblxuICAgIHJldHVybiBwYXJhbXMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIFVSTCBhbmQgcmV0dXJuIGl0cyBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqL1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiAodXJsKSB7XG5cbiAgICBpZiAoaWUpIHtcbiAgICAgICAgZWwuaHJlZiA9IHVybDtcbiAgICAgICAgdXJsID0gZWwuaHJlZjtcbiAgICB9XG5cbiAgICBlbC5ocmVmID0gdXJsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogZWwuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IGVsLnByb3RvY29sID8gZWwucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgcG9ydDogZWwucG9ydCxcbiAgICAgICAgaG9zdDogZWwuaG9zdCxcbiAgICAgICAgaG9zdG5hbWU6IGVsLmhvc3RuYW1lLFxuICAgICAgICBwYXRobmFtZTogZWwucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycgPyBlbC5wYXRobmFtZSA6ICcvJyArIGVsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IGVsLnNlYXJjaCA/IGVsLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IGVsLmhhc2ggPyBlbC5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJydcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZmFjdG9yeShoYW5kbGVyLCBuZXh0LCB2bSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHZtLCBvcHRpb25zLCBuZXh0KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHNjb3BlKSB7XG5cbiAgICB2YXIgYXJyYXkgPSBpc0FycmF5KG9iaiksXG4gICAgICAgIHBsYWluID0gaXNQbGFpbk9iamVjdChvYmopLFxuICAgICAgICBoYXNoO1xuXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgICAgaGFzaCA9IGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIGtleSA9IHNjb3BlICsgJ1snICsgKHBsYWluIHx8IGhhc2ggPyBrZXkgOiAnJykgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjb3BlICYmIGFycmF5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYWRkKHZhbHVlLm5hbWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNoKSB7XG4gICAgICAgICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24geGRyQ2xpZW50IChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgeGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCksXG4gICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uZFdpdGgoeGRyLnJlc3BvbnNlVGV4dCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogeGRyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4ZHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geGRyLmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICB4ZHIudGltZW91dCA9IDA7XG4gICAgICAgIHhkci5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub25lcnJvciA9IGhhbmRsZXI7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufVxuXG52YXIgT1JJR0lOX1VSTCA9IFVybC5wYXJzZShsb2NhdGlvbi5ocmVmKTtcbnZhciBTVVBQT1JUU19DT1JTID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbmZ1bmN0aW9uIGNvcnMgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIGlmICghaXNCb29sZWFuKHJlcXVlc3QuY3Jvc3NPcmlnaW4pICYmIGNyb3NzT3JpZ2luKHJlcXVlc3QpKSB7XG4gICAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmNyb3NzT3JpZ2luKSB7XG5cbiAgICAgICAgaWYgKCFTVVBQT1JUU19DT1JTKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNsaWVudCA9IHhkckNsaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0LmVtdWxhdGVIVFRQO1xuICAgIH1cblxuICAgIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gY3Jvc3NPcmlnaW4ocmVxdWVzdCkge1xuXG4gICAgdmFyIHJlcXVlc3RVcmwgPSBVcmwucGFyc2UoVXJsKHJlcXVlc3QpKTtcblxuICAgIHJldHVybiByZXF1ZXN0VXJsLnByb3RvY29sICE9PSBPUklHSU5fVVJMLnByb3RvY29sIHx8IHJlcXVlc3RVcmwuaG9zdCAhPT0gT1JJR0lOX1VSTC5ob3N0O1xufVxuXG5mdW5jdGlvbiBib2R5IChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSlNPTiAmJiBpc1BsYWluT2JqZWN0KHJlcXVlc3QuYm9keSkpIHtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gVXJsLnBhcmFtcyhyZXF1ZXN0LmJvZHkpO1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9ybURhdGEocmVxdWVzdC5ib2R5KSkge1xuICAgICAgICBkZWxldGUgcmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuYm9keSk7XG4gICAgfVxuXG4gICAgbmV4dChmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcblxuICAgICAgICBpZiAoaXNTdHJpbmcoY29udGVudFR5cGUpICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCkge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGpzb25wQ2xpZW50IChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgbmFtZSA9IHJlcXVlc3QuanNvbnAgfHwgJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJ19qc29ucCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiksXG4gICAgICAgICAgICBib2R5ID0gbnVsbCxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBzY3JpcHQ7XG5cbiAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyAmJiBib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gNDA0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uZFdpdGgoYm9keSwgeyBzdGF0dXM6IHN0YXR1cyB9KSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tdO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QucGFyYW1zW25hbWVdID0gY2FsbGJhY2s7XG5cbiAgICAgICAgd2luZG93W2NhbGxiYWNrXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuc3JjID0gcmVxdWVzdC5nZXRVcmwoKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gaGFuZGxlcjtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGpzb25wIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT0gJ0pTT05QJykge1xuICAgICAgICByZXF1ZXN0LmNsaWVudCA9IGpzb25wQ2xpZW50O1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYmVmb3JlIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LmJlZm9yZSkpIHtcbiAgICAgICAgcmVxdWVzdC5iZWZvcmUuY2FsbCh0aGlzLCByZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbi8qKlxuICogSFRUUCBtZXRob2Qgb3ZlcnJpZGUgSW50ZXJjZXB0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWV0aG9kIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSFRUUCAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnXSA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9ICdQT1NUJztcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGhlYWRlciAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgcmVxdWVzdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJlcXVlc3QuaGVhZGVycyA9IGFzc2lnbih7fSwgSHR0cC5oZWFkZXJzLmNvbW1vbiwgIXJlcXVlc3QuY3Jvc3NPcmlnaW4gPyBIdHRwLmhlYWRlcnMuY3VzdG9tIDoge30sIEh0dHAuaGVhZGVyc1tyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpXSwgcmVxdWVzdC5oZWFkZXJzKTtcblxuICAgIG5leHQoKTtcbn1cblxuLyoqXG4gKiBUaW1lb3V0IEludGVyY2VwdG9yLlxuICovXG5cbmZ1bmN0aW9uIHRpbWVvdXQgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHZhciB0aW1lb3V0O1xuXG4gICAgaWYgKHJlcXVlc3QudGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH0sIHJlcXVlc3QudGltZW91dCk7XG4gICAgfVxuXG4gICAgbmV4dChmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHhockNsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbmRXaXRoKCdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMsIC8vIElFOSBzdGF0dXMgYnVnXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHRyaW0oeGhyLnN0YXR1c1RleHQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHIuYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgIHhoci50aW1lb3V0ID0gMDtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhoci5vbmVycm9yID0gaGFuZGxlcjtcblxuICAgICAgICBpZiAocmVxdWVzdC5wcm9ncmVzcykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXihQT1NUfFBVVCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcmVxdWVzdC5wcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKHJlcXVlc3QuaGVhZGVycyB8fCB7fSwgZnVuY3Rpb24gKHZhbHVlLCBoZWFkZXIpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB4aHIuc2VuZChyZXF1ZXN0LmdldEJvZHkoKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhzdHIpIHtcblxuICAgIHZhciBoZWFkZXJzID0ge30sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpO1xuXG4gICAgZWFjaCh0cmltKHN0cikuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAocm93KSB7XG5cbiAgICAgICAgaSA9IHJvdy5pbmRleE9mKCc6Jyk7XG4gICAgICAgIG5hbWUgPSB0cmltKHJvdy5zbGljZSgwLCBpKSk7XG4gICAgICAgIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaSArIDEpKTtcblxuICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSkge1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyc1tuYW1lXSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG5mdW5jdGlvbiBDbGllbnQgKGNvbnRleHQpIHtcblxuICAgIHZhciByZXFIYW5kbGVycyA9IFtzZW5kUmVxdWVzdF0sXG4gICAgICAgIHJlc0hhbmRsZXJzID0gW10sXG4gICAgICAgIGhhbmRsZXI7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENsaWVudChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gcmVxSGFuZGxlcnMucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVxdWVzdCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBpbnRlcmNlcHRvciBvZiB0eXBlICcgKyB0eXBlb2YgaGFuZGxlciArICcsIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBuZXh0KHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXNwb25zZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXNIYW5kbGVycy51bnNoaWZ0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3BvbnNlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc0hhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gd2hlbihyZXNwb25zZSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChjb250ZXh0LCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hlbihyZXNwb25zZSwgcmVzb2x2ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBDbGllbnQudXNlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmVxSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn1cblxuZnVuY3Rpb24gc2VuZFJlcXVlc3QocmVxdWVzdCwgcmVzb2x2ZSkge1xuXG4gICAgdmFyIGNsaWVudCA9IHJlcXVlc3QuY2xpZW50IHx8IHhockNsaWVudDtcblxuICAgIHJlc29sdmUoY2xpZW50KHJlcXVlc3QpKTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbi8qKlxuICogSFRUUCBSZXNwb25zZS5cbiAqL1xuXG52YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keSwgX3JlZikge1xuICAgICAgICB2YXIgdXJsID0gX3JlZi51cmw7XG4gICAgICAgIHZhciBoZWFkZXJzID0gX3JlZi5oZWFkZXJzO1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZi5zdGF0dXM7XG4gICAgICAgIHZhciBzdGF0dXNUZXh0ID0gX3JlZi5zdGF0dXNUZXh0O1xuICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zZSk7XG5cblxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXMgfHwgMDtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCAnJztcbiAgICAgICAgdGhpcy5vayA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICAgIH1cblxuICAgIFJlc3BvbnNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICB9O1xuXG4gICAgUmVzcG9uc2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiBibG9iKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3RoaXMuYm9keV0pO1xuICAgIH07XG5cbiAgICBSZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNwb25zZTtcbn0oKTtcblxudmFyIFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3QpO1xuXG5cbiAgICAgICAgdGhpcy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG5cbiAgICAgICAgYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldFVybCA9IGZ1bmN0aW9uIGdldFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFVybCh0aGlzKTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZ2V0Qm9keSA9IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHk7XG4gICAgfTtcblxuICAgIFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbmRXaXRoID0gZnVuY3Rpb24gcmVzcG9uZFdpdGgoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdGhpcy5nZXRVcmwoKSB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXF1ZXN0O1xufSgpO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIHNlbmRpbmcgbmV0d29yayByZXF1ZXN0cy5cbiAqL1xuXG52YXIgQ1VTVE9NX0hFQURFUlMgPSB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9O1xudmFyIENPTU1PTl9IRUFERVJTID0geyAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicgfTtcbnZhciBKU09OX0NPTlRFTlRfVFlQRSA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnIH07XG5cbmZ1bmN0aW9uIEh0dHAob3B0aW9ucykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICBjbGllbnQgPSBDbGllbnQoc2VsZi4kdm0pO1xuXG4gICAgZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgc2VsZi4kb3B0aW9ucywgSHR0cC5vcHRpb25zKTtcblxuICAgIEh0dHAuaW50ZXJjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgY2xpZW50LnVzZShoYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjbGllbnQobmV3IFJlcXVlc3Qob3B0aW9ucykpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gcmVzcG9uc2UgOiBQcm9taXNlJDEucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZWplY3QocmVzcG9uc2UpO1xuICAgIH0pO1xufVxuXG5IdHRwLm9wdGlvbnMgPSB7fTtcblxuSHR0cC5oZWFkZXJzID0ge1xuICAgIHB1dDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcG9zdDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcGF0Y2g6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGRlbGV0ZTogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgY3VzdG9tOiBDVVNUT01fSEVBREVSUyxcbiAgICBjb21tb246IENPTU1PTl9IRUFERVJTXG59O1xuXG5IdHRwLmludGVyY2VwdG9ycyA9IFtiZWZvcmUsIHRpbWVvdXQsIG1ldGhvZCwgYm9keSwganNvbnAsIGhlYWRlciwgY29yc107XG5cblsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBIdHRwW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdXJsLCBtZXRob2Q6IG1ldGhvZCB9KSk7XG4gICAgfTtcbn0pO1xuXG5bJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBIdHRwW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdXJsLCBtZXRob2Q6IG1ldGhvZCwgYm9keTogYm9keSB9KSk7XG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBSZXNvdXJjZSh1cmwsIHBhcmFtcywgYWN0aW9ucywgb3B0aW9ucykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICByZXNvdXJjZSA9IHt9O1xuXG4gICAgYWN0aW9ucyA9IGFzc2lnbih7fSwgUmVzb3VyY2UuYWN0aW9ucywgYWN0aW9ucyk7XG5cbiAgICBlYWNoKGFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24sIG5hbWUpIHtcblxuICAgICAgICBhY3Rpb24gPSBtZXJnZSh7IHVybDogdXJsLCBwYXJhbXM6IHBhcmFtcyB8fCB7fSB9LCBvcHRpb25zLCBhY3Rpb24pO1xuXG4gICAgICAgIHJlc291cmNlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChzZWxmLiRodHRwIHx8IEh0dHApKG9wdHMoYWN0aW9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNvdXJjZTtcbn1cblxuZnVuY3Rpb24gb3B0cyhhY3Rpb24sIGFyZ3MpIHtcblxuICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCBhY3Rpb24pLFxuICAgICAgICBwYXJhbXMgPSB7fSxcbiAgICAgICAgYm9keTtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcblxuICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICBib2R5ID0gYXJnc1sxXTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuXG4gICAgICAgICAgICBpZiAoL14oUE9TVHxQVVR8UEFUQ0gpJC9pLnRlc3Qob3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHVwIHRvIDQgYXJndW1lbnRzIFtwYXJhbXMsIGJvZHldLCBnb3QgJyArIGFyZ3MubGVuZ3RoICsgJyBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgb3B0aW9ucy5wYXJhbXMgPSBhc3NpZ24oe30sIG9wdGlvbnMucGFyYW1zLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cblJlc291cmNlLmFjdGlvbnMgPSB7XG5cbiAgICBnZXQ6IHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgIHNhdmU6IHsgbWV0aG9kOiAnUE9TVCcgfSxcbiAgICBxdWVyeTogeyBtZXRob2Q6ICdHRVQnIH0sXG4gICAgdXBkYXRlOiB7IG1ldGhvZDogJ1BVVCcgfSxcbiAgICByZW1vdmU6IHsgbWV0aG9kOiAnREVMRVRFJyB9LFxuICAgIGRlbGV0ZTogeyBtZXRob2Q6ICdERUxFVEUnIH1cblxufTtcblxuZnVuY3Rpb24gcGx1Z2luKFZ1ZSkge1xuXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwoVnVlKTtcblxuICAgIFZ1ZS51cmwgPSBVcmw7XG4gICAgVnVlLmh0dHAgPSBIdHRwO1xuICAgIFZ1ZS5yZXNvdXJjZSA9IFJlc291cmNlO1xuICAgIFZ1ZS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVnVlLnByb3RvdHlwZSwge1xuXG4gICAgICAgICR1cmw6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS51cmwsIHRoaXMsIHRoaXMuJG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkaHR0cDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMoVnVlLmh0dHAsIHRoaXMsIHRoaXMuJG9wdGlvbnMuaHR0cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJHJlc291cmNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVnVlLnJlc291cmNlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJHByb21pc2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVnVlLlByb21pc2UoZXhlY3V0b3IsIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICB3aW5kb3cuVnVlLnVzZShwbHVnaW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtcmVzb3VyY2UvMC45LjMvdnVlLXJlc291cmNlL2Rpc3QvdnVlLXJlc291cmNlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJib251cy1iYXJcXFwiPjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gYmV0XFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLWJhY2sgZm9yemVuXFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLXNob3dcXFwiPjxkaXYgY2xhc3M9XFxcImJldC1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcImxvY2ttb25leVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtaXRlbSBjb3VudC1kb3duXFxcIj48ZGl2IGNsYXNzPVxcXCJjb3VudC1kb3duLWJhY2tcXFwiPjxkaXYgY2xhc3M9XFxcImNvdW50LWRvd24tc2hvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY291bnQtZG93bi1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjQwKnpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwiY291bnREb3duIHwgdGltZVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtaXRlbSBib251c1xcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1iYWNrIGJhbGFuY2VcXFwiPjxkaXYgY2xhc3M9XFxcIml0ZW0tc2hvd1xcXCIgQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCI+PGRpdiBjbGFzcz1cXFwiYmV0LW51bVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJiZXROdW1cXFwiIHYtaHRtbD1cXFwidXNlcmluZm8ubW9uZXktbG9ja21vbmV5XFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXFBsYXlQYW5lbC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi01ZmViZDBiMC9QbGF5UGFuZWwudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5wbGF5cGFuZWwge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA1MCU7XFxufVxcblxcbmltZy5jaGlwIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LnRhYmxlLXBhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAuMyk7Ki9cXG59XFxuXFxuZGl2LnNpbmdsZSB7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpOyovXFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5kb3VibGUge1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTsqL1xcbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuYmlnIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LnNtYWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYubnVtIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTsqL1xcbn1cXG5cXG5kaXYuYm9udWRudW0ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9jOTJiZDc0YVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK05BO0lBQ0Esc0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxtQkFBQTtJQUNBLGtCQUFBO0lBQ0Esb0NBQUE7Q0FDQTs7QUFFQTtJQUNBLHNDQUFBO0lBQ0EsZ0NBQUE7Q0FDQTs7QUFFQTtJQUNBLHNDQUFBO0lBQ0EscUJBQUE7SUFDQSwrQkFBQTtDQUNBOztBQUVBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLDRCQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLHNDQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiUGxheVBhbmVsLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOS4u+a4uOaIj+WMulxcbiAgICBkaXYucGxheXBhbmVsXFxuICAgICAgICBkaXYudGFibGUtcGFuZWwodi1lbDpwYW5lbCx2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5zaW5nbGUodi1iaW5kOnN0eWxlPVxcXCJzaW5nbGVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NpbmdsZScpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmRvdWJsZSh2LWJpbmQ6c3R5bGU9XFxcImRvdWJsZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnZG91YmxlJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uemVybyh2LWJpbmQ6c3R5bGU9XFxcInplcm9cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDAgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5vbmUodi1iaW5kOnN0eWxlPVxcXCJvbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50d28odi1iaW5kOnN0eWxlPVxcXCJ0d29cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMilcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS50aHJlZSh2LWJpbmQ6c3R5bGU9XFxcInRocmVlXFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDMpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAzIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uZm91cih2LWJpbmQ6c3R5bGU9XFxcImZvdXJcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5maXZlKHYtYmluZDpzdHlsZT1cXFwiZml2ZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg1KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNpeCh2LWJpbmQ6c3R5bGU9XFxcInNpeFxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg2KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNiBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNldmVuKHYtYmluZDpzdHlsZT1cXFwic2V2ZW5cXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoNylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5laWdodCh2LWJpbmQ6c3R5bGU9XFxcImVpZ2h0XFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDgpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0ubmluZSh2LWJpbmQ6c3R5bGU9XFxcIm5pbmVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoOSlcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDkgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5iaWcodi1iaW5kOnN0eWxlPVxcXCJiaWdcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2JpZycpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNtYWxsKHYtYmluZDpzdHlsZT1cXFwic21hbGxcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NtYWxsJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5mb3JtdWxhKHYtYmluZDpzdHlsZT1cXFwiZm9ybXVsYVxcXCIsdi1odG1sPVxcXCJib251c051bVxcXCIpIFxcbiAgICAgICAgICAgIGRpdi5udW0uYm9udWRudW0odi1iaW5kOnN0eWxlPVxcXCJib251ZG51bVxcXCIpXFxuICAgICAgICAgICAgICAgIHRhYmxlXFxuICAgICAgICAgICAgICAgICAgICB0clxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkKHYtaHRtbD1cXFwidXNlckJldC5iZXRudW1cXFwiKVxcbiAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcInRhYmxlUGFuZWxJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICdiZXRzJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHRhYmxlUGFuZWxJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcnKSxcXG4gICAgICAgICAgICBjaGlwSW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nJyksXFxuICAgICAgICAgICAgaW1nU2l6ZToge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUyOFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIC8vIFRPRE8g6YeN5paw6K6+5a6a5Lit5aWW6KeE5YiZXFxuICAgICAgICBib251c051bSgpIHtcXG4gICAgICAgICAgICB2YXIgbnVtcyA9IHRoaXMubG90dGVyeW51bS5sb3R0ZXJ5bnVtcy5zcGxpdCgnLCcpXFxuICAgICAgICAgICAgdmFyIHN1bSA9IHBhcnNlSW50KG51bXNbMF0pICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKVxcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1zWzBdKSArICcrJyArIHBhcnNlSW50KG51bXNbbnVtcy5sZW5ndGggLSAxXSkgKyAnPScgKyAoTWF0aC5mbG9vcihzdW0gLyAxMCkgPyBNYXRoLmZsb29yKHN1bSAvIDEwKSA6ICcnKSArICcoJyArIHN1bSAlIDEwICsgJyknXFxuICAgICAgICB9LFxcbiAgICAgICAgc2luZ2xlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZG91YmxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB6ZXJvKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB0d28oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAyKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdGhyZWUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZm91cigpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmaXZlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2l4KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V2ZW4oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBlaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG5pbmUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBiaWcoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgOCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgc21hbGwoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNTQ4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JtdWxhKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAzNyAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDIyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gVE9ETyDpgY3ljobkuIrmnJ/kuIvms6jorrDlvZXvvIzorqHnrpfnrZvpgInmmK/lkKbmnInkuK3lpZblj7fnoIFcXG4gICAgICAgIGJvbnVkbnVtKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgYmV0KGV2ZW50KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hlaWdodCcgKyBldmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0KVxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXaWR0aCcgKyBldmVudC50YXJnZXQub2Zmc2V0V2lkdGgpXFxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgLy8g55So5oi35LiL5rOoXFxuICAgICAgICBkb2JldChudW0pIHtcXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyaW5mby5tb25leSAtIHRoaXMudXNlckJldC5iZXRtb25leSAtIHRoaXMubG9ja21vbmV5IDwgMCkgcmV0dXJuXFxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnREb3duIDwgMTApIHJldHVybiAvLyDlgJLorqHml7blsI/kuo4xMOenkuaXtuemgeatouS4i+azqFxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnTlVNQkVSJ1xcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcXG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpZyc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ0JJR19PUl9TTUFMTCdcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmJldHMucHVzaChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVzZXJCZXQpKVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIGNhbmNlbEJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuYmV0cyA9IFtdXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5wbGF5cGFuZWwge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA1MCU7XFxufVxcblxcbmltZy5jaGlwIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LnRhYmxlLXBhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAuMyk7Ki9cXG59XFxuXFxuZGl2LnNpbmdsZSB7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpOyovXFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5kb3VibGUge1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTsqL1xcbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuYmlnIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LnNtYWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYubnVtIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAvKmJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTsqL1xcbn1cXG5cXG5kaXYuYm9udWRudW0ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRWdBQUFCSkNBWUFBQUNlc1dEaUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRlJVRTVSVGs0TnpOR05VUXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGUlVFNVJUazRPRE5HTlVReE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1ZGUVRsRk9UZzFNMFkxUkRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rVkZRVGxGT1RnMk0wWTFSREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K1V2MkhJQUFBQkR4SlJFRlVlTnJzbkxHT0ZERU1odVBNNkJERkZiUlg4d1IweHl2d0tEd1BqOEpyVUNORVRVZDFCVHBwSnlHWnRYUC9lRFBMNUlUQUlFZktKdXpNTGNtWDM0NTNGUTk5K0p4REtldUxsMjE1Zi8rV1lubTVjUlM3NVNhV2wxdm5zRnR1SzZBWHptRzN2Smg3Ny81NDl6cE1SR3VkUzQzY2o5Q25jbC9rbHJpMVZLcFR6VG12YmVKMktXM2lLdjBUOTJ0OStmSHJ4ZWQwQVFtWUtjWStKSUhEZllGa0NsQ0ZVc2FVdUY5aDFERUxuTWh3eXNWQUtlMSt6aTZnQ21kbUtGZ1JGS29uR2dNa3FtbWdSRFc4b0F2ZnQ0NjZ6RFh2UU9vQ1FqQnpUMFVNWm1JbzBhS0pNWlF5MExOaWVKeWlIdUlhQ3BnMXhpblg4bEZBVVV3TS9CQ3FCeFdFY0t5WVdWVU5Ra0xUYXFvQmtOSXVJeVlXRlp5ZWlVVmxYbVJJUFdKbUFvZkFwQloxYitZNUx5TUttam83bC9nbWtXc0VjeU5MZ0xqV3NZblBFWCs1c0srUmV5WUdsSGJVdndzb2RreEs0Q0M0Q0tabEFWS0c3MDBaNFp4dHJ6bmtTWnc1N01wRHUxaFU3VVcvWTJKV2RyTEV2aVpwUUF4Sk5wZk0vUVR2SFFKRW9DSkN0ZlNxQ2hRdEtFak1oaGlTVnBkVXdwZ3U1ekVUazBsajFOeURZekdheHZnbjhGYXZBU1ZRajRoZ1RFSGdXNW9weWZ2UzExdTlBVWlyTWlBNGpBeEpuSFptVlVsTXRNS0JYZTRZSU5pVk5oREE1TWpvOXpHU2JSNjNlRlo3aHNVVmVNUndhRlJCQkU0NGRQd0xRaUZEd1dJV05UQWtVdjZGT3I2V3J2aWdlR2hWUUZFWGdhR3hTSnAyeGhiVkhJNk9kWDZPaEx1dGtXaGFkaWRSa3BoVmZ1YllZdkRpZ0J5UUEzSkFEc2dCT1NBSDVNVUJPU0FINUlBY2tBTnlRQTdJaXdOeVFBN0lBVGtnQitTQUhKQURjZ1FPeUFFNUlBZmtnUDdaTW53K0tIZmE5ZndObitheWtOdlpVaEYyeHZ6YkZTUjVWM2hDdFAySGZBMEhaZ1lPakMycE9Sd2Q2N3luRXNteHluQlVMWGZ1d2FPMlpBVVNMaXBBNnMxaG5hTzY1OWVBZU9MdEErUkliWGc2Uml1blNUZEhiWTBjQXc0cTA3QXROdGVrcjE5WjJGMEZTYVpld0pTaThIUUlNdkZBOEtndFhWbUp2NldneEVsME1xZWszUVJjUHd5bzBaWUVORWdwMnVROWRJN2FtbEFRdWdtQnBLcmtzS0xDeGhRa2VaN2MzeHloVmZlS3A0OUdkckdXeklJcTZrRlN3QTRERXRWZ2V4WU1PK1N3emNuQ25jSlVPcFJTa09Tc0xxb3Y3WkNKSmZXSGE2WmVUVWFMc1RuQkhEbzVXVlo4VU0vRWVBNEpVc0ZSVVVPQUZsYURKSHBJdXVLYWpNYW0xQkpEeENVWkF0UXpzVVcxR3RTWWlkVS9ER0dUdzdEbVlpay9KUTY4bWFDeFNCb2hMUXJTU2YxN1NFRW5tYlFDRk9CcnhRUitxcVU4R2xLUkxOd2lEam1FN2hNWFRxTUthazhrV0dtbGM5RElRQktrWjJMOFkvckJBcUFnVk5LaUlFMGpKa2Jza0xOeWZKdGNLMGhHTS9sb0NnaDRFempzQ3hXVnVTNmpnTVFoQjZXZTluQVRNSzFyK1ZaV291a2pEemM1YkdMNEZKVE1POWp5bi83ZU04SEc0eitZK1MrS0R1aVBGd3F2N3U5Sys2YlVPOGV4S2Q5Sy9WU2Q5R09wMzUzSFJhbE1IaXVnaDFLL0JIL1lteTVWT0E4L0JSZ0EzVjJNdGxXblIrc0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aYvuekui3nuqIucG5nXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8tIOS4u+a4uOaIj+WMulxuICAgIGRpdi5wbGF5cGFuZWxcbiAgICAgICAgZGl2LnRhYmxlLXBhbmVsKHYtZWw6cGFuZWwsdi1iaW5kOnN0eWxlPVwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnNpbmdsZSh2LWJpbmQ6c3R5bGU9XCJzaW5nbGVcIixAdG91Y2hlbmQ9XCJkb2JldCgnc2luZ2xlJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnc2luZ2xlJyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5kb3VibGUodi1iaW5kOnN0eWxlPVwiZG91YmxlXCIsQHRvdWNoZW5kPVwiZG9iZXQoJ2RvdWJsZScpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ2RvdWJsZScgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uemVybyh2LWJpbmQ6c3R5bGU9XCJ6ZXJvXCIsQHRvdWNoZW5kPVwiZG9iZXQoMClcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAwIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLm9uZSh2LWJpbmQ6c3R5bGU9XCJvbmVcIixAdG91Y2hlbmQ9XCJkb2JldCgxKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDEgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0udHdvKHYtYmluZDpzdHlsZT1cInR3b1wiLEB0b3VjaGVuZD1cImRvYmV0KDIpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMiBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS50aHJlZSh2LWJpbmQ6c3R5bGU9XCJ0aHJlZVwiLEB0b3VjaGVuZD1cImRvYmV0KDMpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5mb3VyKHYtYmluZDpzdHlsZT1cImZvdXJcIixAdG91Y2hlbmQ9XCJkb2JldCg0KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDQgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uZml2ZSh2LWJpbmQ6c3R5bGU9XCJmaXZlXCIsQHRvdWNoZW5kPVwiZG9iZXQoNSlcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA1IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnNpeCh2LWJpbmQ6c3R5bGU9XCJzaXhcIixAdG91Y2hlbmQ9XCJkb2JldCg2KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDYgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc2V2ZW4odi1iaW5kOnN0eWxlPVwic2V2ZW5cIixAdG91Y2hlbmQ9XCJkb2JldCg3KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDcgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uZWlnaHQodi1iaW5kOnN0eWxlPVwiZWlnaHRcIixAdG91Y2hlbmQ9XCJkb2JldCg4KVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDggaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0ubmluZSh2LWJpbmQ6c3R5bGU9XCJuaW5lXCIsQHRvdWNoZW5kPVwiZG9iZXQoOSlcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA5IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmJpZyh2LWJpbmQ6c3R5bGU9XCJiaWdcIixAdG91Y2hlbmQ9XCJkb2JldCgnYmlnJylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAnYmlnJyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5zbWFsbCh2LWJpbmQ6c3R5bGU9XCJzbWFsbFwiLEB0b3VjaGVuZD1cImRvYmV0KCdzbWFsbCcpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ3NtYWxsJyBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5mb3JtdWxhKHYtYmluZDpzdHlsZT1cImZvcm11bGFcIix2LWh0bWw9XCJib251c051bVwiKSBcbiAgICAgICAgICAgIGRpdi5udW0uYm9udWRudW0odi1iaW5kOnN0eWxlPVwiYm9udWRudW1cIilcbiAgICAgICAgICAgICAgICB0YWJsZVxuICAgICAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICAgICAgdGQodi1odG1sPVwidXNlckJldC5iZXRudW1cIilcbiAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJ0YWJsZVBhbmVsSW1nXCIsdi1iaW5kOnN0eWxlPVwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbycsICdiZXRzJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2xvY2ttb25leScsICdsb3R0ZXJ5bnVtJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhYmxlUGFuZWxJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcnKSxcbiAgICAgICAgICAgIGNoaXBJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iLzVY562556CBLeaLt+i0nS5wbmcnKSxcbiAgICAgICAgICAgIGltZ1NpemU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTI4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIC8vIFRPRE8g6YeN5paw6K6+5a6a5Lit5aWW6KeE5YiZXG4gICAgICAgIGJvbnVzTnVtKCkge1xuICAgICAgICAgICAgdmFyIG51bXMgPSB0aGlzLmxvdHRlcnludW0ubG90dGVyeW51bXMuc3BsaXQoJywnKVxuICAgICAgICAgICAgdmFyIHN1bSA9IHBhcnNlSW50KG51bXNbMF0pICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bXNbMF0pICsgJysnICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKSArICc9JyArIChNYXRoLmZsb29yKHN1bSAvIDEwKSA/IE1hdGguZmxvb3Ioc3VtIC8gMTApIDogJycpICsgJygnICsgc3VtICUgMTAgKyAnKSdcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDU0OCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgemVybygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMSkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR3bygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMikgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRocmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm91cigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogNCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpdmUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNpeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAxKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V2ZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMikgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDMpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuaW5lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiaWcoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA0MjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzbWFsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDQyNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDU0OCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybXVsYSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDIxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAvLyBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNDIgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzcgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8g6YGN5Y6G5LiK5pyf5LiL5rOo6K6w5b2V77yM6K6h566X562b6YCJ5piv5ZCm5pyJ5Lit5aWW5Y+356CBXG4gICAgICAgIGJvbnVkbnVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNjggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGJldChldmVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hlaWdodCcgKyBldmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0KVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dpZHRoJyArIGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KVxuICAgICAgICB9LFxuICAgICAgICAvLyDnlKjmiLfkuIvms6hcbiAgICAgICAgZG9iZXQobnVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VyaW5mby5tb25leSAtIHRoaXMudXNlckJldC5iZXRtb25leSAtIHRoaXMubG9ja21vbmV5IDwgMCkgcmV0dXJuXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPCAxMCkgcmV0dXJuIC8vIOWAkuiuoeaXtuWwj+S6jjEw56eS5pe256aB5q2i5LiL5rOoXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bSkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnTlVNQkVSJ1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bSkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ1NJTkdMRV9PUl9ET1VCTEUnXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnU0lOR0xFX09SX0RPVUJMRSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdCSUdfT1JfU01BTEwnXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdCSUdfT1JfU01BTEwnXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJldHMucHVzaChPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVzZXJCZXQpKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgY2FuY2VsQmV0KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmJldHMgPSBbXVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ucGxheXBhbmVsIHtcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgaGVpZ2h0OiA1MCU7XG59XG5cbmltZy5jaGlwIHtcbiAgICB3aWR0aDogNTAlO1xuICAgIGhlaWdodDogNTAlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cblxuZGl2LnRhYmxlLXBhbmVsIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDUwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgLypkaXNwbGF5OiBub25lOyovXG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpOyovXG59XG5cbmRpdi5zaW5nbGUge1xuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpOyovXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2LmRvdWJsZSB7XG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7Ki9cbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAxZW07XG59XG5cbmRpdi5iaWcge1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxZW07XG59XG5cbmRpdi5zbWFsbCB7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xufVxuXG5kaXYubnVtIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7Ki9cbn1cblxuZGl2LmJvbnVkbnVtIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogUGxheVBhbmVsLnZ1ZT9jOTJiZDc0YVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQW9BQUFBSVFDQVlBQUFBUnE5OWdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEZSVUU1UlRrNE16TkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRlJVRTVSVGs0TkROR05VUXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tWRlFUbEZPVGd4TTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1ZGUVRsRk9UZ3lNMFkxUkRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt2Y2xoSlFBQVhTTkpSRUZVZU5yczNYbVVIT1Y5Ny8rbmVoWnB0STUyTkVLSTBVaENFZ0lFd2tKZ3pDSWpnc0VtQVhPSWJjRFlOK2NlSEFkd0VvN2pEZnNQWDhkSjdLUGNYd0FuNXBkalk0TEJ1VnhzeDJBd05tWVRBZ25GWXdraEpMUnJ0SXpRT2pQU2pHYnQ3dHZmcDZwNnVudDZxZXExdXVyOTRqU2oyWHVxYS9uVXMzd2ZRMDI2dkVZcEZWSW1Rd0VBQU1DUG90YmJpQkVMZ0dOaS82aTFRaUFCRUFBQXdMOEJNQko3REVrQW5CYjdSNzBWQW12WU5nQUFBTDRVbHZBWGV3eElBR3lKL1VOYUFVY1JBQUVBQUh3ZEFQdGpqek8xVnZpYkVIczBLTE1WRUFBQUFQNGpyWCs5eWdwOG82endKMEd3am0wREFBRGdTNFBXMjM1NzNGK3RGZjdxMlRZQUFBQytwYk9mOFlQM28xRzJCUUFBUUxCU29Qcko3OTVtU3dBQUFBVEE1NjYvTEY0QUdnQUFBQUZCQUFRQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNpUjJteWZ2UE9LODloQ3hVemJOVFZzQkFBQU1vaUU2dGdJUmZUVDE5L0pMd0NLNy95ZlY5aUNSZkt0ejZ4U3E1Ly9BeHNDQUlBMC91WVRsNnZ2dnJLSERWRUVYMTg1Tit2bjZRSUdBQUFJR0FJZ0FBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUlBQUNBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FHWXpaMXk5dW0vNU9hNi81OG5QTEZNUFh0MmkvdzBBQUFDbGFyMytCRythTzFsOVprV3p1bUpoa3hvN3VrNDl1L1VEMWRZOTRPaDc3NzJ5UmExYU9rYy83ci9wSXJYKy9jTnF3KzZqNnFYM2o2aTNqM1R6NmdNQWdLSzRZKzQ0TldsMGpabzlzUzdwNHdlNkJ0VWpXN3NJZ0U1SnE5M0tKYlBVa2psVFI0UzZMNys0TGVmM1M0dmZiVmZNUy9yWWlvVXo5ZVArbTVUNnhPcmZFUUlCQUVEY2pVME5Pc1RaZG5ZT3FBMG5CekorN2RWenhxcGxzOGVxSlUxanMvN2NleTZmcnI3eW00UHFoZlplQW1BMjB1b25MWFpwTi9peU9ZNENvQVJGYVRGTTUvRlh0aEgrQUFBSXNPV1Q2OVdxYzhlcUQ4MGVwMXFtamxiVHhxZlBESHVQOTZsSDNqcXFudHhqNW9aN0YwOVVkMXd5UlRYSHZzY3ArZGsvdnIxWi9ZK245M29tQkhweURPRHplMDZxdlVmU041ZE9temhHdHc1bWM5bU1jU05hLzJ3OWZZUHFrYlc3MmZNQkFBaWdiMXd5U2YzKzlqbnEyYy9PVS9kZE5WT3RhQjZmTWZ3SkNYcXJiejVIZjUrUUxsNDM0Uy9SUDMzc2JNOXNCODlPQW5udUQvc3lmdTR2UHJvNDY2U08rejk2WHNiV3Z4Kzl2Tlh4R0VJQUFPQWZjeHBxMVA5WU1UMW5sMjA2RWhhbDFmRG4yMC9sL2ZzbGFOcEJrZ0NZd1JPdEIzUnJYVG9TN3I2MmFtSGF6MG5ybjB6NlNPZFkxeG4xbmRkcC9RTUFJSWphZXNOcTNaN1RlWC8vL2N1bjZqR0JXOXA3OHY0WjE4NmJRQURNK2lKMUQ2aG4zdG8xNHVNU0NtVU0zeis4OUg1eXFoOVhyKzVhY3BaYU1HMmMvcnpNK0pYQWwraG5hM2V5OXdNQUVHQy8yWkYvQzk3bGM4ZnJ0Ni91eXY5bjVOdDlYR3llTGdNamt6MnVPcjlKTmMrWXFOL2YwblpjN1dqdlZFMlR4NmpIN2w2aFA1NnBxemVkUmJNYTlmaEJ5c0FBQUJCTU1wbmpxNmNIczQ3N3kyUnN2VGxEK0tmYlR1bXVaUHY5WTdHZnQzYjNLYlYyZjQ5YWU3aFh0elR1L3VKNThjK24reGtFUUl2TS9KMDhwbDZ0MlhjeVBrWlBDajhmNlRnVEQ0QlNFaWExTEl3Ynd6VUJ6VEQ1Mk9zNzFCTmJQdUJvQUFBZ1FDU3MzYkowU3Z6OW5nR3phL2hRMTREYWZLUlBYWG5PMktUUHA3SzdraSthTlZiOTU4Ymo2dS8vMkRIaWEyVDJjRDVqRFFNWEFCLzQySko0dUpNWndIYm9LeFg1WGFzL08xVjllTjB1OVlWZmJ1Wm9BQUFnSUI3YjNLRURuclRjcFF0d0Y4N0kzVTM3MEliamFzUEo5b3lmbnpFKy9XVFZRc1lQK2k0QXlzU054SmE5VW9lL1JMZGVQaytOYjZoVGR6elZ5aEVCQUVBQXlFU09oOWNjVHR0eUo4NmIzcEF6dkdVcUVDMWt0bkNtTHVidS9vZ250b0VuSm9GOC9vcTVGZjM5MGkzOC9Sc1djVVFBQUJBUW1jS2ZoRGVwRFpqT3pxTjl6bkxOaFpsTHZXdy82bzFDMEo1b0Fmekk0cWFpL0p5WE5yV3A5cFBKTTMrWHRVelRFMFZ5dFNwSzRXZ25LNHdBQUFELyt1UjVtY3Uwdk9jZ0FFcXR3ZXNYTjJiOGZDRjFCSDBWQUdYeWg2enVrWTJVYzltMDk1amFkcWhUZmVMU2N6T0dPZm44eURwL1pxaVRidWFIN3J3czQvZEtTSlJKSnc5djJNL2VEd0JBQUVsNHUrM2k5Sk0vWktMSUkxdTdjdjZNT3hkTnlEalRWOFljWnVzNkRsUUF2R2JCakl5Zmt4YTlwOWJ2MVV2RDJhU1VTNllRTjdFaDgrb2dVdmJsL3ArK3JaNTc0UHFNWDNQTzVMSHMvUUFBQkNEb0Nabk5tK2lMU3lkbERHKy8yOXJwNk9kS2VaaE1YdGphNFpsdFVQRUFLRjIwbWRobFcrTHB1MjlRbmVrZnpQcXp2bitEVWwyOUE2cnRSSS9hY2F3N3FkNmYvRnRDWmFhVlFzNXJhdVNvQUFEQTU2U1ZUb0xhajljZmpZOEZsTEYvZDErV09iekp6T0Zjc2dWSWFVSDgxMDBFd0RnM00zNmxtelpiNGVmVU9vSC82NWsvakNqNG5EcEdNTkc0aGpxT0NnQUFmTzVEczhmcG9DYnIrMzdxNHFtNkZFeTJKZHArLzM1bnpxN2JYQUh5bVkwblJyUTRCam9BdWxuSnc2M09NeU5mck0wSE85anpBUUFJc01SWnZsS3VSWUpnSnRKeUp6WC9iUGN1bnFpdW16OUIvZmVCYnIwaWlCM3EvdVhHczdQK0RDKzEvbFU4QU1yYXZRQUFBT1VpQWM2TmR3K2RTV3I5VzNIT1dCMGc1U0hCY2YzZTA2cTdQNXgxalYrdnRmNVZQQURtSWl1Q3JIbXZmY1E0UWFmTHdhVmI1dTNDc3lleDl3TUFFRkFTNEZ4OWZTem9mZkRYaTNYUSs3TmZIZERMdjZWK1BodVorZnVWZGNjOXR4MHFHZ0Fsb0szTzhua1pIeWdCY09VUDFpUjkvT2ozYnMzNFBZKy9zazN0UDltVGRrYXZGSHVXZW4rWmRQY09jbVFBQU9CanFRSE9LU25nZkdOVFE4WVZQckw1dDJ0bXFGUDlZYjNPY0VkZldMM1FYdmxpMEJWdkFaUWFmOW5xQU42OTBneHQwaHJZdXZ1WS9wak1CczQyZGxERy9zbmp3YXRiZEdtWXBzbGoxTkxtYVRuckRXNXY3K1RJQUFEQXgvN3gxY1BxcTlmT2RCM2tEblFOcXF2bnVBK1A4bnRrM2VGVUR6eTdYejI1cHp1NEFmQ0YxallkOHJLUnNKYzZ3emRiWU15SGhNcEgxdTdteUFBQXdNY2tkSFgwSFZRL3ZyM1oxZmR0K0tCWDNYSEpsS0krajBxcStGckFzdnlhdE81VjJqLy8raDNWMWozQWtRRUFnSTlKc2VadnJwenA2bnZzRlR6VzdENmwvMTJvTGUwOUZkOE9JUys4R0xjLytvYmEwbGE1QVpJUFBmOE9TOEFCQUJBQVAvckUyVmxuN080OVBuSzkzOTNXeDJReXg4ZWYycVBMdWhSaXA0TTFoVXZORTdPQXBlVk5KbnJJbUwxUFh6ay81MWk5WXBIUXVmbzNXNUtXbWdNQUFQN1ZlcUJITFdsS1A1YlBudWtyN3BnN1RsMDRZN1NhTUtwR0hUdzEzRVA0TDljM1pWenR3Nm5Fbnhmb0FHajd6dXU3OVVQcUEzNTQvblMxb0tuUmNja1hKMlNjbnoyWjVKbU5CMGFzRWdJQUFQeE5XdkZtVGF4WDF5MU1YdjVWV3Y2KzlMdjIrUHN5Umk5MW5ONVBiMmpLV3ZaRldnYS85ZUloSFJ6UG05NmdXcWFPVGp2WlpPTUh0QUNtSmVWaEVtdjRYVFpqbkZvd2Jaeis5NXdwWS9YTTNteVRQYVFVakxEWEJCWnI5cDFrakI4QUFGQjN2dGl1L210VVRUek1TWEQ3WDY4Y3pscXNXVm9FVTBOaktnbC82WUtqZk8razBUVnE5a1F6REZJR3hpRnBxZnVnWjBCZGRlNWtLOUJsSHp5WldqaGE2Z21tS3hzalFWRW1vUUFBZ0dDUjFyNy8vT1FjTlgxQ25icnZ2L2JuREdVUzZ1NDkzcGR4L09EamJ4L05PTE8zMGpOK1BSOEFwVkN6T0srcFVZMXJxTk9oVGNLYlc4WHNOZ1lBQVA0anJYMmYrbm1iK2tUek9NY3RjdkwxRWhwVFErRHYzKy8wNUdvZlZSTUFwZVd1bk9GTkNrUURBT0FyMFdqQzIyanNqZm5XTUdxVUNvWFlQaWtoOEpHdFhhNisva3N2SEZRLysxUnpmQ0tJakIyVUx1VnFFK2c5WWVha3NlejlBSURxRndtclNGKzNDdmQwcXNpWlU3RkhsNHIweHQ3Mm5sYlIyTWVqZlQwcUdoN1FRUkNGa1hxQTBtVXM0d1lsL0VtcllEWHlWQXZnNFk0ZXVtOEJBSEFwS3NFdUdsV0c5Wjc4dzdEZUd3NkpFYk5WMEREWVlBV1NMdU5KTHg1U2F3LzNacDA0UWdCMHFQM2ttYUw4SEZsZldKYVl5MmJ6d1E1MThneXpnZ0VBMWM4d1FzcW9xVldKbWM5SUNvaVMvY0lxR2duSHZvNXU0R0x3NHNTT3FnMkF3bDRScEx0M1VHMXY3OVQvVGl6bklxRk5DamZmdC93YzljM2JMazM3TTQ1MG5tRjJMd0FnU0FsUXFWZ0FOS0tSV1BETDBNMGJpYWhvZUVpcFVDMnRnUEJXQURSRG03UGcxaGtMZ25aWTNCRUxpcWRqZ2RFT2lqdU9VZUFaQUJDb0JPZ2dJeHE2QlREMnY5ZzdOV3d5QW1CMVNpMFdEUUFBTXNmRGFDd0FHcEdvYmdXVUxtTmFBWU9OZ1FBQUFBUXBDVWFHRkxPQlFRQUVBTUEzNlM1enREUHNyNGpJWkpBSW00c0FDQUFBL0pEL2NyYnJHVlp4R0drRmpOSUtTQUFFQUFEVm53QWRUZ1pSNFNGZEZnWUVRQUFBNEljTW1PdlQwZ29vTTRIcEJpWUFBZ0FBbjZlL3BDODE5RmhBWFJJR0JFQUFBRkRGK2M4SU9mc3krWWQwQTBmb0JpWUFBZ0NBS2c2QXNVdDZUWjNEcnpYTUZVTUlnQVJBQUFEZ2l5VG9NQU5hM2NDRVFBSWdBQUFJU0VUVUFkQmFIeGdFUUFBQUVLQWdLQk5CcUFsSUFBUUFBTlViNmFMbTZENW5YNjBYQ1k0U0FBbUFBQUNnaXZPZjQyb3dpVFVCb3hHNmdRbUFBQUNneWxPZ0M5TDZKK01BUFZJVHNDWms4QklTQVAxalZGMHRHd0VBNEwyNHFMdUJJNTRJZ09GWUdHMGN6ZldTQU9nakU4ZU5VWU5ocHRvREFEd1UvcXdFS0tNRzlXemdDbzhGN0Rvem9GcW1qT0dGSVFENlIwdlRGSFdxZDZDNi93ZzlVTmhhUDVLNlVRRGd6VWhuNUhscDk4RFNjSHVQblZJWE5ZMDNXeVZSVXJTemx1TndqTzNKRnpjM3FiYllqdTM1akRjMEdEc0pERmw1ejc0VGpDcHpTbGwwT0FqSzMxVmJGN3VGcUluOWZTSDlGZ0JROFF1T1VqV3g4M0hVZVpnejR2ZjRFYjAwbkZIQjgvbVcvUitvUzg2ZHFpNlpOVUcxSGp6RjYwa0FyRzdMejV1anBveHZVTTl2MnV2ZEp5bkZRSWY2elFEbzhLUVJIWXpvazAzVWlJVkFPZUZJRUl3OWpCcDJLd0NvWUFvMGc2Q2IzbHc5R3pocXJnMHNOL2tWYW9JNzJkV3QzdGwvUWwwM2Y0bzZjV1pRN1R2Wnk4dFpJblFCbDFoTDAxUjEzZEo1c1IzNm1EcCsyb003c3R6eERRMm95RUN2ZnFzclNFbUlDNFZVS09PalJyODFyQk9HQ2cvR3dtQXNQTXJQc0IreGp3RUFLblJxajdyTGYxWnMxTjNBMFFvUDhWbno3bTUxc0tOSC9mbEZaNmxMejU1QWQzQ0owRlJUcXZ1djJCNTc2WUp6MUtwWStEdlVjVnE5dHZXQTU4NE9VdmRKdC9oSldJdTliOWloVHQ4OTVqNVY2THRGKzY0eGZzYUo2RENvNU9mV0RzVWU5Ulh0VGdDQUFGNkI4dm9PZlQ2M2w0YXJZRTlPT1BZY2ZyWHVQZldSQzFyVXFnVlRkSGZ3eHZiVGFzK0pNNnFqZDBoRktGcE5BUFNhdXJwYU5XbmNHRDNoUThiOFNiZnZ1d2VPcTFkajRTOGM4Y2dPSzJGTnVuaUhCdUxkdlRyMFdlSFBuQTNtT09YRzN4cnk1eG1KUVRCcUJrRzVrNVFRS0NjVGd3Wm53SXVrOWQrYzJHV1k0M3JscGkzRThWclYrVThudXJ4YUw0YkhEMWJ3bkMwaDhMVjNkcXAzOWg1V0Y1eDdsbG9XQzRFZm5UZFpoV2dPTEU4QUROWFVxRzk5WmhWYnlZWEJjRVNkNnUzWEV6NWt6SitudW4xMWQrK2dOZEVqckkvenhPQ1h6MzJqa2ZDUHFObDJxUDhmTmF5bGhhUTdRYnFFWXdIUTBLMkJ0WXIyZk1CYjRVK08wWGo1ajloRlB4cXl4dlhHamxjZEJqbG1xelFGNXZNZGhqa1pKRHlrejltVjFuR3FXNjNadkV1dDRRVjE3WUdiTHMwL0FJclZ6LytCcmVpbkUvMWd2M21RaHd5ejVTL1A0SmNyREpveFVGZVdHZzZlMHNKUVV4K2ZQUXlnMHZlRTRZUnpRc2dLZ1ZFOWhsZVA0NVViTmdtQ2NnUEh6WnV2dzEvaXR4b1JjeDlRSGdpQUtCMjZnSU1rRWpGYjZLVFZ6eHJuVjZyVHVXSC9UM2NQaDNSSkdmMFk3RFBMRE5TUE1pOG9BQ3A0VGdpUE9DZklUZHZ3dUY0SmlFUG1NbUVTQm5RUURLblNuVG5naFJBb0RRTlJxd2VIbTNVQ0lQeHdPcEJ1SFJuYjRXYWNYeEZPUVZHN3BkRWVHeWl0Qy8wUmEyeGdIV09OZ0lxZEZHVDhyeEVmTWhZL2FvMlVTVjdTaWkvZHhITFRWc2VZWHIvSFJuTXlTRlQzM0JqMUJFQy80Z2dPMk1tK25PRXY4WVJpV0hlVk1vQlhsNUN4TGlpUndUNVdGUUVxZHJHM1p2MW5PRjdOaDFrV1NyZjhSYzB4dlpHQlBrK3NHNHNjNS90Q1Q5eXlLQUN2TXdFUUtFb1F0R2NjMjVOUGRBM0NQbDJTQmtDNXJ3QWhGYzNTa21mRTd4dXRtemY3QmxLTzIvNHo1cktROEdiNEs2Q1YxcDdNcDFGeWhRQUk3Z2lMSFFUdHd0S0cxQ09VRUJnbUJBTGxQUmhEam9aZ0pONjgyY2V0dEE1RituczRicjE5eTEzUXQrdnVZRzdPQ1lEd3l3bkJRNmNtdTN0Smp6Y0pzNElJVUExbkVPdTREUm5XVUk2K1dBaVUxa0M2Q2owbnF2SXJCWmowRTF3c0R3b0NJTHg4dCsreGdkdUp0UWp0Y1lHNktDMkFNaDJFTmE3T0MwYlNjUnN5Nndickx1RmV4dlA2TE96cndLOG43dkc2RWdCUjVhOTJTRVZyNjdPTythbllpY1llRnlnbkcra09sbFZFQUpSZVRhMHUvSnpmY1dza2R3bkxEUnhkaHQ2Nnd5N3crL1dQa09vUlR0c1NwYldRY1lOVmdUSXdnUXVCVXRnMVlqYnJLKzhjcEhiWGtoNlBGTEhXRTVaNlpMV2pLRDRMbEpwVjl5K2ZsWUNpMXZyaElSVXhDMHRMUzJEOWFMUEVFNm8vUStyOE54aTdTYWcxeS8rTTNIbk1jN1pNQ0pMeDNOYVNna24xSW10WVVZWUFDRytjNjBOMU9nUWFZUmQzZFpVS2diRUxrMUUzbWhNSFVOSWJ3eHByL2Rkb1hzZHRWRThZa0F0K3hGejVSOHJFMUVVOXNaUVk4YTNBOEtlR2EwRW1oVDc1bUlTKzhKQTVkbHUzL0tuNE5TVWFUbGhwUUZhaE1xeTV4YlcxVnYxWDZnc1NBRkdCYzRLaG9qV3hFM09rVHgvWW5qdGRXYk1OSTNLQ2tmR0FFZ0xyUjFONEZpalpnU2ZIbGp6Q0JSeTMxcytKV01zL1NvMVBmUU0zaXUxYnFaTnBNZGY0MUVzRDFwZ3JoRWlnazhDbnl3QkZWWHdsK0ZCeVhVa3pEMXJMQzFvbGc2SUQ0VmdZSE5EN2l1d2JabEZ4YnZBSmdDanJDVDhxemZJZTZ3b2VibEdJdHllWWQ1ZHl2aUFFQWlWakxmNVdVR2F3MXhsWFVZWnkrQ1VCMmo5QnVuWjE3Y2RvTkQ0cjJJZ3ZMaEN5WHQ2RVZyK29mV05nRFMrd1dnZWo4VUFvNWI4aWV2eXBVVnRQRUNRQW9xeENkYkdETDZKTHNIZzVCTW96aTBnSUhBeVpJUkJBMFc4STlmamd5R0RCQS9nWnlsRkJNZ1pUaHpPcjg3WlloYnAxbFFZMVhBNUdyeDF0ZlR3aDlCbnBrbVBTSjQzNE90T0d2VDY4akMrVWExQnRuVGxrZ0s1aEFpREtjZEkzOUt4Z05kUnZoVUR2M2I5R3JaVUhkR3VnZEFmTCszUXBBVVUvRjVqMVhJcDM3Q2FGUUt1MGt6NTJhY1V2RHVsbXQ4ZHgyK3VzeXd4c0NYM0djUENTbWRyRnVVZVE4QllhZm9YVGhiNXMrMFBpdmhZUGxWWUl0SWI3U0JBMDdEWGl1VmtnQUtMMGQvNHl1MHRPSm9ZSHArNG5oa0JEdWcwU3h4VnhnZ0NLRkNhaWVqQi9NWHNDMG83bmxRL1ZON0M5bmI4dzhaZkVISE1YVGg1VEo2OVovTHh0ZGVISGczeFUxMmtzMm10cG5ZdWRoajZuUDg5OHZzTUJWc1lJcXRvSTUzZ0NJTXJDQ29ERnZnQVVPd1RxVmtBNVNVaVhrbTRKckZkZVd0MEU4RVVRTE9KRmQ4UlFqaUZ6SW9GUlc4ZXhtMm43NjdkbVNSMWx0ZkRwaityd0YwbjZXbk1NbnJXdDdiQ1hGTktLdTQyTC9Zb045eEliVnFkMXlHb050TWFPMG1KTUFFU3BFNWJNQ3E0elR5Z2VMZUlhdjVBa3RpYll0YVVBRk9VOFVJb1dsNHl0K0RMOEpPZ3RQSFo1Rlh0aWhaUlVzWU5nWkNocFBLYVJ1SzNzbGpQRFNBcFJwUTVzcFQ2L0cxYTNzSG1qUHpBOGRqUkVDQ1FBb29SSG9Ea3IyT3dLam5qNkpHRzNCT283WWdJZ1VKUWdVc3IxWHBPTzNVaGlpWmo2QUxYd1JPTmRzMUc3ZkVvNGJOWFFpOGE3ZHUwTlpwWlZDWTFvSlV2NGdxb0tlVTcyRVpXd24raUo1THJjVEZTRlpOZ0FJWkFBaUJLU01GV2ttWUFsdjFQVWJRa0FpcE5OU3I5OFYvellqVThNQ1VBM256MWV6eDVqcWNlNWhkTzM3aGtKM2JqS0dGbFdSZmtyOE9VK3h5dXp4eWQyUFlvT0d1YllVY1lFRWdCUnVrTnZ1QlhRZTZWaGtwNHA1d0dnS2kvdVNSTkQ3Qkl4ZnF2eEtlVlk1SzB1Y1JJWkhyOFhUWmlvWVhmajJ0c2t6WW5OQ1BCK01yekVvTlNDSGRMRGZoZzJRQUJFU1krOGtEa2VVTmVRQ252MzVCQy91d1pRS09tRzFFTS95bkJ4VFpvWUlrRlF4dk5LVjJjMUY0dU96MksxSm0xWU01N05pWFVKNC9lUzZ1Y2xCejVpVGJxYkJiM1JKRkdyaUYxVXZJNWFzQVJBbEU1SVptTFZtQmNFUWhiZ2I3cExNbHpXQUpMVXdpTTl3dnJpYmxSZkM0ODFkbEszVUVuWUN3L0VvMXhTSzE5OC9KNy94dTZWWTJleEIvM29ZQjJxTlZjTkFRRVFKVHJpWWdlWmRGMTR0aXRZcjF6QUJCQ2c0QXd6WkxYK0pVNDRLRnNJdEMvdXl1d09sdWVnZXlDOEgveWt0VStQWXd5SEU1WkdDeVcxN3RIS1Y3eWJoZmdFb29GZVpZd2VSMWN3QVJDbERGamU3UXFPM1F2S2laYTdRS0RBSUdPTlQ2dlF4VFRwNHE1Ynl6dytEdEJldWt6Q3FpNlpaYmZ3aGF3cU90YjZ1N1R5bFdRLzBST0lySm5VYkYwQ0lFcEpkd1hYV3V0SmVxY1ZVTVlOS2VrcUFsRFlzU1NGbVdYU1YxS0prUXBkM0pXSHcxL1VYTTVPYnkvcmZHam8wR2NrcllkTEpDbnRmaEsvVWRFRnk5a21CRUNVOXBDcnFUWHZ0WFRKQm84OEo5M05RazBvb0dEMjJEOVBYRXc5T05URVhxTldhdlZaUFNHR1ZhN0ZTQ2ljVFJZcGI4TUUzYjhFUUpRcGNFV3Q4WFplNkFxV2xnSzlkakdBd280bFhZQTQ3SzFycVpjbW5VbXIzMkQvOEJyR3l1emlIYkVDQjhwNE9aS2hQL1UwQUJBQVViNDdycHJZZWJuT3FnOVl5Uk8wT1RtRnlSOUE0ZUZHU1YwMU9aN0xQUG1qT2piUGtJb09tT1A4Q0g0ZWVVM2tPaVRqMG1rQUlBQ2l6R29rZE1YdXZDcllGU3hqLzZKTS9BQUtQNWJzc1d4ZWF2N1RLeEY1b0dWSHp6VHQwMTIrb1lUZ1o5MkNvcHo3cWQ3Mk5XWWpCSlVmQ0lDb0ZLdnIxUmlzeUZyQjhhNWZtdjZCUW84bWEreWZOWkhCUStlWWlrZXNxQlFjN3RYRFhXajFxMkRvMDcwOU5XWTFDdjNXQS9zR0FSREJ6b0N4UzBhdDJRcFk5cTVnM2ZYTDdnb1VmSUVkSERBRG9PY0cwa2U5c1czQ1ExYjRDM2x3WnUvSWhZR2o2VDVudFp4SnI0a09zekxlczJwQ1g0M1Y4c2RrRHdJZ3ZFVkNXRTFFcjNGWnJnSGI4YkVmbkF5QXdvNGxXYTFDeHY1SmJQQmE2MStGVy9mMU1tNng4MXJJTStIUE1FdGVqZGd1aGhvNWRkdlFSYldUZ3FEdVRqZmlheEo3THU1YkxYem1jNjJSOW1oQ0h3RVFucitJaE9yTUJkejFPcGNsRG9GMC9RTEZPbkoxK0ROcjJIbnNJbXZPdEtqc3hUKytta2Q1YS9vbGoyMUxyQ0J0VldDSWJ4TWplWHM1ZllZVmJsaU4yczlmL3kwMUtYOWJLSDZlQndFUTFVQkNtYlRJU2RkQ0tWc0I3ZkJIMXk5UWNQZ3p1MzZIdkRtdUxlb2kwSlFzZzFvQnRNamhMNW80ZnMzdTJrd0llbEdqSnQ1YVY3SndYYzR3YS85U1F5WFZiR1VTQndFUXZnbUJJVE9jUlFaTEZnS2o5bkowM0IwQ2hSMUw0YkN1YVJleWxpdnpWT2svT3lSVitqalhYYi9GU1Z4SnJWNEpyWHVWR2R0bWxPUm5qbmpOOVB1MUNYKzd3ZVFOQWlCOHkxb3JXSldnSzVoWnYwQ3hEcVpJZk55ZmQ5ZmE5VUFBdExvbERmdHNKczlIaHJyb0c5eG96dk9WN3Q2MHYwK1BhVk0rWGJWSWVvQnFySUw4cVFHUTh6VUJFTUZnZHdYckF0R1I0azBLMFNmUVFndCtSb2ZQMmQ1WjZ3b29lL2lUbGovZDlXc3RvZVhKSThFTExVWHlIR3JycmRPR0VRK0E2YXNlSkxTQVdTRXZhcmYwZVMwRUZUbFlteTIyRE0waEFBSzZtN2JlWENjekdyWkNZTFNBYm1HejVTKy9ybDhyOU1sRlQxb2w3ZWRRVXh1N09hOGhCQ0pnNGM5YXh6YjJzQXNhZS9NSXNGYjQ4VUFYc0hSaGpvdzdPVUtmNTF1OWlyMWRwZGRud0ZxVGx4WS9BaUNDTFdUV20xTFJXcXZMSkdLV1ZOQ3o2dHlFUVVPdjlLRURwZE9MZ2Z4cytYM3liL21kVXNVL0VndC80YkIxOHJZdWVxRWE4aCtDbGY4aVlUM3hJNzZhaFdmemllR05GVUF5aEoxNGQ3Q2VyRkdydXorcjdXUVMxZWZCYUxGK21HNVJqc3FpQUhYMTNGZ1RBSUhoR1hSUlZhTmIzWFFZbEl1UUJESzd4SUlkMnRLRlAwZjEvdXhXdnFoNWFoNGFOQmUxdHdOZy9LbFlkK2xXUU5Sdm1Vd0MxeGU3aEJzTWV5eFk0djRyWThhc21uRm1sNkh5eG41bWovdUxId3VzWnBIM2VTMTJUakpuc0pad3BtNnBBM2I4ZHJnNG0wVC9zTUYrZmM0MldKNlRBQWlrQzRUUm1wQTVXVVMzREliTmxrRTdxQ1dla3VMaEw1VGhJaHkxZ21SVUJ6NVp5OVJJR05zWHY4aFpZNG5pbnpPaUtxSmJRbnBqZS9zb3VvTGhuTFFtRC9Yck1YVFJhRFJoS0duQy9oT3FpWGNMR2xhTk15TitFMk5VWnZ5cEhDTXk3aytLLzNwNTNKOTFCb2dxRDg4VU5ReHJzbHRWMzhVa3BMYmk1RC9kL2Eyc0JRSGlTN1dCQUFoa09KRW1EUnpXTlFUREtsNFFOTEUrbE4zQ0lpMHYwc0lud1U4V3JrOVlnemdVR2k0Z2FxUzhUYjVSTmN3dTZmQ1FMb1VoSjNQZGJVRTlLbVM5WmtaVXBMOG52bVJheGk1VVBkd2hhbDFtelpib2FNaHFrZGF0ZzJaTHRDRkxLTVp2U2tvWUN2VzRQek8weWpGaVZFUExYMDB0QWFMa04rT3F1SVVhREhOd2pUNC82ekhXZFd4bUFpRGdrQzZUVUpOMElkVXRMdkVKSEpHazdsc2pQdmc2ZStCTG56MGxMRWFHQjhYTGpNallCZG04S0hQaHdjZ1FGZW5yMGZ0ZUtHTUxtbmxGMVcwcjBXaThuU1hlWmF3L0ZvN1BLTld0aUhJN0lqY2dWcGtRUFRrcE1SQVdJUmpxL1h2QURuK2g2bWpyWmlKQmVVSmdzWCthWWZhdzZIMU96dEUxbE8waUFBTE9MbFhteFZLNlo2UG1FbFhSZU9pekxwdFdPRXZ1eG5KWHFWOWZwZzByQkZvMXZYVElIT3pUUVRNMHFvR1RGdExzTjFHcjVTL2JtckFKQlcvVjhQaFdNeFRHSTZFVkJpMHlmQ0h4S0RETUdiRDJQbTYya01kK3Q1NFY2KzdDclZ0all2dTFFVExpeTVsVlJmampKcXowNTlwU3ZYelNzNk43VjRiaTR3RjFheUE5TEFSQVlBUUpmTEllcVE1aVVUMmJMUFVlMVVqVHZWdklQZXp3R3VuMldDT3JsU2IydXlPOTNXWnJZUDFvWGh0WVFhcGZ0OHpwSU9XMlhjVklYc3RWL3orMWhUQWxGSm9YVVB1OWZuTWlsZFdsWnRnQlNZNkYycnFNUjRFZUZ6dllxejhicXFKSkgyYnRQQUpnNlRhd09XWmFKdU1WZXpNYjFnMk1QbDlIek1vUFpoQ1VzYWZtOG5hRVFRSWdBbnZ5c2JyQzVLUXdORGc4aGsrL1RXakp5OUt0VzBqd1MzdXh0bVpyR3RHUWZtNVJlOHhVN09RVkdqV0cxZ2dVUEdNOFl5aE12SmxKQ0lWRzJsQTRhTFVtRHErUVlkODR4YnZhckJZWGZkRWQ2Tk0veCt1VFBwSTJzOTRRVENBbzVYNGM2VDlqaHI5UWFTYmF4TS9iSWV0OGFwLzNoeUxtall4TTFwUDlWWVkrTUZ1WUFJZ3NGNTAwNGFmcS9nd1p2MmZOOU5VemZ1MnUzc1J1WFQwNFhnMi9uOUxIVnVvdEVMOXp0U3Y5eTkxcjdJSXJnLzdORUVpWGNOQ1B4VkpjTGcyM29kQXdrbHNOdzBQVzA0dkVmMkxVWHE1TW1lSFBxS3B5THdiaHIwVDdyMTBBWEUrZUM1VjJuMGc4bnhyUjRYR3gwZmh3bXdHekVVQnVXR3JybURCQ0FFVHlBV3N1MTZSUDhES0d3ZzVKTmJYZVBrbnFNWHRxZUphdURITlBuTUNoVXNieHBiVDZsU3Z3WmIwWUo5eTlSbUxQWFFiLzZ4Qkl0MFZnNmRobGxIay96QmdLemY4bGppdE1yRWtZalIxM2hyVVBWMTM0bzN4SThjWDJoOGhnbjFrQ1NKOTNqYkxVZ1RSUzkyRTdETXIxd2JDRzNBelpYY1FENWxqQjJqcHV0Z21BaUljcGEvV01hTUxkdlQyV0luN0MxQWQxQlUrY2RyZXVMczlpdGZCWjRTL3hSSkJwSEYrbEFsL091OWZZZjNveEUxMys0NHdlRThpZGFuQWpZQ2tIenJzTGhmWXFEaW8raGlFcEZLcVVZUlRWY3JxVC80d3FMYXpzeVExcXQvb05XcVdMVlB5bW9Oem5YUHQzbWEyQ3Nxc2FPZ1RHV3dYRFpta3ZlYjY2a1VQR1lIUERUUUFNOUFVbmRqSzBhOXRGRSs3dTVaR1Fxc3dMVTZqT0hOTmhGNTR0OFhxVWVqeFN4T3gyMHQwS2RtQ05SdVAxb014cmtPSDV3SmZ4aEdWWTI5ZXFOeGdkNkZXcUxwcDE0RDE4U282blNMU2lJVEJqSUV3TmhWVnlqR1U2NTlFQ1dJeDc4dkJ3NFc5VnZsWS94L3R0dk15UmtWQ0pJV28rYjJsRWtGNGpYWmFMRmtFQ1lGQWpZR0xKaWZpZ2NQdGVXUTNYeEZQbUxNWGhRR2pPcERNU1d3bmx6aS9mT3lxN2pwazlqcytheEJHL0dObzErZFJ3dDI3OEhGNUZvUy9qQ1NzVUdoNFhPTkJuL24yMXRBUUc2NndZZTcySElna3IxbmgwWDYzeUcxN3ZydjliUmVGUHovN3UxK2RvK3hwaWx3QXl2TGkvMnNIVTdoNjJLekxvSVZDRFp2a2pYVXFHYUVJQURFejZzMCtLdzkwNXcwdUtHc2tEd3RYd0FOdDRuVEU1Q1lRVEQ3Q1F1V2k1a2RCZGJLOVpxc2MzaFpJQ24xbC9UNWIxQ1NmOU85NnRteml1bzBwYitkeTlGTmJpOU5aU1lEcm8wa1VSb09NeFpKWW5pUjBIUmpUSzlpaCtiSWt2bjRjODZYSmE1anJvc3RKUnZMdlg0ME1CMG5ZUDJ5SFFYcTFKZXB4b0VTUUFCaW9CR2xudThPMUFtUEIrK2pJUzFzazFQZ05YbWVOc3JKbTIwWkRWY2hkZnExU1pzN1BDWWF0TE56TDhkT3pRYVArK2xPZHArUHZWU0FpQllmTWtTM2RWc0VoTGhCNE9NTVMyS0hyOHM4Y3pjenpsRlo3bFJsMVA5QmlLTDFPWXZXQzVkNFBnaUxKYytrKzBDdlhMaWswMWRjblhLeEFBZlJ3N25IODJNUlFtemhoVTBUUmR4MUh6UGV0YXBnTmYvSHdTMWQrb0kxNG9GQTk2aHFGS1ZvK3Zxa0tnWGVrK1JMZEVzQTdIa0Y3ajFHd0ZqTEE5aW5xelM0dDZYcXliMGZoRUQzdm1kNVZOQUVwM3JrMHVJMk1NcndNdjE2cmFzTmtpeUUwNEFSRFpRcUUxT0R6ZGJNSGhPaExKUzFQcEdsR2grUGVVc3g1ZmRZVEFrTmt0THQwU2xLMElGajBlU1ZwY0J1Z0tMcEtvZGJHbmE4L2RWaHZSNmxjbFhiNnVyMlgyK01YRVF2M1dHRWNabTJ1dTM4NitRd0JFN2xDWXBvU0Uvbi9TeFN3WTNib0ZOVmhJOTdrMU8xalB2RVp3THIzUzhxdHZBQkltUXFIQVk0b0x1T1A5ejVvbGE3YjZEZm1tMVMvWE5TeXhVUC93K3UzOTV2dDFvOWlIQ0lCKzIrdU5raDFNSTA0cVBweThVZHBBTGY4M0J5bkhaMXNqTU1lbFhwZFh1b0lUNmwyaWdQTWMzYjhPa3A4MWx0dkhyWDZPcmx2eGxhS3N5Z3d5V3poMkxJYnFHd2lCQkVCZjN2dVU3K0NDdTVmRnJGdkFCZ3pjNnkremdpVUVEbHJqQVFtQkJRVkFMdHpaUmF3WnNWTHVLeG9PUkt0ZjFtdVZQYVRKWHJGcGFGQkZZbTladHJOd2JEM3YzZlBBazYrT3dmQy9JS3VwVmRIYXVsZ1FwQVU0WDlMekVHVWNiWTd3RjlZckVVVUh6dWlialpBc0VCRFE4RGN5Q0pxem5mV0NDZGF5bmZZQ0JTQUFBbVdJNXJUK0JQZHNHUXVCTmZXRXdFS09wQkNkVHVuVHNibVVteGxxaHN5Q3pxRlFGYTd4WE5yenNOa0Rib1pBQ2NpUnZ1N2g4bVVnQUZiOUhUS2JvUnBTSUFKN3hxeFIwZHBSWmtzV25KL2I3SU9JTHJ1Ukl1YjY0MUZaZ3p5MnBTVGNoRUswK21VOEZTZXNjNnpMU012eXBNelN6d3UzWXdRTU9EM3JsSGpOWlZUTHZoQ0toY0I2cGNLRzJWckR4Y2Z4RFM0U040Z1pYdUt6V3hNbWVyQ2xIRnd1NDZzMURWQ25sUUJZN1h0MGpSa3d3alJuZTVKTUFxRDdDcWtoTUZKcjFvaWtZSFRPN2FWcVdGTTdUbHI5OUF6ZlFiTnJNMlFFWm9adlVVT2dYYWRWeXVYVXNMb01BYkJxOTJacmZFelUyNHZRQi9KR1hicjk1TFdoQlFPcGx5RFpOd3hqK0xqVmc5SlpRemo5K1kxdTgzaXJuOVQxa3htK1N0SHFWK0FoYUhVRVU2R0JBRmpsNUdJU3RRclBjZ0h4eE5sRkJ2ekx3SC9kM1FDazNVMUNaa3VFYnNXUG1KY2pIUWJ0Rzdsb29BTmhWRzhScnN4NktiZkJBWE5sR2FYaXBWMW85U3NvLzVINkNJQitDb0cxK203R2tJR3RxT3lGUzBwLzZJWElDWDl3Y2pVeTlGQU9IZldzTURpOE0wV0d2MGJDb0l3ZERFcEx2L3pOQVIrZnBkZTFsYnArRWF2Vno3Q0xPaE5mQ3I5bWhzejlpeDZheWdUQS8rK3oxN0lsQVFBQXl1Q3YvK05WYndSQThUOGYvZ1d2aUkvOSszMjNxbnQrdnBVTjRXT1Bmbkl4eHpISE1UaU9VUVhIY1RIUXR3VUFBQkF3QkVBQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBQ0lBQUFBQWlBU0hUVDNNbjZBUUFBVUsxcTJRVHBYVFpqbkZvK1o3STZaL0pZdGF4bG1tcWVNVkdOSFYyWDlEVTlmWU5xNzVFdXRhTzlVNzEzcUZOdGFEdXAzajdTemNZREFBQUV3R29oTFh1ZnVPaHNkZkZjTS9EbElvRnd5WnlwK25HcjlURUpoQnYzSEZQUHZYTlFQYi9uSkJzVkFBQVFBTDFtenJoNmRlK1ZMZXJHWlhQVXRJbGpDdjU1RWh6bGNldmw4M1FZZk80UCs5UVRyUWRVVy9jQWV4c0FwRHNQTjlTb0x5NmRsUFByTmgvcEcvR3hKL2ZRNitMMWEreGpkNjlRcmJ1UHFjMEhPOVFUV3o1Z294QUF2Ukg4YnJ0aTNvaXUzV0tSSUhqL1RSZXB2L2pvWXZYTVc3dlVJMnQzRXdTQlBNaVFqSCs0N1pLa2o4a0ZKWjM5SjN0VTU1bVJ4eGtYSHUrNmNtYUR1dnV5NlhsOTcrcVU5N2UwOThUL3ZmTm9uenJWSDA0S2p6czdCOVNHazV5SHkrWG14V2ZGZThyRXQvc0cxYnY3anF2dDdaM3F0UjFIc3ZhVTNiWGtMRFZueWxnMXNhRmVuZGZVcU1ZMTFPbnJkYTRldWkxdHgrUC9QdHpSbzlwUG5qSDNnVmdBM1hHc202RmFRUTZBRDE3ZG9rTlpxWUpmS3ZrOWQ2OWNwRnNaZi9qU1Z2WHdodjNzZVlBTEM2YU5pMTlBYktudnV3MEtxUmNLMGQwN3FDOU1pZVNpa1dqTnZwUGN5QlhaaFROR0YrMW5MV2thbS9iZnFYb0d3bXJ2Y1RNVXRoN29pWWZFanI2d2VxRzlseGVsU002ZjFUamllcmhpNFV6OWtPdWlqS1YvNi8xMnRlMlFlZHd0aW4zOXZKbU5qb1poWmR3SEVzNE5tYzRUNjk4L3JJLzFaelllQ0d3Z0RGUUF0SnVpM1Y0NGlrVzZtTDk1MjZWcTFaSlo2cjZuVzdtSUFFNER3dG1UU3ZKejA1MEw1TUxrUnFiV2hseXRHeGgyM3ZTR3N2L09zZlUxOFlDWUxpamFBZkdEVTRQcVVOY0E0VEJQTXFZK1Z3UEpxcVZ6OUtPY0VrUG9TNXZhMUZQcjl3YnVlQTFNQUpRSkhvOTg3c05sYS9YTHRlTzk4S1dWNnU5K3RvRUxCT0JBMCtReG5uMXVtVm9iVWxzT2tWbkwxTkdlZTA1MlFGelNOUEp6RWd5UG5CNVVmL2FyQTd4NE9SVFNrbGN1ZGdEOXhicGQ2aDllZWo4d2pUT0JxQU1vWGI2UGZlRWFUNFEvbTdRR1NpQ2xwaUNRMjh4Slk5a0lQalp0ZkYxVlBkL21XR0JkMFR5ZUZ5NEhHY05YVFdUeTV0UDNmQ1F3MTJYZkIwQUpmeklSdzRza2tCSUNBWCswSXFRNmVZWWhIazdjTVhkY1ZUN3Z4TWttU0s5VVF6ZEtmYTRKeW5YWjExM0E4Z0lXR3Y1NkVtWXNKYzR1YkJ4VHI0dEV5OHlrQzg2ZG1uZnJvaDBDMVUvZXBEc1lTRVBHN25xcDlkNHBqbWVISVdIRzZLcDgzakxER05uSjliRWEyZGZsNHo5NDFkY1RSSHdiQU9XaW9ZTlZIbzUxblZGdmJHMTNWY3paTGlMOWtjVk5ydXNKeXM3MnJWc3VWbHNlZllPSklVQ0txODZsaGR6UFprMnNyOHJuYlplWFFXYlNPRkt0NUxyODBKMlhxY3RXdit6YjE4ZTNYY0F5MjlkdHE0RUV2NGVlZjBlZC8vY3ZxaS84Y3JPck8zajVXdmtlK1Y3NUdmS3ozSkJtNSsvZWZBRm5EQ0JGTlhZalNjOEJuUEhpQkJBbjBoV2x4akNwM1ZtTkxmZXAxK1h2MzdESXQ2K1JMMXNBNVFWelcrcmw4VmUycVMrL3VLMG92Lzg3cisvV0Qza2VNc1hjS1ptRmROZm1ReFNzQlJLTWI2aStpNGlzQWdSbkhubnJxRHEzc1U1TkdGV1Q5SEY1Zi83MDVIQ1lyYTVmdWJFQ1NYYkw1MHd1K1RHMjYzQ25PdDA3cUNkdmxJcGN3LzFhSzlCM0FWQzZmbVYxRDZla3BhNVU1VmdrVUVvdHNPOTllcm5qYnVHdi91blNXQUI4a2JNSFlEbDRza2VYWjFpUU1wNW9SdU9Zb2l6ZmlPb01Vc3NuMTZ2NWpXYjM4YVRSTldyMlJQTkdRYnFVejVwZy9sdG02MG81bDJJN2Rwb1czbHhrakh3cDNXNE5tYnB2K1RucVZnZGZMNjN5K2JaSTNuYnhiUFYya1JxSUNJQWxKTXU3T1gyUjVRN2k5aEtQdTVOZ3VlVmZYdEZUeTUzTVpKUUxtc3hjbGhaRUFNclZzWkJhZHNKZVJpclJzcFpwSlErU3NxSUlTa3VXYzNPenBKczkyOWh1YlV4c1lYVGJzcmo3T04yL3VhUWVaMDZ2eVU2dWs3S0toMzNkWGpIUDJlKzU5eWR2NnJjUGZHeUo2eDVDV2NYcnl3UkFiM1BUK2ljdGY3ZVhhZEtGL0E3NVhWTDgyY21GNXROWHppY0FBbmx3Tm54aVc4N3pTT3JFazlSeGlQYTZwRGE1YUNYZWVLWXVKNGZLYzlMU2VHTlRnMjVOdEdjbTI2MkpNOGJYSjlVcTNINlUxVUJ5Y1ZxNlNWYlNlV1hMSWZWRTZ3SDF0VlVMSFgzZmh0MUg0LzllMnB3N0FFcnJuOTNMOS93UDFyZ3VEeWZYYlpubzZiZVovYjRLZ0c1YS82VGJ0NXd6YnVWM3llK1VndFJPZGpaYUFZSEtrR04xUkpCa1hHNGcyTXU4WlFxTGRyZnoyc01Fd0d5Y1RnQ1JKZGp1ZUtvMS9uNnVaZVBpTjNxdEIrSy94MG1qaXF3MW5NaSt0cm9KZ2Rjc21PRzdBT2lyV2NEU1RPdUVUUGlveEFzcHYxTit0eE1ybDh6aUxBSUFIaUpkemhJTzIzb3BBWlBOZ21uT2ludmI2MmJiWWM1dDkrK3FoVE1jL1o1dGgwYTJ5RXNJZEhvOUZ0VmEwekFRQVZDYVo1M2NDVWpYYnlYNzh1VjNPeWtSSTJNVTVJQUFBS0NhT0MzZGxMaGV0dE13bDlqOXUyaVdzMUQyMHZ0SENyb2VpeG1UL0RmaHpEY0JVSW93Ty9HenRUc3IvbHlkUGdlWmVRUUFRRFZwbXV3c0xLM1pOOXdUdDd4bHVxUHZzYnQveGJ5WnVRT2dCTHhzSlZ5Y1hvK3JjVG5Ld0FSQUoyTUhaQ0NvRjhiVnlYTndVaWcybjFsVUFBQlUwc3hKem1aVko0N0RkN0pxaU13U3RyOUhKbXM1Q1dXYjloN0xlVDEyeW0rOWNyNllCT0owUjBnZENGcEo4bHlrOEhNMmJxZXFvMFQ3VjBPTnVuSm1ROWF2eVhjOTA2K3NPODRHQnVBclRxN0hNdnZYSmtPNG5Fd2EyYmhuT013NVhTSXkzZmkvZE1IU3lYT1dzWTErS2dqdGl3QjQ4K0t6SEgzZCtsM0hQUE9jNWJua0NvQkM2cHF4TWtoeGdsdHFTRHR2ZW9NYU55cTVFYnpjS3cwUUFJSEMyS1ZiUkdKQmFOdXkyZW1QYWJmSCtnUFA3bWYxRDRmY0ZseStlTGF6TVlQdkpZUTVwK01NTng3b3lQazFSenJPK0xLTE54QUIwR25GOFljMzdQZk1jNWJuOHMzYkxzMzVkWG9uSndDT0NIV1pLdituMXVzQ1VIM3NjaXVKeDNuaURWc2xsb1NURzBnQ1lHN1NtdWRFNis3aEJobW5rem1lM1RwOExYUXlLemV4L2w4MlVyZHp4Y0taZ2JzZSt5SUFPdGtSRXB1YnZVS2VVNjV1WGo5T1BTK0VoTC9WTjUvanE5WUx1L1lZRUdUL2RzME1kZjNpeHBJczNZYnltVHltM3ZYM09Kbk1rVGorVDkvc081aVZ5NXJjMmZsaUVvaVRIV0dIQnl2ek8zbE9mcHg2WG9pZG5RTysrbnZzcmlzZzZHUlpOaStIUDJtQlJHNnkvS0piVHJwZkU4Zi9PZjJleEZaRytEUUFPdGtSVG50d2JVNG56eW1JNHhLeWNiUDJaeldRZFVrQnhHN3VqbnA3ZmQzVThjSklMM1h0N1V6c0dvRFNaZXlrS3NiQmt6M3hmNmV1K1oxSlYrK0FxK2NTTkxWQitVTzkrQUlIZGFjcjFMSFRnNzRaNXljTDBnTlE2bFMvdDFmWGFKNDZtaGVwQkdTTTN2UGZlazZYV0pGaTBESWVVTHFFVXhzL25Fem1TTlYyb29jTlRBQ0VueHc1UGNCRUQ4Qm5EblFOZXZyNU1UYXh0S1M4U21LSkZTbnZKaFUrWkpLbjFNUk5uTXdobFRIV2ZQdlh1aFNNVE15UXo2Y2JUMDhGRFFLZzVzWFpPMDZuc1NOWmQzL0VOMytMTGxGQktSaEFkZlI1ZjMxZEptM2w1blFWa0Z4a3dzZHc1WTV0YVQrdkE1NitycHVmbCs3a2F4Yk0wSk1ueHpYUVNCQ0lBT2hrTm0yeGRzcGlHdTlnQi9YaTdPVksyMzYwVjYxb0hzK0dBSHhrN1dIdkJ5c21iZVhtZEJXUVV0RGR5UTdLdnNEa2kxR3RoenR5OS9NN21XWmViazZXcjNQeXQ2RjZTZDFDQUVxMTlYcS9CVERmRlg4QUwvSkZDMkQ3eVRNNXYwWUdsTXFZZ3NRNlFwWGtkUGs2SjM5YjBHdytVdHJaZ2pMSlJNWVpwbW85MEZQUjV3WDQzZDdqZlFWTnR0alMzcFAxbUpXSkp2czYwNDgxbEJKVGZxc3lVQW5kdllOc0JBSmdHUU9CdzltME1xRFVLNnVCT0YyKzdyVWRSOWhMWGVvWkNPc0xTYWFMUUdKUWszRkhqT2tCdkhQc1pqcVdwVXlNUFZQWVBvWTVmcjNINmFvYStkUUxMSldnanNmM1JRQ1VnYUNySFh6ZGlublRQQk1BNWJua1BCazZYTVltYUdTczBPTnZIK1ZDQVBqTVA2ODlxc2ZaeVRGZURWM0N5Si9UNWQ5QUFNeHAvZnVIYzk1MXJGbzZSODE1OXQyS2R3Tkw5Njg4bDF6ZTNjY0VrSFRrd3ZBVlpzNEN2c05OWEhBc2JaN21tZWNpWldTQ3lEZWx6YmM3WE9ydDNpdGJLdjVjblQ2SERidVBjcFlBQUZRTnAwT3lwazBjb3g2OHV2TFhZMm1ReVZWRnhPM2ZSZ0FzczJjMkhuRDBkYmRkTVUrLzRKWGMyZVE1NUNMZHYwKzBIbEFBQUZTTE5mdWNEMXY2aTQ4dXJ1ajFXTnkxYkhaSi9qWUNZQmxKQlhIcEJzNWw3T2c2OWQyYkw2alk4NVRmTGM4aGw3ZmViL2ZNakdVQXptL3daSjNTeEFjUUpITGRPdGJsckhxRlhBdWZ2dWNqZWhtNFNoMnZuNzV5dnFPdmxiL0piOWRrWDYwRThuODM3SFUwKzBqRzM5MjM2MWpaSjRUY3Qvd2NSMlAveEZQcjkzSW1BVXBNVmc2WVBHWmtDMFM2V1lIcFZoZHcwblcwWS9YdmtwYTRncmN0bjF5djVqYzZiNVdpZk14SW0vWWVjM3l0azNKby8vbFgxNnBuM3RxbEhsbTd1NndoNitIYmwrbXVhS2QvazkvNEtnREtiT0N2eGxLNmt4ZjBiejkra2RwenZMdHNzMnpsUWlPLzB3bFovWVBadndneWFSRllNRzI0VmFBeEZ0SmtUZEJzc2kzL0pCY1pKeTN2cFNCL0J3R3crT1kwMUtnclp6YkUzeiszc1U1TkdEVzhVb2Y4ZS83MGtUVUZwZmg2TWRjU2w5cUQxejNkeGd1U1lQMHU1d0ZReUxGNTk4cEZlbmpVYnplMnFUZDNIaTNwT3I3U01uL3ZuNXp2cUJhdmJkdWhUdCs5VHI1YkMvZ2ZmN1ZKcmY3c0ZZNTJ1RWMrOTJHbGZ2Sm15Y09XaEQvNVhVNHZRSSs5dm9NekNBTHR0b3RuNnd1Q0h6U09ZYlVYdDRFdWNjV044NlkzcUhHanpORktVaVI2YkQzTHNYbWQ5SzU5WWRWaXg2MXJpZGZsV3krZnB4K3JyY2FRSGUyZDZuVHZZSHdDaG96RGM5TktLTjI4VjUwN1diZnF5L0tyc2dLWG0rQm44K09ZZk44RlFMbHIrTHlEdFlFVFErREZMMjlWMzNsOWQwbWVqOHh5a29HdVRzUGZTNXZhU25ybkExU0QvU2Y5c3dSaXJwYkxvUHJHSlpQVXRmTW1WSDJvSzJUbEVqOTdvYld0NEpzNHVZN251cGJ2UGRLbEowMm0rOTVpa2ZrRmZoeVRYK3ZISGU5cnoveFJqeWx3RXJya2ErNi82U0sxdkdXNnV1L3AxcUs5eUhMWEllTUxuSXhKdE1sTy9QVm4zK1hNZ2NEclBNT1lLcitUTHRvbFRkVWZqbW1SVEUvRzg5MjRiSTdyVmtEWEFUeVAxankzWkg2Qkg0WDgrRWZKZUpzZnZielYxZmRJVUh2dDcvNUVmZitHUlFYTlNKTHZsWjhoUDh0TitCUC8vT3QzbVBrTHhKejBVUUFNYXBIWlhQeTBkclowWHlPWlhNdGtTRmExazI1b3YvYksxZnAxNTVNdVhWbHFKcCtCcVBLUUpsOHB4UHpTKzBkeUR1Q1cwTGRxNFF6ZGl1ZzI5TmtlZjJXYlo1YXBBeXFOU1ZDb0pqSjJzVzBQRTMxU1NYQ2E4L3c3dXBldEdrbXZuUFFvK2xXdG4zZStPNTVxVmE5TUdwdlhXQUFKY3ZLNC95YXovcy91dzEwalZodVJXWWN0TXljVzNNUXQ0LzYrL09JMnpoYUFENVdqaTZvYXlYcS84RDk3ZkgwMWhrRHBTZlR6RFA1YXYrOThuMzk4dlM0MFdjaEpXQUtlUFBKdDNjc1YvaVNvQWtpMnhlRmtMcStyVlBrWnI1TTF2ZjFDWmkwL1NRdGcxaERZMVR1WTE4emdTbm5vK1hkS05qblVLMEorMy9Ga0hNSmxxMS9XUWN0cmZyRnVGK0VQQ0lCS3JYVGdkVDBEWVRaQ1FNZ1FweHYvNVJVOTNDbmRyRjJ2a0I2L0IvN2pMZCtIUDFFYmxKMVBndGIzVDU3eFJHMHgyZmwvVk1MU000QWZITzdvOFd3TG9MUk9KckpybGRta2pFM2lUR1lLUWFlMzkzaWZMMllDejVwSXJVY25wRUZHaGp2SkRHRlpnN2VRY2ZPbHVDNVhZalVTQW1DWnlJNzMybzRqNmx1M1hGeXhjVGx5NFpCQnBWd1FnT3phVDU0cDZQdmxUdjVJWi9xZmtScllNZ1UzNGJid0xMeExWdTFJWitmUlBuV3EzMWxyNUlHdVFkWFJsL3kxcWU4amR4RFVEU0N4aDVSTXUzbnhXZXI4V1kxcVFWTmpXVy82cEliZ3JzT2RldVdTSUU3Q3JBM2FIeXl6QzU5Zi9iSXUwQ3lMUUpkclBJSmNqSDc0MGxabStnSU9QYlB4UUx6NmZ6b1VUSzkrclFkNlhMVUFTb3VoM1czOHdhbEJkYWhySUdNd2swa21maHBuNk9jd2FGNFhoNitOOWxLUWlXdHlGMUpPS2ZHR3p6Nm5jUDRJWUFDMHlkMkhQRW9kQk9VTzQ3ay83S083RjNCSldzbHBLZmMvdTFVdU1kQWxoamttVndUNDJFOEthVlRLSUFDV0tBaktlcjJmV2RHc2xqWlBLemdNU212ZkcxdmIxWFB2SEtTZUdRQms4SlYxeDVWYWQ1d05BUkFBSzBkM0RWdGhUY0xnTlF0bTZEcC9GNXc3TldjWmg4UTZnVExHa05BSEFBQUlnRlVjQm9VTVVyM3EzTWxKNHhHNmVnZFUyNGtlQm9nREFBQUNvQjlKd05NRFJoazBDZ0FBZkNERUpnQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQUVBQUJBQUJBQUFRQUFBQUJFQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQlFYTFY1ZjJjMHFxS1JvZGhiTmlJQUFFQWdBbUEwRWxiUi9sNUZBZ1FBQUFoSUFKUVdRSVB3QndBQUVKd0FhQmlHVWlHR0VBSUFBQVFtQU1ZU29Ca0NBUUFBVUZVS2FNSXpFdjRQQUFBQS93ZEFraDhBQUVEQUFpQUpFQUFBb0NvVk5BWXdtaEFELy8yK1c5bWFQdmZvSnhlekVYeU80NWpqR0J6SElBQTZTWUhLcmdONHo4KzNzalY5ZnRING53Ly9nZzNoODRzR3h6SEhNYXIvT1A3QkczdllFRDcyVngrWlc1U2ZVM0FkRnlvQkFnQUFWSmNDQXlEakFBRUFBSUlWQU1sL0FBQUFBUXVBQUFBQUNGb0FwQWtRQUFDZzJoUTJDN2kyVHFrd0lSQUFBQ0E0QVRCVXE2SUd2Y2dBQUFEVnBQRDBSZ0FFQUFBSVdBQUVBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBQUlBQUlBQUNBQUFBQUlnQUFCQWtOV3lDVXBuVGtPTnVuSm1RMTdmMjlFWFZpKzA5N0lSQVFDQmRzOEZqZXB3OTVCNnMvMk1PdEVmWVlNUUFBdXpmSEs5bXQ5WW4vU3hDMmVNSHZGMUUwYlZxUG5UUjZmOUdjMVRSNnV4OVRVbGVYNWIybnZVQzArM3NZZFdLcnlQcTFkWG5UdFpQYkhsQXpaR2xicXhxWUdiS0tES3RVeW9VNSs4WUxMKzk3Mnh4NEhPZnJYMVNKLzZvSHRRclQvY3EzYWZHbVFqRVFCTjM3aGtranA3UXYySTBMYWthU3l2Tm5LNmFlNWs5WmtWemVxS2hVMzYvVFg3ZnF2YXVnZllNRlhvbno1MnRucDRWRWl0MjNOYXJkL2ZveDdaMnNWR0Fhck1kWE9TcjkyekcwZnBoN2c3OWpqUk02VDJkL1NyUGJISE16dE8wVUlZNUFCNDdid0p2Z2g3TThiWHMzZVcwWU5YdDZoUFhIcXVhcDR4TWVuamR5MmJyYjd6K200MlVKVzVkL0ZFTlcxOG5Ya0JXZGlvSDM5enpWbUVRYURLTEorZC9YbytaV3l0Zmx4ODlsajErN1llQW1DUUErRE9vMzIrQ0lEMnhRdWxjOW1NY2VyelY4eFZmM0x4SERWMmRQcnQvZWtyNXhNQXE3SFZZUDZFRVIrVDRScDJHTHpuOHVscTdlNVQ2cmtkcCtnbURxajdscCtqOWh6dlZzL3ZPY25HOENqcC9yVmIrM0xaZUxDSDd1Q2dCOEJUL1dGZVZXUWxyWDBybDh4U1MrWk16UjNFSjQ3UlgwOElyS0lXZzhuMWFrWHorSnczV0xjc25hSWZ4MDRQcW84L3RVZTE5WEx1Q0lydjM3QkkzYjF5a2VycGl3V0duN3hKQ1BUcWpkd2M1NDA1bTQ5d0krY1daV0E4N0k2NTQ5Z0lKYkJvVnFPajhHZVRWa0JVajArZU44SFYxKzgrM2tmNEM1QW5QN05NaHo4aExmK1BmTzdEZXV3dlBIZ3pOOXQ1QUh4eFh6Y2JMT2dCY1BPUlBsNVZaRDlSYkQ3azZ1dnRWa0JVaHhzWFQzTDE5Yi9mZVlxTkZnQXlzLy90Qno2cVZpMmRrL1J4Q1lIZnV1VmkvWGw0aDl2dVg4YitFUUI5WmRMb0dqWkNDVWhwbDJOZFoxeDlqN1FDY29Hb2d2RFgxT0JxL0t4MC96SWh4UCtraGUrRkw2MGNNY25MSmg5LzdPNFZiQ2dQb2Z1WEFPamF6azcvbE95WVBaR0pJS1h5czdVN1hYMjl0QUorYmRWQ05wekhmV0tCdSs3ZkY3WjJzTkU4ckJnM1hUTFpRN3A1NVJqT1JvYUZTUGN3dk1GTjkrL0tsdkhxZ1dWVGRNRm9lZHpjUEU1ZDI5VEFSc3pCZDVOQU5wd3Nid0I4L08yajFoMUk3cTVuQ2FmbGZuNUlUeVoxU0t0ZXJvdENvbHN2bjZlZWUrY2dBOFk5N01vV2R3SHc1OXZwL3ZXeWgyOWZwaTQ0ZDZyYWU2Ukx0ZTQrcHZhZjdGSFBidjNBY1cxT2U3S0hVOUk5L09DaFRpWjlWWkFFdHdWVFJqbnUvaFdKdFFFVGZVMGwxd21VTWpITUZQWnhBQlN5aW9idGc5aUxmYWhyK0dRaHM0VDNkUTd2QUtsTHJ2M1Q1VlBWM1pkTmQvUjcxdTg5cmI2eTdqaDdVWldTVnNEN2I3ckkxZmZJV0tGcjNtc2Y4ZkdteVdQVXpFbnV5Zys5c3VVUUY1b2ljdHY5SzhkdktXL0k3TldHWklVaENacmMvTGtqclg4ckZzN1UvNWJXT1h2aTFqZGpEeG5Dc1dudk1kVis4b3phZkxBajdZbzlkeTA1eTFYNHM4azVZZU9CRG03MHltREtxSkQ2Y05NWU5YL3lLSFh1cEhwMTN2VGl0OW9sMWdtVUZVVWtFTDYyNXhSaDBLOEI4TG9DbGxDN3lrVUx3bjhmWU5hUmwwbWR2d1hUekpuVWM2YU1WUk1iNnZNT2F6WVpLNVJwSEpGYjBxS0I0bkhiL1Z2bzhXdXY5UzFqZFdXNGhyMXNwQlJ4VHcyaTBrTkFBSFJIaXJCbklpMzNpWk01VnNjZW4vL2hhMG1oVFVMaGhhOXN5eXNFZnUvVHk5V1dmM21GVllCS0dQZ3VqUVV5Q1dabGZ3NngzeWxCVUI1cll6ZUJUNzdYR2RnZ1dNc3VtWHpITHV2N092WFRiWFFmVmV6aUVMdTdUd3gxeTFxbTZiY3lvNjlZQWEzVUpJaWllSmFlN1R6VTl3eUUxZC8vTWZ2NFAybFJsSEIzYnFNWjd1eUFKd1dsM1p3bkJCTzY4amdmdDB4My9ucjJEYVp0c2Z2eWk5djBjWlk2OHpjWENaalMvWHp6ajlmeFFoUkladlBLaEk0bE14cEswc0pYaUN1Yngrdkh6OTg5cVI1OXQ1TUFHR1J1Nm9kSjl4RzF3eXJuODFjdmNGWEx6NHZ5YllWRTRUZHZlNC8zNlRxYjBqMHI3SEFuU3JHU0VCTzYzRW5zL25YaXR4c3o5L3JjOFZTcmVudG1vK3NiUS9uOU1vWlFRaVRjdXlOMlBaWEpHVzdHOGxYczJuL0JaRFZqWEozNjlycGc5Y29RQUJPNDZmN2RmcFJwNTBDbDJhMTBkcEJ6U2tMZTZwc0o0RjZWcmZzM0habWNsYzN0ajc2aFh2dTdQOG00NUdNbXQxMHhUNzIyNHdqakFmUFFNbmxVVllRL203UUUzdE05R0tpV1FBS2dmY2ZaNEs1YjUwRFhZTnFWT3BqcFd4NDcyanVydmdXdzJwOS9xWDNqa2tucTJubkpOMlhweHRkVkE2OTFmWG1kbSs1Zm1SQ1NLNkRKV0w1dlBmM2ZhdlZucjNEMVBPd2kwYyt2ZnBrWHhhVWozZFUzcms1YUFvTTBPWVFBYUxsemtic0I1QTllUHl2N1NlbjBvRjVpU2dhYXY3U3ZoMUJZWktkN21jcnZkeCthUGE0azNiR1ZNRzRVTmZjZDM0eTc3UDU5WTJ1N282L0xkMUtJZEIzVEZaekhUZnFKL3FwODNuZWMzeGlZcm1ET1NzcGNjL2ZqTHBlUHlrVmFLV1JCK3Z1dW1xbWUvZXc4OVY5L09wdTFmWXRJNm9INUFXdVFadWFuWVJiU2NnbG5pdDM5bTBoQzNKWTI5Nlc3SkRSeXJMcnphbnQxSHIvTHpnN08wSkJBdGdES3VLR3I1NHhWeTJhUExWc0xnNFJCZVh5K3ZVZDkvZmVIYVJFc1VPY1pmMnkveVdNSUJrRlFqZDNXbFZMczd0OVVuMzk4ZlY3akFla0tkdTlBWjM5SnhnRktMYjlQLzJyL2lJL0xqT056eHRXcThhTnExTXpZMjdtVFJ1bjZmMjQwMUlYVXNxbWpWT3Z4ZnQrL1BvRUpnQkw2cEU2WXJCUlF5Wk94Qk02ZmZhcFovWGo5MFp4bEtKRFpqbVArcU1Fb3BXeVFucFBWZGVBdnBlcitUWlR2ZUVDNmd0MXI2eGdvU1FEY2xxRjNRTWJ1cFk3Zms5cURmM1hKRkQzSnc2a0o5Y0hvSFBWMUFQUks2RXNsZGNTa2ExZ1FBdlB6OWhIdkJVQnBqVGpTZVlZWEIybkpFSkFuOTFBOFBodTMzYjl2N2p5YTErK1I4WUFmWHJkTEwrL29oblFGTXl2WU9TY1RRV1NveDVZanZhN3FCRzc2d0huMzhvbitpQjdUOTZ1engrcldQUVFnQVA3KzlqbWVIMEF1SVhEakIzMUpTOUhCWGVCeXM1WnZLbGxmVkFySTJsSlg1cEJ4aHFsZHpkTHk2TVh3NlVkckQxZjNjU0cxQnFYZ2RPdUJIbC84UGVYZ3R2aHp1aVhnblBxSGw5NVhIMW5jNVBvYzhzREhscWpuZjdDR0Y4dUJkQk5CZWdjanF2VmdqdzV4YjdhZjBRRk4vR3BobzZPZktkLy83TjdTbm9OUERVUUlnTlZNMWdCZTB1VDk1L2xQSHp0YnZmZlVIb3BLNTNOMzJaa2NBQk1EWFdLWWs3VkNFKy84VVIycTRaaXcxeDIzUTU1MFcxTUtLbjhYbk91OE5OSmI3N2NYdG45MUQ2aS8rOWtHOWRnWHJuSDFmVksraWE1Z1p6WmJBVkRHQW02TkhSdXZ0WFduSFZzblkrNmN0czY5ZjhUOWpaUjBBenY5K1RLK01BamovM3dkQUovYTNLR3VjM2hIVVVuU05mM0ZwWlBVVjlZZDUyemgwdXJmYk5GdjZZN3hMMmxGYzd2c1dqRi90N1RnZGZkSDRqT1M3WEdKZE9VVzMzM0x6M0UxTVdQOXJzSkxkY2k1NC9FOFNzTklnZWhIMXU1bXJlQmNZU3AyN1B6bHJ3L2tyS3QzNlV6bmRUSTM1eEVBYnpqWGVRV09iUUZhNU1HM0FWQzZWYVVXWHpYTXZydnQ0aW5xWHpkMTBBcVl4OGtiL2lZQnJKamtuSERrdEhuUmxsNkNRMTNtdjZXd2UwZGZtSEJYUVN2bVRYTytYL1FOcW9jMzdDL0s3NVdXdkt2T2IzSzFWSndFMWUvZWZJRmVaZzdaT1NtcXZIeTI4K0ZhTCs1emYzeGVPTU41d0hRenZwQUE2R0ZyZDU5U3R5eWQ0dm5uS1pOQ3BCQTFFMEtLNzdJWjQ4bzJacStjdnlzb3NnM2xrTzVYYVIyVTQ4ZUptLzlqRjEyekhyYTAyWGtBTExUN045VWp2MzNQOWF6Z1ZVdm5xSnZXNytWR3RFRFNQZXQwcHJDMHhOdGpCdDFZNkRBQWxtTjhJUUd3VEo3YlVid0FLQzBSNi9hY2pyY1kyRjFCc2c2cHZkQzcxQlYwYzBGS0pLc2VLQUpnVVVuaDFrYys5MkYxdE91TSt2WXZONWIwUlAza1o1YnBDOEpMbTlyVTE1OTlsNjZoSW5sb3czSDFtOWh4TEJNbzByV1F1NW5zUmZqejlySHFaakxHdGtQRlhhODEzMW5CVEFncG5KdnUyUzE1ZFA5ZTI5UlEwdkdGQkVDUEttWTNzSVMvTzEvTWNkZHBqZU83ZC9GRWRjY2xVMXlOWFdxcDBEZ252NUo2WXQvNzlITGRWZE04ZXFJZTZQMkwyQWxlWnY0Vk81elo0Yzl1RlpnM3M3SGtnVE1vSkxRVkk3akplRDU0MXpVTFpyZ0xiSzBIaXY0Yzhwa1ZMQk5DSHJ5NlJYM245ZDI4aUhseTB6MHI2L1M2ZGNsTTU2L241b0FGUU44WHhaRnU0R0pZdjkvNWp2ZkkxaTcxcVorM3Vicm9zRkpBY1QxOXowZEduTWpsN3Y2Rkw2MVVkeTA1cTJnaE16SDgyV1Fza2JROEZ1djNJTXNGMkdIclg3SEhFcUs0WkF5ZTQzUHgrNGRMMHNJdVAvT0hMMjExL1gyZnZuSytQaGNnUDA2N1oyVjJycFB4aEtrV3ozRGV1TEwrTUFIUVY2UWJPQjFwR1hUMWMxeU9DNUR1cWw5dnBVdTNFaVNVWlJyUUxhRlF4dnI4OEpZTEN6cHB5L2RLeUV3TmZ6WnBlWlRmSTYwRHFMenUvZ2did2FOazdLeWJDUmpiMnp0TDlseGtZb25idFlMbG5ITHZsUnpuK1hEVFBmdUhnKzViLzl5TUw1UlNOZmtFVEFLZ2gwazNzTjBTSjYwQXY5eDBRZzhHZjhGRk9KUEI1dm5NMFAzcHRsTWM0V1VtZ1N0VEtFc2tyWUd5SHFpVW5zZzMvRG01YU4xLzAwV0V3QktaMCtCOHJPMzJveFJoOXFwVkM5MTEvejZ6OFVCSm44L1hudm1qNisrUnNqQzBBcnJucG52Mmo0ZmRyN0xrWm56aDFnQXVQUm1JZFZHa0plN2hOWWRWeTc5dVYzLzUyaEU5cG1pWmkybm5kcEZYdHlqclVsNHlrRndDbDFQU1N2Zk4yeTdWTFJCdWZvZDBJN3Rwc1NBRWxzYVZMbXFId2J2Y3JQNGh4ZDVMUGROZWZyN1VCblJEemlWZlc3V1FGOU1scDkyek1qdjMxVHhXekdxWjdId2Q0bndDSmdHd0NraDVsZFFTSzI2V2lYdTlyWWNqMWVQc1NSOXV5WW5lelFYbFc3ZGNuTmZ5YzRSQUlEMDNxMzlzM0hPc0xNOUppanpMVXBOdVNLK0NtNXZKb0hQVFBadnY3TnhGMDUzZkpMNGF3Q1ZaQTdreXNpeks3cFNNRlN6SFdyMXV4eVFpMmNPM0wzTWR6R1F3dWR2bG5HNS85QTNYWTRRSWdVQjZNbEhLemVvZmIrNDhXcGJubGUrRUVMZmQyVUhtcG50MmM1N0x2MDBaNjZ6UVNWQ0hpQVF5QUY3b1lsYlFPNGZ5Yi8xekV6VHQxUW5nbnF6THVXTGhUSGVCTzNaM2Y5L1Q3cXY0eTRWaDVRL1c2SHAvK1laQTZVWkdlVTBZVmNORzhLQVB6M2ZlL1N1cmY1UnpMVzgzRTBMa3VUMzAvRHVVZzNIQlRmZHNQck56UDl6a3ZFRmd5eEVDWUdCYzFUTEI4ZGNXc2k2Z0ZJbDJhdWRSNnBUbFE3cGNaQUMyVy8vNHEwMEZsWktRSmFEY2poT3lTWWtZdW9yS2EvNTA2bXg2MGNWem5hLys4ZTYrOHErWC90anJPeHlGdjN0LzhpYmh6NlZsWnpzYmhwWHY3TnlaNDV5WE9UN2NQVVFBREFLWk9laW1RSE1oTTNuUGQzSFJPZFhQaEpGOFBIVG5aYTY2a0lRRXQySzBKRWozc2R6MXV5WFBWNTQzc3diTHA1bEM2OTQ3RjhmMmZ6ZVRxVGJzUGxyMjV5am5pV3l0L1RJcDVacnYvWmFpNzI3RDM5UlJqc3UvNURzN2Q0bUxBdE9uQTNyOURWd0EvRVN6ODVZWEtSOVR5RXplcFdjN24yaXkrUWd0Z0c1SjE2K2JDNGg5d25ZNzdpOGJ1ZXZQSndUSzg1YkY1SkcvblozT1czQmxlVVpab1FmZWNkZXkyYTYrL3FYM2oxVG1KdlBsN2VtZlR5d1l5cGhnbG4xMDcxSVhNL2p6blowN2Rhenpob0hOSi9xemZsN0dFeElBZmNCTnE5eW1nL21QLzNQYjB2amtubTdPQ2k3SU9McTdWeTV5L1gyeVJGdXg1UnNDcFY1aFBuVUlZWEs3Ukp3c3oxZ09jdXhMMlB6cERVMnV4Z0VIemFKWmphNXUzRXBkL2lXVGRHVmg1SDBaQmtMNHk0L1Qxcmw4eTcvbzBEYldlUmR3cHZHQ0V2enV1YUJSZlc3SkpGKytEclZCMi9IY3RNcXQzWjkvQUx4emtmTnhocXhUNnA2VVkzRkxUdHFsNnFxeHgvKzRxVU1vL3ZiakY2a05iU2NyZG5HcmRuTHNPTDNSa3ErVFVKWnpUVytYWVUvcUVjckVzbGtUNi9XYTNvblA1MURYQURkM21jN0Z6YzdILzVXci9Fc21VaGJHSG12OHo3OStSMDhRUWY3T2MxaWU1ZjB5VGM3NDAwVVQxWHNuekxHR0xSUHExUGxUUnFtbFp6WG9jWXJTVlMzakVBbUFWYTZjclhJZm11Mzh6dDl1YWJ5eHFTRnA0b2gwY2JsdDVRaUNmTHArWmRadk1idCtpeFVDWlR6Z1A5eDJpWjVaRFBmazJIRnpURiszc0ZHdGkzMzlrMzg4b2Rmc2RzSStMczl0ck5PemlTWG9uUlc3U01qdmxhN2xiSFRCK1hYSGVhRlNTQXUrbTdKTjVTci9rb20wOUQzejFpNzEybzRqalBjcjBNM05wUzMva2crcFIvaHZINStkOWZQU0duakNaMHRLQmlvQXVoMy9KOTAzOWtrLzllNWxYSVl4QVU0dUNxbHVXVHBGUDFJOS92WlJ0WUdMeDRnTFJ6NWR2ekxydHh3a0JFNXNxSGYxSEpmTW1hci9MaTRzN3IxM3RFL2Q0dko3NUJoOThQcFo2bSt1T1VzZjV6SURYeVpoMmNGT0IvUDZtcUpNSEpreG5vays2Vnl6d0YyOXZIS1dmOG1rMURlUVFURy94T1ZmU2tYcUZqNjUzVi9MdS9vdUFDNmZYSy9tTjVvbjNkVHc1bWI1TnpuNXI3NjVzdU96enB2T1VsZXBIdmpZRXRmZkk0TzF5M2tCa1F0RjArUXhqdFlrRmpKK2tQQ1hIMm5Ga3lEbjlxYkxEbm15SXBDYlZZSGNtamErVHZjOHNDeGt5cm10eWZuNFB5bllEdjl3dXZ4YnZ1VmZFci9mNlVvalRyaXBXMGdBcklCL3VueXF1dnV5NmI3NWU4YU5DaWtNazY1ZmFTMXpRMnAwZmYzWmQ4ditYR1dBK05zekc3TjJWY3R6KzlITFc2a2ZWcUJuTnA3dzlIRXZZd1RiR0FlWXhNM3liOXZiTzlsZ1BpSGo2NXlHc3EwRlZzYVE3eTltQUZ6a3d3WVpYeVVNdjlYU28vc29tUXpFZHRzYUlPTjJLalZUVDBwRVNNakxGUDRvSGxzYy83cXBRL1VNZVBmWWQ3UHlVQkM0WGY1Tnh0M0JIMWE0S1AreTgyUmhFeS8rYTJkeHUydGxWbkhMaERwZnZSNitDb0Q3T3YyMW5xNTBIMkdZQkxtYmY3eE96K2JORkt3U0Zidm1YejdQVjBKZXB2Qkh0MitSdG5OdldQM3Yxejd3N1BPVHNZVklKamR5TWpFckYva2FqaFAvY05PTit1emV3bHJOcGZ2NHQ5dTdpdnI4cjVzejFsZXZSeTI3SktxTmhEcHBGWkJTTU5tNldCLzU3WHNWZjY1eThaTEFhazhLa1ZCSzhkamlrN0dBVXVNejNXU3FpbC8wV0lVa2lZekh0Y2ZreXBLSXkrZE1WdWZQYWxRTG1ocEhEUEhZdFBjWUc4eEhuSGFqYmo5YW5Na2ZxMXRQcUxIMUlYVmw4L2lpL0x5NWsvdzFEdEJYQVZES3RxejIyUUVqTTVHcEk1WStXRDIvK21YMXcxc3VWTGRlUGk5dEM0TVhaZzdhZ1ZVR3ZjK1lOSWJ3VjBKLytkb1JOWDUwalM3MTRpVXNRNWVaMUw4MGEyQU8xOVdUR2ZFeVMxZ21VcTNmUlFEMEMraytkVnFjZVVzUnk3OThlOTB4ZFUvM29QcmtCWk1ML2xsSGUveTFaakF0Z0tocVgvamxabDBqN0t0L3VqU3BydGpmUC8rdXA1N25mVSszNnJlRXY5S1NJcy8zN3UvSmUyWndzYTNmZTdwb3JSbUJ1cm1qMjlkMzNJei8rME9SeTc4OCttNm4rbjFiajdyai9NWjRjV2NuWkNVU0tVWXQ5UWhmM05kTkhVQ3ZjN015UURXUUFlUzBBR1luTFgxcjlyMmlIcjU5bVZxeGNLWXUrK0sxbFRVSWZ1VWozY0hQN2UxV1gxdzZTZDEyOFpTeUJVRTU5K3lPUFdUMUQxbmJtK01XR0NZMTlDUkVYVGhsbEZvUWU4aHljT2xLblVub2FqMWUvSlUzWkV5Z3RBWXFkVXhkMjlTZ24wTTYzUU1SMVg1NlVPM3ZIaXFvREEwQnNBTEtNUnR3UzN2NkplSzZZM2NIVHU3MlpiYXkwd2tyYmhhOER6Sjdnc2lEVjdlb0oxb1BzRUdDdmovMGh0VlgxaDNYRDFtWFY4WUh5aktRaGQ0Y1NzaVRjNHhkUEZxQ1hrZGZXTDNRVGlzZmtJdTBvTW5hdm5wOTMzZk44ajUyR0pQeGRRdGpvYkFjeTcvRm4wUEErUzRBZG1kcG9yVlAzcmJXQThsQmJuTkszU0ZPN05XSHNpcElwWmQ4UzFqMlRjYlZpbXpsV1ZKdjBtak5BOG9UeHFaUS81WUFtSy8vLzcrUHEvLzdiZ2NCRGtCYWRwZ2oxQUhlNDdkeGRnVEFNaUx3QVFBQVpFZGJLd0FBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBUUhXb0xkWVBldlNUaTltYVB2ZnY5OTNLUnZBNWptT09ZMVMvdi9ySVhEWUN5aE1BLy9vL1hxM092ejQ4cEl6d2dES2lrWUovVk5RSUtSV3FVZEdhZXFVTWd6MExBQUQ0T3dCV3JacGFGZFZCc0xBUUdJMEZQeFdxaTRXL1d2WW9BQUJBQVBSK0NJeUZ0MmpzRVpZb0dIVVgvS1NsejZoUjBWcHA5V000SlFBQUlBQldDY1BzdG8xR2xSRUpPd3lCaGhuK3BBV3hwazYvRHdBQVFBQ3NxZ3hvV0VGTzhsOUVHZEZzcllHeHJ3MkZ6SzhQc2ZrQUFBQUJzSHJKQkk3WXd3Z1B4VExnVUVJUVRNcCtzYSt4V3YzbzhnVUFBQVJBZjlBVE9lUWhJVkIzQ1Z2Snp6RGY2Z2tmaEQ4QUFFQUE5Q0ZwNmFPTEZ3QUErREhtc0FrQUFBQUlnQUFBQVBDeG5IMmNEOXgwS1Z2SmhYQWtvcnJPREtpOXg3clV1d2VPcXhPbmU5a29BQUNndWdMZ2QxNDd3Rlp5dWpGRGhtcHNxRlV0azBhcHBVMVQxQ1hOTTlTNys0K3BWN2NlVUVQaENCc0lBQUNIcG94dlVFdk9ucXpPblRwQlRXeW9WelVoT2kzZGlJVERoUVZBT0RjVWlhcmpQWVA2c2VGUWR5d0VUbERYejV1dUdzZU9Wci9Zc0VPRkkxRTJFZ0FBV2RTRURIWE5vdG5xd25PbXFHTmRQYXAxeHdHMTY0TVRxcXVuajhZVUZ4Nzg4NVVFd0VxUUVvSWJENTFTSFdjRzFhY3VtaDdibWM5Ukw3L1h4b1lCQUNCTCtMdjFRL05WVStNWTlXTHJEdFc2NjFEc2VrcmpTU25RbmxwaSt6cDYxZTkzZGFnTG0yZm81bXdBQUpEZU5ZdG54OExmV1BXejF6ZXBQK3c4U1BnakFGYTMxa09uMVBFelliWGtuT2xzREFBQTBwQkdrb3ZPbWFaKzk4ZnRhdStSRGpZSUFiRDZ5UTNNcHZiVHFubjZKRFlHQUFCcFhEQjdxanArcWtlMTdtNW5ZeEFBL1dQM2lUTnE0cGhSYkFnQUFOSm9ualpSYll5RlA3cDlDWUMrMHRrM3BFSWhndzBCQUVBYTBraXlzLzBZRzRJQTZDOW1DUmdDSUFBQTZjZ000TTd1UGpZRUFSQUFBQVNKcktZRkFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQVJBQUFBQUVBQUJBQUJBQUFRQUFBQUJFQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCMEkyZjN0Q2tibXhxNEZVRUFBQWxkZG1NY2I3NmUycXI5WWwvNDVKSjZycUZqZnB4N1BTZ1dydjdsSHB1eHluMVFuc3ZleWtBQUNpS20rWk9WdCs2NVdJMWZlSVlkZTlQM2xUUDd6bEpBS3lrankrZUZQLzN0UEYxNnBhbFUvVEREb1AvK1BaeDFkWWJaczhGQUFCNStmNE5pOVJ0Vjh4VFkwZlg2ZmNsQ0c1NTlBM1YxajFROVg5YlZYWUJTN2R2ODlUUmFUOG5ZZkRLbGdtRVB3QUFrSmM1NCtyVkszOTFsYnA3NWFKNCtCUE5NeWFxNzk1OGdTLyt4cW9NZ0orNWNGTFd6Nyt3dFlPOUZ3QUE1T1dGTDYxVVMrWk1UZnU1VlV2bnFQdVduME1BTEhzcWI2alI0LzR5NlJrSXEzL2RSQUFFQUFENStkbmFuVmsvLzdjZnYwaTNFbGF6cWhzRCtNV2wyVnYvM2oxMFJsMDVzMEhkMlZpbkpveXF5Zm56RG5RTnFrZTJkckczQXdBQTdUdXY3MWFMWmpYcTFyNTBwRnY0YTZzV3FpLzhjak1CTUYvTEo5ZXIrWTFtaXI1d3h2QzRQZ2x2ODZjUHZ6KzJ2aWJqdUw5RUs1ckg2NGRUVzlwN0NJQUFBQ0RKMTU5OVYxMnhzQ2xwREdDaVd5K2ZweDU3YTQ5NiswZzNBVEFmMzcxdXBsclNOTFppdjErQ0pRQUFRQ0taNmZ2UHYzNUhmZk8yU3pOK3pmMGZQVS9kOFZUcmlJOUw5N0E5V1VTQ3BCZG5EUWQrSlJBbnJZb0FBQ0I0SHQ2d1gyMXBPNTd4ODlKQ21Eb1dVTjUvK3A2UDZPNWplY2kvdlRoZXNPSUJjT2ZSUHZZd0FBQlFWazVYOW5qczlSMFpQeWZkdy9kZTJSSi9YNHBHeXd4aUtSZGprMzk3TVFSV1BBQ2U2cTk4dmI0NzVvN2pTQUFBSUVBZXV2TXlkZlI3dCtwNmZ6Kzg1VUpkMmlWZEtIeGl5d2RaV3dGdlhHWk9GSkh2ZitSekgxYlRKbzRaOFRWMkNDUUFlaXdBQWdDQTRKQ2daN2ZTU2IwL21kQWhZLzJlZStCNnZmcEhxbXl0Z0JMNDdscHlsbG94YjFyR0NTTjJDSHp5TThzOHN3MHFQZ2xrWCtkZ3dUL2o5KzkzcWtOZEl3ZFliajdpckh0NVorY0FSd01BQUFHeGF1R01qSi9iZjdKbnhNZWtGZkNyWFdmU3R1NkpHeTZjcFNlRFBLbFV4dEl4eXZyYzkwK2VVVjkrY1JzQlVNTFg0MjhmVFJ2YTVITWJUZzZvZFhmT3pUaFpRd28vMy9saU8zc3pBQUJ3UkdyOFpTSVRQOUtSNHREMzMzUlIyczh0Ylo2bTN6b0pnYks4M09hREhUcFVCam9BU3NEYnNDNUwzM3FXZFgvRk14dFBzQ2NEQUFESDdNQ1dLdHRZdnlkYUQyUU1nTkl5S04zS1VoTlFRdUN6byt2VmlvVXpNLzZzYjkvK0liVm0zMjhyV2g3RzgyVmdjcTM3Ky9QdHA5aVRBUUNBSXhMVU1uWGx0dTQrbHZIN0pLenRQWko1NFlnRjA0WW5rTnozZEd2V3I1V3hnby9kdmFLaTI4SFRBVkRXL2IxOGJ1WlZQV1RzbjdRZ0FnQUFPSkZ0L0o5MHpXYXpjVS9tZ0hqaDJaT1N3dUw5UDMxYjlmU2xuK2NnSDEvOW15MEV3RXhrM2Q5c0szWDhaZ2V0ZndBQXdMbXpKMmRlZlN6WHVMelR2Wmtucm81dlNKNEJMTjNCc3BKSUtta1ovTlFQWGxYUDd6bEpBTXpreHNXWnUzK1BuUjVVVCs3cFprOEdBQUNPTFdoS1B3RWsyL2cvVzdZV3duUS9WeWFVL0dMZHJ2ajdMMjFxVTdjLytvWW4xZyt1OWVvTEpNV1pwNDNQWEUvblB6Y2VaeThHQUFDdVNOMi9kSGEwZDViazkzM2hsNXZWeFhPbnFUWHZ0WHVpL0l2bkErREhGa3pJK3ZsUFhUeFZuVDJoWGoyMnVZTnhnQUFBSUtkc3k3OGRURlAvTDVWMEVhL080L2RLcTE4bFoveFdUUUJjUHJsZVhiZXdNZXZYU092Z0xVdW42TWZlNDMxcXplNVRla1l3WVJBQUFLU1RPRk0zVmR1Sm5vSitkcWFXUmYyenU3MlhUVHdaQUQ5NTNnUlhYeTkxQXVWeDkyWFQ5ZGpBdGJFdytON1JQdlhJMWk3MmRnQUFvQ1hPMUUxVjZjTE1CRUNWZmZKSEx2R1d3ZGkvSDd4K2x0clMzcU4yeHNLZ0JNSU5IL1RTUWdnQVFFQTFUVTVmL3k5YnpUNENZSm5jdTNoaTFza2ZiaTFwR3FzZnQxanZ5OUp4MG1Vc29mQlVmMWd2UGRmUkYxWXZ0UGR5WkFBQTRHTVB2YnhkYlR2VXFVdkJ5TVNNNWhrVHpXelFOMGdBckxRL1c5SlkwcDh2ZFFYdFVHaVRidU1YZnJTVEl3TUFBQitUOGl1cEpWanVXbktXNCs5LzhPcVdqSjg3MW5XR0FKZ3ZtZnlSR014R2JOeFlVQnN6S3BTMU9IUSszam5VdzFFQkFFQUFwWTc5Ky80Tmk5VCtrejJxODR3NVpHek5Qck5nODEzTFpxdS8rT2ppakQvblNDY0JNRytmejdIdXI5VCsrL3MvZHFodlhESkpYVHR2UXRhdzZNYWhMc1lGQWdBQXBaYTFURk4zcjF6ayt2c09kMVJYWTVKbkFxQ3MrM3Y5NHN6ZHZ6SjJUOEtma0xmeWtCWkRtVEY4VmNzRVBRczRYNiszMFFJSUFBRHlKMk1MQ1lCNXVIUFJoS3hkdTcvYk9uTER5b3plRGV1T0t4VjdTSUNVbjdGb2VvTzZmTzU0VjkzRVRBQUJBQUNpZGZleHJEWDkwcEZKSkUrMEhpQUE1dVBqT1VxL1BMZmpWTmJQdC9YYUxZUm1LK0dOVFEzcTRyTkc2MERZWXRVSlRFZkt4QUFBQU9Ucm1iZDJlYkxZcytjRG9IVGxadXZDbGJJdGJsdnA1T3ZON3hsZXVGbEM0ZHpHZWpWN1lwMDZMeFlNeDQwS3FkWURCRUFBQUdEYWY5SmRMbmhwVTV1bjF2aXRxZ0FvWGJtWFBicGRkK0YrYVBZNHRhSjVmTkxuWlptM1l0Q0JrTzVlQUFDUWdUMzdOeGNwKy9MRGw3YXFoemZzcjhxLzB6TmR3UEV1M0RTVE8yU05Yd0FBZ0ZLVHNpK1B2MksyNk1tTTRGUTcyanZWZTRjNnF6YjRlUzRBSmtxYzNDRmhrT1hiQUFCQU9jaFl2dUV1M1cyKy9UdERYbitDaEQ4QUFJQ0FCVUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBMWFZMjF4ZDhmZVZjdGxJUlBYRFRwV3dFQUFEU2VQRFBWN0lSdkJBQS8rT05yV3doQUFBQW42RUxHQUFBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFDQVlqQis4SDQweW1ZQUFBQUlVQUJVa3k2L0xQWjJVdXd4TnZhb1o1TUFBQUQ0MGtEczBSTjdkTlRHL2hlT1BZWmlqMEcyQ3dBQWdHOE5XcGt2TEFHd1AvYm90VDVSeTdZQkFBRHdwU0VyOC9WTEYzQkw3QjlqWW85UnNVY04yd1lBQU1DWHBOZFhHdjdPU0FDY3BzeXhmN1VFUUFBQUFGOEhRR2tGSEpBQU9NWUtmMUlTeG1EYkFBQUErSkpVZm9sSUNKUUFXS09HNndFU0FBRUFBUHdiQUVYay93a3dBQ1FtU21NTmZPUXVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmdcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ1FBQUFBbENBWUFBQUFxWEVzOUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvNVJrTXlSRGs1TnpOR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG81UmtNeVJEazVPRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPamt5TjBKRlFrRTJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qbEdRekpFT1RrMk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0VWd2NHUUFBRGV0SlJFRlVlTnFjV0dsd1hOV1pQVy90ZlZGM1N5MjNKRy95Smk5WVhuRU1qZ05NSUVPd0lXUnFvR3FXS2dmYjQxQ1ZlQUtrWnFveXFjR1pNS2xValJNOGdja1VXVWorSkFYWUNUQXNKc1pPakcyQ2pZMHNlWkdFWk8ydHJmZlh5OXZmbSs4OXRhZHdoZ0JKeTdlNjNkSzc5OXp6ZmQvNXpyMk1zRFdHUCtYMTd6LzdaMzVZR2Q1NVgvd0w2emFITjkraW1tcUhsL1VHR0RDUUxka0lDSUhlbzduWHo3MmFmL1ZzaDcvam1NaUlPYzNVb05uYWpSUFpjMjhIZG4vL2hxLzVUd3JrOFo4OHNucGFuOWx6c1hMeEM5MXlkOXZOMFMySUJDTFFxaHBVVzZYNWJTU0VCRmdQdS9WaTdlTFdDN1VMRGtBcHhzVitsUlNTejBiNHlGdUtwVUMzZFRqZy85aUwrVGlHdnZ2c041aFJkZlRKRVcza3F4VzdBcGlBV2xYQjBjOVAxdjRVN2JGMlFIRm1vdUVCVGt5ZXdHTlhIMFdNajRIeE1iQjRDejc0MGNhMy9xTGQzLzRZeDNCVFZiTUt4bVkrbENHT2EvUDlVVEFIZnZybzVwNXF6N0VoWStnZTB6VEIxd1R3SmdjLzYwZFpLT09NZGdZZXhnT1RNVEd0VCtPMTNLdDRPdk1VUkU2RTMvYUROVmh3R2dlTGZwOWhNbXNLV3VHaEVCTWFpZkxSSzlkRGVQTGxkejRaUTQvKzk1NHZ2bEo0NWJETjJWaGtMNEt1R3VCRURueUlnMlJMWUdzc01hWEJ0bTJreEJSTTI4UU1nZkp6ZnBjcHphOGh6SWVCS24ydWFmQjZ2WmpsWnBIVGN0Z2UzdjZ2bmNIT2I1V01FaDdmL2IyUFo0akE3THdpWC9uMS9jbjcwWUpXdkYvb1J5UVJRWkV2d2k0QlM5Vmw0TE04aEtLQXVKYkFmTFlOQ1NzQnNlS0JWdEFSVnNKWXlDMUVSU2tqSTJZUWk4YVFMK2FSNGxONHNQVkJUQ2dUdCtXMGZMbkYwL0w3Mzd4MDhxT1QrcDhPUGR6eVF2NjVseDV0ZXd4N0Z1OEZLRzN1WlhaaW9EQ0FEZHBHZU10ZXNKUXc2eExyMEJKdXdZTFFBc1I5Y1RkUmkxb1JZK1V4cEtVMHhuSmphTktTYUF3MW9sZTVDaWtzNFdEYlFXeEtiWVpVTHVHK3kvY2RETUIvaVpZODlsR0FtR0VNdmNIUWtqUFZHVWhWQ2YxcUh3cUZBdFlXT3hFMGc1Z1huNGZOTk9tZEMrOEVCSHJDb0FyV2JUZDBMTTlpaTdnRnNJQzN4OTdHcVlsVEdKc2R3eXBsRFM3NHorT2NkZzRybFpXNGtMOEExVkJvN3ZkZit0b1RlNUxmLzhhUHloK2FRdy8vNEcvMzkyZzlUL29OUDBxVkVwTEpKQ1pLRTFoVldnM0JFTkE1dnhQNzF1OXpLNm9rbFdoZHExN0NiSDBHeXkxL3A0S2l3YWdMK01pVkkzaTk3M1VFeFNCT2UwNmhyYWtWMlprY1BJSUhsdC9HRXI3OXVaL3QvOVdEL3krSE5tNWZLNWhMdE9PYXBmR1FnVUE0Z0JGNUJCM1ZsUWdZQVd4YnZBMjdOdXhDclZKRFdaYkFzQXd0M1FETDlMcjFidE93TEM5czFnZVcxU0NyRmJjUTFzMWZoNmduaXE2cExqY2Z1N1Z1Tk1VYXdjb3NXSTZoaktpc3Z1ZXpkejUvOXRqRjdBMkEvdktyMi9kUDJ1blBDNnJnaXFnWk1wR1VtaEV0UjlIWnVoYTdOdTZDVkpTZ21USVlyZ0dtNXFkZDlzSWZlZ05lNFZYNi9CWTh2bXRnTEJ1YXVwREM1NmN3bHFISUtsYTByRUJCTG1Ba000S1V0eFZUNGlSRVF3UmpNRkI0R2FUMDBaN2Y5UC82ZzRDNHhYZWsvclBLVkZPOFFkWGpFNUdUY2xpcUxVUEVHOEZETisyR2FJbFFES3BoTGdhREZna0Zmd2hlK1RhczJSZWh6L2JBeUhWVEFSd0hiNzhCVHpBRHBiS1dRa2JwWUZjSnZFWEp2QWxYaTFlUnpXZVFOYk1JTjRScEhzTmwyckt0K2F2YU9uN1lkL0dhNmdaLzlSY1hMK3MxZXplVWFrV1lCa214eDBLYjNZWkNLWS8xODlhanNhRVJKYVZFRC90SVV6aUVmRStBTFIxQWRaQWpGdjRDWXZRdWVCdnVKT1kraTlwNEFuYithZnFiUjJEVWF2UmRrRFlpdStXekpySEd6YS8xdmcwb0drV3dOZ3VEd2pxRW9lZzF1Lzl6MXhsaXZyempvUWMrdmVUV3UxVlp4NkE4QU5tVzBjbXRRNXlQWTJ2TFZsZjRuRWt0SmdxZitCTHB6Uk9valhXaVlmVWRFSnBqWUhVU0FsYUFrR3lDdDNFSjVCRmlXWHdUWENBT3hkd0NqbEdvRW9GR1h3SVRsVFJtcTdOSVcyblUyQnBzQ3ZIZHpYZGpFN3RsK3MzZnZmV0d3eEMzOTlON051MUxmaGsvNy93NS9tN1IzMk5hbXNGc2NSYU5nVWFzYkZnSlNhTWtkbHFFcG9QWERrT2Y5aUE4bjBMQzZ6QW5Tc1RTTkd4bUducGFJaG1vSWpSL0JkU0pKSVh3QlpqcUpJRU5vV2JVaU9rbUpBSUpET1dIWU9vbW90NG9EblVjd29INTM4SS9iTjI3amJBSURpREIwczJ0cy9Lc205eGZYL1IxZkNyMEtWd3VYRUxFRTBiQUY0QnUwZmE0RU8zbUN0U1pickJNT3l4VlFyWC9QR3h1R0pXaHk2Z085NEVWUnlHUHZnY2xOd25CdnhTUUJpRUtsNml0aUhQTmw3TEJML2dSRmFNd0xBTmZhZnNLTmlZM29hQVVVSlFLVFU2NU9vQkVsdVdhSFQzSktCbGFHTGd0ZWh1eWFwYWFwTWVkeUJFOVIycHNKUTFrcmdHRWoyVjE2SVVzakV3dnRZc3l0R3dSVnFFUHl1d01oY2lBYlJLYnhTeFlaWnFhYjkzL1dKalRMZnEzekxjTUcwTWJLYzhNQWtkL3l3a0JoeHhIcVVtK2JHSE9NOW51ZzA0bjl2QmV5RTR5V25VRlpXd1k5bndZZVhvdkVVdmtiYWh3b1kxSXhEUG41a0p0b0FiT1F4b2pqVU9lR25kOEN0UllHRUtjcGlFMXY3NjVzbDZHei9hNU1ucmRxN0VzSXpycDR3RGlMTXQyR29BbjZVMjZyZUMxN0d0WTFiQUtFb1VsWDhtRFozZ0tVUWxzd3hvWWdZMHdwMDVCS2hFY2djeFp4UVRuaUNRdHh0Sml2RGVORXJIRW1wT1F3d3VnUis2QVI1Y3BXbk9MbHlrZlRRcFhqOVNEODlKNTdKeTNFMXlKY3l6TUhDNW44NEZRb0pnTUpWR2pIWDI3OTkvUXIvZGhVV3dScHNwVDZDMzBJaUpHWUpvcWZDUlpjdE4rVUcra2tFaFFpaWJVZkJXR2JybE0xdWl6WE5ESUZXb2dsWUNjM0E4L01XVFF4aHhiTXA0ZnB3ckxZR2w4R1pVM2kvKzY5alJPanAxRTNCdEhKQnhScnBkOVVQTlY3eGp3dkwvZ3liRkRPRFoxekhXQlRtTlZ5b3BiRlowdG5kUXVLclJyRFd4cUE3S1pQS3dycCtEeHl1Q0NEV1JqS1o5SU1zUmdrRmdxUXA2b29yVHdyeEhjZGhDQ1ZvSnVhSWlINHpnK2VoeW54OC9RTXl5c2dJVjhJVWZSZUIyVFRCcGRYVjJaRTZmTy9OZ0I1RHM5OGR1YkxrVjdOZ2pOUEJyMEdHa1lqeWxqR3N1OXk1R3B6R0pGcEFQSlFEUEtGRFl2OVI5KzhiMG9hRDVJNlY1VU14UWVXWU9sNkZRcE5iSWdCSERsdzRoLzdrY0ljQ29CTGNGUGpkV3lUQndaT0VMbFgwVzMyWTJ3R0NMOTlTTFVFTVM1OURuODhvWG56ck1GN3hFSGtDY2NEa2JuSlp0MkpPY25vZGQwVnlQOFlTOUtORmxBQzJLOE5vN3RDN2RUbUd6SWlvU0F3Q0J5MCswdzJ2NEdGVEpuZHFRTlp1TjZLSzEvaGREdGg1RGE5Z0E4cER0cXBVQlpLcmdHN1pudVp6Q1lIVVROVjBQRlQ3cEdqdE8yTFFUakFXakRPcFJyeG1HMWFKNTJBSEZheFZKNG43VXozQndLK2FKZWFCVU5JZ2xoanMwaGlCQTBZbUJZR3NhMmhkdW9Wd2tvT3dsU3F5SWFhMERUVGJmQTI3RUR3VlU3a1ZxN0RaRlFHSG9wQTExVHFPbjZFSS9HOFdMZmkzaG4vQjJZZ29sTGRvL2JBWnlXNFFtUjJLb21KdCtiMGdyWGF0OHhWWHZNYlIyVVN6NldSNUQzc2x0aWk4aFNHSmJiK0JST0FSMXAwRUxXVTZQL244K2N4OGFtalVpRUU1UVhCckZWaGtuOWlsV3BaMUZCR05VS05LVkNNaUNnS2R4RWsvcndUTTh6T0ROMkJpWnI0b1IrSElKSGdGcW01dXdKVWYvekl0T2J3ZlNsMlRjclU4Wmh3cEZ4QURsS3c2c2xzOEFJK2ozZWlOY2ZhQTRpVjg3aDd0am5zVy9GUHB3c25vUkdpU2xYYTdpVXYrUUs2RHovUEtTaUtRU0ZJSVV3NEk2Z2gvajBFNk82aHFPalIvSHk4TXU0UEhNWkJtK2d5KzdDUDY3NEdyNlUraExTdFVta1NSNnNvbzN4c3hNb0Rxbi9ZbXIySU9FbzhuVmRxampvcWxQR2Y2VGZtL3lPMVdBajFoakhOMWQ4RTN5Y0orMG9ZOC9GUGJqTGY1ZDdpcGdZbU1CQWRvQVNQVW5KR1FiUHpqbGg1K1JSMDJ1dS9lM1A5MU16dG1CNkRQeGVld2VMSW91d083VWJpQURqNWdSTzlKK0FlRlpFWlVaOVZxdVl3L1M0NUV4eDNRK1pqaDdwVlV2akJEdG1WTFRsM2hZdndvRXdSRm5FODBQUHUrcXQrbFhRb1JHdG9WWVUxUUxlblhrWEU2VEt2YmsrOU9YN01GZ2NkTU5hb3FNSmFSdklEaVBuelNIcFNVS1NKTWhrN2xUNk9adzVqS0V6UTZpT3lOMkZRZlVIdExZREtPODBsdzk2YXNlTExxQ3hQTEhjOTNpZzFiY3VjVXNDL29BZmxYd0ZZU3RFZVdCQjlJc29tYVF0T3ZVZml5ZFJOTnhUS3Brc1NDU1dBVStBU0NRYWVRWXhvY0d0V3R1Z3BrUWtWb05rYXcwZGhmTUYyTU1ZbjdwU2ZvVFdHNkJ4clI2bEc4NWw1dHdaZ2c2b09lT3FJR0toa3BWYnhLQ0laQ3BKbHBTQlNZbHRhcWJiaHh3NzRlVE1ydlpkMk5HeUE3YzAzWUlHZndPNnlsMTB1dVVSdGtNd0ZNTk5DREVrSUJDbkEyU0JhRGlYSTBlZ2pPYXZLUWNzMDNhWUdYRTZ5dlhyaHo4OEtPcjF3VG1nZUdwaThreDFoVWtsNmlVNThDWDg0TWl4VlBXS0MreGd4L2R3NzRKN3NWaFlqSFpmTzI1TjNrcTZGY0RScWFNSWVZTmtaVDN3TlZBVHBkYmlWTlBFK1FsVVorUzNjMzNxZHduTUtLMHpSQ05YSitORFQ2NE9TcFdHYy9CbWxJSXh4ckRzcUZ5c3BpcVpTdFJwRDQ0anlBazU3RjI2Ri9lbjdrZTZsSWFrU3lqcEpSaWFnWnZqTjJPRUc4RlZwUmRjaFVOaHRFQmxQWTNzKzdtTVVyU2VLdzZxdjZTNTAzVXdtVG9CSDNrZDQ0UXRXMGV0bGRPcVdrN2pVbFRCN2JXc3ZKVVBjRXZ6UWg3TkR6U1Rlamw2d2JzZWgySElpbGkwanhCNUhYa1pubnJ6S2FTc0ZHbU9Oa0Y5K1Z4aFVQbWZlaVU1WU1ZY1p0cHVqV3JqcDR1ZjZIN0lxR2U5ZzU0eUZQT0t3OG9yOVA3YjREeXhRemIxSmUvMlhGaittZmJiWXJLaUJFUkI4RGlBRE1QUTg2Vjg3WGRuM3lycGczWi8yYU1OUytOS0Z6MVhxODgzVFdPS1JvbkFHSC9PL1pEcktPR3FCeHBwSk9xZmZmWHYrZnJOMEFkdm9LdzZ1ODVtNURvcjJYcDRIRG9VL0ovdCt6TXVyRDRBekpHRklJMHczTUFnTUhkRjVZSmk2NkNzT3J0YW5kbHlIVkM1RHNUOHVJV1lQL0dPa2EwREVPZXM3dzFncmhlRlhRZWwxNEhwSDhYSUg3NytWNEFCQUFtSDEzRldjZDJUQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJwbGF5cGFuZWxcXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLXBhbmVsXFxcIiB2LWVsOnBhbmVsPVxcXCJ2LWVsOnBhbmVsXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCI+PGRpdiBjbGFzcz1cXFwibnVtIHNpbmdsZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJzaW5nbGVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NpbmdsZScpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzaW5nbGUnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gZG91YmxlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImRvdWJsZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCgnZG91YmxlJylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ2RvdWJsZScgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB6ZXJvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInplcm9cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMClcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMCBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIG9uZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJvbmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHR3b1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ0d29cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMilcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMiBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHRocmVlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInRocmVlXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDMpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDMgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmb3VyXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvdXJcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNClcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNCBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGZpdmVcXFwiIHYtYmluZDpzdHlsZT1cXFwiZml2ZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg1KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA1IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc2l4XFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNpeFxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg2KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA2IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc2V2ZW5cXFwiIHYtYmluZDpzdHlsZT1cXFwic2V2ZW5cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGVpZ2h0XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImVpZ2h0XFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDgpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDggaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBuaW5lXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm5pbmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoOSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGJpZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJiaWdcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2JpZycpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdiaWcnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc21hbGxcXFwiIHYtYmluZDpzdHlsZT1cXFwic21hbGxcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NtYWxsJylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ3NtYWxsJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGZvcm11bGFcXFwiIHYtYmluZDpzdHlsZT1cXFwiZm9ybXVsYVxcXCIgdi1odG1sPVxcXCJib251c051bVxcXCI+IDwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBib251ZG51bVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJib251ZG51bVxcXCI+PHRhYmxlPjx0cj48dGQgdi1odG1sPVxcXCJ1c2VyQmV0LmJldG51bVxcXCI+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PC9kaXY+PGltZyB2LWJpbmQ6c3JjPVxcXCJ0YWJsZVBhbmVsSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCIvPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxTdGF0ZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTBjZTc0MTkxL1N0YXRlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLnN0YXRlIHtcXG4gICAgaGVpZ2h0OiAxNyU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3R0b206IDFlbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG50YWJsZSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5zdGF0ZS1pdGVtIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMy4zMzMzJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYubW9uZXktc3RhdGUge1xcbiAgICBwYWRkaW5nOiAwIDFlbTtcXG59XFxuXFxuZGl2LnBvcnRyYWl0IHtcXG4gICAgcGFkZGluZzogMDtcXG59XFxuXFxuZGl2LnBvcnRyYWl0LWltZyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMvdGguanBnXCIpICsgXCIpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbmRpdi5wb2x5Z29uIHtcXG4gICAgLypjbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAsIDEwMCUgMjclLCAxMDAlIDczJSwgNTAlIDEwMCUsIDAlIDczJSwgMCAyNyUpOyovXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICBtYXJnaW46IGF1dG87XFxufVxcblxcbmRpdi5idXR0b24udW5kbyB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aSpOmUgC5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGhlaWdodDogNDAlO1xcbiAgICBwYWRkaW5nOiA1JTtcXG59XFxuXFxuZGl2LmJ1dHRvbiBzcGFuIHtcXG4gICAgLypmb250LXNpemU6IDEuNXJlbTsqL1xcbn1cXG5cXG5cXG4vKmRpdi5zdGFycy1idXR0b257XFxuICAgIHBhZGRpbmc6IC44ZW07XFxufSovXFxuXFxuLm1vbmV5LWljb24ge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nKSA1MCUgNTAlOyovXFxuICAgIC8qYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXFxuICAgIC8qYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsqL1xcbn1cXG5cXG5zcGFuLm1vbmV5LWljb24ge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXFxuLm1vbmV5LW51bSB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgLXdlYmtpdC11c2VyLW1vZGlmeTogcmVhZC13cml0ZS1wbGFpbnRleHQtb25seTtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT80NmE5MWY2OFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNGQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSw0REFBQTtJQUNBLHlCQUFBO0NBQ0E7O0FBRUE7SUFDQSwyRUFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0E7K0JBQ0E7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLDZCQUFBO0lBQ0EseUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxzQkFBQTtDQUNBOzs7QUFHQTs7R0FFQTs7QUFFQTtJQUNBLG9EQUFBO0lBQ0EsNkJBQUE7SUFDQSxpQ0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGlCQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsK0NBQUE7SUFDQSxpQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJTdGF0ZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLSDnirbmgIHljLog77yM5bGV56S655So5oi355qE5LiA5Lqb54q25oCBXFxuICAgIGRpdi5zdGF0ZVxcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0ubW9uZXkudGFibGVcXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICB0YWJsZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLm1vbmV5LW51bShjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiLEBrZXl1cD1cXFwiY2hlY2tEYXRhXFxcIixAYmx1cj1cXFwiY2hhbmdlRGF0YVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVxcXCIsdi1odG1sPVxcXCJ1c2VyQmV0LmJldG1vbmV5XFxcIilcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnBvcnRyYWl0XFxuICAgICAgICAgICAgZGl2LnBvbHlnb24oQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJoZWFkc3R5bGVcXFwiKVxcbiAgICAgICAgICAgICAgICBzdmcoeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIix2ZXJzaW9uPVxcXCIxLjFcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGgrJ3B4J1xcXCIsdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0KydweCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgZGVmc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4oaWQ9XFxcImltYWdlXFxcIix4PVxcXCIwXFxcIix5PVxcXCIwXFxcIixwYXR0ZXJuVW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSh2LWVsOmltYWdlLHg9XFxcIjBcXFwiLHk9XFxcIjBcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uKHYtYmluZDpwb2ludHM9XFxcImhlYWRib3JkZXJcXFwiLGZpbGw9XFxcInVybCgjaW1hZ2UpXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGltYWdlKHg9XFxcIjBcXFwiLHk9XFxcIjBcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIsdi1iaW5kOnhsaW5rOmhyZWY9XFxcImhlYWRib3JkZXJpbWdcXFwiKVxcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0uc3RhcnMudGFibGVcXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uLnVuZG8oQGNsaWNrPVxcXCJjYW5jZWxiZXRcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJCZXQnLCAndXNlcmluZm8nXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnpvb21SYXRlKVxcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4kZWxzLmltYWdlKVxcbiAgICB9LFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBoZWFkem9vbTogMS4yLFxcbiAgICAgICAgICAgIGhlYWRib3JkZXJpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nJylcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgd2F0Y2g6IHtcXG4gICAgICAgICd1c2VyaW5mby5oZWFkaW1ndXJsJzogZnVuY3Rpb24obmV3dmFsKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxzLmltYWdlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ3hsaW5rOmhyZWYnLCBuZXd2YWwpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBoZWFkc2l6ZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTQyICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGhlYWRib3JkZXIoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDcwICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDcxICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE0NiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XFxuICAgICAgICB9LFxcbiAgICAgICAgaGVhZHN0eWxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCAnICsgKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggLSB0aGlzLmhlYWRzaXplLndpZHRoKSAvIDIgKyAncHgnIC8vXFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm06ICdzY2FsZSgnICsgdGhpcy5oZWFkc2l6ZS53aWR0aCAvICg2NDAgLyAzICogdGhpcy56b29tUmF0ZS54KSArICcpJ1xcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnLCcgKyB0aGlzLmhlYWRzaXplLmhlaWdodCAvICgxMDA4ICogMC4xNykgKyAnKSdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIHNob3dNZXNzYWdlKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpIC8vIDXku6Pooajog4zmma/mlbDnu4TnmoTmnIDlkI7kuIDkuKrvvIzljbPmmL7npLrlhYXlgLznmoTog4zmma9cXG4gICAgICAgIH0sXFxuICAgICAgICBjYW5jZWxiZXQoKSB7XFxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXFxuICAgICAgICB9LFxcbiAgICAgICAgY2hlY2tEYXRhKGV2ZW50KSB7XFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coL1xcXFxkKy8udGVzdChldmVudC50YXJnZXQuaW5uZXJIVE1MKSlcXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTC5yZXBsYWNlKC9cXFxcRCsvZywgJycpXFxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQuaW5uZXJIVE1MKSB7XFxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG1vbmV5ID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LmlubmVySFRNTClcXG4gICAgICAgIH0sXFxuICAgICAgICBjaGFuZ2VEYXRhKGV2ZW50KSB7XFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxcXEQrL2csICcnKVxcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5zdGF0ZSB7XFxuICAgIGhlaWdodDogMTclO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYm90dG9tOiAxZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxudGFibGUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuc3RhdGUtaXRlbSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMuMzMzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2Lm1vbmV5LXN0YXRlIHtcXG4gICAgcGFkZGluZzogMCAxZW07XFxufVxcblxcbmRpdi5wb3J0cmFpdCB7XFxuICAgIHBhZGRpbmc6IDA7XFxufVxcblxcbmRpdi5wb3J0cmFpdC1pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL3RoLmpwZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LnBvbHlnb24ge1xcbiAgICAvKmNsaXAtcGF0aDogcG9seWdvbig1MCUgMCwgMTAwJSAyNyUsIDEwMCUgNzMlLCA1MCUgMTAwJSwgMCUgNzMlLCAwIDI3JSk7Ki9cXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLyogICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nKSA1MCUgNTAlIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXFxuICAgIG1hcmdpbjogYXV0bztcXG59XFxuXFxuZGl2LmJ1dHRvbi51bmRvIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBoZWlnaHQ6IDQwJTtcXG4gICAgcGFkZGluZzogNSU7XFxufVxcblxcbmRpdi5idXR0b24gc3BhbiB7XFxuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cXG59XFxuXFxuXFxuLypkaXYuc3RhcnMtYnV0dG9ue1xcbiAgICBwYWRkaW5nOiAuOGVtO1xcbn0qL1xcblxcbi5tb25leS1pY29uIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xcbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICAvKmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7Ki9cXG59XFxuXFxuc3Bhbi5tb25leS1pY29uIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblxcbi5tb25leS1udW0ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFZQUJnQUFELzJ3QkRBQW9IQndrSEJnb0pDQWtMQ3dvTUR4a1FEdzRPRHg0V0Z4SVpKQ0FtSlNNZ0l5SW9MVGt3S0NvMkt5SWpNa1F5TmpzOVFFQkFKakJHUzBVK1Nqay9RRDMvMndCREFRc0xDdzhORHgwUUVCMDlLU01wUFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMy93QUFSQ0FFc0FTd0RBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEMXhqVGQxRFVsQUM1b3pTVWxBRHMwWnB0RkFEczBacHRGQURzMFpwdEZBRHMwWnBNVVlvQVhOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TkdhVEZHS0FGelJta3hSaWdCYzBacE1VWW9BWE5HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TlBEVkhpbkNnQkRTVXBwdEFDMFVVVUFGRkZGQUJSUlJRQVlvSHBSMHJLOFI2N0Y0ZjB0N2s0YVp2a2hUUDNtUDlCUUJYOFNlS3JQdzdHRmNHYThZWlNBSEhIcVQyRllPai9FeUtXUVI2cmJpQWsvNjZMSlVlbVIxRmVmM1YxTmUzY2x6ZFNOSk5JY3M3ZFRVV0txeE56M3lHYUs1aFdhQ1JaSW5HNVhVNUJGU1lyeHJ3MTRudXZEMTBBcE1sbzUvZVFFL3FQUTE2N1kzc09vMlVWMWJTQjRwQmtNT1B3STdHazBOTXNVVVVVaGhSUlJRQVVVVVVBRkZGRkFDMGxGWTNpYnhKQjRjc1BNYkVsekprUXhaKzhmVSt3b0FzNnRyZGxvc0FtdloxUlQ5eEJ5em4yRmNWUDhBRStmN2NqVzlnaTJnT0dEdDg3RDF6MEZjWnFPbzNPcTN6M1Y3TTAwckhxZUFCNkFkaFZjQ3FTSmJQY3RIMWkwMXl5VzVzNUF3Nk1wKzhoOUNLdkUxNGxvR3VUNkJxYVhjT1RHZUpZK3pyWHM5bmN4WDFwRmRXN0I0cFZES3c5RFNhR21UVVVVVWhoUlJSUUFVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQlJSUlFBQVpOZVdlTGJxZnhINHdUVDdUSldKL0lqeDAzZnhOL24wcjBqVWI2UFQ3S2VaeUEwY0R5cVBvUDhTSzRENGJXWnU5WXZOUmx5endyZ0UvMzM2L29EK2ROQ1oyVVhoWFRVMFJkS2UzV1NFTHl4NFptL3ZaOWE4eDhUZUc3anc3ZEFNeGx0SkQrNW14d2ZZK2hyMGZVdkVRdFpkWXQxSUV0bFppVlQ2c2M4ZitnMVBaMmNHdGVFclNHOFVTUlMyNmJpZXVjZFI3NW9UQm84WTRJcm92Qi9pZDlCdmpGY3NUWVRrZVozOHR1ekQrdFp1dTZMTm9XcHZhVDVJKzlISUJ3NjlqV2QzR2M0OXFyY2s5L1ZsWlF5RU1yRElJUFVVdGVmZUFmRlFWVjBlL2ZIOE50STMvQUtBZjZWNkNEeDcxTFJhWVVVWW9wQUZGRkZBQjBvb3FPV1dPQ0o1Wm5DUm9DV1pqZ0FDZ0N0cStxd2FOcDgxNWRFZVhHdkNqcTVQUUN2R05VMVc0MWkva3U3cGp2YzhKMlFEb0FQU3RMeGQ0a2Z4RGZnUkVyWXdraUZmWDFZL1dzRE5Va1EyTGdIdml1ajhMZUVKdkVFbm5UTzBGaUR0OHpIelNIdUYveHJQOFBhTExyMnNRMmNaS3huNXBYL3VvT3RlcGFxOGVrcG8wVnNCSENMeElsUmVnVXF3b2JCSXdQRW5nS3pYUnpMcENOSFBicnVLRnR4bEhmOGFiOE10WDh5M3VOTGtiT3crYkZuMEo1SDU4L2pYWldOL0ZmaWRveU5zTXp4TjdsVFhuVFFEd3Y4U292TEcyM2xrQkhwc2ZqOUNhVzR6MCtpbzRKa21qM0kyNEJpcFB1RGcveXFXa1VKUlJSUUFVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQlJSUlFCd1B4SXYzdHJtMmhVbmJQYXlSa2ZWbFAvc3RYZmhuRUY4UDNNdVJtUzRJL0lBVmxmRk9QL1M5TmsvaE1jaTVIcmtmNDBuaGJXLzdIOElDNXdXaWcxQUxPbzY3SFhyK0I1L0NuMEo2bUo0c3U1VThXYXNGY2dTZnVtSHFNRC9DdlF2QXQydDM0VHRCbjVvdDBSSDBQK0dLODQ4V01rbmlpOWxoY1NSU3NzaU92UWdnR3QzNGNhdUxYVVp0T20rVkxyRHhFLzN3T240aitWTmdqcmZGbWdKcitrdWlBZmE0c3ZDM2ZQOEFkL0d2SFNyS1NyZ3F3NElQVUd2ZmhnL1N2S2ZpRnBhYWY0aDgrTVlqdkY4ekE2Qmh3MytQNDBrd2FPV3hqbm5QWGc0TmVnZUdmaUVrY0sydXRNK1VHRXVBTTdoL3REcm4zcnorazZWVFFrejFLNStKZWxSc1JCQmRURDFDQlIrdFo3L0ZGYy91dExKLzNwc2Z5RmVmVW5XbFlMbmZINHB6ZjlBeVAvditmOEtraitLUzUvZTZXNEhxazJmNWl2UHNVWW9zRnoxTzErSldrU245OGx6QmdkU203K1ZjbDRxOFl6ZUlHK3oyNnREWUwvQWZ2U0hzVy93cm1NWnBhTEJjS1E4ZldscmE4S2FJMnVhNUZFNC8wYUkrWk1lMjBkdnhQRk1EdnZBT2lmMlpvYTNVeVl1YnZEblBWVS9oSDlmeHFoOFJkVCt4UzZTa2ZMeHltNHg5T245YTdaaWtTWkpWSTFHU1NjQUFWNHg0cTFrYTVyczl4SGtRTCs3aC93QjBkL3hPVFVvWjNIdzFsYWJSN3d5RWxqZE14SjdrZ0dxSHhPdC9LbjAyL2o2cXhqNDlRZHdxTHdycVEwVHdSYzNBdzA5eGNtSzNUdTBoQUEvQVZyZkVHM1AvQUFpRVJjNWFHV1BKUGM0d2FPb2RDejRFdkd2ZEFhVno4eHVaU1FmYzUvclhTNXJrdmh3b0hoY2tuQmU0Y2dmUUN1c3BNcEMwVVVVQUZGRkZBQlJSUlFBVTRVMm5DZ0JEVGFjYWJRQXRGRkZBQlJSUlFBWm81N2RjVVpwT2xBSGxYaXU3OCtPNHNKeisvd0JQdlhLWi9pamZuOUQraEZVdkRVd3VMUFZOSWRnRGV3bG9jLzhBUFJPVkgxUE5iSHhLMG93YXBGcUtBK1ZjRFkrT3pqL0VZL0t1TWpkb1pGa2pZcXlFTXJEcUNPaHFpQnF0bkJKSjQ5ZWxiK2l5V09wSkRZM3R4OWl2SURtenZWNkE5UWovQUk5RFdGSko1c3J1UU1zY25IclRQeXBnZTcyVFhLV0NIVVBKRXFqNTVJMitSLzhBYTU2WnJ6WHgvcmx2cTJwUVFXYkxKRmFncVpGNURNZXVENlZ5NXVaekVJbW5sTVk2SnZPQitHYWpQTkpJYllVVVVVeVFvb29vQUtLS0tBQ2lpaWdBR004NXg3VjNQZy94Um91amFjTGFkSm9wNUczU3pGUXdZOXVuSUErbGNOUm1nWjdMcUYvbzJyYVJJODJwUm14QTNUQ09UYVdIOTA5L3c3MTVQcTk3RGY2akpOYlFKQmFqNUlZbEdOcURwK1BlcU9Ncmc5YVh0ajBwSkEyZEY0U2pOL3E5c2JxWUpZNmFHdUdMY0l2T2YxYkg1VjFuaVRVbDFqd0JlWGlwdGdlVlJCdTZzb1lEZCtKelhuMmwydDFxVThlbVdwZi9BRWx4a0Rwa2R6N0FacjBmeHJicFllQjQ3QzJRa2VaRkRHcWprNFBZZmhReG96L0FVNWx1YlcxUW55cksyZVNVanA1a2pkUHdVVjNaR1RXRjRQMEgrd2RJMnkvOGZVNTh5YkhPUFJmd3JlcE1ZVVVVVWhoUlJSUUFVVVVVQUZPRk5wd29BUTAybkdtMEFMUlJSUUFVVVVVQUZIV2w2VlQxRzV1b0xmRmhhbTR1VzRWV08xUWZWajZlMUFGUHhOTHBTNk5ORnJFcUpES01BZnhrOWlvN212R0pOZ2RoRXpOR0Q4cFpjRWpzY1YwZmlUVFpZYnQ1OWQxZU9XK2ZrVzhJM2xmUWRnb3JtdWhJeFZJaGhSUlJURUZGRkZBQlJTVXRBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBU1c5elBaeXJOYlRQRkt2M1hSaUNLN1BSZmlEdmxnVFhZQk9Jam1PNGpUbERqR1N2Yzg5UlhFVWd3RGtnbjZVV0hjOTdzN3kxdjdkWjdTWkpZV0dReUhJcVUxNUg0YjFHQ3l1ZzFwcUV1bTNEa0JsbkhtUVMrell3UjlhOVdzNUpwN2RYbWlWSkNPZGpoMWIzVTl4VXRGSms5RkZGSVlVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQ1ovS3VMOFErTEx1NGFheDhPeHlTZVdDSjd4UjhxWTZnSG9QclhZWE1jVWx2SXM1eEVWTzRrNEdQYytsZVZlSy9GSTFJL3dCbmFXb2cwdUk0Q29Ob2xJN2tEdDZDbWhNNXR5enlNWkczT1NTV0p5U2ZyVFR4UjFvcWlBb29vb0FuMCt4bjFLOWp0YlZBMHNod29MQWZxYTYrMitGOTg2ZjZUZXdSUDNWVkw0L2xYUGFQb1VtcVlkWnhDRk9jaUo1Ry9KUWNWM0dudytKcktIRm5xVUdvb28vMU56RzhiWTlpdy9yU1kwWmMzd3R2RkdZdFNoWStqSXdIOWE1N1d2QzJwNkNpeVhrYUdKamdTSTJWejZIdUs3VWZFTmJLYzIrdGFWY1djeS9lQ25jUHFBY2NWc3czMmwrTWRIdXJhMms4MUdYYTRaU3JJVHlEZys0Rks3SFpIakZCNHFXNnQzczdtVzNtR0pZbktOOVFhaXFpUmFDYVFjMVowK3drMVBVWUxPQVprbWNLUFlkeitBb0Fsc05FMUxWRkxXTmxOT29PQ3lyeCtmU3RBK0N0ZkF6L0FHYy8vZmEvNDE2MXAxaERwbGpEYVd5aFlvbDJyNytwL0dwcHBvcmFNeVR6SkhHT3J1UUIrWnFibFdQRWJydy9xOWtoZTUwNjVSUjNNWkkvU3FCNDZqQjlEWHMwMS9hYTBoZ3N0WG5qWG96V3Fubi9BSUZqajhEWFBhaDhNWXBVZVN6MUdiem01LzBnQWhqN2tkS2R3c2VkQ2lyV282YmRhUmZ2YVhzUmpsWHNPUVIySVBjVkhhUXhYRTRTYTRTM1VnL082RmdEMkhITk1rZ0F6UzA1MVdPUXFySTRCNFpTU0RXdGRXVnZjMkl2YkxTNzYyajVIbUJ2TmlKSFh0bGYxb0FxYWJlVzFwTHR2YktLN3QzUHpLY3E0LzNXSFN2VVBDY1ZxbHNzdWo2aEpOcHJjRzJuNWFCdlFIdDlPaHJ5SUhQcDYxM1hnM3lMbVlYT2t5ZlpOU2pYOS9hRnYzVnlucU0vZFA4QUkwbU5IbzFHYVJjOVQzOVRTNHFTd29vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BS0tLS0FNYnhOYkc5MDU0cDd3MnVucUM5MUlvK2QxSFJSOWZXdkg3MldDYTVKczRQSXQxT0kwems0OVdQY212US9pRE5kWGtSc0xSVDluZ2orMFhrbWNLQi9BdWZVbnQ5SzgwNmNZQXhWSWxoUjF4MnpVdHRISExNQk5PSUU3dHRMSDhBT3RkUHBkNTRYMDVjeXRkWExqcUpiVkNHUHB6azB4SEppclduV0UycWFoRFoyMjN6cFNRdTQ0RkdvWDdhaGV2UDVVTUFKK1dPSkFxb1BUaWpTNzV0TTFhMXZGR1RESUhJOVIzL1NnUjZWcHR6cjNodlMwZ3ZOTlM5Z2hYQWtzM0c4RDNYdjhBV3M2NytLSTRGanB4SjdtYVRINkN1MysycTFpdDFhSjlvalpSSW9qUExLZlFkL3BYanV2SlpRZUlwSmJWdk10SkpQTjh2QlZsNXl5RlR5RG5OU2lpN3JmakQvaEliVHliN1RvUk1uTWN5TWNvZng2ajJxcDRUMWg5RzhRUVM1SXQ1RDVVd0o0Mm52OEFnY0d0RlBETnRIZXJxQXU5UG4wZkpsUG1UYlcyOWRwVWM3cTVac2IyMmphck1jRDBIYW1JNlB4L1ovWi9GYzdnREU2SktNZTR3ZjVWeldLMy9FMTZOU3RkR3V5ZjNwdFRGSi92S3hGWU5OQUZkdjhBREd3V1cvdXI0ai9VSUVRbis4M1g5Qit0Y1JYcVB3MGlWUERrcmdnczl3MmZiQUZKZ2plMTNXcmZRZE1rdkxqNW1HRmpqQndYWTlCWGsxeDRnbDFQVlZ1OWFWN3FGRGtXNnZ0UWVnSG9QV3UxK0lVa1VTd1NNcG5uUkNZMGIvVnhaUEx0Nms4QUQ2MXhtaWFYYjYzSGMyNXVvWUw3Y0pJVE1jTElPZHk1N2RxRU5uU3hmRXVTMFNPTnRGV0tIYU5pcTVYSTlnUmpGYkZuNHh1OWNqS2FMcE1yeWpobnVIQ3hSbjNQZjZWeSt0NlcxaG90cHBrMTJ1b2F2TE12bFJ4dVdFS1l4dEI2OGsxNkRvR2tyb3VqVzFpQ3BralhNaEhkenl4L09reG84eDhYNlhyRnBlTGVhMUpGSTl4a0swYmZLTWZ3NDdBVmhXMXcxcmN4VFJIRWtiQjFQdURtdTMrS0Y2cjNsbFpnZ3RFaGxiSFl0d1A1Vnd1TS9kNjFTSk43eElSY3V0eWx6cDF5cmNzMXNubHVNOW1YdjlSbW5lR0xneHBjQ1c2MWEzdGxIeXZaRWtLM2ZjdjBxOXFPMXZET25UYWxvNE1SZ0FqdjdlVEVpbnR2R01mbitkWlBoclU3alJ0V1M3aVdkNEVPMmZ5MUp5aDlmNTBnSTlZaWdrbmE1dEw5YnNINys2THlwQi92TDBQMUZhL2d1eFRVUktiT1Q3UHJGbXdtZ2NuNVpVUEJWaDZkdnhxL3F1bytITmZqSlM3V0dYcXJYVnR0NS8zMTVINDVyQTBhNWw4TitKYmE0bEk4c1B0WmtZTWpSdHdTR0hCSGY4S0FQWTBkbmlSbVhZeEFKWCs3N1U2anJ6a0VIb1JSMXFTd29vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BVVVob3pta0hYR2NVQWNSOFM5UkVHbndhZEhnTmN2NXNtUDdxOU0vVS93QXE4NFVGaUZVRmlUZ0FESk5iSGkzVS93QzEvRVZ6TXJaaVErVkgvdXJ4L1BOVk5LMG02MU9ZbUJsaGlqLzFrOHJiWTR4N3Q2KzFVaUdibWthTHBscXF5NjVjV3NUbjV2SmtsM0VEM1JlZnpQNFZUOFU2bFpYTjBsdHBNY0VkbkNvK2FLUGI1cmR5ZStQU3V2MHp3dHBXa2FQTHFFY1oxRzRTTXRHOGtad3pkZ2lucnozcno3VTdKN0c4TU55NGU3NnpxdklqWTg3Yyt2cjZVSUdNMDdUcnJWTDJPMXM0V2ttYy9kSFFlNVBZVk5ybWt5YUhxa3RsTklKSkVWV0pVWUJ5TThlMWRSNFRsZUNaTk4wVUo5cm1HKyt2bVhjSVZIOEtnOWNmeitsYlBqcnc0ZFIwbU84dFEwbDFhRDVzL2VrVHY5VDMvT2k0V09aOEkrTEw3UjR6YlBiVFhkaUR5cUtTMFdmUStudFhhU1dXZ2VNRTNQQXhsQSsrVWFLUWZqMy9BRnJ5aXp2cm14bVdlMHVKSVpGNk5HMkRYVldQanpVWEFXLzFVeG9PdmwyYXV4L0hJRkRRN214SjhMN0JuTFJhaGN4ajBLSzFVZFYrR3JXMWxKUFkzclR5UnJ1TWNxQWJnT3VDS3ZXZmpmejVCYWFQWlh1b1hMOVh1SEFIMU9PZ0g0VlA0azhaSnBPbW0waXVJcmpWSFRhNWlIeXhFOWZ5N0NscUdoNWdYTElFM1pWU2NEMHpTVVk0R2NaOWFLb2tLNzc0WWFpRmt2dFBiK0lDWkJuMDRQOEFTdUJHTndKR1I2VnZhS3gwVFY5UDFhSXM5azhubHRKL2R6d3lONkVaejdpaGpSM1hpZlFyanhIcVZwYUxMNUZyR2htbWxBeVNlaWorZjBxQWZEVFJ0Z0RTM3BPT2YzZzUvU3VxbmZBMlFtTnAyVW1KVzZQam5GWThIaWVPL3RuRmlrWnY0bS9lMk03N0pPT29CUEJQcDIrbFRjb20wand2cEdobnpMTzN4T1JqenBHM1BqMlBiOEtwNjc0ejAvU0luamhJdTcwOExGSHlBZjhBYVA4QWsxU3V2R3R1c2hqRTgxaGNyOSsydmJVbGZ6SElyTm4rSkQyNElYVHJHWmgwZEhZRDlRRFJZRGl0UXVMcTh2SmJxOERtYVk3eVdHTS9UMnFiUmRHdU5jMUdPMXRWUFBMeWRvMTdrbXJEUmF0NHIxWjdsTGFTZDVXNUtqQ0tCMEdlZ0ZlbStHTkJrMFN3Mnp0RUpYSHpKQ3VGWDhlckgzUDRVMnlVZzFEUnJpTFRGaTBpUlQ1Y1FqTnJQODBNeWdkUFZUNzVyekhUTlhrOFArSVB0TUVieFJveFNTQmlTZHZkVDlQNlY2WnFHdXplSDcrTmRTSG1hZGNOdGl1d09Zai9BSFhBNmowSXJsUGlGbzhTNmhhYXJDeUxCZUhaSklPVkRkbTQ5Ui9La2huVGExcEdoYWpZcmRUV01ycElnY1Qyc2Z6QUhuSngvZ2E4L3dCUjhQUnJFODJqWDhlb1d5WkxvcHhMRVBkUDZpdlFQQmNseGI2SkpZM2lONTlrK3phdk81RDh5a0h1TUhpcWVyNmRvbmlPY2kydW83TFdFUERIOTNJVDZNcHhuNjBKaFkwdkJ1cS8ycjRidDNadDAwUDdtVDErWG9meXhXN1huSGd1ZTUwTHhUYzZScUtlVzF3TzU0M2prRWV4R2E5SHlEeUtHTkJSUlJTR0ZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZZM2l6VmhvL2grNW5WZ0pYSGxSZjd6RHIrSFd0azRBOS9TdksvaURyaWFqcW9zb1d6RGFmTHgwTWgrOStYU21rSnM1VGtrS3ZKUFQzTmQ3NGQwZTAwMW9FMVF0ZTZpUnZpc0l2bUVIKzA0NkErNTZWeWVnNmJkNnJxMFZ2cDV4S1BtTW5hTWYzai9uclhwdG0yZytEN013TmV3ck1lWlpHYmRKSWZmR1QrRk5zU1JyYWplalR0S3VieVZRREJDWk1kZWNjQ3ZESkpXbmxlUmlXZVJpekU5U1RYcUhpclYwMUR3WmV5MjhOd0laQ2lyTEpIczh6TEQ3bzZuOHE4MHY3VTJONDF1VDg2QUNUMllqSkg0ZEtFRFBRUEJ6V25ocndoTnExOFF2MmhpZjlwZ09GVWZVNU5kUG9NOTVmV1gyNitYeXpjRGRGQUR4R25iUHFTT1RYQVJLZkVHczZMb2d5YlN6aFF5QWRDY2JtSi9sWGErSXRZYXdGcnB0amdYMTZ3aWlBNlJMMEwvZ09sSmpSbjYvNEJzTlZsYTRzM0ZuY3R5eFVaUno5TzM0VndPcStISmRKbGVPYTlzWGRmNFVtTzc4c1Y3RDVzTmxHSU0vSkRENWpNVDkxUjNQMTUvV3FGMUJaYWxvc1Z4cTFwRE1aUUdDdXZJTEg1UUQxN2loTVRSNDJ0eE5IRzBVY3JvamZlVkhJRGZYMXFJRDg2NmJ4cjRaaThQM3NMV3U3N05jQTdWSnpzWWRSbnVPYTVycFZDQ2lpaWdRZ3gzNlZ1YUxPdGlEOXBCbTBpOC9jWFFYckVleDltQjVCN2lzVEZhZWszRGFlNW5taDgvVFp6NUYwblVFZjBZZFFmYWdaNjROUGE3MFNHMm1tSmtFYTdMaEQ4d0krNjRQcjBOZVRlSWJxN20xRjR0VGhRWDhEYkhuUWJUSUIwSkhROFl3YTlPOE0rYmFXcDB5U1VUUlFLSkxTZi9ucEEzM2Z4QjRQNFZ5L3hOMG5aTGJhbWk0My91WnNlbzVVL2xrVktHY2hhUlNhcE1zVnhxTWNKWDdyWFR0dC9QQnJxTkk4QlhVc3kzRUdzV1cxRHk4SUV1UDZWTDRVOEJ3MzFsSHFHcU01aWwrYU9CVGdrZGlUNytsZWdXdHBCWXdMQmF3eHhSSjkxVVhBRkRZSkVXbldMMkZ2NVUxMVBkTnhscFFvSDRBQVlwdW92ZVc4Um1zWWxuS0RMUUU0TGp2dFBadnIxcTNJQ1VieThlWmo1ZDNUUHZWRFN0WmgxVXpRYlRGZVc1SzNGdTUrWkQvVWVob0tLNlQ2ZjR3MEthR0ppVWRTam93dzhMZHNqc1FhNEtLZWQvQytxNkJmOHk2Y1JMQ1QxQVZzTVAxeitOYkhpVnBmQ0hpbURXYklFVzE1a1R4TDBZajd3L0VjajNyTDhibExYWDQ5UXRTRERxTnBuSTc1WEIvcFFpV2RiNEMxRDdmNGFpMzRNMXNmSlk5eW8rN244RFdqcTJsYVY0Z1ZvTHNSeVN4RGhsWUNXTSszZitsY1I4UGRadE5KUytUVWJsTGRaQWpSbVRJREhuT0s2TFdMYncvNHFWVERxVUVkNm5FYzhNZ0REMlBxS0dNNVB4UnBPcmFDOXRKTk05MWJ3T1BzMTIzM28rY2hXNy9oWG8yaTZwRnJPazI5N0VRUE5YNWxIOExkeCtkY0xjM1BpTHczYnZiYXREL2FlbHlmS3hmNTFaZlp4eUQ5YXJlRC9FZHZvbXF5V3BrYit5N2xzcVpPc1RkaWY1SDg2SHFKSHFXS0tGWUZRVk9RUmtFZEtEelNLQ2lpaWdBcHdwdE9GQUNHbTA0MDJnQmFLS0tBT2U4VTZ0ZjJkbTBPbDJOelBjU2phSlVqSldNZXVlNXJ5cDlNMUJDVExaWFdUMXpDMytGZTdNQ3lGUWNaSFVkcTVMVzlLOFZwdWJTOVplYU0vd0RMTnRzYmo4Y1lQNlUweVdqZ2JiKzJyYXdlMnRZTHFDR1E1bFpJeXJQNlpiMDlxZ3NOVGwwaTRMeFcxcTh3UERUeGJ5djY0cTNxVmw0a2tmR3BRYWpLQWVqYm1INmNWVmpqT25zSk5RMHQ1RkorVlppNkEvbGpOVUk2N3c5ZjYzNHkxT0ZMMTFPbTI4aXlTaFl3cXN5OHF2NTl2YXVOMVNRemFyZU94NWFlUS84QWp4cjBYd25xZXNhb3NaZ3NMUFQ5TGo0RHFoeS9zb3orcHJnUEVOcWJMeEJmUUhCMnpNd0tuSXdUa2Z6cEliT20rR2NZKzM2aGVTRWZ1WVJsajJCT1QvS3BQQzEwL2lQNGdUNmpKbmJFak5HcDZLdjNWL1Ftc1RSYjhXUGhUWEFyWWxtTVVJOWNIZG45QWExUGg1SXR0RnJWMTNodGdSK3AvcFF3UnNlSU5SM2VINzJWVHpxTjRMU0xCLzVacWR2SDVOK2RhSGlXNUVlbytIOU9IQ3kzYXN3SG9nNEg1L3lya2ZFRTVnc3ZDOW9UOXlOYmhoN3N3LzhBcjFwZUxMM2I4Uk5JVS9kaE1mOEE0ODFJQ3Q4VDdzdnFWblpqcEZFWkQ5V09QNUN1SUZkUDhSR0o4V3lqKzVHZy9TdVh6VFFoVFNmV2w2NC9yV3JwMzJlMjVrMU5JR1BhSzI4MS93QXlNVXhHWWtjai9jamR2OTFTYTF2RDkybGpxSGthakUzMkM3QWhuVjFLakI2TjlRZWMxMU5oZVpBQ2FyNGxjZjhBVE96QVgrVmRCYXpGeUZrMUM2ZE9teStzUUFmeHdLVngySWZDeVNhYk5kNkpjbmZMWW5mYnlIK09GK242MWM4WVdJdi9BQXZmSi9HcWVhdjFYbitsVFhkc1YxWFRyOUJsaHV0NU52QUtNTWo4bUEvT3JWM0lxcWtVZ0dMaGpDTStwVS80VWlpdm9ENThNNmUvL1RxaC93REhhc1EzZjJqVFV1bFVrTkdKTUtNbnBuZ1ZsNmRjL3dCbTJlaDJFbldXM2RUbnR0VElwZkJ0dzF4NFZ0SEo1WGNvL0JqUUJyUTNNVnhiSmN3eUswTEx1VndlQ1BXdUw4Y1J6NkxxMWw0aXNEdGZjSXBjY2gvVFBxQ09LbXRMNCtHUEdNdWwzQi80bDJvTjVzTzdwR3pkUVBZbkkvS285V0pPbmF4NGV1U1dhQ0g3VlpNVDFqQnp0LzREeVBwUWdaWThYU3hhOTRDVy9nR1VVcE1QVWM0WWZxUitGY0xmM1p1dkRXbElUODl0SkxFTTlkdkREK2RiSGgrL2FUd0xyMWl4NWlqRXFBK2pIbjlSK3RjOXBWcytwNmxhV0NaL2ZUQUVEdDB5ZnlGTkVucGxucE9temVEdE1zOVdWRkJnQlZ5Y01oUFBEZHV0Y0Q0azhKM25oK2JjeStmWnNmM2M0L2syT2hydC9GT3NhcDRjZU9TT0czdk5KbEhsK1hLbUNoeDkwa2R2VGl1WnU5YmtodEd2OUF1bmlzeTJ5NHNKZ0pGaEo2WUJ6OHBvUXpuYmJWdFFzQVJhMzA4SVA4S3VjZmwwcTlhYVJxL2lPWVBEYWw4OVpTZ2pYNms0R2FzYWQ0cGVCeDVPaTZaTEt4NnBiSE9menJ1dEp1UEUycTdYdjBnMHkxSDhLUjVsWWVneVRqOGFHSkYvdzNvMXhvV21MYjNWN0xjdHhnZndSK3k5NjJLYUJoUVBTbHFTd29vb29BS2NLYlRoUUFocHRPTk5vQVdpaWlnQUZRM2YybnlHTm9ZQkwvRDUyZHY2Vk5TWXpRQnhPcUh4MCs0UXJickdlOXF5NS9Oam11Zmk4TGVKN204RTg5ajUwMmM3N3VVTVAxTmVyOWV0VnRUbit5NlZkempySEE3RDZoVGluY1ZqeUc4MXZYTDY0Rms5OUs1RCtVRWhZS2hPY0FER09LdCtKb05Hc2JLMXNMTnpMcU52a1hFcWNxeFBMQW51UWVsYzRra2tiN2xabGNjN2gxelRhb2trRGtSdEhuNVdJSkhxUjAvblhRZUdadkowUHhHdmMyWUkvUEg5YTVzbXREU3JrUXc2bEd4NG5zcEV4NzhFZnlvQXYrTUpmK0p4YlJyOTJDemhVRC9nSVA4QVdrOFhYLzJueEY5cmovNTVRdXBIcnRCL25WTFhwdk8xZVIxUC9MT05meVJSV2V6dEpqY2M0QUhQb09CUUIwSGpXNEY5ck1WNm4zTG0xaWtINWMvcURYUFZMSmNQTERGRzV5SWxLcjdESk9QMU5SazBBVDJjdHRGSUh1clo3bFY2SUpOZ1AxT00vbFcvYStPSmRPQVhUOUkwMjJYMmpMTitlYzF6Sk5Cb3NGenRZL2locVFQNzJ5dFhIK3p1WCt0YStuL0U2eW5ZQyt0NTdmSndYWDk0ditOZVo1cHA2MHJCYzkvamRKNGtsUWhrY0JrUHFPeHJuL0Z0NTlqbTBWYzh2cUNIOEJ4L1d0YlJUL3hJN0F0L3o3Ui95cmcvR2VwQzk4YVdGbkd3OHUxZEEzcHZMQW44aGlraWkvNHgxWVdIaTdUQmtCTFdHUm14NnNDUDZDdGp3Q2hYd2RaaHY0aTdjKzdHdUhsdHBQRzNqTzUrejdoQVpPWkQwU0plTS9VNDQrdGVxVzF2QnA5cEZid0tJNFlsQ3FNOUJRd1J4L3hOc2ZNMDZ6dmxHSGdsOHZJNjRZWi9tUDFySTEvVUd2TkcwVFhGL3dCZUZlMW5BL2k0d1FmcnorZGRqNDBnVzQ4SlgrZXFLSEgxQkZlYlc4NWw4RzM5dXg0Z3U0cFY5dHdLbitWQ0V6UHNMdzJsdGZSS1R0dUlQTC84ZUIvcFhTK0NyVmROdW9OUnZsYUpMMHRiV3MvWkg5U1Bmb0RYSDg5UWNWMHRwcUQzdmdPL3NwWEpheGtqbWhQY0F0akEvSCtkTVNOclY5WU9vNlpjUjNhcXNpdWJLOVFkRmNaTWNvSDFHUHhya2ZEay9rZUlMTU1xUEZKS3Nja2JESWRTUU9SK3RHcWFpMXhxTjVLcDR1MVhlby92WVUvekZiTmxwT2RUOExUUnJqN1dvWno3b3g1L0lDZ0QxR0cwdHJjSHlJSW9zLzNFQy95cVhyUWZRMEFWSllVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQldiNGpWbThOYWtGNm0zZitWYU5SM1VIMnF6bmdKNGxqWkQrSXhRQjR4cXRpYkhTOUlEY1NYRVRYRG42bkFINUFmbldWWGIvRU93S1htalFSanJDSUZJOVFRQi9PdVkxMnpYVDljdTdSUHVReWJCK0FGV2lHVUtVSEJwS0tCRHBaREpJWFBmSDhxYUtLVEZBQzBVVVVBRkZGRkFBS0QwSjlxS2tnZEk3aU41a0x4cXdabEJ4a0R0UUI2N3FPc3hlR2ZDMXM4bTB6K1FpUXg5MmZhUDBIZXZLYlMxdmRhMVJZNE4wdDFNNVl0bnZuSkpQYXJza3VxZU1OWUdGTXM3OEtvNFNKZjZDdlR2RGZocTI4UFdtRUt5M1VnL2V6WTViMkhvS25ZcmNsOFA2QmIrSHRPRnZFQTByY3pTa2N1MytBN1V6eFZjTlorSEx1NWorL0Rza0gxRHFhMURNbVpQbTVqR1c5aFdENDdtQ2VEN3c4ZlBzVWZpd29ReTM0Z2xXYndscUVvKzdKYWxoOUN1UlhrTnRONWVtMzBYL1BUeXYwYk5laTZyZUJQaGZHN0g1cGJXT01mVTRGZVhrOFlCNE5OQ1luYXJOcmRlUmFYY1FiL1hvRXg5R0IvcFZjQ2w4bHpFWlFoWkE0VEkvdll6aW1TWDdyU2pCb2VuWHlaSnVua1EvN3lrWS9UK1Zlc1dHaHJiUmFOdUEzV0VESitMS00vd0JhcDIzaG5kcDNoKzNtVWJMRW1hVmY3ekVjRDh6K2xkSWFsc3BJS0tLS1JRVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQmgrSmROKzNTNlZPRnliVzlSbS8zU2VmMXhYQ2VQTlAyZU1TUU1DODh0Z2ZjNFUveXIxY2pqdFhLK085TE4xWVdtb3hydWxzWlZaZ092bGtqUDVVMHhOSGxrOExXOXhMQytROGJsU0Q3SEZSbXVtOGU2YjlnOFJ2Y0tQM0Y0UE5Wc2NaL2lINTgvalhNNXpWRWkwVVVVQ0VOYm1pNlpaM1doYXZlM3UvL1JVWHk5aDUzazhEOGF4RFczcGJodExoc2MvOGZPcFJnajFWUVA4QUdnWS9VL0IycGFaYXdUemVTNnpsVlZVYjV0emRGMjl6Vk81OE9hdlpsQmM2Zk5HWkhDSU1mZVk5QUs5RG1rR3FmRWFPM1A4QXFOTGdNZ1hzWkQvK3Y5S2ZZeUhYUEcxeGNNU2JUU1Y4bU1aNE1wKzgzNGRLVngyUFBoNFUxMXp4cFZ6K0s0clQwMzRlNnZkekw5c1JMUzN6OHpPd1ppUFlEK3RlaVdlcUxxR3MzMXRBY3dXUUNNMzk2UTlSK0FINjFva1k0Rks0V0tPajZKWTZGWmlHemlWQVI4N25sblB1ZjZWZUhXczdXTG94aTB0RS93QmZkekJBQjFDajVuUDVEOWEwdXZJNDdVaWpDTjEveE5OZmlKNGd0WXpuL2dEVnpmajdVTjNoYlNiY25MM0twSzR6MlZQOFRRK28rWmFlTWIxVG56cEV0WXo2bmxmNjF6ZmlPK1RWTmJpakQvNlBicEhiS2UyRjRZL25tcVNKYk5meGRkbTM4TWFIcFA4QUdJRm1rSHB4d1AxTmNiakZYOWExTnRYMVdhNjVFYllTTmZSRjRVVXVpYUxkNjdmcGEyb3dPc2toKzZpOXlmNkNtaEZSYmFaclNXNUVaOG1JcXJQMnllZyt0ZWdhQjRVWVcra1IzTWVBck5mVGc5MklBalgrdGEwbmhpMi80bG1seFJrV0ZtMzJpY25ySy9SUWZVbmtuNlYwbzY1L0twYkdrSFNpaWtBelNLRm9vb29BS0tLS0FDaWlpZ0Fwd3B0T0ZBQ0dtMDQwMmdCYUtLS0FDaWlpZ0Fvb29vQUthNkxJakk2aGxZRlNEM0I2aW5VVUFZbmlidzlIcm1oRzFqQUU4UHpXNVBZZ1l4bjBOY1BCNGNmVy9DL21Xc1JqMVhUM2FDYUk5WkFPUngvZXdmeHhYcWRWRnNJNHRSa3ZZZmtlVkFzd0hSOGRDZmNldE5NVFI0VVF5a3E2a01EZ2dqRkZlbmVNdkJvMUpXMUhURTIzZ0daSWw2Uy8vWmZ6cnpFZ2htVmdRUWNFRVlxa3lXZ3ExcDkxOW12N09SdnV4VHJJZnpHYXEwaDRGQWowcnc1Y0FlTHZGRnkzSlRMQSt3Si93cGZDdDcvWm5nUysxUmptWjVKWmNudTNRVnkzaDNVMkUyc05LMzd5NXNaUHhZRC9BUFhWd1htUGhXWWgxRjRJejlNN3FUUlZ6cHZoeEczL0FBajgxdzUzUFBjT3pNZXA2VjFwNDVKQUE1Sk5jMThQUi94U0Z2OEE5ZEpQNTB6eDVyTDJPa3JaVzJmdFY4ZkxVRHFGNHlmeDZmalM2ajZDNkJPK3YrSUw3V0NNMnNIK2kybWVoSFYySDFyVThSNnF1ajZKZFhURUJ3dTJQM2M4RC9IOEtrMFRURTBqUnJXeVRHNkpNdDdzUmsvcm12T1BIdmlFYXZxUXRMWi85RXRTUmxlanYzUDRkUHpvQXpMcTVNSGhhenNneE1sek05M0w2NCs2bjhpYXlNbk83UE5PZVY1Q0RJMlNBRkhzQjByUzBIdy9lZUlidnliVmRzU2tlWk1SOHFEK3A5cW9rajBYUmJ2WHIxYmUwajkza1AzWXg2azE3Qm9taTJ1aGFlbHJiTHgxZVE5WkQ2bW5hUG8xcG9kaXRyWnBoUnk3SDd6bjFKcTlVdGxKQmdaSnBhU2lrTUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNuQ20wNFVBSWFiVGpUYUFGb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FBMXlIakR3WU5VVjczVFVDWHdHWGpIQW0vd2IrZGRlRG1qNjBiQnVlQU1yUnVVa1VxNmtobFlZSU5OTmVyK0x2QjBldW8xM1pLRXYxSFR0TVBRKy92K2RlV1RReTI4elEzQ0dPVkRoa1lZSU5XbVEwTmprYUo5NkVoc0VaOWp3YXR3MzIzUjdxeEorU1NhT1ZQcU1nL29mMHFuMW9vRWVxL0RlVGQ0V0EvNTV6dVB6d2Y2MWpXODMvQ1RmRXNTTWQxdlpFN1IySVRwK2JHby9BZXFmWTlFMXhUOTZDUHoxNS8yU1A1Z1V6d0pjUjZUbzJyNnpjY2xBc2FnOVdicmo4U1JVbEc1NCs4VE5wZHAvWjlrK0x1NFg1bVU4eHA2L1U4MTVhT0J6MTlhc1h0N0xxTjdMZFhEbDVwV0xNZjZmU3VpOEplRFp0Y2RicThEeFdBUFhvWmZZZTN2VDJFVS9ESGhTNjhRM0liSmhza09KSmNkZjlsZlUxNjNwK24yMm1XU1d0bkVzY1NEZ2RjbjFQcWFrZ2dpdFlFZ3Q0MWppakcxVlVZQUZTQ2syVWtGRkZGSVlVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFDdWI4VytFWXRlZ056YkJZOVFRY09la2cvdW4raHJwS1BvYU5nUEFwb1pMYVo0TGhESE1odzZNTUVHbVpyMW54ajRVajEyRDdUYXFGMUNNWkgvVFZSL0NmZjBOZVRNalJ1VWtVcTZraGxJd1FhcE1ob3QyTisxbDlwQ2dsYmlGb1hIcUQzL0E0cVdmVUdHZ1dtbklTRUVqenk0L2lZOEwrUUg2MW4xMDNnN3d3ZGZ1VFBjNVd4aEkzZjlORy91ait0TUN4NE44R0hWMlM5MUJDdGtwK1ZEd1pqL1JmNTE2Z2lMR29TTlFpS0FGVlJnQUR0UXFySEdzY1lDb29BVlZHQUJTaXBiTFNGb29vcEFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZPRk5wd29BUTAybkdtMEFMUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQW5zUlhBZkVMdzJ1dzYxWkpoc2dYQ2p1T2dmOEFvYTlBRk1saFNhSjRaUUdpZFNyS1IxQjdVMDdBMGVHNlRwaytzYXBCWlc0TytVOG4rNk81L0N2YmRQc0lOTXNJYlMyakNSUktGSHY2bjg2NWZ3VjRiYlJyN1U1WmVTc3hnaFlqK0FjNS9ISS9LdXdvYkVrRkZGRklZVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZPRk5wd29BVEZKaW40b3hRQXlpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEwREZMUzBVQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOSXAxTFJRQi85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL3RoLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUJUQ0FZQUFBQTJqQzBJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBDTmtOQk5rSkNPRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZOa0pEUkRkR01qTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rSTJRMEUyUWtJMk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tJMlEwRTJRa0kzTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrMFkxbExRQUFIZjlKUkVGVWVOcnNuUWw4Vk5YVndNOTdiL1l0ZThoT2dFQklTSUtBaUlDeXFWaDNySHVyVmR0aTdWZC9WVnYxOTMxRmEyMjE3cldmV2orcnJWbzNCTkZpcmJ1eUNzZ21rQUFTSUdSUFNDYmJKSm5KYk8rOTc1NDdrMG5lTXBNRWczWGl1M0IrTTNsejU3N2wvdSs1NTV5N0RDT3VYUUFuTVNVUW1VdmtWQ0xUaUV3Z2trMGtrWWdOdERTV1V5K1JMaUpOUkk0Uk9VQmtGNUZ0UkZ5amRSTG1PcWZrYngySW8zNGpPVVN1SXZKOUluT0ljRnJkZmllVExTekl3Mm1EanZORXRoTjVtOGliUk9wRzg2UTZHRDJpVWRYZlNlUThEV0l0eFVqSXhyeXdQRXprQXlLUEVkazRHb1d6bzFER0lpS2J3aGQwb1FhemxrWUlOekt6SWN6UW9xK3RvY1VUVjlDWmdnaVBzUXo4WUtpTWRjNGc3RG5taDhOTkFhaHI0Nkd4UFFoZGJnRThQbEdyMGpHWUxFWUdFcTBzWktmb0lDK1ZneWxaZXBneDBRQjVhYnBZWHp1VHlIckMxT3VFcVR2SSsrWVRzcW1GdDg4WThaZDRBYTdrV0hndTdQU3BwcXJqUWZqM3pqNVlYK0dGNDEyOFZzdGFnb3hFRGhhWG11Q0NVODFRa0JrVGJoZGg3Q2JDMk9vaFRZenIyMGNHOUgxSG40Mjh2N2ZnWmdOcFFYOGlMZWdYYW5sUjIyK3I5TUdMbi9WQ1JXMGdjdHhnVG9DVXJGSklUQzhFYTJJMldPemo2REZPWndTVzAyczFQWWFTd0FlQUQvckEzK2NDVDA4THVMc2FvYXUxRXRxYkt1aXgvbFE2WGc4M0xMSEJ2S2xHWUpnb1pZbndGOExhcjQxWGJmZjFIL090bWpNRTBHL0ZCdnAzWWFCL1YzQ3puUUM3bHB4OGlWcStRNDBCZUd4dE4reXZDNEdzTjlraGUvSml5SnkwQUJMU0p1R3B0TnIrVGljUlhNNHFhSzdhQkkxSDFrUEEyME9QbHVUcDRZNWxEcGlhcmE3WUNIT2JDWFBMakZkdjc2QkF2eUVEK2dZRjBQTmpYc2E5UjU2Rit5YmZuRVlLL3BBVVBGUCt1VDhvd2pNZjlNTHFMUjVzVVdDMEpFRis2VExJTFZwS05MQkpxMGN0S1UxV29zRWJEMzhHeC9hK0JUNVBCeEF0REpmUHM4QXQ1OXZBb0dQVW9DNG43SjF0dkhxSDAvZkdhVEtnTzZSQTgwTUFqWFl5QVhVRE9la3A4Zy9xaVlOMzkydGRjS1FwQ0F6THdmaVNpMkRTakt1QTAyc2dhMmtZWUFlOFVMVm5GZFR1ZnhkRWdZZkpXVHE0LzRlSmtKdktxWmtmK3dpREMwRTJLTU1wZ0Y0ekw5WTVEY1E0LzRnWTU0cHdDcG9XZDd6a2dtNlBBSmFFVENoYmNnZllVeVpxdGFTbEVhZWU5bXFvV1A4RXNiZnJ3V0ZoNGJFYkVxZ3BvaEtNMkVCWVBCY05nd2pRTjNaSzhuRDNYcGtiSzVyeE5Dbmdjdm54YlpWK3VKUEE3UGFKa0RiK05KaHg3ajFnc3FWck5hT2xFMG9HY3lKa0VYL0wzZFVBblcwTjhNbGVIMHdoTnJWY1V4TU5uVStZVENPdjcvVWYrLzA3WG1rZUdwcFFrVDZmY0RYSGlEZkxqeCtvODhPS1YxM2dEWWlRUFhVcGxKMTFGK2owRnExV3RQUzFFcHFwWldmZFNabEN0cEF4WkUzT0h6SkoyTHdtY2t5V0dQN051WXFESFc0eE44bkNWQkJEWEJKbmJtam5ZZmt6WGVBaVprYk8xSE9oY041TldrMW9hZFJUNWRibm9PSFFSOFQ4WU9ENW55Y3BORFhoMk5YbEVjdVNyRXdkOStNdWFjUDQ3UlU1a2dPNm43aVkrNWFaWGlHbVJ0bmc0NEdnQ0xlLzFBTk5uUUtrNXMyR29qTnZBUzBVcDZXVGtaSnpaa0J2UncxMHRqZEJlVzBRenA5aEFGWTZTY05Fekk0QzQzTFhHL0x2S3VaeXREL3RPTnVnZzR2a3g1LzUwRU9qR2RhRWJDaGVjR3NzYTBVVFRiNldJRnZJR0xLR3pDRjdDcnViTU5yeHRHT3BDdEJZUWtpSWRtYk5ldmpENEdNb2xZMEJlR3U3bDRibWloYmNCaXhuSkNjV05kSGtwQWt5aHF3aGM4Z2VNaWpuMHFTSCsrUkttUjJjcCs0eCsxa0dEdVlNUGlZS0FJLy95d01DZWMwdXVnQ3NpZU0xTGFMSk55TElXazdSaFpTOVA3M3JvU3dPWmhOWnJYN0VkcmJFWkJiRG5xSitlUS9yK292dFRybmp1SzB5QUFjYmdtQXdKMEZlNldVZ2l0b01PUzE5Y3ltMzlQdlFjbXdUSEtqdnBPSGl1WVhTK0hTeWxjN00reFRIWGlRMjlJZS9zdVNZOVl4aW5zWXJtMEp4dnR5U1M3V2hiQzE5OCtFOHdseGU2ZmZwKzVjM2VSV2ZJN1BJYmtSRDk4Znlpak9aSHpFZ2NvTVhzRlMxOExDL2ptaG5veDNHVFZxa2FXY3QvVWRTK3NTRlVMZHZOUnlvNjRHanpVRW95QmdJNHpHRWVXU1h2TDJmYW1oRVZIOVRyOTVoWmk0UlpXYjNSL3VJSWM0d2tEcmhUR0tjR3pTN1RwUC9pQ0I3eUNDeWlFektPVVYyRWVQSVNPR2pWeGpTelRweHByeWtUeXRDUStacDQ4L1FQRzlOL3FPU09qNDBpVzdkL29DQ2VHUVhHUTZaSElUeEpWUFpCUXdqU3NJZjFhMEN0SFdMb0RjNXdKSTAvanRsYnBRV0RReVFlanhCcUtwMUsvTFlyRHFZa0dlVkhITzJlZUc0MDZmWkNDY2hXWlB5YVdEQzJkMEo5ZTA4NUtZTTRFb1VONHNNazdjcmRZYWZlYmlqZnpUUGtpLytycWdMTFp0eXBFOGpNSStORWNFTHpzNkVzeGRtUzQ2OStQb1JLUC9LTldoWVZZUWJyNWs4MExEcnV1SEo1eXNWbzZLblRrK0NpNzgzWG5Mczc2OVZRbk9yZDlnanFMY3VMNVErODRPZHNHNUw2NGp2YTdUSytYWW5ockJZREcyMVcyQnZOUUU2V1RvbW1HQm1acE9YMWJpd1MyL1NpOVBrK3Zkd00wK3J4WlpjQUdOQk40dWlBSUlRVkJ3UENnSDRKUUdDR1pSdmNNcE10OEF2ZjBvK0Q2OFRldmZqQmpoUzB3T1Q4cVhhdWJPckQzYnVPdzRHZ3hsWVptaWdKK1NaSUQvUExqbTJkV2N6Q09UOERLTmNqRjgycU5kd0QrbzFlSEpQOG5JT1YzVkd5bGt5UHgwczVnRW5hc00ySi9TNmczR3FwU2RDT3dINmFBdVB3NERTc1hDOVdJUXM0MUdEVWNma3lhbXRhd3RWck5HV0NhSVFuMGlYRlNkQVhyWTFEQ29QRTJVUWhyUjJEbVJsMktPV1lUSVIwMks4WXlCTVpCUWhMWW1GYVZOVHBlWkdlemRjZkU0V2VhSW05R0pDejdEUkRlVUgxVFlKRWlFNVFRbHR3UVFycENhYkNJZ0RBUGIxQmVIVHpTMndlUDQ0eVhYY3VtSUgxVnArdnpLVUZRaDZJUmdNQXNkeXNHRHVPRWhNTUVZK2UrZkRlbURaK054cHdtakxvSy8xeUtZTVNjb3dIUkVuVkJ0WU1VMmVvZFVWQnRxYUhwZjJNMTV6YnBZSnpsbVVIVE5mVm9aalJPVm1aeHBnOGtSbHc1Z3lhUnlWd2VuajlYV3dkMzluUkx2M0o5U3F5WW5LVmMrbnpWUmVhM1d0Q3o0ZzVkUTJkRWlBTGltMFFzVWhOd1FDZnNWM2NLR3F3QWZCYW1Fa01CK3RiZ04vd0FkR2d3bmljV0taMFJwNnZzMmRnbUxxcUlHRjlINE5yZU00MFM1SHRyc3ZaRzF6eGdTSVIzK1FGM2lpcGZ5alh1NTVaeGNNT3krZUg2K0RZM1V5NEFRb0xFZ2VWaGxvSm5sOWZYRGtXQXNzbXA4Zk9UNTNkaHJWNUJXVnZTcjZYNlRyT3hmUFM1YzFEaWNFQ2V3RzBSeWZneXlFUldTU1dIZjBIaVdmY1lCYVJxZWpnekVNbU9RYXVzOGZhc1A5RTVIaURtaWlvWGgrZUVDdlhyc0ZsaXdvSmQyOVZGdi8vdEUzSlg4WEZlYkNGUmVmUG9KcjhOUHJZQWVaRUU4L05HZEU5eUdRQnNFVENMLzRzZ0dXWHpmdzNaS2lkQ3BQLzYxSHphS0J2ejZtM0lTenhka2RtcDhUcHhFclpCR1o5UHBCWVhJUWhzMlVaWWpNdUl2ZWRjZGpFZ1FCZXR4ZU9IU2tNVFREaXFUVTFBUUZ0SFVOVGxqMTdoNDQvZFFwQURLbHVXRjdQYVFsMjJEVmM3RVhNaHc2WEsvaWxMUDAvSGdkL2MrUUY2STdZN3YzSG9XcW11UFNJa2daUGg5SHpZTmV0d2oxalcyUW15MjEzWU1xalZidTJQYW5MeXRhU1ptMk1SS0NWYjBIMmhjeXNXNHdmdStkZ2JjL09BSXZyTnBNN0VZdnZmOWJiamdEcmx3bVhlWCt5dXF0TUx0c0V1VGxwQ2xLV0xmbVZ6SFA0T256d2I4LzJnVlB2YlJaWVNjYjlDWklkR1JBRXBIK1orano5VVV0Ni8zUHl1R3pyZFdTY3RDcHMxdFRJTkUrampxYjZ6WWZnZ3VXbGtrYVpTRGdVekczZ2xCNXREa0V0aGdhVC90azQwR29iL1pDa2owQnhnTFBVWmhsZE5GaGoyOE5qVUFiOUdhd1daS3AzWWkyS01zcVZ4SXZtbDhNWCt4cUhIYXBhSjc4K1lYMUlYVkFUQWtFRjgvQmtjN3VsT0owY05oQ1RoaEdFbngrUGRUVWk1Rm5pTmRSZVFSRGMxSk43V3pyZ2EyN25RUzJjZElJQklIYmFMQ1FzdlcwakRmZk93eC9YN1dGbWpGb1E1cU5kakFaYlhEbkxVb04vVi8vc3pyVWtPbDFNbUF4SnhCSE5KdHEvVEdob2FQY2dpN2FwLzJhSW03dExWSnhGcU9EUW8wVmpBNGF4eGtVK2ViUG1ReGY3RzRhZmpNaDVWNjRlRHA5WllnKzhQcFlPRnJqcDQ3Zml0dlBBck5wd0FIYy81VVRubnora09RWjN2cmJ0ZUR1YzBrYW5vbEFpOXJjYWttVTJOdFlCM2dlMU5Ubm5aTUZaU1V6aWZVVURKY25odUxWS2pIdlJmT25RbWxSN2tDOTBuSTRVcllPSHYzTGdiZ0dlcUFIRTZNREhlc0doVGpXMExodm5pRzhkeDdMZU1GbU5VZU5KQXdub1luQkVjZmtON2RMVjZqZCsvQk9BaU1yZ1JuVHdVb25qWEwweDZXeGg3anVzdE5JUG1iUVZZYXVVOGVacUNhV2g5TThmVUg0WUYwam1NMDZtRHd4ZFZqWG1VTHNmaFRWeUF2UHgyMGNlamlXZys1RXZ4aVBEMkRXOUJ6Vnp6REcrK1k3MnduWXNhTWloNCsxd1JkN091RzhzMHNKbEFQbXk1eVp5YVRoSzNkWTNiYjdHREVQVEFRZ1hkZ20xc09jV1JPZ1lFTHlzSys3cXJvTC92VnhOU2xuZE9hSW9CbUNac3hZVGJxaFBMK3hNaWNwTzhNRXlVbktBUkVFT1RjckVhNjRaSGpodEllZi9BUjI3NjJHTTA2ZkVqbTIrTXc4YUdqc2trVlAycUM2dmhzUzdPYklNd3hGUElTUlJXdUl2WTJESjd3d09zUFZBV0o2R2NiQ1BpcGlUSk5EcmNNZVN4cGFoTkxpbENoYTF3bDYzZkFyR00yR1BSVjFFcUJSVzArZUpJMlNIRGpVU0NNVGFCTVBPSVYrdW9mYmlLNGNCNGg0djJvbHZmSFB6ZkRFMzlaSC9lNUxUOXdJUlZOeUZUMVZYTnZRUXloYUhRd1I1aGdMUU9QZ1JOSGtKTlhQT05hZ0NMa04xVGplVzFjTlA3bldCeGF6TVdxdXZmdWJpRjBjS3J2L0dhS0dycTVEdXpxMGdqa3RKUUZTVTZSeDhiYjJibkMydXlMVlY5ZlFGZExzcW82dkRzekU4Vlc3ZmpvNUNSalYraHpEY2VnWUprY2t5aEgvdDQ1aHJpbVQwcUpvWE4ySTdoSHo2blZtMkxYbkdDeVlWeFExMytjN1d5RFJrU21iZXN2QUU4OXZoeDUzTzRYNnRwOHNoS3N2bGU3UC9lbW1jdmp6M3plR25FVnliUmlIUmxGdGpNUkJUVW5NVVkzZStBTjlFV2RVZnYxeFhhZjlqVmNjY1pTRGlXaVZlRStGa3l4Z051dUgzZG8zZkY0QjZ6OC9RTi9mOTk5WEs4SkdPcDJSYU9ER3FFRHYzbnVNYUdjakRaVkpueDhMUm1LL2lwWlFHSkZsZEtwYTEycEtwREN6YkNnL3JRdVZPbG8wdnhDbVQ4dFhuVzZLVG1wT3BsM0ZoQkhHUkoxR1kxWTN0SzBTN3lwYWhMTGk1Qkg1RmlWRjR5RWpQU2xLcDBZZUdqRlQzbHRYQXorOVR0M3NPRmJiUnFGblFEcUlnYkZxaXprSlRFWTdjYzU4cXBvVmp5WFlNeUxtU3FnSFVUYzVVcEt0VkVZS3dsaXdvVThneWpFMlRBN1VSbE9ucEk3SUZFTzdWbTdiRG00QTZCaWlJN2x6VHhVc25GZXN5UFBaNW1vQ3I1VStRK256WTJIbFg3OFg4M292dTJnbWxmNTB0TG9MN241dzI2Z0dCOGFHQ1IxRFE0c3huRUpCaU8rN3QxckVxUFp6YkhjNHVvWmpnQU05WjRLOUZRMEtvTkdwcTJub2d3U2JRL0hzaEJNSXZZV2lITHhxQlZJSHNpMzZyd3lQejB0WDlDQTRVQmJ2ZFJxTDJhaHpPZUo5NkxzL25UbzkrUVJhZW14elc2U21nUjYyN2pvT3QvNU0rdkdPM1ZVMFhNY01DdGYxSjErZ2IrUTlqQmdrOXJaUHRmbysyYkFQSG45K3ZYbzBnL3g3NVg5dmdLTENQQlVOUFFhR3ZzVVJteHhqb1ZjU1lFS2VZOFRmTzFoWkIvdjIxOUQzMTF5MlFEM0NRTXlPN2w0bFNDWEZlY1IrcnFFT25iSzM0MC9vSHFKOUQrMXJLN0hKV1ZicEN1R3FGYlVveHhpcTNCaFJqakZxY3N5WmtRUm5uRDUreE41eXE5TUZoNDYwcUtvQnVocUVQQk9jL0RTck5GUHhlVjVPQ3VUbk9LQzVSVlI4SDc4My82TEh3ZU1ObVFsMzNYd1dhVEFMSlhsV3ZyVVJIbm4yczRnVGFiT2tFa2xSclVDV09LY09LenFReWdnT2h1MFlZRlhyOHp0cGNrQ2NSem53dWllTXQ0SFpiQmp4ZHhlZFVVb2xtbWFna1FMeWRsWlpwbXFXaFhPellPVS82eFUrT1RZQ2c5NGE3dllGeVdMWWdTNlZBNVBCVGtOeE9Ja0lZOTVNRkUxN3hTV3pxSHlYb2h4RE9UOVJUWTZoaGhpLy9kRU5ua2hBY3F5MnZoWEc1NlovUGFjdy9FeHdKQzQvVC8yWG9XZWRrZ212cnFsVnpHckRHWFVPNnpnUXpEemRQb0ZqalNxbWpCRVNIVG1ndzduYlRHZ2tNM1lmT3ZJYmlHZWVtZUdaSExIRFh2R1lnbnhRRWxWb2EzZkIxdTFmS1lFK0FhY3dOTW1JaDhMSjZyLzhsWnVkQ0hZclFJOWIvdXpZeUx3UmpqaDYwVFMwVVdlbGNlekl2WkM4bzBXaE1GWUdWbUNrVG1HY1J6bHdST3pqalVlZy9PQVJxcWwzbFRmQjlWZk9IZjZUaVdHNzRUTXBuZW9BU3d4elpzbVpHYkQyZytPeHUvNm9QWURVTElpVzkrQWgzQ2FoT3VvNWxpNCtCVkpURWxTdlB6NHJsYWRjNmxnbHM4UXRDRWFBRGdxaWwyU1NiUDVzMW92UUYyQ0l0MHcwQ1dlTXgvZ09IS3Z6UUhsbE81MTZpVjI0dzI0YjFsZGZYN01SSG5ybUUvcStmTjM5cWxEUEtKVU8xbmc4UHJCWUJwNVRTVkVxdlAxK1UxVDdWeHpLckJsR1hvekVQUGJjcHFpVGtFNHBuYUFDTk1UdFRsaGllRTY0MmFDOGk2QUEzZ2pRL2dCNGRBWXAwQTd5bDVlWW9FS2dtOWlDcVhGNCsraUEyV0JSV1FiY2VNME1hbjNsNWlRT3kxdkdibi94NlVWdzgvVUxGWjlObVpRQ2wxODBIYVlVU0ovSjJ2ZS9nQjljUHBCL1Jsa09QSHlQR1Y1YmN4akt2K29hdHJOOXdkSVNZbXRiNkxUVERWdWJvYWJCSFRVdlF4cXAxWndTMmZkamR0azRTSENZd3FaRkVOSlRFOGVVVXlnRTNiVHBXZzNLVmhrTUFnYjVSWHdTb3RzUEhVUWpTMFlnMG13Q3RQWnd3SHZiZ1RIRUg5Q29HWFU2RXlRbEpCQmJkOXpJbWdKeHhOSlR4a0ZSWVk0S0VJSUNaa3p2ZmJvZjVzOHBrdGpvVXdwU3dHYnRuOC9CS0RSbFQ2OXlGUXFhTVpkZU9KVytQM3lzRTZycmUwTjFKNnBkSndLZFN1ZDk0RG1XWHpkZjlkb0cvSWp1dUI3NjVyMXQ5RFhWS2lnYXBkdlBZQ3lVYnFFcmRIdkZGdmt2REdVbmhSd0h2cThsVHZjVUR0bFo4a2lIUE5YV2R5a2VUclRGcC8yYVR3MlV3elZ1S0Q5UXAzUk9pVU9IRVJlMWF6eFlHWHVIVU55b1p2QytIa3FQbjZVRFBCZ0pZVlZHSnVXcHBzNFoyV2dtSG9YdkN6MnZFSnRTWG50OElqb3NBbXBvdnFXYnFaNllMRW8yckppWUVnYmFVeGZYbTgzRVdpZTQ4cTNQQ1lndXlNdEprS3ZoMEVpYkxPRWkyWWFtZHNreG5Jei8xSE9mZ0pHWU4ydmVyWUM1c3lkTDdGWThQMTZIWXVTUVBOS2Q1YTN3MkZQdnd2bm5sRWtEVS9RL0I1MnU3a2hqNk9uMWtnWlFIOWswaDI1a1E0NzFWelpkRFNOR255dUNOdjZyYis2TWEwZWY5elRRMTBtcHlzMGFDY00xK0xnWnNCZWwvSG1aNzZiclp3Zi9PRGhEWFFjTHQ2MnhBYU96Z2FWNEJjVGo1bjZvVGQxOTdlQnlONFBmSDlwK3RuUktPa3pNUzRVZCsrckIxWU1qY1drMFg3ZW5oZWJCZVJnV1lwZU9TN1pBeVZTYlpISHE3b29XNkhBSmRIZlBRTEF2dFBjZlRnazFKVkh4Qnp6UTYybURBTytsamNKZ3NFS0NOWlBhdWZMaGFaeXY3UFc1b052ZEFqNS9yMkt0SWE3N3cxRkFMQmZ6WXJtOWZjNVFDQStkSDUwUmJPWTBPcEtJYzYvOUFUY1VUOGI5TjRJMHBDaFB1eXVhb2Nkam9YRndIS3lKeDBDZDU2c0hRU1ErM2ROWDlVSldndlI1L1dPbjdqZTNyVFUraDA4NThPb3UvYTRmelFvS3pLQ3gwanlpMWxNc0luUjRla25MYUFUV25CMlhzVXJzamcwNmEyaS9DM0xnY0kwSEtxdnI2T1Fpc3pHQlZpNXF0LzQ4bUI4QlFYQS8ybFJINGUzWG5MakhCd3JDMmIvbEFPWTFHeE5KT1ZicVRPSStkRnd3NUxYUXJRbnd0MmxVdENJVGprbGJUTW1nWTQyS1ZlTllibWkrTk4xaGtKWmxOaVFDcnd2MUhHaHE0REdJekxsbVNTTjEwa2FpWElFZXVuYUx5VTRYRU1TamhoYjZHZ21wM2RSK3puSklOVFIycUN2MzZIWWh5d2kwZjFjRGUveDREMVJsT3NUSmd3czVvOEFQL3lvM0F0KzVCeGhUVmh5MmFvWkNZeWRhU2FUcjhrU3F2VkFiaHVZMGg3WVlZQms5c0ZZZHpSTWFjdGFGOCtnaXE2MnBrNG0yS240R0FzMkxyTkZHd0Jrb0tQaWV0ZWhET3lQUkg3dGhLYXloZWRHaXFsT0hqUUhORmJtR1ptampvanUxVWZneEQxNXZmejU2bmVTYy9Zc0k4TndtbzRNMkJIbmtobDQ3dVVZOVoxYWRCUmdYNWtiWFh2bzZmMUpBNFNFZjcyR3F0dGR5YUVQN3FZWW0wcnVua2QyV1lROUtnRjdRRDNUWEh1RFN6eUUxb0krLzRCMkJ3akNvdXcrdC9oQXBDUDFURVJFOGc4d2t3RXFuR2xJY3RQdlFvTytvUjFZNDllNWNqRDU0VFJzQ0YzMTdsSDc0YU1PTHNzQ0l6dEhHYmNsSUw2SG5MTXFReUtCcmowdjdtVGoyZk9lWEVTYmw5N0Nua2NNVkVMMVVRM2Y4dm9kUC9xM2QvY3dXdzRmblRnbGV5dzR5Ty9LVGVDZ2NGNFRLRmc4RVNZRnMwaHlJLzhRT0REQ0lzYlU3NmRobFVIN2JRMTVzVk52cjIzL3RNWGdtN0ltOGg3S0lUQTV1cnpoNUVObkZ5QjBxY2wzNDA3NHROZHl4Mms1bS80UmtZYkRMRFpkTjk4S0RIOXRBYUZzUGpPTVU4c3dNb0NVdGZYTTArMFBzaFZtVTl6NjFuZXgrWkJjWkRqWHAwT2VZcy8zMUwvVnI1YjlxT0NNbkFBVnB4Q1lNOXRDQ3RhU2xiNVRuOXZXVVBXUVFXWlR6U1prbDdJWVp4bCtTRmFIOVBoZmEwYTdITnhrM043aVlLaEVHL3VHM2ZqclBRMnc0WW45MWJRUFIyNlQ5RUtRbTM0d2dhNTNiS0h2SUlJQW8rWWVzSXJQSWJ0Z1hER3Zva0paR283cmxsZDJHTmZKV01ERTVDT2RPOWRMWlRrTFRhanBKUlB2SlhrMU9xaERHaE9iVmxEbGtEeG1VYy9uYWwvbzF5R3lZM1g0dklrSTBSdXlkajI0MGJxaDBzdnZrMzc3MlZEZE13RUlEN1NBZXgzSjRVSnhCRTAxR1JmZ1FZLzUyeWh5eUo4K0RqRDY4d2JRQm1RMnpDeElOM1g1dkZ3WTR1NGswM2ZtZStVVWZ6bDRhVklhZUdDZTNMZXdCbTBFRXhsMEowUHErcGtVME9TbUNiQ0ZqeUJveWgrd05aaEhaUkVhUjFUQ3prU0ErZDlmU2dUbkNqMncwbzlvVjZydFlKc0Vrd3V6YzRNekJCcnJOS01DMHpBQnNxVFlDMzlkRWpYWFJVaENYdytKYStsYTZnTUE0L3cxTTl5NHc2a1JZc2RRRmVVbksrU2wvM1c1NitlWGR4blhrN2JFdzBLSXEwSGN0OG9vRWFqU3VtZlZWK3A0RkU0UFpPUW1DWkdPSFpJc0ErYVFiMkZGbkJNSGJUTHFGRmhETmt5TS8xNklsTFoxb2VJNXRmUXVZM25MUWN5TGN2cWdicG1Vb0o0aDlVYWZic3Z3dDZ5dms3ZUd3L1N3aG5ydnJIT25lYUFSb1ZOODRSWTE5NzVDaGVWbXhyeVRSSkowcm5lbmdvVEE5Q0x2cmpSREErZEx1Z3lDYThrRGtiRnJGYUduRWlTRktrVDMrS2pEZVdyQVNNK1BPSlM0b3kxTE9rcXpyWW85ZC9BL0hrNzRnY3dqLzdBL1Z4UnhhYXZ0dGh4Z2VkYWwzZVptalAzekQvblNibTIyVzU1dVc0WWNIenUrZzJwb0pkQURYOURkZ08wa3ZJQWExR3RMUzhCSmhCWm5obXA0bkREa3BTOGdVc3FYZ2tqRDRnNVgycDVCSlpCTVpEYk1xYlJ6T1I5UlhMcWY5SVFVbmJ1QlNqK0tTak9EMFZkZjAzSlp1RXhRemxBSThBeXYzMk9IRFNrdklxT2ZzSURqbWdtQW41amVqMXlwTlN5b2dCNER0M1Flc2F3c3dmRGRkUzdGMGlnZCtPTE9IbWh0cU1GL3h1djJKL2NkMTVlUlAzT2U0eFhsUGV5RE02ZkNBRG1mR3FXSUljVkZ1b2xENDlyWGR2OGhQNGllcDVhM3UwTU9MT3h4d3RDMEVzY2hhUUxDV0FrOUVOR1JxbGFnbFlsbzBBK2V1QUpZSUkzam9zWUxVQU54NFdqZE1TRlpmV1ZUZnhWWmZ0ZEx4ekpFMjdpdnk1MEdNYkJDWWZZTVlsUU9kRnZNaTB2NlFpcE51Y1RKMEliR2xKNzU4VmZmVmMvTUM4MVViSHBHOWpVWjRaNzhORGpzSDVueUluQlZFWXo0SXhtd1E5U2tnNnBJbzhNQVl4dmIrYTk5SjdZdHpsZjBVV0NiWVNVeUpkbUI5amNENGFvZzJka2V5VFVuend5VWx2WEJLdGk5cWpHeGJuWDdyajFZNVZuWjVHWXhtVkJKcGRON1Q1cFh4S1FQNjRiUWhyekh0ZmdvMXFsbWNYcHAzOXhMM21UK2Y0NzNTd0ltbWFOK3A3OUxCeGlvTDdLZzNrUzZEMHlwYVM1Qmk0V0ZPbmhjV1RPcUR2TVRvYXozOVBIai9iN3Q1OWYzcnJKdkQ5akpHTkpxZGQ3ZDVWZGdjT2REaEw2TDVnWmtuRXNtZm5oa2MvL2o1dlplUzF4bERmYmU1V3dkZnRScWdocGdseDNzNGNQYnFvTmZQZ0RmSUFpOW9GVDJXRWtjNlhKTk9vSU1pcVRZZU11MUI0dXdGb0NqZEQ1bU9vUU1HKzVwMWUzLzl2dTF0OGxwTC9xeUJVS3paU1dEMlJlRlNCdlJEdzkraUlPMkJORFNRY2JNSC9LMndDVVRTbDgvdUsvbjVuTDd6Y3hQNGZLMDZ0WFNpcWQ3RjFUeTd3L3pCY3p2TUZlUlBYTjVkSGRiT1hjNFZ6a0FNSnFWQXR6NDBzajAzMGg5SVE2UFhHbzZBNUlXZHhzUWZuOXBYL09OWmZZc21wL0pUR1czb1VFdkRNYmZKZitMc0hYcGh0M25EQzd2TTZQRGhqanc0bkkweFpodzBjYmV1Y0FwRDhQajFnQTRYZ3NDaXRzYjEraGxocHhGTGRzek9DV1RjT0t0dnh1bDVnWkpzaDVETFJGMUdvYVh2S01SQ1l6ZGIvMFdkZnYrTHU4MTdkamJvY1MwZ0RsL2pKS05HSXZnM25RNUtZQmFId2FJYzZKUVR2cmowQjlJUlZtTVk3TFF3M0ZnZy9wNllPU2VCdHk4cjlrMlltUlhJeVUvaU0xSXNRckpGTDFwTk9qRHJPZEhBTXFCNWkyTXdDU0x3QVo3eGU0UFE1d2t3N25ZUDIxSFR5UjMvc2tuZnNQYWdzYnJCeGZWQWFJVUp2cmFISVhhR1FmYTFybWdWUnNDZ0RPZ0hVNzcyRGFUL01RSzJMV3hqWTZINDA2MzRleEM0YXRRUTF1ZzQ0WU1OQ3dPYWFUS0dGVEVWSVN6b0RhSWQ3QStEakJxNU13d3ptaG05Rk9UZnRBb253SjRVYUxBWGplYU5NR0ZvTVp4bkNZc3RMSmJ3Y1RuWVdocURTbG9HTW9iYlBHRndlOFB2UGVIalFSakZEVkYxSjZGbEJzS0MzUWtYQmxqVDBKcUc3dGZRK01xZnJCUC92d0FEQUNFREl5RExPTVhyQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUxRQUFBQlRDQVlBQUFBMmpDMElBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcENOa05CTmtKQ05ETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwQ05rTkJOa0pDTlROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tJMlEwRTJRa0l5TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa0kyUTBFMlFrSXpNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCsrTHB6cVFBQUV2RkpSRUZVZU5yc25RdDBWUFdkeDMvM3pyMlRtY2xra3BCTVNBZ0o0U2xJVko2aUlFaXRwYWZxVm1wOWJYVmRwYlU5SHQydWE3Vm56NHJiNDZ0ZEZXMjdxMnlyWjJVUFhjVjNzY3BLV3hjQkR5Q1VwNEFsSUFUeUpwUEhQRExQKzlyZjc4NU55Tng1WmNLazBQRC9jbjdNWk9aLzc5emtmdTd2L242Ly8zLytmMDVidndSR1VNVm9WNkxOUTV1Sk5oR3RHcTBFelFsTW8xbDlhRjYwTnJRVGFJZlJkcVB0UVBQbDYwTzR2L01rL0N5QWx2ZGZaRHphYldnM29TMUFzN0J6ZTBIS2FSanhjUG1nMXhXMG5XanZvYjJOMXBUUER4VWdmMFNUcTM4RTdSc01ZcVlNSWpZV0d2WU0ya2RvcTlDMjVHUG5mQjcyc1JSdHEzRkFOekNZbVhLRW01alpiREMwOUt3OXREWjhCMTJsYXJDSzUrQTcyUm8yZVdUWWR5SUdSOXNrYU9wU29MVmJCbTlRaFZCVVk2ZDBGTXBSd0VGSklRL1ZaUUxVbGx0ZzJqZ1Jaayt5UXExYnlMVFpZclJQa0tuWGthbUg4WG43c0dKcTliMnJjdDVJVWVGV0N3OHZHMGxmU2gzdmtPSERQNFhoazRNUjZQQXE3Q3d6UVdXSkJiNXlpUTJ1bjJlSEtWVVo0ZlloWTk5SHh0N0tHbUw4ZlhkdVFQOWorTVdCNTcrMFAyREZLK2dGdklMdVQ5V1d2UDJPaGlpcytiOCtPSGhLR25oZExDd0cxOFI2Y0k2ZkNqWjNOZGhLeG9KUTZBSmVMQUJlRU5tWkhrVlNaUWxVS1FweTBBOFI3Mm1JZUZxaHIrVVkrQnNQZ1JROFU5eTRaSUlJZDEvamhJWFRDNERqMHV4TGc1ZVF0UjhWM0xZejJ2OWE5TTBGV1lCK053dlFrVGpRdjdROVVJVEFyc2NQdnlaVnV5T3RFcXhhNzRkRFRYR1FCVWNSbEY5Mk5aUmZ1aGdLcXlaQjJxTm11akNFOEFUYlQwRFg1NTlDMTRFdElJY0Mrc3YxdFNJOHZOd0YwNnZGZEp0OWl1Z3NMN2g5WjQ4TzlCc21vTzlPQW5wUnh1UDRZZmdsK0hmNy9XN2M4VWJjOFJ6eit6RlpnOVVmOWNGYjIwSjBSWUZZVkFwVkM3OEpGWE9YQVc4dFlDZVNLZG56b2dmMzdOc0U3Wi8rRm1LQkhrQXZERGN2ZE1BRDF6bkJLbkNwb1A0YzJidTI0UFpkbnVnYmw1dUE3a2tFV3NrQ05NWEpDT3BtL05CWjVqZWFNY0ZiK1pvWGpyWEp3UEVXR0h2bERWQjk5UzBJc28yZE5hYnNZTWNpMExybGJUajkyWWVnS1FwTUhTZkFVM2VVUUUyNUpWWDRjUUFadkJwTW5US1dKS0RmV1pqcE02MFluUDhlZy9Pa2NncUZGZy8vdHcvOElSVnNaVlV3K2VhSHdGRTFrWjBscHB3VjZqZ0pKOTc5QllROUxlQnk4TERxN21JOUZFbFJqTmlNTEg2ZEFvTUJvTy9wVFdoaitjbXROWm1xR1MvaURtNDJ2NzZqSVFhUElNekJxQVlsMCtmRDFEdFhnclhFemM0TTA3QWtPa3VnZk5aU0hXaGZld3Y4Y1g4VXBtRk1iZmJVNktIcmtFazNQbTdvZisySjl5TW1ELzMybFNrL0pCelRicmRidVhYbTF3ODNTL0FQci9nZ0ltbmdudnMxcUwzK1hndzNjdXVmVWZIK0VaWlVORVdQd1NYOFdWWTB2YzlTMDFodCtxOUpIQWEzRlBVS0ZnNUVKSTFpWUx0b1FlT0I1M01yQkdpcUNrMGJYZ0hQbmorQ1RlVGdQKzR0aHBrMVlpbzJ2OVBQcG1XRk56dlFQVUd0cHRUQkhjUmpUYWd6dDNRcmNPOXFML2d3ekhEUFc2YkRuTk90SmFhQ1B5THJqeW9EZDFTTFIzZ2NWaDVjTmtGL3pFVTYxTHYvZ09FSEI2L2NWNXJrcVJFZG56ZWtYVnBheURXWmdSYk1IbEg0cm84TC9icjRKZHlzZVBCYkVuclNsZXNDNEF2SHc0eWE2NzQ3NUFNTUlzQTlRUWxpaXBad1pUT05YbW5HZVEvR1ltQkY3MTFXS0E0WmJHSkw2dXNGYjhOdWVPeU5BTHo4QXhlSWlkV1BZb2NWdytFVjNodkJOQmdwNlJPNlgzUmRheFhnYjh5dnI5NFkwcXNaOXZKcXFGditRMzFUQWo2VEVjQnR2aGgwK0dNSk1ETmRXS0p6MzQ0TUVBdjBQQnMzeEJZeFJxd1JjOFJlVXJVQ0dlMTUwYlVzNmM0UUJ6eHU2SjE1dXdoUERuNk5yS0ZWZ25kM1J2VFMzSVNiSGdUT2FqTzFTTGErcUFLdDNpakcycW9lWXpGalJpd1FFOFJHTm42SU1aMDFaSTdZSXdiTnJXd2lQRzUyeXZ6Z05rMnJpcjVxdGNDQ3dhOXBLc0R6dnd0aElnZmdYbkE5Mk1kT3lIcEY5b1lrOFBSSndNSmtwcVJRQkprZ05vaVJiQ0xXM0ZmY29MUDN3Z2NobmNYQmJCS3JqYzg2cjAwQW1tSm9NdUY3ZnI3WXJqM1MvM08vVVludWl4Wlo3d0dzWEhKejFvT2dXTmtYWm9PUm1ES0xHT2tPWm9lNmN2RzNkZllPTjhzNmkyWSt4eFRxSS9QNHBCaDY0ME9POFhhUlN4cW44WnV0OFRwZnhhS2JnQk50R1dNZnV1b0NlRHVoZkk4WnMyeEdvUWN4azRrcFlvN1lJNjNkR2tuMjRzZ3NzVHNvNUlodmVYRVZkeGNIbW1YdzNtZ0k2S0VtOU02T0loZ3o2eXRaU25JSytDUE1NelBsSm1JbUdNdk1EYkZIREI1R0ZyOXNseE9JSjJhSjNUTWhCLzRuZnI5UGRObTVHODJCK2U4UFNQcWxWSExKRXVBc1lwSzc3emZxR09rTnl5enhZVFlzOHlJN3hGQTZ2b2c5WXBCWUpDYk5uQks3aFBHQWgzN3VGbXVGWGREbW1QMzl4d2ZqWGViRjlWZGx6RWk5eG0xRDd6Vml4aXhISTNaMGhqSXdWand6UHN4NTB5RXBLUzRoZG9saHZSK0ZtbDh6blYvQ2NWcEMrYU94VTRVdXY2WVB4TGRYcGg5MFJLVVlxaTJ5ZmhLbXM2MVZFMHMyTVhYbmk3MXFJZ2pPVXZENGU2RzVXNEdhTW41UUp4M3d4REErWGNkYmZ4Q3lGTnU1dWVaTDRtQlRQSzRwbkZBUGVxU1NvZDdNYnB2TThtR1o2OU1jRk5iTjFKbmMzNmdrTlVDRzUrTXpDMkV1MmtSdEpnME5Hdnp2YUhzY1ZNZTRLV212cWloZVViTEtpczFNK1JHeFJFeWxrNk55a3M3a2w2Y1ZNUE9LRE04Z2x1bWJpdFlDZ2FzMVQ4L1IxQlhmc1ZoV25iYURKQ0tyN0N3dzVWWEVsRlZJSFhhSVk4YnBqODNFcG9sSm5XRzlSeHpiV1huTmJXN1E2VE9BTGgyYmNpb2F5ajVqK09Fc2RtYktheXd0eDBkaXBocThKbzZwMUIvYmUxVXdlMWtyRHhYOUhscXdXTFFpTTdUK2NEemFGZ3BUejFRZ0c0T05HTTlNZVE4OWtDMHh4WGNMZFJhUlNXOFlRRE81V1lzRkNxa0pBVzNCYlcxbU54eU9HY0c2M2p1WTdLT3Bic2lHZ0RLTmhJaXRWRE1nRVl2NklLY1lKSVVjOUwwQ25XVVlHSEdYV3VuaVovcldDY09aYVNTa3F0b1FCcmFsYk1BVDBOeHd2dmJFaWh0TUl3YjBFTmhLd3l3bnBJY2RNcjZsZDBreUY4MDBBdEs3dklmbG9QV2V3dFR2RGlVK1pqd3ovYVYxaGtzdFBkQ1pRbzUwYjdHRWtHbGt2ZlN3UWc0UWhobXJzSENEYWNURGp1Rkl5SFk1YUN6Y1lEb1hRQS9UaFF2cDN1T0d1bU1tcHI4ZzBGeVdrRVFZTHJZczVHQTZINUZQSDNJWXhMS2trT204U2dyN3VkTnlybkp3bVpOQzlqZG5Pb2RKWVRwbTAxWTVzZ0diNjBSOFRFeTVTRldINTBnelZEazRsaFF5blhkSlllYVl4UERRV3NiQlNlbXVGT2FobWM1aHlKRTVLVXlmOUtWTkN0bmZuT2tjSklVRHhRZ3Q1NUFqczFpVmcrbDhKRDU3eUpFV2FQWTNaVHAzTVhUT0lVYzIxOC9DRHFhUmhGblRoa2Q4MnBDRHdjcDBQb29iV3NpUmU3WkpkVUphS0lhSktkOVNGRzBJVlk1Y2swSXVjeDFhWllraDB3aEpUUmNocTNKOEpnSSttVmxhU0cwQWFGblZJdGdvWWZsWHUwaExyM0g2YXAvMGJWdXpKRmtGbThDenZ6NVQza1ZzcGZLeFdqUStQN1RkcWlXNVd0d2tNZ0IwVElLUVlFMEUybVdqaVJoeHM1QWZ1T0lVUVBmUHk4R2NORk0rRTBMdERGdkpRSWYwR0xyUW1odzZ5RExRVERMNmpLTmFNQVk5NWpsNTNjNzR6RW1LNzNUYUNmUmliQ293cG54NzUvNEZXRk1Zc1VncUwxU1Q1cEJHaG4zOVFLditpSGJhdkhsMXFRRzB0eVB0aDBkbHRzSVZzM3l2bEpWK052OStGdU5zSnZJYWlHcjBwa3BBSzZmOVhLUDVjcGhVWmdCOStuamFtZFVKYURiN0tGTytwTTgrS3F0cGVWTThKL1Yyazh2VkpQZU5ETk9iS3NYUWNvT0grK0tLdWtRd3AxZFNSbWtEdWEzQnlEbFRCOHZCcUFJbGRvR2REYWF6VnRDWUh6cGRvVTV1TzZJbmJUUEh5VWwxa0NPZDNCZkVNcEVvL2M5dWNmZGRjMldWWmtMdmIxQ0xicjNNb1VFUEpvV0twd240OHRUckU5SWk5QTdNT2d0WXhZUHBMRVNlT1p4aGJtaTFxd21KOStyeDh6aFg0blM2Nkx6VmRmdUUzY1F5VVJqYjNjSjNkQVRndU5tUFh6VWx2c2FLZk95empBZmpDOHNETXlreFk1YXJFVHZFVU1adzVNdWQrdU9peWNrcnloSzdPMDlaS0lhT0VkRFVvbTlmSzcvREhMTXNHUUI2Qi80WHl4ajdlTE1jRUJOVE9oRTdHWE14WkU4K3VsMS9Ta3lhT1NWMmlXSGRRL2M4RWFDME1yaDZtM1dqcXVxZE5BUHcxNVVxY05GWTlMNlJQcENPYnN1NFNsRUlieGUwNkNaTDFabmxZc1FNc1pPSkxaMDlaSkJZSkNZSHYwbk1FcnZFTU5VdytxZlNEVzg3YVRseHFwYzdaTjdkdHkrTDZKOHQ3OTJBZTQ1bURUMkNFUVU0V3VLTkdiTXNScXhrQ3pXSU9XS1BHQ1FXelh3U3M4UXVNVXpOZVNPNHBwYmRyKzhWMTVzdmo5bmpKWmppUmk4ZDhvSzA1NE9NeTlpUzlZUms4TFBsa1psbE1XS0VXTW5HazdUM0E1MDlZcEJZTlBPcE00dnNHZ3pUU3JJYWREL3VvemphOS96V2drOWJmTnp4d2FzTDBWYmZXeGpTditVdEgvNFlzODFUYWV1RS9kWWJsS0NyankzR3lTejFJcHZFQmpHU2pTTmlUVDcwc2M0ZU1RaW1sYStJVldLVzJEVnlRY05EeDcwMEJkV25mN1BIK2s1U0o4c1lHYjQrSFM4QVZRRnAwOHU0YVNScm9FOXJ6clg1b2hsTE1Vd1hsb2dGWW9MWXlONEhIZ0hwazFkMDVvZzlZdERNNVd0N3hYZUlXWU5kaUFOOWhtZ0trRDNQYlNuWTNPRGhENWkzdm5OZUVDYmlUalYvSjBpYi93dXZvTXlCdkQ3V1E5R2dIWCtCemtBc3ZtSVd5NEV1U0tOelR3d1FDN0VNWXpVR0ROblNHZk9kMXBrajlzeXRpTkZuTnRzMkU3TUd1NURnb2J0LzRpVlg2a2RyZTJTRGZVMlVSaThOMm9lSXdjbURWd2ZBYWNVRGFqb0F5dloxV2VPZmZndGc4Ti9jR3gyNE9sbG4rZWlYTnVndVRlZWVHQmdxTHpwYnlCaXhSc3dSZTROWkpEYUpVV0xWWUhZZ0RMRDhlSmx6NENDZTNXS25lNEhhN09XNVlwc0c4MnZrT1lNUDBsbWd3c3dxQ2JZMUZvRGNlUW9nNUFPdXBuN0lZMGhwSkJYOWtwVFowdTFIMXM1MCtNU1RCWTRsVEg5bHB2ZmlJWVUwOERKSzV6ZW1RRzhvbmtOUlNTN2RVTkRVVjRFSzZ2YlhRRzNZQ2dXQ0JvOHU4MEZ0YVhJVjVOYzdiV3ZYN2luWWhFOVBHRUFQZkFqWHRhb3lvWEg1NDZVMDJwVDZ1Uy85OEo3QVAxMVJLeTh5NzNCZml4VmUyT3pDZzBVQUo4d0N5NUlWdE1BeWMwdE13NWNVQldYcnE2Q2QyZ2VpUllPSGx2cGg5dmprenJ6UG1vUnRONndwK2prKy9SenRGRVUwZzkvbmsveDlQRnVrYnNUR085WTVYejNWd3gwM3Q1bGRIWVYvL3FvUENpbjhPTFVmbFBlZkFxMjdpWjBVcHVHRkp6MHRvSHp3VXgxbVlvcllJc2JNM0RYMWNpZUlTV0xUWUZReTc0dnJlbTVzMGdlVVB6R0d1c1RMMEdaTWR5dHoxdDhWK0hGNW9WcGxidGZodDhBdnRoYkR5UjVCWHlHT3UyUVo4TE91eDBCR1pHZUpLYnNVQ2RUOUcwQTcrQWY5KzRKMW1BQSt1TVFIbGE3a0traFhrRzlmdnJibzJTTWV5MTc4OGM5VWUrNzYxeDRWV1UwRTJ2TnNSY3JQY2o5WlJsUVM3UmZYVjhxWHZmbTNnUWNybk9xNDVMaVlnM1g3aW1Camd5UHU0QjBsd05kL0RiaUxGZ01JQmV5a01hVWNtNkVkMnc3cXdZMEF3VjQ5Rmw4MkxRUjN6QW5vNFVZcW1HOTV2ZWpuaHpvRUNqTU9VNm5PODFpM1pIQTZOS0NOeGtRa1FUeWpwa1M5NkwwNy9mZlhsU3FUVTdWdDdCRmh6UzRYZk5sbGVHY2JKcHVURndBM2FRSDYraHBnTTMyd3VnZDBONE4yWWlmQWNiUkl2SFE4cFZ5Q2V5NzN3OFF4VXNxdG1yMTg0MjNyWEt1UGRWbklLOU9ZNXphRU9UcUlVVFBRN295SDRYNnluTEs5YXJTTFNtemFwTFczK1crL3NsWmFsSzVVczcrMUFONC81SVNqSHV1Wk4rd3VnTXBwd0xrbkFoUmo1RktFQjJFcmludHczc0xPOVdpU2l1R0NqTHhGQWdDQmJnQmZPMmdlREhrN2pnS0UvUVBOcHJsamNHTjlIOHpDV0RtZHE5dlJKRzYvNjAzWE9tK0VvMnBHQTFxcjU3R3VpSWxQRTlEUHVMTWVvL3NwSFdxS29hZWkxYTY4SnJqNHZnV1JXNjBXTFcxcG85a3J3SmJqRHRqVmJNTmJCb09XQ1cvVURnVVcxRVpneWVRdzFKWklhZHZGRklqODUwNzdXMDl0S3FSdTdXWTB2QnFnM2JPeUs1S0N6ZHlCTmphazhJTWFUMEtydTZ4S252RDhkWDNmd3NmWjJiWnQ5d3Z3NTA0ckpvOGlkQVFzNE9rVG9DL0dRVVRtUVdFOTQ2TktGaDV2dm9LcWQ0cVVPeFdvS3FKa1Q0SVpGVEdvY21VZk0zK2dYZGovby85MXZvZVBWSkk3Q2ZGYXN3ZGhqcWJoMGdUMHY1VVArV0RkVDdzcFFDNUJvNkFZNHdlb3VIZCt1UDYrQmVIcmFvcVZPblk2bVlhclpwL2w1SzkyMlQ5NmVaZjlJUDdZQ2ZIU0hIbG5yK2RSajVTQnlVU2dPM01BbWxUeHRKdEtlb1ZHQmFUV1NCcExWc3dMWDd4aWJuanAxSEpsT3NjeVFLYWhwWWthSm50SFh0MWozL3pxYmpzbGZGNklkMmRUcHdZTk9ncDJQdXBScy9CNGRrQWJPeUZneVZzWG8xVWFTU1B0MlRWL3ZGUjV6OXp3N0N0cXBmcHFsMXJEQWJCdnp6SU5obGh0OWZQTm56V0poOWJzc2UvN1U0dElIU1NVTGRJZ28xYUlkNWpvdzBFUlptMElMSnFCTGh2MndWVThYVUd3RmhoZ3V3MjRhWWRGVk5zWVg2d1VMYjg0T25IT09HbDhYYWxTV2VaUXh6aEVyZEFtZ0YyMGFGYWVBNVl0anNaQ2h3YUtwSEN4aUF6aGtNUUZ1ME44ejhsZVM4ZmVOckZsL1JjRmpTMCtTd0RpM3pDaHgyNERZbzhCY3JUejBVNDFCd1pOUVArczdLeC9nWXFmRG9EdE5HSnMybWtwZVd3Q0c4MXFlSFNhTm9FM3JIOTBJZE9vZE1TNnFZWlJOa2h4Y013QW1UeHlyd0V6aFJsOU9zai8wcWtPZzcxRW9LRm9SajUvRWM2QWxzcDVEc09jaGptTTE4MWdNNDFDSjIwQ21jcHRJUVBjUHVONXlIaGRoanl1SGlpTXdKVXBHVWEzRTRzQk1QUFF6RVAzZTJoNlZFYnFnLzlmZ0FFQUZJNGNQVEY4R2pvQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDnirbmgIHljLog77yM5bGV56S655So5oi355qE5LiA5Lqb54q25oCBXG4gICAgZGl2LnN0YXRlXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLm1vbmV5LnRhYmxlXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGRpdi5idXR0b25cbiAgICAgICAgICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5tb25leS1udW0oY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiLEBrZXl1cD1cImNoZWNrRGF0YVwiLEBibHVyPVwiY2hhbmdlRGF0YVwiLHYtYmluZDpzdHlsZT1cIntmb250U2l6ZTozNCp6b29tUmF0ZS54KydweCd9XCIsdi1odG1sPVwidXNlckJldC5iZXRtb25leVwiKVxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5wb3J0cmFpdFxuICAgICAgICAgICAgZGl2LnBvbHlnb24oQHRvdWNoZW5kPVwic2hvd01lc3NhZ2VcIix2LWJpbmQ6c3R5bGU9XCJoZWFkc3R5bGVcIilcbiAgICAgICAgICAgICAgICBzdmcoeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZlcnNpb249XCIxLjFcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aCsncHgnXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodCsncHgnXCIpXG4gICAgICAgICAgICAgICAgICAgIGRlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4oaWQ9XCJpbWFnZVwiLHg9XCIwXCIseT1cIjBcIixwYXR0ZXJuVW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiLHYtYmluZDp3aWR0aD1cImhlYWRzaXplLndpZHRoXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlKHYtZWw6aW1hZ2UseD1cIjBcIix5PVwiMFwiLHYtYmluZDp3aWR0aD1cImhlYWRzaXplLndpZHRoXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uKHYtYmluZDpwb2ludHM9XCJoZWFkYm9yZGVyXCIsZmlsbD1cInVybCgjaW1hZ2UpXCIpXG4gICAgICAgICAgICAgICAgICAgIGltYWdlKHg9XCIwXCIseT1cIjBcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIix2LWJpbmQ6eGxpbms6aHJlZj1cImhlYWRib3JkZXJpbWdcIilcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0uc3RhcnMudGFibGVcbiAgICAgICAgICAgIGRpdi5tb25leS1zdGF0ZS50YWJsZS1jZWxsXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvbi51bmRvKEBjbGljaz1cImNhbmNlbGJldFwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlckJldCcsICd1c2VyaW5mbyddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnpvb21SYXRlKVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiRlbHMuaW1hZ2UpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZHpvb206IDEuMixcbiAgICAgICAgICAgIGhlYWRib3JkZXJpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgJ3VzZXJpbmZvLmhlYWRpbWd1cmwnOiBmdW5jdGlvbihuZXd2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVscy5pbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICd4bGluazpocmVmJywgbmV3dmFsKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBoZWFkc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDE0MiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLngsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRib3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gNzAgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTI4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDQ4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgNzEgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTQ2ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDExMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnlcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZHN0eWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4ICcgKyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCAtIHRoaXMuaGVhZHNpemUud2lkdGgpIC8gMiArICdweCcgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnLCcgKyB0aGlzLmhlYWRzaXplLmhlaWdodCAvICgxMDA4ICogMC4xNykgKyAnKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzaG93TWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpIC8vIDXku6Pooajog4zmma/mlbDnu4TnmoTmnIDlkI7kuIDkuKrvvIzljbPmmL7npLrlhYXlgLznmoTog4zmma9cbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsYmV0KCkge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrRGF0YShldmVudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coL1xcZCsvLnRlc3QoZXZlbnQudGFyZ2V0LmlubmVySFRNTCkpXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTC5yZXBsYWNlKC9cXEQrL2csICcnKVxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IDEgLy/mnIDlsI/lgLzkuLogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG1vbmV5ID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LmlubmVySFRNTClcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlRGF0YShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxEKy9nLCAnJylcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5zdGF0ZSB7XG4gICAgaGVpZ2h0OiAxNyU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm90dG9tOiAxZW07XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG50YWJsZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuc3RhdGUtaXRlbSB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDMzLjMzMzMlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2Lm1vbmV5LXN0YXRlIHtcbiAgICBwYWRkaW5nOiAwIDFlbTtcbn1cblxuZGl2LnBvcnRyYWl0IHtcbiAgICBwYWRkaW5nOiAwO1xufVxuXG5kaXYucG9ydHJhaXQtaW1nIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy90aC5qcGcpIDUwJSA1MCUgbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbn1cblxuZGl2LnBvbHlnb24ge1xuICAgIC8qY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwLCAxMDAlIDI3JSwgMTAwJSA3MyUsIDUwJSAxMDAlLCAwJSA3MyUsIDAgMjclKTsqL1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICAvKiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5aS05YOPMS5wbmcpIDUwJSA1MCUgbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xuICAgIG1hcmdpbjogYXV0bztcbn1cblxuZGl2LmJ1dHRvbi51bmRvIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xufVxuXG5kaXYuYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGhlaWdodDogNDAlO1xuICAgIHBhZGRpbmc6IDUlO1xufVxuXG5kaXYuYnV0dG9uIHNwYW4ge1xuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cbn1cblxuXG4vKmRpdi5zdGFycy1idXR0b257XG4gICAgcGFkZGluZzogLjhlbTtcbn0qL1xuXG4ubW9uZXktaWNvbiB7XG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xuICAgIC8qYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXG4gICAgLypiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyovXG59XG5cbnNwYW4ubW9uZXktaWNvbiB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgZm9udC1zaXplOiAxLjVlbTtcbn1cblxuLm1vbmV5LW51bSB7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XG4gICAgZm9udC1zaXplOiAxLjVlbTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBTdGF0ZS52dWU/NDZhOTFmNjhcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJNEFBQUNsQ0FZQUFBQ0tsc1g5QUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRBY01Ed1VNWGZzdDJRQUFJQUJKUkVGVWVOcnRuWGw0SE5XWjduOVYzUzJwZCsxcUxSYmVrQzFabHJIQkxNYVlRQ0FCa3dsSnlEZzNETnlFTzRIQklVTXltUm1Jbndsejd3Vm1JRE4zY2ljYkRnVEdTU0RKWEJJbUpLd2hyQWFNV2VKRmxyeklOcFlsVzd2VWU3ZDZxVHIzRDdYMjdxNlNEVmhxMWZjOC9rTnlkVmZWcVZmZmVkLzMrODRwNmI3ZEFpTW1SUlB3TjhCNjRBM2cvd0xOdVhxejN6cm4xRDVuUHQwVFA5dlNteE1EdUxHeHdndzhBTnc4NGRkTGdTOERQd0crK1d4TGJ5ajNnRk54Wm9DVEk2RDVKdkFWb0Y0STZQQkdPRFlRWVZHcGpkb2lHNUxFemNBVkd4c3JIbm0ycGZlZmN1bmVKVmVEQVp4VEFNd25nYjhGcmdRWURNZHA3UW9TaWlVQmFPMEtjbnd3U24ybGt6SkgzaUxnM28yTkZWY0NEejdiMHZ1citUeDI1bmtLbUJyZ084RDFBTkdFd29IdUlEMkIyTFJqUTdFazc3WjdLWFBrVVYvcHhKRnZ2aFM0ZEdOanhmWEF2YysyOUw1dEFPY1VRakMzeVBVMWpaNTdnTnVBSWtVVkhPa1BjMnd3aktKbXY0KytVSXorSXpGcWkyelVWVGpJTThtZkFqNjFzYkhpcDhBZHo3VDA5QnZBeWNHNHB0SHpSZUIyNEVLQUx2OHdCM3VDUkJPSy9qOFNBY2VISW5UNWgxbGFabWRoaVExWmtyNE1YSFZObytmaFoxcDY3aktBb3pNNmRyOHhxMjl3ODQyZmJ3THVCZjRNSUJCTnNMODd5R0E0ZnNyZm1VaXFIT2dPMGpFWVlYbWxFNCtyd0FOOCs1cEd6eFhBUTFzZi9jMDJBemh6TkRiZitQbEo4anFlVkduckM5RXhGRUZveks2aGdXNEMvU2R4bEZUaUxLdENrcVMweDRYakNuODY3cVBFbmtkRHBST1gxWEloY09IbUd6Ky9DYmgvNjZPL2VjMEF6dHdDelRlQVc4Yms5VkNFUTcxQkVvcWE5WFBESVQrK2s4ZUlSOE1BK0xxT0VScnNwckJxSVRaM1NjYlBEWVpqdkhFa1JrMlJqV1VlSi9sbStTcmdxczAzZnY2WHdMZTJQdnFiVGdNNHN4c3dud0QrYnFLOGJ1bnlFeHhPWnYyY0VvL2g2MjRuNGgyWTluL0oyREFEeHc2UzczQlRXTDJJUEtzOWcwZ1k4WCs2L0ZHV2xEbFlYR3JISkV2WEE5ZHZ2dkh6UDk3NjZHODJHOENaNUNCSlp4NHdOMXhYRGZ6TFJIbTl2eXRBdDM4NE85bFZWWUw5SnduMG4wU29hdFo3aVlVRDlMYnR4VjVjanJ1aUZwTWxMKzF4U1VWd3FHZWMvMVFYV2dGdTNYemo1eThBSHQ3NjJCTVBHTUNaRFZubWh1dnVBYjRLRkkvSTZ4RHY5MnZMNjRodkFGLzNjWlJFYkVibkN3LzFFZkVONGlxdnhsbGFoU1RMYVkrTEpoUjJkL2hvSHdqVFVPV215R1paRGZ4bzh3M1hmUWI0N3RiSG5uamVBTTZaQWN3WGdiOEdMZ0xvOGtVNTBCM1FsTmZ4YUJoZmR6dXhVT0RVdlN0VndkL1RRV2l3bDhMS1dteUZwUm1QOVViaXZIbWtuK3BDSzhzclhWZ3RwaXVCS3pmZmNOMnZnVzl2ZmV5SnRyazQvdExwVnNlM2JhcjdTQy80cHNmYm1vQjdnRStQeXV1VzdnQ0RvZXlaUTAwbUNmUjJFaHJxUlZOV3pURHliRTdjbFdlUmIzZG1QYzRrU3l3dWRiQzAzSUZaSHBzV0h3Uyt0bTFUWGZKTUFLQ3R4NXpid0xucDhiWnA4dnBRYjVEamcrSHNPQkNDMEZBdmdkNFRxSXFPWnlNRXBzNC9ZVDY2WFZKcTE5NlNYSFRSZzhqNkJ0ZnFLc1pkV1lzNXJ5RHJjUVVXRThzOFRoWVUyMGpCNXdEdzhMWk5kZDgxZ1BQQmd1YnJ3RitOeXV2amcyRU85bWpMNjFqSWo2K3JuVVFzcXVzOHNyY0RjOHRUa2pUVWdZQ1JoMm9ySXRsd3RWQ3FtMFovbzZFVkpCd2xIcHpsMWNpbTdBL0ZiYld3b3NwRmlTTi85RmN2QXovWXRxbnVTUU00cHdlWUs0Ry9INVhYQTZFWUxTZjlCSVlUV1QrWGpBOFQ2T2tnR3ZEcUc0VGhJT2JXWnlUNXhCNkVxcUtvS2tLb1NKS0VMSnVRSlFsUmZCYkpsWjhTYWxHdFBoQ2F6TGdxYXJBWGxXc3F6MHEzbFlaS0YvYjhzWWY0SlBBL3QyMnFhemFBTXpQQVZBSC9PaWF2NHdxdFhYNjZmRkZOMGhvYzZDWTAwSU1RcXZhSmxBVG1vNjlMNXNPdm9DYUdVWlVSMEtpcWloQmlCRGlTaEd3eVlaSmxKRmxHclRtSFpNUFZRbGdMOWFtUGZDdHVUeTBGRG5kMm9Fa1NpOHJzMUZVNHNaakdsTm9qd0padG0rcjZEZUJvZytZZVlETlFvcWlDSTMxQmp2U0ZOT1YxMUQ5SW9LY0RKWm5RbHhHNld6QzNQaXNSR2tCVlZSUlZRVlZVVkNFUUUwaVRKRW1wekNOamttVmtrNHhzemtkWmNnbkpzeThUbVBOMG5TL2Y0Y2J0cWNXY2I4MU90TTB5eXowdXppcXhqeWFxbmhUL3Vjc0FUbnJBZkJINEdyQnVWRjYzZHZtSXhyUEw2MFEwakwrN2czaFVYMWVuRk96RjNQeWtKUFVmUlJVQ1ZWRW1aWmxzM0dVays4aVlaQk95TElQVmhWSjNoVkFXbmcrU3JPUGtFdmFpTWwzOHg1RnZwcjdLVGFWN0RHZzdnWWUyYmFyYlpnQm5YRjdmRFZ3TDRJOG1hRG5oWTBCVFhpY0k5cDhrNGh2UWQ2UHhNS1lETDBoeSswN0VHRmdVVkZWRlZmV1B3YlRzSThuZzhwQnMvSlJRSzVicDVEOG03Q1dWMkl2TGtUUUFWK3JJcDdHbUVMZlZNdnFyNTRIN3QyMnFlMjFlQWllZHZEN1lIYUI5TUpSVlhnc2hpSGo3Q0ExMG9TbzZlbW1FaXFuOWJVd0hYcEJFTERRQ0ZtV1VBSXVzV1VhTGs4Z3A4SmhrRTVJc0lTcVdrMno4bEJCT2ZRM2dKa3NlenZJYXJLN2k3QThKV0ZCaXA3N1NSWUhGTlByclh3TGYycmFwcm5QZUFPZW14OXR1QjI0ZGxkZnRneUVPZHZ1Sko3WGtkWUJBYndmSnVMNHlnVHh3RlBQZUp5VUNQU2tlbzZJcXlqUWVjOHJ1NlZUK0k4dElKaFBxd2d0UjZqOGhSSjVkMS9kWXJIYmNGUXV3V0xNZmI1WWx6cTV3c2FUY2lXbmNRUHp4dGsxMW0zTWFPRGM5M25ZRmNNZVl2QTdHYUQ3aEpSRE5UbWlWZUl4QWJ5ZXhzTDR5Z1JRZXhOenl0Q1IxNzBPb0FrVlZVQlJ0SG5PNkFCcVp2a2I0ajV4bkk3bnM0L2NyaXk2K0U1TytoMVBnS3NKWlZwMnhnRHBtTk9hWldGRmRTRTJSYmZSWHUxTUUrb0djQXM1Tmo3ZFZBdjlub3J4dU9lbmpwRGVTbmNjb0N1SEJIaUxlUG4wUFBCbkRmUGdWeVhSa08yb2lOcDVsVkJXaHFoOTZkL1JVK1M3TDhvaUJ1R0tqVUd2TzBXa2d5dGlMeTdHWGVESVdVRWVqMko1SFkwMFJ4Zll4b1AwUitPNjJUWFhQejNuZ3BPVDFyVUNwb2dvTzl3WTQzQnZRSWErSENBNTBvK3FTMXdLNWN3L21scWNrb3Y2eEtlbDBlY3hwQVdpTVFLY014SktGS0NzL0xkVGlzL1JOczJZTHp0SktyTzVpeldOcmlteXNxQzdFbWpjR2dsOEQzOTYycWE1dHpnRW5KYTl2QXk0R09PbU4wSExDUnlTZXZWNlVHQTRUN0R0SllqaWk3d2E4SFppYmZ5ZEpnKzJvUXAxbTRwMnBrQUJKbHBBbGVaS0JLR3BXazF4eGpSQTIvUWFpczZ5YVBKc2pPOUdXSlpaV09Lbnp1R2RVUUowMXdFbko2LzhOZkdaRVhzZHA3dlF5RUJ6V0lhKzdHQTc2OUYzNGNBRFQvdWNsdWVNZGhES0IrS29qSnQ1c2lZd0c0dEpMU2RaZEpqRG42ek1RN1M0Y1paVzZDcWdOVllYVWxqcDBGVkRQT0hEU3lldjlYVDZPRFFSMXlPdCtJa045STExNFdxRXFtSTYrL212endSYzJxWW5vdEF3anhPeGM1NVhlUUhTakxMOVNLQXN2MUcwZ1d0M0YyRXNxTkEzRVFsc2VLMnVLS0hPT0FTMXRBZldNQXVlbXg5dittcEV5UWIwUWNLdy95UDR1bjdhOER2c0pEWFNqSlBRdFZaRzdXekh2KzcxRXNQOURrZGNmUGY5SkdZaHVEOG1WbnhacXhYSjkzeUdic0JlWFkzV1habHlCTVJwVlJUWWFhNHB3WkNpZ25pbmdmQnk0YzFSZTl3ZUhhZTRjd2gvSkRvUmtQRVpvb0p0NFJHZVpJTkNMZWQvdkpLbjNBS3FxdjB3d215TzlnVmhQY3VXMVFyajBHNGlPVWcvNWRwZm11WmFVTzFsZVZUaXhnUG9UNEp0Yk5qU0VQa3JnZUlCL0c1WFhrWGlTZlNlOG5CZ0thNWk0Q3VIQlBxS0JJWDFkZUlrbzVvTXZTUEtSN1lnVWYxRk9vVXd3bTdOUFdnTngwVHFVaHF0bVpDQTZTaXN4NTJmblAvbG1FL1ZWaFN3dWM0eG1xbVBBSTFzMk5QelRSd0djZXhocHFpcFRWRUZiajU5RDNYNE5lUzJJQnJ4RXZMMDZ5d1FDMDdHZG1QWS9LNG5oMEFoUXpxQzgvcWdBTk0xQXJML3lQV1hKK25QMWRpQVdPSXV3RjJ2ekg1ZlZRdE9DWWlyR0M2aXZBUTl1MmREd3F3OERPRjlrWkRYQitoRjVIYWE1WTBoYlhrZkRoSVo2U2NhRzlhWHcvaU9ZbTUrVThKNUFGZXFZNHp1WHA2WFRNaER0eFNNRjFBV3I5Um1Jc295dHNCU3J1MFNULzFTNHJUUXRLTUUxWGtCOUdyaDN5NGFHdHo4STRFeVcxNUU0ZXpvRzZROW95K3Z3VUsvK01rSEVPOUsyMmJuckl5a1R6QjBDUGNGQVhQVlovUWFpeVl5dHFKd0NaNkhtdVJhWE9XbW9LU1RmUEZaQS9TbHd4NVlORGYybkFwd3A4bHFoOVlTWDkvdURXUitrRUlLb2I1Q29mMURmQTFjU21BKzlLSm5hWGtaTnhpYkw2NCtnVERCcndaUEpRRnl3aG1Uam53bGhLOUpuSU9ZVllDOHB4MUpneTg2VFRETDExVVVzclhBaGoyU3FIdURoTFJzYTdwb0pjTDZXbXBicWhSQzgzeDlrL3drdnNhU2lJYThEaEwzOU15Z1Q3TWE4N3ltSjhOQUk4YzFoSHZPQkc0aDFIeU81N0FyZEJtS2V6WW05cUV5emdPb29zTEJ5UVRIVlJXUEVmQ2Z3MEpZTkRkdXlBZWR5NEZ0ajhqb1FaYy94UVh3NjVIWEUyNmUvVE9BN2dYbnZieVdwNy9Dc0toUE1EZjR6eFVCc3VFb29peTdTYnlBNmkwYjRqMFlCdGN4bDVaemFZZ3J0WThCOEhyaC95NGFHMXlZQ3B3TDQ3a1I1M2R3eFNPZGdTRk5lUjN5RCtzc0VzVENtbHFja3VmMnRXVjBtbUhzR1lpWEpwczhJMVZPdjIwQzBGWlpRNEhSbkpkd1NzTERNU2VPQ2tva05aRC9kc3FIaEp1bSszYUlSZUFrb1YxVEJvUzRmQjdxOG12SjZPT2duR2hqVVh5WTQ4aHJtL1grUTFIZzROUzNOL2pMQm5ETVFQUTBrVjMxV0NKZEh0NEZvS3l6VDVEOW1rMHg5VlNGMWxZV2pEV1RyemNCV29QekVVSWc5eHdlSXhMU3ExeEVpdmdIOVpZS2VBNWozL2xiQzM0MHlSOHNFc3pGVUlSQ3BUSzNLWWlRRGRiVmk2VDBvcVl2WG82ellLRVMrWFVPWHhBbjJuOFJTWU1OV1dKcGxCdzZGZloyRFNCSXNyeW9DdU1RODZzdnNhT3ZKZnBKa2dxaHZjR3pUSVMxUFFRcjFZOTd6aENSMXQrUk1tV0MyeFdpMkZrS2dxdW9JZUlSQVByS2R2STczcEdURFZVSlplaW5JSm8xa0VNWGYwMG0rM1luVlhZSnNNbW1ydFlrWGtmN2lWSWFEUG9aRC9wRXlnWllIbFloaTN2KzhKQjkrRlpGTWptZVplUzZ2UHlvQXlhbzZJdC9WRUtZOS95V1pEcjlLc3VsYW9kYXUwZnhqajBXQ3hLTmhDcHlGNUR2YzB3ekVpUkF4QXdwZ2tpUnBHbmppa1JEUndOQ0VNb0dVN2VveHRlL0V0TzlwaWFqdmpIZmh6VmNBS1VLa3BxOFVnUTROWW41cm15UU92NFp5enVlRVdySkk4enVpQVM5Q0NLeXVvcXdaSnd5NFRKSkVZZ29oRG52MXJUeVZCNDloM3ZXNHhGREh2Q3NUekZZQXFZcUNFT3A0QnVvL2l2bWxmNU5FN1hra202N1ZOaEJGOWpxMGVkS1JVeWNTaldsSml2b3c3M2xTa2pyZUcxdXNiOGpyV1FJZVFLZ0NJYW1UTTlEeGQ4Zzd1VmRTbGwxT3N2NFRtUTFFYVRvZTFIRUZuYWRSZHBVeTBYRk1oMTc2dGZuQVNCZWVNa2U2OE9ZNy94R3FpaXhrVEtwQWJuMmV2R003cGVUYUc0UmEyYURyMlNmSFp5U3JlZW9KcG5vRjZVQmdlZTRlaWRCQWl2aU9GQ01Od013bC9wT1M3K0VoNUw3RGtxaHNFT2s0Ni9UbktkSk5WV25aQ3pEZDRCUEIvckc2a3NGajVpQ0FGQ1dWZlV5WUVzTVpaaFpKcHh3bkRjSXlmRGFwSkZFVUpTZTY4T1pycUVLQXFpQ3JTdHJubkE0UFUrVzRCc2VaL3EwcU1xcWFORVovem1lZjBjbG41aGxIbmlhcVJIcUJOVGxQNVJtalBtK2tXWG84bUlFNGpHeFRKOUxLY2NrWXdGd09TVXE3UjZFUWFwcDNrWWxKR1NjQ1lKWmxZeENOMEIzbXlST2VtTkU4WjBUT3BKM01KR2hDS09QYkEwL3djZExSR2dNMzh4czNVMzVXeG9HVW56M2pTRExvMmZiVmlCeEVqalFkRCtua2VNYU1ZMlNkM0k3RWNIb2ZSeUlMTmRZcWNtWkVqb0dtM05MY0V2b21xMHdsQjcxR3NNbGlqUGQ4d0ZPV2xKTjFxcEl5YUh5OW15RWFNVWNZVHJwbkxHbDR3RUFNd0NSSkgvaDduSXlZeXhrbmV5ZVhHUmdlQXc0R081NmZpdXAwcStQcGtwTmtVT1A1cU1iVDRTRXh2a1dOVFlNY0d4bG4zaUluRGNrUjQyMDBGdTJlWTRQMjVEaVhVVFdrbGRaVWxiWlVsVUZWR1Zrb2R5SVJ5L2dHdnl6R01VWkozSWhUaXF4VGxaU0o0MWdLakpITEtVMGxwZmw5T3A2U3pqbk8xUFdYVGxWSnhsU1ZNeFFuRXh0QmFEckhVUUNUU1U0dng0MWExYnhVVllMcEhhRmlTZ2RnQWhqZDkwMzNlUXpvR0J3bnM2d3lwcVI1a25EMDllTWt4L2VBZEppMUtJNFI4NWovVFBsNXdqSTZrd1k1bG93cEtkZERTV1pRVmRrenlXbnRWbUZFTGdBbmtVWC9uUExhY1drR2M2SVJ1YVNxVG0vdGVLWitESXZWR092NXdHK21yUjNYbTNHa0dmK0hFYm1TY0hUSThSQ0FKYzFPazFtcHNkRXhtRU80a1U0Sk9NbzRGektBWUVRV3FxSjdtNU5NSk5pWXFYSnJtcEwwTFFGT2pCdUFycXl0bzVLQmtubE9rRFBXcWlSdE9XNDBjdVYySk9NWm5ySFFhUUJtV01ocFFDVEhRMVhJMkZXaFowSGVUS3BWa3JHWHpyeVpyREw5ckUyTzA2VXhzOUVCbUR1cVNaeFNKV0JTeHBtMnp6SENLSFBPRTJHVkx0Y0lEZWM0QUdBeG16TnBOV05rNXlWMHRET095UHBSUTFRWnVKbk9lQ1NOUFFBTjVNenJ5V3FxQVpnWTI5dmFxYmxmaWRGQk1ROWdjNHBGVGcwNWJpQW5weU1lelRLcmZOQTdjaG1SRzJvODIwT2YyWTVjMDJ0VmFUZHJNcmJrenluMFpGemtrR1ZkbFk0OTJkSTBNaHQ3QU00RGNxemRPaW95cWlySklNZnpsaHpMYUc3bEZnRElzeGdHb0pGeFpwWnhQdWp2TkNJWGNKTW0yVXdvT1ppeUdvRFp0OEF3SW5kd28yOEo4QVFEMEpHMVA4SjQxK1o4VUZXbjlvek5XZk5UdG41VUkzSWpFdEVNbnN0cEdJQ1NNT2hNemllY2JKUlZud0U0dlZsZFpNbzR4bFp1dWEvSEplblVEY0NNZTI3TEptT3djMXhVNmVFNENxUzJIMDMzYWtYSjJGcDlYbVljV2M2NklFOEdnZ0JtcytsRHhxZ1J1UlJaVmRWSXI3b0JrdHhQT1BwZWRLYUtzWldjZWNZNkZ5TjBSM0w4TGNDMnJBdnloQ29NNXpqWEk4TldibnIyT2M2TW5FeEdqb0dibkFtUmpKMlNrYU5qS3pjREpmTlRrTStrT2o2dHlDblNxL0Y4dXpBUWxSc2h1OG96VjVXeWJPMTNTbTlsTmRjMElsbmRpSWpQR1BtNW1tTXMrVmpYL1lXd1h2RG5NOGhDRXdBSEpBRmthU0xQR2VjN2tpUk4rMmRaY2dIRm14OFYxZ3MyM1MrWjg0Mm5NTWVtcGZ3Vkg2ZjQxcDhMKy9vYmtTMEZhWit4TE10cDhERDVYUTVoU08wQm1QNlk5S2N2Y09DNFl2T2R4WnQvTHZKWGZOeVl1ZVpBbUQxblUvaWw3d3ZYWjc0dFpGZTVEdWFjRVRjYUJpRGFCcURKWFlIN3MzZUp4UG5YRVhyaGgxTGk1SDdqQ2MwMkhtTXJ4SEg1TGFKZzFkVzYybVJVUlNFYThFN0RnNktPR1lENVdkL2xFQTM2RUVKUTRIUWpTZG05UWt0MUEwVTMvVWdNdDc1TStPV0hKTVhmYXp5eE16MHBtU3hZMTM3dWNmdjZHLzljS25Eb3lEQ0M0WENBYU1DSFNQT3V6Z2tHWUg3VzFsRWhCTkdBbDFnNGdOVlZRcjdkcVRsL0ZxeTRndnhsbDRqSXpzZUo3UGlGSk9KUjR3bWVnY2hiY2o3T1QveTFNSlhVNmpvK0hnMFQ5UStpSkJQNnBqMDlCNm1LUXRqYlJ5enN4MVpZZ2lYZnFzbllIWmZjaUczMVJoSGEvak1wdXZ0cEdFOXpSbnlJWVNxdXdYWFYxMFhla3ZOMUhhOGs0b1I5Z3lTR0kxbVBjOWdLdUhCbDNlaVBiMGozN1JicmdkY1RTWVhkaDQ3UjNOWStNU1dsUjdQVmpxMndGSk5aMzhLOFpIODd3VC8rU0lvZmZkdDRzaC9XdEZUZ3dISEpsNFIxN2VkMExaZ1Vxa28wTUVRMDVNKytmc29rczZwdUlhdVhMOFpza2hHcUdwQmsrV0xwdnQyQ1pEejJLM05lL244RENFV0cyYm12alNPZDNScFhLbUYxRm1KekZldmVFekIyNUcyQ2YveVJsT3h2TjU3MEI0WVlHZXVxcTNGKy9CWWgyNHQwZldRNEZDRGlHMERWbUFVV1ZWZHc4YXJsT0d3akhaLzlIZSsvMmJyOXhiLzl3MFAvL3JaMDMyN0JsZzBOcmszL2NQOWZMbHgxN2xlS1BOVU5BTDJEUG5ic1BVVHZZSGFUVDVaTldOM0ZXSjJGK2hyYlZZWElydDhUZXZVUlNZMzRqUWQvR21GWjBJanI2bThLaStkc1hjY25ZbEhDUTMwazQ3R3N4eFc1SEZ5eXBwNnFzbUlBQms5MnRMMzM5Qk12di9xTG56d0h2QVAwakFMSERpd0ZHcSs3ODk3UExydndrZ3VkSldYVkFFYzZ1bm0zOVREK1VQWTUwR1RKdzE1VVJwN05vZXNteEhDSTBQYWYvU255emhQbkNTVmhvR0FtUE1aZGdmT0tXMFZCb3o3L1RFMG1DSHNIaUlVRFdZL0x0MWc0ZitYWjFDOWVnQ3hKaEgxRGZZZmYyL0hXLzd2N2ptZUFQdUI5NEJnUUdnV09HU2dCRmdHMVFNbGYvZkN4R3hZMnJWa0hvS29xKzQ1MHNHdi9VV0tKN0EvWlVtRERVVnlPT1UrZm82ejRld20rK0dNcDJ2SVN4ajRyR3JPU09SLzdSVjhRanZVM0lPVnB2L3BwUkJVUEVmRU5wWlhYNDZ4RG9tSHhBdGF1V0VwQi9zaE9KTWYzN1hyN2tXOSs1WkZFYk5nUG5BUk9BSU9NdkRWYWtlN2JQZkt3dG14b3NBQU9vQXlvQVNyUFdybm1GOWZjZHNlN0N4cWF6Z01ZanNWNXQvVXdCNDUyb21vczVDcHdGbUl2S2tNMjZTdUhKVTYwNHYvRDk2WEVpVllESWVuR3MvNVNYSis4WFpqY0ZmcjRaQ1JJYUxBWFZVTmVWNVVYczI1VlBhVkZMZ0Q2Mm84ZWVPbW5EOXpiL1BKekpxQXJCWmcrUmxxTXg1WnlqZ0VuQlI0SnNBQnV3QU5VQTU3enJybHU1U1ZmK1BMVjVRdVgxQU40QXlGMjdEbElaMCsvQm0rVHNSV1dZSE9YNkd4QkZVVDN2VVRneGEyR2dUaWF3VDFuNDdycWRwRy9jTFUrQlJ1UEVScnNJUjdWa3RkV0xteGF4dExhU2dEOGZUMGR6YTg4OTlxelAvclhWNEhlRkdDNkFUOFFuem9kVEFMT0JBREpRRDVRbEFKUURWQzI4YmEvdjdSeHc1VVhGMVhXTEFibzdPbG54NTREZUFPaDdIT3kyWUs5dUlJQ2gxc2YvMG5HQ08zNFQwSnZQRHB2RFVUWjVzWjUyVmVFL2R4clFjZHlwRkd2TFJyMGFzaHJFMDExaTFqVHNBUno2aDFsN2MyN2RqejR0UnQrRGd5a0FITVNHQUtHZ2JSelhGcmdUQUNRQ2JBQ3hVQlZDa0FsZjNIUHYxKzc5TnlMTGlod09JdFZJVGh3dElOM1d3OHpISXRyOEI4cmpwSktMQVg2WHMyb0JBY0p2dnFJRk5rMWp3eEUyWVI5N1djV095Ky81YWlzczB3UURYZ0plL3RRRlMxNTdXSGQ2bnFjdHBIeFAzbW9kZmZUUDdodlRYdnpydXNuOEpoK1JncmZXYjhzSzNBbUFNZ00ySUhTRkhpcVhHVVZyMS8vdi83dE4yZXRYSE1CUUN5UllGZnJFZllkUG82cVpqY1E4KzB1bktVVm1DejZ0b1JMOXJmamYvNEgwdkNSblRtTm1md2w1MU40OWRlRnVXeWhydVBqMFREQi9tNWQ4bnI5dVN1b0xpOFpsOWZQL05jcnJ6NzIwTTdVZEhRQzZFbnhtTGd1b3E0SE9CTUFsQWM0Z2ZKUkF0MTArZFhKeTc5MDY1YUtSV2MzQXZoRFlYYnVQY2l4RXowYS9xR0UxVjJDbzdoYzk4clE0U003OFQvL0F5blpmeXluQUdNdXJzSDFpZHVFdGY1U2ZaazRtU0RZMzZWTFhxOWR1WXlHcGJVajh0cnY3VHY4N3BzVDVmV0pGQUgyQXJHWnlOb1pBV2NDZ2M1UEVlaktGSURLci96SzdldFdmZnlhUzB1cUZ5d0Y2T29iWk1lZS9ReDRBeHFaMll5anBCeWJxMWkzZ1JoNjczY0VYbjVZVXVkNEI2S1VaOFcxNGI4THg4WFg2eTRUaEwzOWhMMEQydko2U1Mxckcrc215ZXYvK0x0YmZoR1BSbnJUeWVzWlgvdE1nVE9GUUZ0VEJMbzY5YS8wQy8vNEx4dlBQbS9kUmZiQzRuSWhCSWZhVC9ET3ZvTkVvdG5UcVRtdkFHZFpGZmsycDY3enE4TWhncTl0STdUejE5S2NNeEFsQ2R1cXEzRmZ1Vm1ZbktYNnNtM1FSM0NnR3lXWmZTYXBLaXRoM2VvR1NvdmNZL0w2NVo5dDNicjNwV2Q5VStWMW5TZVpiT3N4bjlvdG5DcHdwaEJvZThwQXJBR3FMZmtGenIvODdzTTNuYlZ5elVVQWlXU1MzZnVQMG56b2ZaSWFCQzdmN3NSWlhvVTVUOStPR0VsdkY0RVhmeXhGOXIwNEoxNUdtN2Vna2NLcnZ5N3lGalRxODdkaVVZSzlKNGxIdzlyeWV0VnlscDVWUFNhdjk3MzZoOWVlK2VGM1hrdnhsMG55dXM2VEZBQm5ERGpiTm8yVTJ0dDZ6SllKL0tjYXFGcDI0WVpIUDNuek4vWlducjI4Q1NBVWliSno3MEdPSEQrcC9SZnBMc0ZaV3FIYlFJeDN0dUI5N250U3ZMTmxWZ0xHNUN6RmZlV3R3bjdPUnAxZGVFbUMvZDFFL0VQWk03WEpSTk95eGF4WnNWU1h2Szd6SkNmTmNXY2NPS21Ma0lDOENRWmlEVkR4c1J0dXVlQzhhejUzV1VsMWJSMUE3NkNYSGJ0YTZSMzBadWMvc2dsSGlRZGJVYWxtQitLb05JM3MreU8rRng2UUZIL1A3SmlWVEJhY0YxOHZYSmQrV1ZlWkFDRUllL3NKRGZab1Y2OXJQS3hidlFLbjNhWXByK3M4eWJSZk5pdUFNK0ZpWktBZ3hYK3FVaG1vN0xvNzcvM2twQUxxOFpQczNIdUFVQ1M3eVdleTVPRXNxOExxMHRjMklCSXhnbS8raXNEMm41MVJBOUhhOERFS1AvazFZUzZwMFhWOExCd2cwSGVTWkd4WVExNDdXWDl1STlVVnBacnl1czZUblJUTkt1Qk11Q2dUWUV2eG4xRUNQYW1BbWxRVW1nOGVaZmYrSXlTU3llejh3R3JIVlZGRG50V3UwMEFjd1AvaVExSm85ek1mcVlGb0tWOUUwY1p2aUlLbEYramphZkVZZ2Q0VERJZXl0NW5rNTFsWXUzSTVEV2N2SEpYWC9ZZmZmWE5ISm5rOXltUG1ISEFtWEZ6YUF1cWYzYjVsVi9XeUZhc0JJdEZoM21rK3lLRmpuWnE3blZwZHhiaktxM1ViaUltK1kzaWYrNTQwZlBpdEQ5ZjBMWERpdnVJVzRUei9PbDFsQXFHcUJBZTZDQS8xWmIxblNaS29YM0lXNXpjdG55U3Z0OTF4Nnk5ajRWRHZCQjR6QUVRelRVdHpEamdUK00rMEF1cTY2LzdpM0FzL2UvMlZaYldMbGdFTWVQM3MyTlZLVjkrQUJuK1djWlJVNENqMTZPNUFIRzU3Qys5ejM1TVNmUit3Z1NpYmNLejk3QldGVjl6OFI5bFdxT3NqRWQ4Z3diNlRtczNobGVVbFhMeW1jWks4ZnVYbkQvNSt6NHRQdDA2UjE2RTZUM0xHdnNTc0I4NFUvak5hUUIwMUVNdXUvWnU3THErLytMS0wzZVdlV29Cako3clp1YWNWZnpDN0REV1pMYmpLYTdBVjZ2TkRVQldDNy80VzM0c1BmU0FHWXNHaWN5bmErQTJSVjdWTW4vcUxodkQzZEJLUGhyVGw5VGtOTEQyclpxSzgzdjdNRDcvemFqWjVuYlBBbWNKL3JGUDV6NWUrcy9Wemk4OVplMkdlMWVaVVZaVjloOTVuVjJzYnNiaDJBNW5iVTZ0akNjK29nUmpFLzhwL0VIenI4Vk15RU0yRkhvbzJma1BZVmx5dWoyOGxFd1I2VHhEeERXakw2K1ZMV0xPaWJteDd2Wm5JNjV3SHpvUUxOMC9nUDlWQWxXZHgzUzgvZCtjOTd5eW9YN2tXVWcxa3pRYzVjS1JkVndPWjIxT0RPVjlmQlQ0NTJJbnZ4WWVrY1BNTHVneEVLYytLKzlJdkM5ZjY2NUVzMmwyT1FnaENBejBFKzdzUUdzWGZSUXNxV2JlNkVhZmoxT1gxdkFIT0ZQN2pBaXBTMDVmbnZHdXVhNXJVUU9ZUHNtTlhDNTNkdlpvR29xT29ERmRGalc0RE1kYlp3dERUMzVWaW1ReEVTY0xlOUFtS1BubWJNQmQ2ZEgxbk5PREYzOU5KTXE0aHI5MU8xcC9iUkxXbkxKMjg3Z0U2OWNycmVRV2NLUURLQndvbitEL2wweHJJdW52WnNhc0Zyeitvd1ZsTk9NdXFjWlI0OUhVZ0NrRzQrUVc4Zi9paGxQU05HNGg1VmNzbytmUWRJcisyU1orS2kwWHhkM2N3SFBKcHl1dnpWaTVuUmQxaVpFa2lFdkQxdDczenhtbko2M2tKbkNrRWVyU0JySnBNRFdSSDJubTMrWUJtQTVrNXJ3QjNaZTJNRE1UQUc3OGcrTjd2cGNMTC9vZHduUHNwME9GY3E0cENzTzhrd2NHZXJOT0VqdXZ2QUFBRHhrbEVRVlRlbUx4ZTFUQkpYdi8wenMyL0hBNEZUMHRlejJ2Z1RPRS8yUnZJNGdsMnRSeGkzNkdqMmcxa0RoZUZsV2RoMFdrZ3ppVENRMzM0ZXpwUU5Vek15dklTTGo2dmlkS2l3akY1L2VwakR6MjkrNFduOW4wUTh0b0F6dVNiMDI0Z0M0Ylp1YnVGWTUxZG10OW5MeTdIWGJGQXQ0R1lsUnVGQS9pNjJ2VlZyMWMzc25UaHVMeHVlZTJGMTUvK3dmMnZNTkljM3ZsQnlPczVBNXhuOW4wMHhjUTNicnRjWHdOWjd3QnYvbWtmQTk3cy9FS1NUYmpMcTNHV1Z1bzJFQ2Vwc1VRTVgzZUhMbm05cW40cHExZlVZVEdiTmVYMStoKzlyUElSeGh1M1hYNkdnTlB5MFZhaDMvanE1Zm9heU40L3p0dDc5eE9KWmxjMEprc2Viazh0anVKeVhlY1hxa3F3dnd0LzN3a2Q4cnFLZFd0VzRuS01USTFkYmZ0M1AvWDlmMDRycjljLzhQSVo2Y1ovNDZ2ekJEZ1RibGhmQTFsckczc1BITlpzSU11ejJpbXNXcGgxQ1UvRVA0aXZxMTI3T2R6dFl2MTVUZFI0eWpYbDlmb0hYbzV6QnVPTUFlZlpsak83Y083MXIxNm0zVUFXanJCemR5dUgyenMxdjgvbUxxR29haUhtL1BFT3hIZzBqUGZrTVYzVjYvT2E2bWxjdGlRbHIvMERiZSs4L21ZbWVYM0pBNitjOFpiRjE3OTYyZndFVHVybTlUV1FEUXp4MXE0V3VqVUxxQkxPc2lxY0pSNEMvVjM2NVBYU2hWeHd6b3BKOHZyblcyNzdYaVRnVjZmSzYwc2VlR1hXTEJLYjE4Q1pNQWk2R3NpT2RYYngxcTU5K0lPaDB6NW5aWGtwNjg5YlJXbnh1THgrN1pjUFA3M3IrZDlOazllWFBQREtyT3VxTjRBemVURFNOcEI5K1Y4ZXZHN1JxblBQSHkrZ0h1VlArdzVvRmxBenl1czFLemw3NFlJeGVkMjYvY1hYbi9yK1A2ZVYxN05oV3BwVndObjYyQlBNMXVoNDZLNXBEV1NleFhXL21GeEFqZkh1M2dQc1AveStaZ0YxWEY2ZnplckdaWm5rOWFoYUdnS0dhMis1UjJVV1I4ZERkeG5BeVRBd0V4dklSZ3VvRmRNTHFBRjIvS21aanE1ZURYbmRoTXVaa3RlSEQreDU2bnYvdEhxS3ZCNEFRclczM0RNbkZydWZPZUE4K2h2bXhBRDk1QjlIRzhnS1V3WmkyZ0pxUjFjUE85NXJ4dXNQVEpiWGExZFJVMW1oS2E5cmI3NDd6aHlLanAvOG93R2NHUUJJczRDNnYrMTltZzhjcG5IWkVocVhMeDJWMTROdDc3eitSaVo1WFh2ejNYTnVTekVET0RNZk1NMEM2c1E0dm0vWDI0Lyt3KzEzaDMxRHpxbnl1dmJtdStmc0hpd0djRTU5NE5JV1VOZHYrdExmbE5TY3RXand4UEZqTzUvOHoxZDNQZjlrODFSNVhYdnozWE4rMThzekJweGNpRXc3Y0tROG9lRVVVQ2JKNi91Mjd4YzVjdStuOURrelJwQUN3ZkNXRFExeElKU2FnaW9aYVdVTnBqTE5FREI4My9iOXFqRmlCbkNtQWtnRndsczJOQXdEdmxRV2lnUFIrN2J2VHhvak5CNy9IMXRBd2dxN0hQQTVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJzdGF0ZVxcXCI+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBtb25leSB0YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwibW9uZXktc3RhdGUgdGFibGUtY2VsbFxcXCI+PGRpdiBjbGFzcz1cXFwiYnV0dG9uXFxcIj48dGFibGU+PHRyPjx0ZD48c3BhbiBjbGFzcz1cXFwibW9uZXktbnVtXFxcIiBjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiIEBrZXl1cD1cXFwiY2hlY2tEYXRhXFxcIiBAYmx1cj1cXFwiY2hhbmdlRGF0YVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVxcXCIgdi1odG1sPVxcXCJ1c2VyQmV0LmJldG1vbmV5XFxcIj48L3NwYW4+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBwb3J0cmFpdFxcXCI+PGRpdiBjbGFzcz1cXFwicG9seWdvblxcXCIgQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJoZWFkc3R5bGVcXFwiPjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGgrJ3B4J1xcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0KydweCdcXFwiPjxkZWZzPjxwYXR0ZXJuIGlkPVxcXCJpbWFnZVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgcGF0dGVyblVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIj48aW1hZ2Ugdi1lbDppbWFnZT1cXFwidi1lbDppbWFnZVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIj48L2ltYWdlPjwvcGF0dGVybj48L2RlZnM+PHBvbHlnb24gdi1iaW5kOnBvaW50cz1cXFwiaGVhZGJvcmRlclxcXCIgZmlsbD1cXFwidXJsKCNpbWFnZSlcXFwiPjwvcG9seWdvbj48aW1hZ2UgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIiB2LWJpbmQ6eGxpbms6aHJlZj1cXFwiaGVhZGJvcmRlcmltZ1xcXCI+PC9pbWFnZT48L3N2Zz48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJzdGF0ZS1pdGVtIHN0YXJzIHRhYmxlXFxcIj48ZGl2IGNsYXNzPVxcXCJtb25leS1zdGF0ZSB0YWJsZS1jZWxsXFxcIj48ZGl2IGNsYXNzPVxcXCJidXR0b24gdW5kb1xcXCIgQGNsaWNrPVxcXCJjYW5jZWxiZXRcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXEJldE11bHRpcGxlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtOGZmNDA2N2UvQmV0TXVsdGlwbGUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ubXVsdGlwbGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcXG4gICAgaGVpZ2h0OiAxMiU7XFxufVxcblxcbmRpdi5iZXQtYnV0dG9uLWFyZWEge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnRlbiB7XFxuICAgIHdpZHRoOiAzNCU7XFxufVxcblxcbmEuYnV0dG9uIHtcXG4gICAgLyp3aWR0aDogMTAwJTsqL1xcbiAgICAvKmhlaWdodDogNTAlOyovXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbiAgICAvKmJhY2tncm91bmQ6ICNDQ0M7Ki9cXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcXG4gICAgcGFkZGluZzogLjFlbSAxZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT8zODAzOTc5YlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7SUFDQSxpQ0FBQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLGdCQUFBO0lBQ0EsZ0JBQUE7SUFDQSxlQUFBO0lBQ0EscUJBQUE7SUFDQSxvRUFBQTtJQUNBLGtCQUFBO0lBQ0EsbUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiQmV0TXVsdGlwbGUudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g6YCJ5oup5LiL5rOo6YOo5YiGXFxuICAgIGRpdi5tdWx0aXBsZVxcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5vbmVcXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiAxWFxcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5maXZlXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gNVhcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEudGVuXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMTBYXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7fVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4ubXVsdGlwbGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcXG4gICAgaGVpZ2h0OiAxMiU7XFxufVxcblxcbmRpdi5iZXQtYnV0dG9uLWFyZWEge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnRlbiB7XFxuICAgIHdpZHRoOiAzNCU7XFxufVxcblxcbmEuYnV0dG9uIHtcXG4gICAgLyp3aWR0aDogMTAwJTsqL1xcbiAgICAvKmhlaWdodDogNTAlOyovXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbiAgICAvKmJhY2tncm91bmQ6ICNDQ0M7Ki9cXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcXG4gICAgcGFkZGluZzogLjFlbSAxZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDpgInmi6nkuIvms6jpg6jliIZcbiAgICBkaXYubXVsdGlwbGVcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5vbmVcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMVhcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5maXZlXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDVYXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEudGVuXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDEwWFxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubXVsdGlwbGUge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAwLjYpO1xuICAgIGhlaWdodDogMTIlO1xufVxuXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgICBmbG9hdDogbGVmdDtcbiAgICB3aWR0aDogMzMlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LnRlbiB7XG4gICAgd2lkdGg6IDM0JTtcbn1cblxuYS5idXR0b24ge1xuICAgIC8qd2lkdGg6IDEwMCU7Ki9cbiAgICAvKmhlaWdodDogNTAlOyovXG4gICAgZm9udC1zaXplOiAyZW07XG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcbiAgICBwYWRkaW5nOiAuMWVtIDFlbTtcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogQmV0TXVsdGlwbGUudnVlPzM4MDM5NzliXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm11bHRpcGxlXFxcIj48ZGl2IGNsYXNzPVxcXCJiZXQtYnV0dG9uLWFyZWEgb25lXFxcIj48ZGl2IGNsYXNzPVxcXCJ0YWJsZS1jZWxsXFxcIj48YSBjbGFzcz1cXFwiYnV0dG9uXFxcIj4xWDwvYT48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJiZXQtYnV0dG9uLWFyZWEgZml2ZVxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+NVg8L2E+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIHRlblxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+MTBYPC9hPjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxNZXNzYWdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0zM2ZkYjgwNy9NZXNzYWdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5kaXYubW9kZWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHotaW5kZXg6IDk5OTtcXG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDEyLDI2LDU1LC4zNSk7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZ1wiKSArIFwiKTtcXG4gICAgdG9wOiAwO1xcbiAgICAvKnBhZGRpbmc6IDEwJSA3LjUlOyovXFxufVxcblxcbi5tZXNzYWdlLXRyYW5zaXRpb24ge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbn1cXG5cXG4ubWVzc2FnZS1lbnRlcixcXG4ubWVzc2FnZS1sZWF2ZSB7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi50aXRsZSB7XFxuICAgIGhlaWdodDogMjAlO1xcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXFxufVxcblxcbmRpdi5jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LmNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlPzVkMjNkMDU2XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrRkE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsYUFBQTtJQUNBLG1DQUFBO0lBQ0EsMENBQUE7SUFDQSxPQUFBO0lBQ0Esc0JBQUE7Q0FDQTs7QUFFQTtJQUNBLGlDQUFBO0lBQUEseUJBQUE7Q0FDQTs7QUFFQTs7SUFFQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0Esc0JBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGtDQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1lc3NhZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICBkaXYubW9kZWwodi1zaG93PSdkaWFsb2dTaG93Jyx0cmFuc2l0aW9uPVxcXCJtZXNzYWdlXFxcIilcXG4gICAgICAgIGRpdi5kaWFsb2codi1iaW5kOnN0eWxlPVxcXCJkaWFsb2dcXFwiKVxcbiAgICAgICAgICAgIGRpdi5jbG9zZSh2LWJpbmQ6c3R5bGU9XFxcImNsb3NlXFxcIixAdG91Y2hlbmQ9XFxcImRpYWxvZ1Nob3cgPSBmYWxzZVxcXCIpXFxuICAgICAgICAgICAgZGl2LmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXG4gICAgICAgICAgICBkaXYodi1iaW5kOmlzPVxcXCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS50eXBlXFxcIix2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIpXFxuICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGRpYWxvZ1Nob3c6IGZhbHNlLFxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcXG4gICAgICAgICAgICBkaWFsb2dJbWc6IFt7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdiZXRJbmZvJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9udXNSZWNvcmQnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lvIDlpZborrDlvZUucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdydWxlSW50cm9kdWNlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdleGNoYW5nZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+i1oOmAgeWlveWPi+mHkeW4gS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlY2hhcmdlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfV1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIGRpYWxvZygpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA3NjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE0MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDQ1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBjb250ZW50KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY2xvc2UoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0MiAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0ODQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndXJsKCcgKyB0aGlzLmRpYWxvZ0ltZ1t0aGlzLmN1cnJlbnRJbmRleF0uY2xvc2UgKyAnKSA1MCUgNTAlIC8gY29udGFpbiBuby1yZXBlYXQnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5kaWFsb2dTaG93ID0gdHJ1ZVxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gZXZlbnRcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcG9uZW50czoge1xcbiAgICAgICAgYmV0SW5mbzogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlJyksXFxuICAgICAgICBib251c1JlY29yZDogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZScpLFxcbiAgICAgICAgZXhjaGFuZ2U6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWUnKSxcXG4gICAgICAgIFJlY2hhcmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlJyksXFxuICAgICAgICBydWxlSW50cm9kdWNlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWUnKVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG5kaXYubW9kZWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHotaW5kZXg6IDk5OTtcXG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDEyLDI2LDU1LC4zNSk7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZyk7XFxuICAgIHRvcDogMDtcXG4gICAgLypwYWRkaW5nOiAxMCUgNy41JTsqL1xcbn1cXG5cXG4ubWVzc2FnZS10cmFuc2l0aW9uIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbn1cXG5cXG4ubWVzc2FnZS1lbnRlcixcXG4ubWVzc2FnZS1sZWF2ZSB7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi50aXRsZSB7XFxuICAgIGhlaWdodDogMjAlO1xcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXFxufVxcblxcbmRpdi5jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LmNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGTVRaRVF6TXdSRE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZNVFpFUXpNd1JUTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVXhOa1JETXpCQ00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tVeE5rUkRNekJETTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrWDJ5bWF3QUFBQTlKUkVGVWVOcGlZR0JnbUFrUVlBQUFuZ0Nhb01YTEN3QUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICBkaXYubW9kZWwodi1zaG93PSdkaWFsb2dTaG93Jyx0cmFuc2l0aW9uPVwibWVzc2FnZVwiKVxuICAgICAgICBkaXYuZGlhbG9nKHYtYmluZDpzdHlsZT1cImRpYWxvZ1wiKVxuICAgICAgICAgICAgZGl2LmNsb3NlKHYtYmluZDpzdHlsZT1cImNsb3NlXCIsQHRvdWNoZW5kPVwiZGlhbG9nU2hvdyA9IGZhbHNlXCIpXG4gICAgICAgICAgICBkaXYuY29udGVudCh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXG4gICAgICAgICAgICBkaXYodi1iaW5kOmlzPVwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVwiLHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiLHYtYmluZDp1c2VyaW5mbz1cInVzZXJpbmZvXCIpXG4gICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpYWxvZ1Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgY3VycmVudEluZGV4OiAwLFxuICAgICAgICAgICAgZGlhbG9nSW1nOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiZXRJbmZvJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/mipXms6jorrDlvZUucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib251c1JlY29yZCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncnVsZUludHJvZHVjZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+a4uOaIj+inhOWImS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNouWVhuWfji5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWNoYXJnZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGRpYWxvZygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDU1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA3NjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTQwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNDIgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0ODQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd1cmwoJyArIHRoaXMuZGlhbG9nSW1nW3RoaXMuY3VycmVudEluZGV4XS5jbG9zZSArICcpIDUwJSA1MCUgLyBjb250YWluIG5vLXJlcGVhdCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1Nob3cgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGV2ZW50XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgYmV0SW5mbzogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlJyksXG4gICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlJyksXG4gICAgICAgIGV4Y2hhbmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlJyksXG4gICAgICAgIFJlY2hhcmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlJyksXG4gICAgICAgIHJ1bGVJbnRyb2R1Y2U6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZScpXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5kaXYubW9kZWwge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgei1pbmRleDogOTk5O1xuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZyk7XG4gICAgdG9wOiAwO1xuICAgIC8qcGFkZGluZzogMTAlIDcuNSU7Ki9cbn1cblxuLm1lc3NhZ2UtdHJhbnNpdGlvbiB7XG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xufVxuXG4ubWVzc2FnZS1lbnRlcixcbi5tZXNzYWdlLWxlYXZlIHtcbiAgICBvcGFjaXR5OiAwO1xufVxuXG5kaXYudGl0bGUge1xuICAgIGhlaWdodDogMjAlO1xuICAgIC8qYmFja2dyb3VuZDogYmxhY2s7Ki9cbn1cblxuZGl2LmNsb3NlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG5cbmRpdi5jb250ZW50IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC42KTsqL1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1lc3NhZ2UudnVlPzVkMjNkMDU2XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd01EVkRORFkwTWpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TURWRE5EWTBNek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakF3TlVNME5qUXdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQXdOVU0wTmpReE0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0lpMk4rUUFBR0xOSlJFRlVlTnJzM1F0c1hmVjl3UEcvbjNIc0JGZ1NWbGg0ZFVCUjJNTFFJQlZVaUJaYUpsSlZ0QnNxS3hxMDY2b0tXQjlhcDAyYXFnbDE2NFEyVFlOSkJRbjJWRWM3dWpLbWxUSG95bFphVkExVVlDcGhEUVhLS0k4TUtDUlFIRHYydFgyOTg3dlkyZkc1NXo3OHVPWUdmejdTWDVCenI2K2RZMGZuNjNQKzUzOTdabmZkbVphZ054czdzbkZlTnM3TXh0dXlzVFViSTlsWWx3Q0F0V0l5RzJQWjJKT054N1B4WURidXljWUQyYWcyL0tqdE8wczM5eS95a3grVGpVOWs0OWV5Y2F6dkJRQ3NlZXZteHFiSWpXeGNQTGY5Mld4OE9SczNaT081ZGwrc3Q4M25iWjU3NFNlejhYdWlCQUJvNGRpNVpuaHlyaUUycjFTWVhKS05IMlRqTjdNeGFEOERBSXN3T05jUTBSSy8ydXJKL1MwZSswSTJyaXg3c1BxVDExSmw5eE5wZXMvemFlYmxmYWs2dWorbHFlazBPejN0V3dBQWEwUlBmNVlMQS8ycGQrT0cxTGRsVStyZmVuUWFQUFhrMUh2NFljV25ic25HVjdMeHJteDhLaHVsd2REVFlQTHJjRGIrSVJ2dkt6NHd2ZWVGVk5tMU8wMDg4RDNmRFFDZzFOQ08wOVBnYWFkbW9YSlUyY04zcERoN3NuM25lRHRoRW1kS2JzdkdSY1VIeHUrK04wM2M5NkM5RFFDMEZ5aG5uNW1HTHppMzdLSGJVMHlVM2I1enVoZ2hSZGNYbzJUNm1UMXA3T3YzcEprWGZtd1BBd0J0aXhNYVUwODluVVl1UEQvMUg3YzEvOUJGYzgyeFlNcEljZkpyVEVxNUlyOWg2c2tmcGRGYi9sbVVBQUJMTXZQQ1M3V1dpS1lvdUNJOWN0ZWxqY0prODF5NUhEVDk5SE5wLzIxM3B0bkpTWHNWQUZpeWFJbG9pbWlMZ3V1ek9EbXlMRXorS0wwK1kvYWdzWCs3SjgxT1ROaWJBTUR5NHlScmlwZ2FVaEFMczMyK0dDYkhaZU5qK1dmRlJOYzQ5UUlBc0ZKbVhud3BqWC9qMjhYTnY1RWV1ZXU0ZkpoY2xZMkIrVWRqYlJKMzN3QUFuVEJ4LzBPMTFzZ1ptR3VSV3BqRXVDei82T1REdSswMUFLQmpTbHJqc3ZUSVhiM3o3eEo4elB6VzZxdXZwY2tISDdiSEFJRE9oVW5XR3RFY09kRWlPeUpNenM5dnJUejZoTDBGQUhSY1NYT2NGMkZ5Um41TDRab1BBRUJIbERUSG1SRW1wK1MzeEJ2eUFRQjBXa2x6bkJKaGNuUitTM1gvbUQwRkFIUmNTWE1jSFdHeU1iOWxkckppVHdFQUhWZlNIQnNqVEFZWGJKcVpzYWNBZ002cmI0N0JYbnNGQU9nV3dnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBbmRadkYwQ0gvNUZ0UHlPdHYvU2pCLzg4ODh4VGFmekdQNnY5Zjg4Um0xUC9xYWN0K2JWbjlqeWJxay8vc083ejlXdzg3T0NmWjBkZlM5T1BQTlQrYnl2SG41VDZ0aDY3WU52MDdsMXA5dFc5aS82N2xqbHd5OS9XdnA1MXYzSlpHanp6ckdYdjMvblhtN2RTcjl2Vy9zOTlMd0ZoQW9lRWlJU0JrMDhwL3dlWVJjbkd6M3gyeWE4OWZ2dHRhZUxtaFdFU1laRC9mTE1IRHFSWFBueFJ5L2lZTjNqV3VXbmQyZWZVZlo2Wkp4OHJmWDQrV3ByOVhlZE56RVZUejhpR2xzOXR4MFF1d2xieWRRRmhBbThLOFJ0N0hCem45UjM1bGdXUDkyM2Vrb1l1dnpJTGloczc4dm1uSHYzdkJRZm1udlhyYXlHU1A3TXllTzU3MHZCRkY3ZjltczJlTzNyZE5XbnFQKy94alFlRUNYU2p1SXpRN0RmMjNrMmJhd2Y2VG9WSjljWG42Lytobi9KenFWSzQ1UE5tRldkMjRneFBKd3lkODY3YTl3OFFKckJtVE85NU5zMk9qNWYvZ3ozbXVOb1prS1lmLzlqMzZ6L3VaMDlLbGRXSWd1eHJieFVGOFp5bEJrUTdZUkJuYnpwMUJtZGcyODhMRXhBbXNMWWMrT3JORFErc0c2KzV2dVg4aWJoa0UvTks4Z0V6OU80TFU4L3dodFM3NWNqYW55ZnV1SzFoRk1UQnQvZzVKdS83VHBwNTZjV21vVEgvdVl0elhsWXlJTm9KZzRGM25KZjZUdXpNSEpPNERBY0lFemlreEowYWVUM0R3Nm0vTU5HMFU1Y2E1azAvOTB4ZFhPUW50STQyaTRMTHI2ejcyTXI5OXg0eTgwZ2lTaFl6ZndZUUp2Q21Wcng5Tkg2REw5NTUwNm41SmZPS0UyQUJoQW5RVU55VlU3bjMzenYyK3BQL2NtdnBKWmxPYTdZdVM5bWFLNTBRKzdYUnJjM0x0ZjZTeSt2T2ZnSENCQTU1Y2FsaEpRNmUvY2UvdGU1VzRCRHJpb3grOXBQTFhzQnQwVjlQazNWWnl0WmNXYXpaOGJHV3o0bDkwYWtBR25xZlMwUWdUT0FRMTN2VTFvWUh1Ykl6R3JGU2E3c0dmK0VYMC9UVDd6bDR3STlJR2JuaXR4WThKeTdyZFByUzBWSXNKWnA2aGtkYTcrOG1pOGN0KzJzZUhxNzdjNngydTVpVmRRRmhBbStvZ1ZPM0wrcjV6UTV5cmM0WXhKbUM0aTNGY2ZEc3hqQlo3cXEzRFdOdGtZdkhMZXZ2a0FWUXJMUTdLa3hnNVg2WnN3dWdnLy9Bc3QvZTQ2eEdVVnpXcUw3OFV0MzJxU2VhWDk2WitOcFhVM1ZmOC9lc21YcjgwYnFEWjN3ZHF5SE85c1RmWVRwM0MzR256YXppNXdKV0lmanRBdWljK08yOU5EQnV2ckYydDA1K2JaRFpzZjJwOHMyN21yNWVuRTE1OVlvUExYaWp2dUtCZWZycHArcGlLTDZPL1B5T1ptKzJWN1pXUjB6NmJEUy9JdjhtZXZIZk9IdFFkaWRTSjBTa1ZkZklpcllnVElEbGg4a1piMi80V05sNkd5T1hmbVRSbnlQZXF5Wi9jSjcrM2dNcEZWNTMvUVh2cmQybGN6Q003cmh0VVhmc05Mc1RwZmdtZXNzUkM4UEZHaXh0UFhkOHJIWUdxU3o2Rm5QcGF0T3RkeS80YzV6eGlZbkRnRENCTjVXNGZQSkczRm9hWnkyS0s3L0cvK2REWktKTDkxbEV5WEtqSUNiVmJ2emNuOWJ0Ky8xL2VYMnFmT05yeTNydGVJUEdlQytrdk1xRDk2ZkpmL3FTSDNnUUp0RGRHbDNHV1EweHo2UnNic3RhRUxkSzc3L3VtblQ0NTY5ZEVHY2JQcDRGejhmL1AzcGF2U3R5V1lRVXp6TEZYSnBXbDk4QVlRSmRJZDV3YmxVT3hDVzNGOGNsam9HM2JXdjRobi9UdTNmVkRzeWxRWFhXdVF1V3J3OHhXYmZSdWl2eFd0MG1MbTN0di9HNlpjMXo2Um5aMFBKeTEvaGYzMUFMSVVDWVFGZUx5Wit0M213dTVrSEVLcVZsYTI3RXdUNS93SXZmM3N2bW40emQ4c1hTMjR0ajJ5c2Z2cWoyZFRRNnE5RG9iRUhaRytCRmxCd3E3NVV6TDc3ZXNhTzJwdUVQWE5MeUhabVhJbUxOK2lVZ1RLRHJ0Zk1Pd0FjRDRTZXZwUFhaYi9YRitSQnhpV0QwYzc5YkM0aG1VZEpxYmtNY25PUHJLZHUrRnNUK2lWRzI2RnFyTXozTmxyYVBzMVNpQklRSkhKTGlMbzlHb1ZKYk9qNExrT0premZqLzJGWjU2THVsaTRYRmIrdnRUTGlNMjRMTDVrV3NOUkVseFROQmNadjFZaS9ERk05a0FjSUVEcjNmMnI5MWQ5TXpLTTNpcE95dW5zbjd2dFAyN2JEOXArK29QN2orNFB0cmF2L0hYVG9icnZ6TWdzczVFWXV0OW1IRVRIR095dXZ2OTNPakgycm9JQ3Uvd2dxTEJjZGlZbW1NVjMvbnFyWnVVWjJQazFabk15Skt4cTc5ZzdhL2x2emFKUWZENUgvVzFvSms2ei8wNjNWelRNWnUrdk9XSHhlWHU0b3I4Y1o2TUJFNmdEQ0JRMGJNUGFnZDFMS3htRlZKVzhWSjVlSC9XbFNVeEFHMDdFek4xSGUvczJhK0YzRXBhK2pkRnk3WVZuczdnRGEvTDdFUTNZSjltZ1ZPaEE0Z1RHQk42RHYyaE5TM2FVdnBZM0g3Ynh4bzJ6WHc5blBxbzJrSjh5cFdVOW43QnkwbFJ1SnVwTUZmZW44YS90Z25GcjcrdnIxMWwySmlNYnBHSWk3akxGVmVoRTZqdTUyQUZmaUZ3aTZBbFRkMCtaVXRueE4zMjhSYUdYbTFTd1VOYm0yTjdZZGQvY2UxQTJYK1BYYUt0L0xHWFRpeFhIdUVURjJZek0wdktTN0Qza3B0cmtXRE5VSGFYY0k5dnl4K28rZkgraW1EZjNmN29tN3ZMUzZVRnU4QjFHaE96OWdYYjNvOTJyS3dtSjhNMitwekhianR5M1hydXNUK3FIN2tpdG90NGZzK2VJRWZlQkFtME4zSzdxUXBpbFZGVzkxV1hIWkhUOW5pWi9rRGM3UFhuUG54aTIvWVBpa3VpOS9zZVowUVFUZS9uOHJlcDJoZVJGMWVYUGFKankzdTkxYnIxQUJMNDFJT3JMTGloTXBHSWpqaXpFSzh4MHV6eXczdGl0ZFlyZVhUeTFhanJZdWtWYnh0T1M3aHhKbVB0cjQvdXgrcDJ4WWZ1eExmQTZBMVoweGdGY1VFMXJKM3hNMkxlU0NUOTM3ejREb2xjVmRQOWZubjB0RDdMMGs5d3lQMUVUQzJ2K1huamRmTUw1L2ViaHkxWSthWnArby8zeU1QbFo1bEtKNkptUGlQcjZkMTczam5pcDRsYWVleVVseitpdkFyMjE2MitGeDhyYTkrK3FPcC85VFQvQkJEaC9YTTdycHpOcjloM3g5ZWE2OEFBS3RpMDlXL3ZlRFBMdVVBQUYxRG1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBckpEK2J2OENaN094cnpKVkc2TlRNNmxTcmRhMkFRQ3Q5ZlgwcE1IZW5qVFMzNWMyRFE3VVJvOHdXWnFJa2FmSEo5TEVUTlZQRmdBc3djenNiRG93RTZPYVhwNmNTa045dmVuNDRhRmFvSFNqcnJ5VUUyZEVJa2dlR3gwWEpRQ3dndUs0R3NmWE9NNTI0eFdJcmd5VFo3S2Q5YjhISnYzMEFFQ0h4SEUyanJmQ3BJVzlsU2xSQWdDckZDZHgzQlVtRGNRcHBSK05UZmhKQVlCVkVzZmRicnFrMDFWaHNuZHlxbmJYRFFDd091SzRHNU5paFVtSmZWMTJPZ2tBMW9KWEtzS2sxUDdwR1Q4ZEFMQ0dqNzlkRlNaVHN5N2pBTUJxNjZacEZGMFZKbFZMdWdMQXFqUDVGUUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdGaUZ3QUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtZGdFQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhZaGNBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENwQXYwOWZUNGpnREFLdXVtbzI5WGhjbEFyekFCZ05VMjJOczlPZEJWWVRMUzErZW5Bd0JXMlliKzdqbitkbFdZYkJvYzhOTUJBS3ZzcDdybytOdFZZYko1M1VCWG5VNENnRGU3T081dUZpYmxZb2JKQ1NORGZrb0FZSlhFY2JlYnBuaDIzZW1KcUxhZldiL09Ud29BZEZnY2J6ZDMyVFNLcnJ4dWN0endVRHBxYU5CUERBQjBTQnhuNDNqYmJmcTdjV2ZGR2FXM2pxeFBodzMwcDJmR0o5TEVUTlZQRUFDc2dLRyszbHFRYk83U0cwNzZ1M25ueFU2TE8zWDJUazZsZlpXcHRIOTZKbFdxMVRUcjV3b0EydjVsUHlhNHhpM0JjVXlORzAyNmVkV3cva05oaDI3SmRtSU1BT0ROemIyNUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQW9ENU1LZ3UyOVBYWkt3QkE1OVUzUnlYQ1pEUy9wV2Zkb0IwRkFIUmNTWE9NUnBnOG45L1N1MkhFbmdJQU9xNmtPWjZQTUhrc3Y2VnZ5eVo3Q2dEb3VKTG1lQ3pDNUtIOGx2NnRSOWxUQUVESDlXODl1cmpwd1FpVGUvSmJCcmU5elo0Q0FEcHVjTnZKeFUzM1JKaDhOeHZQelcvcFBlS3dOTFRqZEhzTEFPaVlhSTFvanB4b2tRY2lUS3JaK05LQ2dqbnRWSHNNQU9pWWt0YjRVdHErc3pxL3dOb05LYmVlU2N3ekdUcjdUSHNOQUZoeDBSaUZPYTJWdVJZNXVQSnJuRDc1cS93emhpODROL1c5NVVoN0R3QllNWDAvdmFYV0dBVi9rN2J2ZkM0Zkp1SHFiT3pOUDJ2a3d2TlN6OUNRdlFnQUxGczB4Y2pPODR1Ym96MStmLzRQdllVSFBwbC9adi94eDZRTkY3ODM5UXdPMkpzQXdOS2paTjFnclNtaUxRbytuYmJ2M0ZzV0p1RXIyYmdwdjJIZ3hCUFN4a3QvMldVZEFHQkpvaUUyZnVnRHRhWW8rSXNzU3Y1K1FjRE03cnF6K0tSWXVQN1diRnhVZkdEODdtK25pZnNlc29jQmdMWU1uWDFHR3I3Z25XVVAzWjZORDJaaFVta1ZKbUU0Ry8rWWpaM0ZCNmIzdkpBcXUzYW5pUWUrWjI4REFPVkJzdVAwMmkzQkRWYVUvOWRzWEpKRnlYanhnVVpoRW1KaXlSZXljVVhaZzlWWGY1SXFqLzR3QzVYbjA4ekwrMUoxZEgrYW5jeWlwMXIxM1FDQXRhSzN0elovcEhmamh0cDczOFF5ODRQYlRrcTlSeHplNkNOaXlzaW5zaWlaS251d3Y4bW5pZys0TWh2Zm1ndVVMUXUranV3VHh1a1pBSUEydkp4aW9tdEt0elR0bkRaZUtDYkVic3ZHalNtM0NCc0FRQnNxY3cyeHJWV1V0QnNtODVWelZUWk96TWFmWkdPUC9Rd0FOTEZucmhsT25HdUlsOXY1b0daelRGb0Z6WTVzeENvcGNUMG4zcEk0Ymt6ZWtGNmZtd0lBckEweDlXTi9lbjBWK2NlekViZnZmak1iRDZUWDM0K3YzUGFkcFp2L1Q0QUJBTUZuWSszRnQxcUlBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+aKleazqOiusOW9lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeFJETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE14UlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBd05VTTBOalEwTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16RkRNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNZnRobkFBQUJsSkpSRUZVZU5yRW1WbHNWR1VVeDg5Mzc4eWRtVTVub0tVdDNVanBndG9BcllaQVVHTVV4QWVNb0xqeUlnODg0UExnOHVxTFQwWjkwY1JFM0dKSXdBU0NSQTJJTVpIbHhiZ0FCbWxrR3pxbGhkS09MZEIycHJQYzNYTm12cWxUT25QbjNwbHArWkwvTEhmdWQ3L2ZQWE8rYzc3elhmYkpxbllvbzBtb0IxRWJVRDJvZTFCTnFHcisrelJxRkJWQzlhRk9vbjVIS2RrTG5JZ1BPeHJRVlNMb0E2aFhVYytqYWkzT3ErVmFpZHFHZWhjMWdmb1c5VG5xck5PQkJZZm45NktPb3Y1QzdTb0NXNmpWOEw1MGpaODIrbHQ3NXdQWWkvb0lkUWIxSklwQitZMnVzWm11aWRBZm83eVZBdTVDL1lGNnV3d1hLdWFXYjlFWUNOMVZGckFKNWpvK1NYcGgvaHVOOGVjR2Y4djZrb0FSZGowRGRnSS8xc0hDdFZvYzg1Z1ZkRjVnQTh3VjJQRUlmdlREd2pjL2pmMll2MldGTFdEWjFIM1k0ZEFDVy9iT1ZrY01EMWMxK1lyR1lUY1RQbVNaSkREMy8ycFlDbzgvc3gzcW0xcWcvL3c1T0huNEVLaUs3Q3pUZUwyd1llc0wwSDd2U3JnWkdZSGpQeHlBaWZHeGZDR2tCMWsrd0k5djVoNFhOemZVekh4UlRXT05pd2xmNUxQOGtxVk44T3pPMTZHbXJnRUVRWUM2eG1ab1h0NEovZitjQTBQWGJjTSt2ZU1WYUZ0eEg0aWlDSUZGaTZGclpTOE1oaTVBS2hIUEE4M1d0THFyajE1VFk2TnpYQUpUSkJNWmU3OVE2TnEwYlR2NC9OV3pqalczdGNQV0hidkFMWGxzd3pZdWE1dDF2S282Z1AvYVN3VkRIbWRpYzREUlg5WUp3RFlWVEUvMURYbVBaNkVsajhjeDdJeXIxVGRhaERIMkJMSE5BazViRjlnYlZobHNLSFNwNEVVSmVzdkwrYUdMd1ZLN2V2bThaVWJNWlVzRHQwdkJnTWlFTFZhOWFIS01ERjExQkcwSDlzWmdPRDE1clJxeEVlTU1jSVBvZXdUeEExYWRGRm1HSS91K3RBMXRGL2J3M3E5QVU1VmlpNDRBTWFiaFBmNjRzRndLdm9iUllYMnhpYU5qTkFoak9HdHU2NFRBNHBxODU5QngrcjM3L3JVVmdmMC84OExZZFhYNkY3S3dHeDI3eDI0Y3RXdnBTc0x5eWRlVFlRWHdDSXc1S2p2c1FGY1NOZzJjWWZRUXNJUXZTNXdPWEFwMHFiQjhzaTNockpRb1dGVXBDZDhKZERtd2ZPb1JvNHVBeGZMcUJwWk8xY1ZQRS9DOHNnc1ZrVVppdVBaTmxsUXkyd2hkZHBLTHZTaVJabVJwMHhpbU9UV2ZzSldBempJU3NLbUNNVExmc09WQ2MwYVRnSFhGTU1LVmhLVUo1alNORjUzZ0dVYWRnTFVwUXo1VFNWaUtCazdTdUoyR2pMU1BvUkd3TXF4T256R0tURHluYXdPbmF3OUwvd1V6aFdtWmpLb1FzSnd5OWR0eFF6dHQxV25qMWhjZHAxdTcwSTgrOVp3bE1MS2R3bHJ6RnJFS2FYOEdpSTVxOFIrdE9uVjByeW9wS2RpQjd1aGViUWtjeWJCRmlWWFk2RzgxYUpjUjNlSjAwdEF1RnVvMEhybFJjZ1lyQmszRmFLRkdUT2dPcC9sT3FKRk5VVlFCamcycHNXOU1jcGw4Qy9qdkQwQmlPbFp5dWkwRUhZOUY0ZGgzK3dzdEtRMWsya2RzbkRGVE5WOVZvd1RKWW9hcTE0cWVWcS9nbXJONlM4YmpXQ1pkVEpmNGt1U0Y4SVUrK1BuZ1BrZHJnK3g2ZWxGTkhWUUhGOEg0NkRBYzNiOEhwbTdkekI4WmRQbGtTSms4U0ZVVUttMHRsdDNReHJxT2RnODdKQ2F1WGVkcmVBL2ZXKzdpUmdvb3BqNXlLam4yRHI2VE93eWdVbmZ1L05DT1NBUlBHTGdvVCt6V3dZemZMVmdhR3hrK0pSWmk0bXl6eTN5Y2ZDWTMrK0F0UGZYM0ZYbnlNMXh3S0FzTlMyUFMyTVJBTEp6SnpMdnpnNVdwZ2Y1TVljNUFmNVlWMDRqVXVyeTlESmg3SVdBeFFTUkM4dVR1RVMzK0czNjlESm5uSTdMbDNocjNGWXBoYnV3b1lNQk9kSHRxZHFKUE44KzN6NkliN09HV0RYR0cxSndGY2E2RnVaV0JXNWxTdFpZME5YVlVTNXdQQ3BJZm84Y3lWcG5IQmJOQzE2UXUvM28yTmY3MXRLRmU0cFlkNG1ITUxBcDhCM1NDN2hML0tqT2lKUVlTcHRwZkxVaTFiaVpVWkNzMllXaVhRc3JFM3JBeWRSekhHT1N3MXd2QkZuS0ptVW1Jb1k0Nlh1UGdzVEV0R1VjTkxIVlZkYlc0L0E4RlJXbTE0TEFlcEVWV1ZGZjZicUNmL3FzbCtpSHpHR3lZVDdDYjNBM01ncnVEbGd1ZVRPUklJbmlFM3pVdFFGcHdvQ25VRlpFeGY2UEwzNG5KcHRQSFhFMGVKdGJqc1NCT1Vpazc0M1hUak9JOEdFZlhHcjJ0eTJGY0Y0VHhXSnl2RGNhNHIwWjRORkNMMW9aMm40VFNoaUh0QzZDQ2ZIZStIaktsTiszQlV0SnhjNGs1bTRwbU9xeG1RRlJ1dldsKzQrUGNvbEVlQ1V3N0hDNEhqMDVOUGlCZGZJcUhuQUMvZ1FBSDkrVkFRdzVza29QR09HQ011NWxpRjlTV1MxaUF5em5nYm01NWlWOHZuNFUxRGlmekd6QktuYWovQ1RBQXdkUS9JUGhDYWg4QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd05FSkdPVE15TlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TkVKR09UTXlOak5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakEwUWtZNU16SXpNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQTBRa1k1TXpJME0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K004WkszZ0FBRit4SlJFRlVlTnJzM1cxc1hmZGR3UEcvN2RoeFlpZU80enczYlpwMlRSKzIwYXBOaXhnd21tb0lsWTVxRXRCRnJBS0phWFFkZEMvNkFuZ0JUQlc4WUx6b20ycXdkc0NFVk5SUWloRFZxZ2lCU0RlZ0UzMVkyNjNyVTdZMmFaTTRhWndIeDNsdzdDVG0vRzV5MCt2amMrMXIrMTducHZsOHBQOExuM3Z0T0NkWE90K2M4ei8vMC9MRU8yTnBCbHF6Y1dzMk5tVmpZelkyWk9PeWJIUmxZMzRDQUM0Vko3TnhMQnU3cy9GMk5sN014clpzdkpDTk05VythZlA2NHUwdDB3eVR0ZG40L1d4OElSdVgrN2NBQUtwNFB4di9tSTF2WkdOWHJXSFNXdU1QN3p2M2czK2FqVDhXSlFEQUZDNC8xd3cvUGRjUWZiVjhVeTFoY2s4MjNzekdWN0xSWVQ4REFOUFFjYTRob2lVK1A5V2I1MDN4MmlQWitITFJpMGVHUjlQMmZVZFMvK0R4ZFBEWVNEcDZjalNkT24wbW5Ub3o1cDhBQUM0UjgxcGIwcnkyMXRROXZ6MHQ3ZXBJcTNzV3BtdFdMazZMTzl2emIxMldqUzNadUQwYkQyVGpWTkhQcXpiSFpHRTIvaWtibjgyL3NIZndSSHE5LzNCNjVmMkQvalVBZ0VJM1hiNDAzYkI2U1ZyVnM2RG81ZTlrNC9PYjE2Zmp0WVJKbkNuNWwyemNuWC9oZTIvdlN5L3VITEMzQVlDYWJGeTNMSDE2dzhxaWw1N094cTluY1hKcXFqRDVaamJ1cTl5dys5RHh0TzJ0L3ZUQjBMQTlEQUJNeS9KRm5lbU9hMWVueTNvWDVsOTZOQXVUTDA4V0pqRXBaVXZsaGgwSGpxWm5mcmdyblR4MTJwNEZBR1prL3J5MmROZlByRTFYOW5YblgvcXRMRTZlS0FxVHVJMG5ac3d1SzIvWWRlaDRldnJWOTlMd3FDZ0JBR2FuczcwdDNYM2pGV250K0RNbk1XbjF1aXhPOXNjWGxiY0wvMFZsbElTNGZDTktBSUI2aUtiWTltWi9mdlBTYlB4NStZdHltRnlSalM5V3Zpc211dTQzcHdRQXFLUDlSNGZUZDkvZW05Lzh1MXZlTGJYSStUQzVQeHZuYnpqdUh6emg3aHNBb0NGZTJubWcxQm9WMnMrMVNDbE1ZdHhiK2VycmV3N2Jhd0JBd3hTMHhyMWIzazJ0NWFjRXJ5MXZQWEppTkwyNnkrSnBBRURqUkd0RWMxU0lGcmsxd3VTT3lxM2JQemhpYndFQURWZlFISnNpVEc2cDNCTFB2Z0VBYUxTQzV0Z1lZWEp0NVpaNElCOEFRS01WTk1lMUVTYXJLN2NjT3pscVR3RUFEVmZRSEtzalRCWlZiaGs1ZmNhZUFnQWFycUE1RmtXWWRGUnVPWDFteko0Q0FCcXVvRGs2V3UwV0FLQlpDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQU5Obzh1d0RxNjhHTnkrZjB6M3RqLzRtMGRlZlJjZHZ1WE5jOTd1dksxL08vMzlhZkRLWTNEbytNKzk3cmx5ODQvL1dlSXlOcHk5dUROZjB1bjFxNUlOMzNzeXNuZmMrai83Y3ZQYmZ2UlByU0o1ZW1YMWkvZU5aLy8vTFBLNnZYejYzRk93UEQ2YUhuOXZyUWd6Q0I1clg1NWhWeit1ZHQrY0VIRThKazg0M0wwdldydXM1L3ZlUEo3ZWZqSS8vN1JkaFVoa24rZStQbjUwTW5yL3puOTNTMmpmdmVJdkdlc0dqKzFPK3RSZm5ubGRYcjV3TENCS2lUZlVNajR3N09ONjVZTUM0K3FybCtTY2VFZzNvdG9iWDFzUi9iNllBd0FZcnRIUm9kOS9XZDEvV21OWXM3MHNNdjdpOTgvOWMrdFNwZHRhd3pMZS91dU9qLzduRUdLTTd5Tk1Kbk52U21aZDN0UG1BZ1RJRHBIcHdyeFZtUUdOWENKS0trSHBjL2RneU9UQmtGOFo2WkJrUXRZUkNYbGZLWHR1cmx4alZkd2dTRUNWeGNianQzV2VNZjdyNXl3c0grYS8rK2MwWUh6WmpqOGRDdnJCc2ZIM3VQcGQ5NWVzZWtCLzlaQjA3MloxU0tNeXI1QS9ON0I0Yy9mUC9oa2ZSR2xmaXBSMERVRWdiNXlidjE5RkU0b3dUQ0JKaHpFUWpQdkhZZ2JkcXdKQzNzYUp2eS9YRjNTZDZyZTQ2Tk84T3lvck10UGJuNW1nbnYrN3NYOWpYVjN6MmlaSzRuSUFQQ0JKaEMzTVphNjYyc1Q3NStNRjNaTS81c3dPRHc2WEZmMzMvejhnbVI4K3oyUXcyN2JBSUlFK0FTZGVmSGVnclBNcFF2UGNYbGticyswVGZ1dGVNanA5TzNYeDRZdHkzT3F0eXlzdmd5U2x4ZXF1WE9vTmtxcmN1U20yTlRMMSs4ZFdXNlltbW5Ed3dJRTJBbThndWV4ZVdaNmZpMTYzcExZZkxBejYrWjhOclRyeDJZRUJvUkpmbTVNR1V4MGJYVytTZlZIRHQ1ZXNyM2xPYTVOQ2lBWW8wWFFKZ0FNL1M1RzNySFRjRGQrdWFod3ZjTlpRZjg4a1RYeXZkdlhMYzQvZFdtTlJNbW5BNGNIVTJQdjNad1ZyL2JaR2RYcXVtYVAvVjhtVmlMSlg5WnFsNjZjcGV5NHV1SXY4cVZad0ZoQWxRNThOKzI3c09sMmVQU1N5d3QvK0R0YXllODkxcy9PbGdhNGFuZnVIcmM1WXJicittZDhQNS8vZEZBK21ENDlLeCt2OG5PcnN4R3RjdFNqUkQ3S2M1SVBWZmw3aWhBbU1BRkY4OXFpV1hSaTI0dDNYVFY0aG5keXJwcTBjUmJaT1BueDNOdjhzL0tpZi9CMzN2VHN0TFpoY3JKcXMvdlBGTDE1eGZkMmx4Tm5Ga3BSMHhlVEppTjErTk13bHpOeGFqWHJkR0FNSUdQcEhpQVhMV0RmTkhaaDVtS3l5dHhaaUQvckp4NGRzekdkUk1mWXZlRDNjZnE4dWR1ZVhXZzZtdHhTU1BPSGhTdHU5SUljVWxwTGliVUFzSUVxS1B5Wlp6WmlyVlJHbmw3Y1B5ZU93OE8xL1RlbUFqNytDc1RJeW5XWG5sNEdwTnNuLys5ajQvN2VyS0Y2d0JoQWt4VCtYSktwY3F6SFBuWDR2MUZDNnpsL2MrN1I2cGV3cW1YaUpMWlJrSE1yZm5yejE0NTRWTFN3OC91bW5XY3hXVzZPQ00yMS9zRmhBbHcwU3BmVHFtbThzQWZkN0RFWk5HaGtkUG5ieVhPejFtNTJNU2szRC85ei9mVDMzenVxbkZ6YkdMU2IrWEUzNmtlRDFBVUlmbExkTEVjLzc5dEgvU2hBMkVDemF0ODRMK1F6OHFwVmR4V203K0RKVDluNVdJVTgwNit2bTNYck9hNXhBVG1xU1lFUC96ZmUyWjlkeElnVE9BamJiWVRUeU5VcG5PN2JZVE13N05jT0swUklxN1dmcjgvZmVHV0ZUVTlMMmk2NHU5dC9SSVFKZ0ExSzYvUFVyVG8ya3RUUk1Wa1M5dkh2QnhSQXNJRVlFWWlTdkxyeDhUNko5TzlEQk14NDlJTkNCT0FHWXU3ZFA1bzA5cHhsM05pZnM1VWw1OGladktYeEpyMXNoVUlFNkJweGR5S3JZLzllTkwzeEIwblgvcTUxWk8rSis0NCtjcDNkbHowWndqdXYzbjVoRGttZi9tOVBUWHR4ODFad0ZST2dMMzdFMzJsWndRNWF3S04wMm9Yd0tVbEhzbzNWWlNFV0FjazFnT0pNdzRYcTFpZS82NHNKaXFWbm5KYzQycXgrVlZ1STNBaWRBQmhBaGVkV0ptMG1VUmd4QzNNUmN2aVA3djlVT21BZmFIalpOL1E3SmVYanhpSk81TTJiK2hKRC83aW1uR3Z4UkwyK1VzeHNkcHNOWEhXSlBaTnBRaWQrUGxBWTdpVUEzVldmb2pmbFgwTExzaWZYMTQwTGU4ekczcEx6OWNwaXBJLzNIYjIwc1pRRmxQNXN5bmxPSG5xaHdOcHNDQzJZaEpwTFdjZzRqTElqV3ZPWGhhcHR2NUtSTk96NnhaUDYvYmUvTm93OGJUZmF1dVBQUEsvWi8rZUVSYmx5YkJUL1ZuZmZubGdRc3pGM0pNSHNzaUovWG5iRkpmTkFHRUNGOVJrRC9HYkMwV0xwbFVUejc1NTZMbTk1Nzh1TDYxZUZDZVZxNlpXS2wwYXFXRkNhQVJBTGZ1bEVXdU9sQU9zSERBUkpkWDJVZjVNVjBSWGZHOCtUb29pRDVnOWwzSmdEc1haaFdieHJlLzNqNHVTeWppSjEyWmpzSWJKb1hPNUwrSVNUcHo1cU1YTGV5WStoVG0rZDdKTFBrRDlPR01DY3lUKzExM3JwTXVpQTMzKzRYdTFQSGd2ci96MDNxMXZIcHIwZ1hZUkozRlo1N2MzcnB6Um1ZRllmS3pvTEVQK1RFU2NzZG0wWVVsZHo1TFVza3gvTEp4V05LZW0ybk9DNG5lOVo4djJkTXZLQlQ3STBHQXRUN3d6TmxhNTRlSC9jTDBVWmlNbVgvYmtKb3ZXT2crakdjWEUxOGtPeUJmejN3MjQ4Qjc4NVkrUCs5b1pFNml6ajlwUzViRm14OFgrVUQvZzRtR09DUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FCQW5jeHI5bDl3Ykd3c0hUdDhJQnNIMC9DeG9YUnFkS1MwRFFDWVdtdHJXNXJYMFpIbUwraEtYVXY2c3JFMHRiUzBDSk9aaUJnWjJMMGpqWjRjOXNrQ2dCazRjK1owR2hrK1VScERod1pTKy96TzFIZlp1dFNkUlVwVGhsUlQvbFpqWStuQTdwMnAvNTAzUlFrQTFGRWNWL2UrODFicE9KdWE4QXBFVTRiSmdUM3ZwVVA3ZHZ2MEFFQ0R4SEUyanJmQ1pBcEhEeDhRSlFBd1IzRVN4MTFoVWtWTWFoMTQvMTJmRkFDWUkzSGNiYWFiU3BvcVRJNGVHaWpkZFFNQXpJMDQ3c2J4VjVnVWlMdHdBSUJMOS9qYlZHRXlmUHlvVHdjQVhNTEgzNllLazlPam96NGRBRERueDkvbW1VYlJaSk5mei9oMEFNQ2NIMzlOZmdVQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNaMkFRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0ZpRndBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1kZ0VBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUxud3YweGJtMzhSQUpoakxTMHR3cVJJMjd3T253NEFtT3ZqYjN2ekhIK2JLa3ptTDFqbzB3RUFjNnh6WWJjd0tkSzFaS2xQQndCY3dzZmZwZ3FUN3Q1bGFWNjd5emtBTUZmaXVOdmQyeWRNaXNUa20yVnIxL3VVQU1BY2llTnVTMHZ6NUVEVDNTNGMxZGE3OGpLZkZBQm9zRGplTnRQWmtxWU1rOUMzNW9yVXMzeTFUd3dBTkVqUDhsV2w0MjJ6bWRlVWU2dWxKUzIvZkgxYXNHaHhPckI3WnhvOU9ld1RCQUIxMEQ2L00vVmR0aTUxTCtscnl0OXZYalB2dk5ocFhUMUwwOUZEQStuWTRZUHA1UEdqNmRUb1NCb2JHL1BKQW9DYS9xL2ZVcHJnT245aGQrbnVtN2pScEprV1ZMdW93cVM4UXhjdFhWNGFBTUJIbTJmbEFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQWdJbGhNbEs1b2EyMXhWNEJBQnF1b0RsR0lreUdLcmQwdERtSkFnQTBYa0Z6RE1XVy9zb3RYZlBiN1NrQW9PRUttcU0vd3VTdHlpMUx1enJzS1FDZzRRcWE0NjBJazVjcXQ2enFXV0JQQVFBTnQ3cG5ZWDdUaXhFbTJ5cTNiRmpSWTA4QkFBMTN6WXJGK1UzYklreWV6OGF1OHBiRkM5clRUWmN2dGJjQWdJYUoxb2ptcUJBdDhrS0V5WmxzUEY3NXlnMnJsOWhqQUVEREZMVEc0NXZYcHpQbCszUytrU3JXTTRsNUpodlhMYlBYQUlDNmk4Ykl6V2tkT2RjaTUxZCtqZE1uZjF2NWprOXZXSm1XTCtxMDl3Q0F1bG5XM1ZscWpKeS8zN3orN0xTU3lwVk4vaXdiQnlyZnRlbmExYW16dmMxZUJBQm1MWnJpanV0VzVUZEhlL3hKK1l2VzNBdC9VUG5PdGIwTDA2OStjbTFxdHhvc0FEQUxIZk5hUzAyeHRyY3IvOUpYTjYvLzhNUkl5eFB2ak9YZjhNMXMzRmU1WWRlaDQybmJXLzFwLzlDd1BRc0FUTXZ5N3M2MDZiclZwUk1lT1k5bFVUS3VPWXJDSkpaaCsrZHMzSjEvNGJ0djcwMHY3VHhnRHdNQU5ibGxYVi82cFEycmlsNTZPaHUvbVlYSnlGUmhFaUpwbnNyR25ma1g5ZzZlU0svM0gwNnZ2SC9RM2dZQUNzVTZKWEZMY0pVVjVaL0p4ajFabEJ6UHYxQXRURUtzZXZKSXlsM1dLUnM4TVpKKzhzRlE2aDg4bmc0ZUcwbEhUNDZta1ZObjBwbXhNZjhhQUhDSmFHMXBLYzBmNlo3ZlhucjJUU3d6LzdFVmkxTFBncXJQM25zMEd3OWtVVEphOU9Ka1lWSzIrVnlnV05nRUFKaXBnV3g4TlJ0UGxPSmlmWlhRcWVFSGJjbkc5ZW5zcE5nUit4VUFtSWFSY3cxeGZUbEtKbFByZmNCUk9mZG40K3BzZkQwYnUrMW5BR0FTdTg4MXc5WG5HbUtnbG0rcTVWSk90YUM1TlJ0M1pPT1diR3pJeHRwc2RLZXpjMU1BZ0V0RHpCVTVtczZ1SXY5Mk5sN0t4bjlsNDRWMDlubDhoYXBkeXZsL0FRWUFWT0FLeXJXZmMyRUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5byA5aWW6K6w5b2VL+W8gOWlluiusOW9lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3lRMEkyT0RZek5ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRveVEwSTJPRFl6TlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pKRFFqWTROak15TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakpEUWpZNE5qTXpNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtJTWtOUFFBQUJvWkpSRUZVZU5yRW1XdHNGRlVVeCsvTTd1eDJIOTJ5TGR0M2VXMUJETkRTR0tCQThKR0kwWUJHVTFHajhRc2ZmTVFvbXZnSXFNRmdGRTM4b3VHbGljR29BYlVLaGtlTkFWdGlTbHRwS1pVSWxLVkxDNFh0YTF1NmJiZjduQm5QbWIwbFc3cXpPN083TFNmNVp6WjM1OTc3bXpQM25udnZHY2IyN3U4a0JkT0JWb01lQXBXQkZvRUtRR2I2L3hpb0IrUUFuUWZWZ1JwQndZa0cxbFp2VXRXaE5rblFDdEFyb0tkQjJYSHV5NlphQW5vS3RCMTBDMVFOMmdjNnA3WmpWdVg5NWFEam9MT2dseExBeXBtVjFzVTJhazV2cWk1WFU1bFJPQ1F5UUorQ1hrL2hyY2haR0xRTHRCV0doejhkSGk0bFJHeUM2MXZUQURzeExOL0VQc0RicFNrQk13Sy9FaHFDU2NLVWsyazM3RVA4cDZIcXA4cWtnQUcyVW1UWld2ZzFtOHlZTWRuUTU4bDQwREdCV1NHMEVDb2VoUVpNWk1hTk1XSGZqVlVIRmlvQzF2a0dEUUtqL1hWbVBUc0Zlall5TkcvY1owZ1loOE42eStlRVljcGlOVFBmbGtrK2ZMeUMzSk9mUldvdnVzak9tbi9KZURDc0NzV3M1OGpXRGVWazNhSjhjcVhQUXo0K2VvNTB1Y2RpTURObHdQSVovTm9pRzlhNHdPaDlJWDFtVTZ3SHNlZGF5TjRYMXhDclVYKzdySzE3a0d3NTBLUVlHbUcvZW1FMVdWWmt2VjAyNUEyUWw3K3ZqdzBOL2dPbVZTdVBiRzZkTWlRZ0JqSThsN0ZUTG5SdGY2SmlFaXphOHBJYzh1WHpsY1NvMHlZRkt5MkZKajM1WUdPRmJNaWpUTXdVWUJndkt3V1dlMWl1NXR3Y2M4eHlKZEJ5c05GRFRjNkFhVDJ5VFFLV3ZLczF2aEg5SkhkYVEwZS9iS1B4b0JQQm90VTdldVBPd0dnMmpXbnRjempBTGNONVpWL0RWUzlYcTlIWlR5cm01cEQ4TEdQTS83RWMvLzhMSm1PSUZ4VER0bDV6ay9jUG55VmhRWlM5UjJTMTg0QnRkOWJBaFlEazRjR2lWZXVnSURQZVkrTEV3Z21HRTAySnA1WENiam5ZUlB3aFBrR1VZeklsUnZUd0k2N2YyQnYzVnIzS2M0YktSQk1IUFljZVZPTHBEZVZ6MGdNN3dTenkvVVdPWXlmUXc1eWc0Y3FVeGxHbG5rNG5yRFQ1SW93Y0F1c0ZqVzYrbXVDdkJEcWRzQkZnaVZHUHdEcVIwZWFvN1RnWjZHUmhwWWtYWWRRaHNGWmtXR015Szc0YTZGUmdJOEFTb3hhQk5hbHNVMWlHSVJvMjhUbUFaUm5wM2hSTncwcEJRK1I5eWRSV0VycVNXY1psb2dReU1wSnJOSHpBTTUydzZZQ2VZRVJnVVJ2MHVxWWJObFZveWlnaU1NLzViem5UQ1lzVFRPbUtxTlFvSTQvQVlZdjdja3M2WVRFYXFGbkdsWmhsMElGNWpEQUNCd3M2YWxvWUlleExGeXlHTHJWN2ovaW45N0MvMEhFY25ScEU0SUIrZkhESU9OTGRISy9TTmpqV3FGMXVsVUsvOTFqOG5RR3duWUd6SmpZaTdkWkNvSkc4enJwajhTbzlzTGdncVVWQkNmU0RjZHBHeSswNmhXd2p5TXFlM2xTTm05ZXhnbzQvbWpQRytpN0pWWEwwZXBKZXdSSkJPL3Jrb3lveUZWNnBhYWFaVUdGaWlmS0Mrb3ZiRC85SVJGR0lWWEVIbkc3eHdKanNjaXNIUFREcUp6dU95Q1F4Z2FXNC9kQVB5RVlaSXllT09SY2xMelBtNFU1K0pIZHBjY0JrbTdKN0d4NFBrdE5YK3NnaU9PSWI5VnBTZDZtSGJEdlVvbXB2TUxHZkxyYWFpTTFpSU8wOUh2Sk85Um5TUGVTTmVYK1crMUxkZ3JiOXY4RFBUdERvcEdNK25Pc3dRN2tnbURGclJkdjZMejRKWldRVmtidG9uTi9qV243aTdXMDYvekFPaDZzZy81MlpIM3pmdlhERDFZVXRlL2F3Zk1CN3QyQ3hiMkRZalN6SVJOa21IL05oOG9uVTdWM1dudGEyQlczZjdXVUVQampqU1Nyb0UvdEdCbVNoVEdMTTNCcEFZNGh6ZzV4NVYwODIybHUvMmNYeXdmR1o4Mnh3SFB2RXZwR0Jzb1RpNXRib1dMbUp3eWl2czViVitZYkdPMWE4dGhuR2R1RjB3c0xyZDVVMjc5bHY3VDJIbm5WUWhpa1orVWhlSXNxNmx6eURVUU9mQ3BmcXNHR3NONVRYVlhmQm0yMDMrWTI1SmJCN1p0SktDcUZyMXNCLzlVdFBmZlN0eVhPOUhVb3VnNjdSTURZbFdTSDdqUU96UVhEQi9EQkdDenVvMEYyeVp2SDFKYzl1OEdVV0xrNEhxMkhVMVQ3bndzL0haM2MzSUtpTERvT2JjckJ4Z2FPZ01keGhybmdlcUJoa2RaZXNMZTBwZlhUTm1OVytESTdmUm5Yak5PUXozM0tlejNmKzJXQzdYdDlCSXAvQmJ0QUo1cWJEUURZTnBPZ3JFb0J6Y01ITVVENzFlQzd1K0hpdHdkUS85MzY3SjYvTTdqUG5GNFF5WnRtZ3pDS3dXbDBra3g4T2FzSytFYzQvUEFCRHF5ZXI3N3d6OTlyZlRpanowcjFCUC9Wb0w0MEdvWVJSUk9tWFVPcHR6TDFacU1kdElEeDZtK2xiNEtnMFVVbEY5QlJQUVVMVWU3Z253UFY1Z0hwMGhNWlpVVkhZZTNJK3B6cFVrc2duV3lQMXVvVmVFZHdRQlUyaVlIMFVkSlFDNGhYRFpWQXBhTHl3bG5CZVU0K2dQQlJRVHg5Q0srUGhNSVVMMEFjUWtwMm8vd3N3QU42RUlIbmpDU3lvQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpWUFBQUw0Q0FZQUFBQlArandaQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG96TmtFNE1qRXdOak5HTlVZeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3pRek5GTmtOQ1FUTkdOVVl4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qTTJRVGd5TVRBME0wWTFSakV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pNMlFUZ3lNVEExTTBZMVJqRXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrakdWanBBQUFHZEpKUkVGVWVOcnMzVzFzWFhkOXdQRy9IMklITjJsYXAwOXAwcXhyUzlOU3ZGVTBwZDNLMUJZUUxHTmoycm9WRlpBMlVUWWV0bFpqcjZZeGVESGd4ZlptYUlBMktrQ2J4aGgwb0dsc3REQVZLTkxZK3BDeXRpblFBaTJsaWR1bVRkS21ka3pzeFBiT3ovWjF6am4zM090cng5ZmN4SitQZEpUNDNPdHIrL2hLNSt0ei91ZC91cVlmdmlNdFFYZTJYSmt0MTJmTDlteTVPRnMyWjhzcDJkS2ZBSURWWWp4YkRtWExjTGI4SUZ0MlpzczNzK1grYkpscStGbERPeXBYOXk3eWkyL0psai9LbHJkbHkzbCtGd0N3NnZYUExZT1JHOWx5dzl6NjNkbnl6OW55aVd6WjArcUxkYmY0dkkxekwveDR0dnlaS0FFQUZuRGVYRE04UHRjUUc1Y3JURzdNbGtlejViM1owbWM3QXdDTDBEZlhFTkVTYjFub3liMExQUGF4YkhsMzVhUGpCMU02a0gyTjBlR1VEdTlQYVdJa3Bha2oyWExVcndBQVZvdnVMQmU2MTJUNXNUNmx0UnRUV3JjNXBjRkxVdXJmVUg3bUdkbnkrV3k1TGx0dXlaYktZT2hxTVBoMUlGdStrQzIvWHZmSTZOTXA3ZHVWMHQ2ZGZoa0FRTFd6dDJjcE1wU0Z5cmxWai81bmlxTW5RenZHV2dtVE9GTHlwV3g1YzkzTFBQWDFsSjY1eDhZR0FGcXo2ZXFVdHI2dTZwRXZweGdvTzdTamNPU2thb3pKeCt1aVpHUjNTbzk4V3BRQUFJc1Q3YkRyVTdNdFVmVG11ZVpJemNJa0JxVzhxN0RtNEJNcFBmYUZsQTQ5YStNQ0FJczN0bmUySmFJcGl0NlZkdDE1VTZNdzJWaFhMaU5QcGZTamYwdHBjdHhHQlFDV0xsb2ltaUxhb3VqaldaeWNXUlVtSDA2ekkyYVBlZksvVWpwNjJNWUVBSTVmTk1XVFh5dXZqWW5aUGxRT2s2M1pjblBoYVRIUU5RNjlBQUFzbDdIbnNzYTRxN3oySFduWG5WdnpZZktlYkZrei8zRE1UV0tnS3dEUURzL2NPOXNheDZ5WmE1R1pNSW5sN1lWUGlIbEtBQURhcGI0MTNwNTIzZGxkdTB2d2x2blZNYVByM2dkc01BQ2dmYUkxb2ptT2lSYTVNc0xrdFlVbnhqVHpBQUR0VnQ4YzEwZVlYRkZZVlR6bkF3RFFIdlhOc1QzQ1pGdGhWZHlRRHdDZzNlcWJZMXVFeWFiQ3FvbFJHd29BYUwvNjV0Z1VZYksrc0dyS0xLOEF3QXFvYjQ3MUVTWjl4U2ROMmxBQXdBcUVTVjF6OUhYYktnQkFweEFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBd0VtcjF5YUFuNDJuOWg5T1krUEZHMWhkY3U0cGRjOTc5T2xEOC84ZjZPOUpXemV1YmV2M2RjZUR6NmVkangrYy8vamFWd3ltYXk4ZFhQTDNFNitYZDhGWkEzVS81NzZSaVhSZjdtc3V4cXN2M0pET1dOKzNvcis3YjMzL1FEcVUrOTM5MnVWbmVrT0RNSUhPRXp1c1AvL2NEK2MvZnNkck42ZWJyOTlTK2R4L3VIdFArdHFEK3d2cnZ2MmhxK3AyNmgvNTBoUHpINy8vaGdzV0RJRy8vTktQNmw2M21Yak44bzQxLy9tbkR2UVd3dVRtdjN0ay92OXZ2SHhqK3VBTkZ6VjkvZnozWC90NjlXRnlwTzU1cmZyMGUxNVpGeWJYZk9EZUpiMVcvdWRwRmgvZit0NkJ3allTSmlCTW9DTmRtZjMxZnVhR05lbjVnMGRtUHY2UEI1NUxOMTJ6S1EzMDlTejZ0ZUtJeW0xMzdaNy9PRjYzNmdoRXUzZUtMNDBkWFoyUktUNUFtTUNKTGdMa042NDRLMzNtRzhNekgwZWczSjN0NEdLblZqNzZVYVhaWC9yeFdsV2Z2eHc3ekRnNkVEdmk4T1R6UHkwODlwMGZ2elJ6RktaVkN4MnhpWjhoLzNQRVVZb2JmMm1UTnc4Z1RLQWRmblA3c1RBSlg3em4yZlRLODlhbjBjT1RLL0wxTDltOHJ1bmo1V2c0cGI5bjVwUkZvNWlJSUZyTXFhSGxFRWVIWHZYenAxWStGdUgwMlBEWXNyeFcxZllBaEFtY1ZHSzhReHdGcU8zd1lpZDYwMGNmbWxtM0ZGZGR2Q0c5ZnFqMXo3M3g2bk1hUGhZRFY4czc0c3UyckZ2eXdOTjJpWkJvTkhhbGxTTlBWYThWQTJ4akxFdk4xalBXemh6aEVpWWdUT0NrOTZaWG5WVzN3OXQrNFlhWkpZNmcxUDdpMzdaNUlQMU9rNUFJMTcxaWNGRmpWTXBYMWNRUmxGcXNQUEhjV0YzMEhNOFZMZkh6dE5QdDJiWjZkSGgwL3VPRkJ0bzJFL0dWRDVvWU5GdDFGUlFnVE9Da2MwWDJWM3BjZlpJUGhEaWRFMWZVeExwYW1KeC81c3NxeDRpTVRVeW1wL1lkbnZsLzdkOHFWWmZybnIyaHZ4QkZNVWFrRmlZN1MwZEdybjc1YVRQL3hpVzg4ZjNXNU9NcHhOVkZtMDd2TDN4dTdlY3BpM2pJQjBSNTNFelZWVUQ1UzVBTDY3TW95ZjhzeHhNbWdEQ0JWUzEydmtzZG1Cb3hrcjhzdDVHcXkzV3ZLSTJuaURFaWNZVlBSRVQ1S002Rlp3L00vQnRIRHZKSEQvTHhGQzQ2WjJEK2t1SGEvQ3V4UkZBNDZnQUlFK2hRNWRNbzczM0QxcWFuU2lJVXFzWTQ1STllTE1Ydi92TFo2Vi8vWisvOHg0L3NIa25QdnpSUjk3eExOMWRIUmN4ZGtwZWZ6Nk04LzBwNTdoV0E0MkZLZWxoR01RdHBuRHFwQmNlLzczenVaL0o5WEx5cEdCeDM3ZHFmSHQ5YkhGOFNSMXNhalYwcGYzNDVwdkt2QWJDY0hER0JaUlJIUi83dzllZk5EN0tNeTRiajh1SEZEakNOY1NJeE9MUHNyNy84Uk9FVVMwd1gzeWlROHU3OVFmMVZONHNadUJwSGdVd3dCZ2dUT0FIRlZUUXhZMnR0OXRkM2Z2S1JtVXRXZi8rNkxTM2Y1eWJtRmltUDNZanhIUGtvaWZrNXJtd1FGeEZDY2NWTlBraktjUktEVnh1SndiQlZ5b05VTncvVy96emxtV21ySXFmOHMwYUlBUWdUYUlNNFBmSytONTAvZjgrYzJnUmxWYk9iMWdhdnhnNi9hckJyczFsVTMvcWFjNXRlUmh4WDNGUWRLYWxGeldKdUJsaWVEYmFtZktWT1dHaU9rZks0R2pPL0FubkdtRUFieEJVc2NjU2luWDVoNi9vbFAzN2RaWU5OUHpjbUg4dXJIYWtwejRNQ3NOd2NNWUUyK2ZCYlhwNitQM3dvN1QwNFB2UHhHZXZYck9qWGoxTkIrUnNLNWpVYjNCcXFqc1RFM0NwbGpVNzVBQWdUNkRDeGM3K2l5VDFhV3BHZnJHeWhtK05WeWQ5UU1PL1ZMUXg4alZscDgyTmFZbTZWWjE0WVgvRHo4cGM2eC9Qelg3OXFwdHNZWXdJZ1RLRE40dDRzK1h2UXhOR0ZsWjZNTENaR3F3cU9WcTRTaWxscHl6ZkxHejVRbklXMmZNb241Sy9laWJzVzUxMno3ZlRLcTNzYXpmd0tDQk5nbVZUZG02VlZoK1ptVmMxN2NleG80ZVBhZUk5bXNWTjExVTdFUVN2S2s2ekYxeXNQZ2wzb0hqNTdEMDdVaFUxY3RmT3ppRFJBbU1DcVZyNHNkakU3NGhpWHN0RFZMYlhIbTgyOG1yK2JiczNJNGFOMTYvTDM1cWxadjdhMzd1ZkpIMEdKSXk4THVlZUhMeFkrcmwyUkUvZmVhV1Y3VkYwTkZLZCs4aE83RGJSNEttajA4R1JkL0FIQ0JGYU5UcGdodFJ3R0lhYXEvNU1kNXhmV3RYSnZudkw0bGpqVnM1QkdseXQvKzdFWDBzM1hieWxFV3ptdzRqUlFQb1JpbXYwUVZ6elY3dHV6R0ovNzc2Y0xIMy9sTzg4ZDl4Z2dRSmpBQ2FGOEdtWXhzNnd1cDY4Mm1PenNnUisvZE53NzVhckoxWnB0Zzd3SWpoaUQwMnlzeXo5K2E3Z3VxR3IzLzZtNlEzRmVQZ1F2MmJ4dUpuTEtWeWZWNXBZcFB4Y1FKbkRTS2MvMzBXeVcxU3BWVTlMZjl2WGRoU01Rc1hOdWRybHU3UGpMZzFkckhuenkrTVBrOHZOUFhkUTJpQURJSDNYNTdwN1Joa2MreWtkTEZxdDh4K1UvL2FkSEs1OTMrLzgrVS9kY1FKakFTU2R1bWxlejJGbFdROVdVOUtlVkJxTXVOSUQwdnNjUE5ueXNmQ3Bsb0RSdUkzOVVJUzhtall2dkk0NEFMUlEyNVRFMmNYUWkvM3IvbDhWUnd6RDVYdkZxbnZLbHk0c1JSMjRhblZLcUhUV3AybzZPbm9Bd2dSTmVIS1g0eWI3RGhSMWh6Q1d5SE1wWHlTd21qc3BpSi8vVS9zUHp3UlQvVmgwNWlEc2w1MCtCdk8wMTU3WjhwQ1UrTng4V3NmUFBCOGJkM3oxUU45YWxGaEw1Z0ltd2k3bFBGaG9NM01oWEgzcStMcTd5djU5R1IwMXVMTTIzQWdnVE9PR1VMeEVPdGJsRTR2UkVIQWtvSDRXNC9aNW5Ld2VwaHZ3TjhSNyt5VWhMMzBOOG5iamlwSHlVb0x4RC91Z2RUNmJYRDIxc09sWWpiajZZLzM1andHaHRKdHNRRTdXVng0bEU4RHl5ZTZRUU5MVkxsT1BmV3BqRTR6SFc1Y3hUKzJiQ0tJSWtac2VOVU1pTHV6V1h4Y1J0OFhYR3NwOHo1bEpwZE5seVBLYzJMcVVXU0RFajcxdi85cUg1NzYvWlVaTkc0MlFhM1RzSUVDYlE4UzdiTW50S0lHS2hIQ1Z4Rk9UUjRkR0dweHFXY3BTZ0tuN2lpcGFZaHI1OHQrRlltb1ZKZVlCcitRWjhNUTZtSENZM2ZmU2h1dGVwM2V5dlBPSGJyWi81L3Z5TkRCdGRGUlIzYTc2N2RHb25acE90elNnYjMwTStLaHJkRURIRWtaZUltSWlkL0xiTlB6OS9kZEJDVnlvQnk4OU4vS0NOWXI2T1psZWUvTW9sOVdNczR0UkZLM044TE9iZU83LzZpMmZPN09EanRSZWphdWJZcGFnTi9yMXlrVmNueGZaYmFCSzNWc1hQSHR1Z0ZqdUwzUmJOWGhkWVBvNll3REtLVXh1MXEybGlRR2wrMEd0K1lyQTRVaEpSRXVNMUh0OTdiRkJuclAvdFZ4OGIyNUMvNzB4ZURIeHRGRHpsUVp2WFpqdmhXdWg4NElhTFprN0h0Q29HcDhiM3NMUEJRTnFGSmplTG5mWmJYM1B1L0hhSXlJalhhK1ZJVUd5cm02N1pOTDlkajJjQWJJaWpKTFhJaVgvZjk2YnowOTk4NWNuS214eTJLcjZuMzd0MnN6YytMS091Nllmdm1DNnN1ZmNqdGdyUVZ2bVpabXNCVnh2UFVRNjY0M250K1Znei9UMTBycXZlWC9qUUVSTmd4Y1VSaTNJc0xGYzhWTDAyY09Jd3hnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFDZWIzbzcvRHJ1NjBtVGY2ZWxvLzJscGFzMHBhYnE3YjJZZEFOQ0M2YW5VUFRXUnVvNk1wZDd4RjFMUHhJdlp1bWxoc2hTVC9hZW5pWFZiMG5SUHZ6Y1dBQ3pwRC96dU5OV3pOcVZzbVZ3N21Mb214MVBmNko3VWswVktKK3JRVXpsZDZVZ1dKT01iTGhRbEFMQ01ZcjhhKzlmWXo4YitWcGkwNE1pNnplbkl3RG5lUFFEUXJuMXR0cCtOL2Ewd1dVQ2N2aEVsQUxBeWNSTDdYV0hTU0ZkWG1saC9ubmNLQUt5UW1mMXVCMTFVMGxGaGNyUi9jUGFxR3dCZ1JjUitOL2Evd3FUQ1pQOXAzaUVBc0lyM3Z4MFZKbE85cDNoM0FNQXEzdjkyVkpoTWQ2L3g3Z0NBVmJ6LzdiakJyd0RBNnQzL3VsY09BQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEd3Q0FFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3c1FtQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCZzFZWkoxL1NrM3dnQXJMVHBhV0ZTYWVxSU53Y0FyTEN1RHRyL2RsU1lkQi85cVhjSEFLejQvdmVRTUtuU00vNmlkd2NBck9MOWIwZUZTZS80Z2RRMU5lRWRBZ0FySlBhN3NmOFZKbFdtcDFQZnlHN3ZFZ0JZSVRQN1hZTmZHK3NaZnlHdEdYdldPd1VBMml6MnQ3SGY3U1FkT1kvSm10SGgxUHZUNTd4akFLQk5ZajhiKzl1Tys3NDZjM1BGS1oyblVzL0VTSnBZdHlWTjkvUjdCd0hBTXVpYUhFOTlvM3M2N2toSmg0ZkpyTmhvTDV0NE1SM3RIMHlUL2FlbHFkNkJMRkw2WXJONlp3RkFpMy9zZDAxT3BPNmpZek5YMzh3TWRPMmdNU1VuVkpqTWJzL3AxSHQ0Lzh3Q0FKemMzQ3NIQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBMUlmSlJIRk5qNjBDQUt4QWhkUTF4MFNFeVVqeFNmMDJGQUN3QW1GUzF4d2pFU2JQRkZiMXJiT2hBSUQycTIrT1p5Sk1IaXVzV3J2UmhnSUEycSsrT1I2TE1IbWdzR3JkdVRZVUFOQis2emFYMSt5TU1QbG1ZZFhncFRZVUFOQitnNWVVMTN3end1UytiTmt6djZwL1EwcG5iN2V4QUlEMmlkYUk1amdtV3VUK0NKT3BiUGxzNGNsbkRObGdBRUQ3MUxmR1o5UFFqcW5hQkd1ZlNQbjVUR0tjeWFhcmJUUUFZUGxGWXhUSHRFN010Y2o4eks5eCtPUlRoVS9hK3JxVUJzNjI4UUNBNVROdzFteGpGSDBtRGUzWWt3K1Q4TUZzMlY5NDJ2bHZTS2wzclkwSUFCeS9hSXFmZTJONWJiVEhYOVErNkM0OThNZUZwNjdmbXRKRnY1VlNUNStOQ1FBc1hVLy9iRk9jdXJYOHlLMXBhTWYrcWpBSm44K1dUeGJXYkxnZ3BXMXZjVm9IQUZpYU9IMno3Y2JacGlpNkxZdVN6K1ZYVk4xZCtOWnMrWEpoVFJ3NUdYcG5TcHV1c25FQmdOWkZPd3o5d1d4TEZFVnIzRkplMlRYOThCMlZiWk10WDh5V0hYV1BqRDZkMHI1ZEtlM2RhV01EQU5WaW5wSzRKTGg2UnZtdlpNdU5hV2pIV0t0aEV0Wmt5OGV5NVYyVmo0Ni9tTktCeDdKUUdVN3A4UDZVSmtaU21oeFBhWHJLTHdNQVZvdXU3dG54STMzclorOTlFOVBNRDI1THFmKzBScDhSUTBadXlhTGtTTldEdlUyK1ZIekN1N1BsN3JsQU9hUHdhSHhCcDNZQWdOYnNTN1BEUmY2bDJaTzZXM2loR0JBYk45RDUrNVNmaEEwQVlHRVRjdzF4NlVKUjBtcVkxQ3JuUGRseVliYjhWYllNMjg0QVFCUERjODF3NFZ4RDdHdmxrNXFOTVZrb2FLN01sdGRteXhYWmNuRzJiTW1XZFdsMmJBb0FzRHJFMEkvUk5EdUwvQSt5NVlGcytVYTIzSjltNzhkWGJXaEg1ZXIvRjJBQXN0V3FXb1Q1bmQ0QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd05FSkdPVE15TVROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TkVKR09UTXlNak5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakEwUWtZNU16RkdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQTBRa1k1TXpJd00wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KytZS21id0FBQmtoSlJFRlVlTnJFbVgxSVcxY1V3RysralpyZzUycDFhS2RXK29jZkcxSS9Wb2NWTXNISi9tZ3BnMjJNd2Y3WUI3b3lIVk0zaGdqaXBoVlJWKzBIVyt0S3U2M3JuTUphaDFDcFVteTFzN3ExRHVla3hpbjFXMnVxSmpHSk1Udm41VVpTKy9MeVhvejJ3Q0g2OHU0OXYzZHk3am52bml1eTJXeGtHeUlIVFFmTkFrMEVqUVBkQytwUHYxOEZuUVlkQWIwUDJnbmFBMnAyVEhBa1dpN0lvTWhENEpkQVB3UTlCaG9rY093UzZDK2daMEQvM0duZ0pOQ3ZRSE53TE5tZW9PRjIwTThCK3A2M2dYMG82TWVnVXVKZFdRZHRvT0JyN200Vzg1Z3dGaDZxRno0TGRnQ1cwRGsvUVJ1dFduUHN0b0N0NjVZVW1LaEhKQklsa1IwV3RBRzI3alNQNk5NOEFnYllOTEZFZWdNbUNpRzdKR0FyQ0d4MmNFR3pBbHZNcHYwdzhDcE00RWQyV2RBbTJyNHl2TEtmRi9EaXpLUlNLcFUxNzZabldhQkRrT0c3MjJOS3Q4RHFvSkFxa1ZpY3lEYlIrUGc0eWN2TEk5bloyYVNpb29JWWpVYkJNSHE5bnBTWGw1T2NuQnlTbjU5UEppWW0yS0dCQVZncU9kUGE4dEpDc2pvd3BKY3RHNHlOalpIQ3drS2kwK2sycnlVa0pKQ3FxaXFpVkNwNXd4WVZGWkdob2FITmE0R0JnYVN1cm81RVJrYXlwanhnU24wM09YemdLUTlERGhRcC9WUmZ1MHBkQ09ZTWl6STRPRWlLaTR0NWVab05saWw3UzB1a3VycmFaY3FqVEtLbmdDRmVVbVJ5aGNiVlNGYy9uUVBhWURBSWhuVU9OVmNDVEs4aTJ4UEFqSGY5VmNlNXltMXFhcXJMU1JHNnBLU0VGZG9kTEVwNmVqcm5HblJtazVTVmxlRmY2aGN6TkdkaGRTcGNqVXBKU1dIQTV1Ym1XTC9INi9oOVptWW1rY2xrdkdHVGtwSklhV2twa1VwZEYxSElHUHVBcmZIdk96ZE5qSWZUYzQ2K0FxdFN4ZldZdnI2K3BMS3lrbGxvZkR6TkZ4Ylhoa0toNEU1endJYU1URWhBT0lqOTFJRWFQcXRjQ0xTM1lCMUNHY1ZpZTF3ckV2bm1VYjdRM29SbGRncDJSaGtDSytRK3loZUVKSDgrME42RVpZRHRqQW9FbGt0bHNtQ2hoajJCOWhTV1dYaDJSamtDUzhWaWlhOG5OVjhJOUhaZ21jVm1aNVFpc0dSYit4d283VmFyMWUxOUd4c2J2TzV6SXhJRUZsbXQ2MFpQUnZOSlhYeUtDeCtoakNJbUQ1dU1oc2M3Q2VzTmFBY2pBdHRXSCt1bWRocDJ1OUNVMFliQTFxWDU2VkZ2d3VJQzQxc1JlVGN6N0l4V0JGNGY3dSs1NjAxWXpBWkN5amdmK1hlZ3R4OVpFZGpjOW4zRDNYV0wyZWd0V0V4ZFF0ODlPQnNYRnZQYTFmUGZvRlBOQ0d4YW1INzRhR0prcUk5clVFMU5qZUJ5eXhlNnZyNmVFeGpZL29DOTVpS3lJckFGZDBjM21pOWM0eHJVM2QzdFVWSGdBODAxTjBwbnkwVmtXMFpXY2F2V3ZJR0xzTzFDWTkvTWhQWWZsKzJmMkZpUEs1Zzc2SmlZR0pkamtlbGEwOGsrMmduZGNHeVI5UGdPM25MNnhDVWJsaVFXd1cwUWJoZzlMYmV1b0lPRGc1bTVXYXNvc1B4NnF1b2lzbEhHelQwZDltc1hydjk4dm0rb3I3dUxiWEJVVkJTcHJhMGw4Zkh4UktWU0VZMUdJL2pkd0FHZGxaWEZ6SUZ6NFk0NUlpS0M5WDVrNmJqU2hJdHR3ZEZUM3R6bXc0czhkaWlqQTBMRER0YTI5VlVFaE95SklNOVFkQXV6VXdXNUI3L1F6YzlnT0doQjE3WTJVa3dZTW5DRHRxSDRnMU5RQ3ZYUENoWnRBME1qc2lBVFpYdHltdytMRDEyOUF2cGZmK2Z2ZjUwci8vUzBGUkxnYnNPaVRiU05ETWhDbVd5c3JTcUF0dEI0R2IxKytWelBtUy96Rzh4clJzTnV3YUl0dEltMmtZR3lXTFkyazdjS3hzb2s3cDhnNE1XTHMxT0c0eWUrZlE5aU8zeEhZM1orWnVwazhmdE5BMTN0Nk5rUnlyREcyVnR6YmxzUiswbFFGR2ljZjBCUTVHY05QeDVOU0R0OENMYmNZbStDWXVvYTdPMjZWWjMvVnN1cTd0RUVoUjJuZWRmR0M5Z0pHdnZEbUMwd3M0Y2Z5ajEyNE0yQ3N0eUk2TGdEM29DZDFJNE0vMVJiMW5hcnJYa1kvcDJpWVRCSmN5NHJHT2VoRElYR2RJZTk0bjJnejJQRE1lUDFOMkpmZStlamwyTVRraE5rQ2g5QiswR0xhYzM0WUxEL2Z2dWxzN2R2L25iNUFiRWZnejJrQzJ5QmhvRkxLRjZuU0FDT3ZTZnNESVZSanorSHJXU2xuOHJ2OEpHM1k1SXlOREZoVWRGN0EwUDNoTUkxdFZRbWw5TzNMTE5SdjdLOE5EODdQek91bmI3WDNUSGExZnJES0Z6VDAzZURPZXJSR1pvTkxHNmIzWHpQNmFpM3NheXBxY2REc2JMU1dNZGZRVVpWNHRSVXhNbXRGTVJDdllleGlXOWU4OVNqeXpUUDhnS1JDamlKdEZHRE9EbnVyNmFwMTlYMEU4R1ZUdERFQ2RaSVFWY29JSDRhYUxrVmRMTHB5Ym1ialVJN3dHWFU4M0k2SDV1SDF5bWNpVDdBaHFjTDlYOEJCZ0I1aURuME1zKzI3d0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+a4uOaIj+inhOWImS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xUlRVMk1rWTVPRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFSVFUyTWtZNU9UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVkZOVFl5UmprMk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pWRk5UWXlSamszTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTVRHV0JBQUFGamRKUkVGVWVOcnMzWDFzWFdkOXdQRW5qdC9pT0MrTm5UWnAzb2lTcG10Unhmb0dhNFhVVXZMSEVCME1wallJcUdDVURTaURQOUEwSVcyYUpqWk4ybFNoYVVBSEhmRFBDbTNHeTBRRm1yU21kQjJvd0JLb1J0ZXU3Um9GbXFSSnV5UWx0ZXZZanVQcy9HNTh5L0c1NTlyWDlyMkpuWHcrMHFQYTU5eGMzL3M0NnYzbTNPZWN1K2owb1lmU0xMUmw0L3BzdkNVYjEyVmpXemJXWldOcE5yb1NBSEMrRzhuR3E5azRtSTFuczdFbkc0OWtZM2MyeHFmOTAydTJUL3EyZllZL2ZIMDJQcDZOOTJWamc5OEZBRnl3dWliR3FteGNsWTNmbTlpK1B4dGZ5OFlYc25HZzBUdHJhL0IyZlJOM3ZEY2JueFlqQUVBZEd5WmFZZTlFTy9RMUswaHV6OGJUMmJnckc1M21HUUJvUU9kRU8wUkQ3Smp1eHUzVDdQdGNOajVhdHZQVTBMRTA4c0xQMHNtWDk2VlRneSttOGVIajZmVFlhRG85ZnRLdkFBRE9jNHZhT3RLaTlzN1UxcjBpTGU2OUpIVmN0RGwxWFhwTld0eXpxbmpUL213OGtJMmJzL0dKYkl5VjNsK2RSYTA5MmRpWmpWdUxPMDYrL0lzMHZQOG42Y1MrUi8wMkFJQkpsbXkrS1hWdmVGTVdLSzhyMi8zZGRPWm95VkJ4VVd0WmtNU1JrVzlsNHgzRkhZTlBmanNOUGJmTGJBTUFVK3JadWozMXZ2N2RaYnNlVExFQWRzMzJzZW1DNUl2WitFaCt3OG1qejZXQko3NlJ4bzd2TjhNQVFFUGFWNnhQeTY2NlBYWDBiUzN1K2xJV0pCK2RLa2ppTU1vRCtRMmpMejJWanUvNVNqcDk4b1NaQlFCbVpGSEhrclRpdWp0VDU4VlhGbmU5TjR1Uys2dmY1TSt5aWROeVBwKy9aUndaT2I3bnEySUVBSmlWYUlob2lXaUtncytudzd0V2x3WEpYNlV6SzJGZk0vREVQMmQzTkdRMkFZQTVSTWxRR3ZqNXp1TG1PQjNuTDR0QnNqRWJkK1p2RlF0WXg0NGZNSXNBd0p5TnZYSXdEZjczdDRxYlA1UU83OXFZRDVLUFphT2p1amRPN1hVMkRRRFFURU43SDY0MFJrN0hSSU5VZ2lURysvTjdoL2YvMkt3QkFFMVgwaGp2VDRkM3RWVS90WGQ5ZGV1cG9hUHB4TDcvTUdNQVFOTkZZMFJyNUVTRFhCOUJja3QrNjhnTGo1c3RBS0JsU2xyakxSRWsxK2EzeEdmVEFBQzBTa2xyWEJkQmNubCtTM3hRSGdCQXE1UzB4dVVSSkd2elc4YUhYekZUQUVETGxMVEcyZ2lTWmZrdHA4ZUd6UlFBMERJbHJiRXNncVJ6MG8zR3g4d1VBTkM2SUtsdGpjNDIwd0lBbkd1Q0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFEam4yazBCTk5leHdiSDArL2Y4c21iN1ozYXNUVy9ZMURQbG4zMXd6OHZwSzk4L05tbmJsa3ZhMDJjL3NHbEdqK0hnc2RHMDg3R2prN1o5NnRhMU5iZTdkOWRMNlhzL0c1aTA3Wk52NjA5dnZXcEZ5K2JuZnc4TnB6LytwNE0xMjcvekoxdm1mTitmL2U2aFNkL3Z1TEV2clZ2Vk9lUDdlZWZmN3ExNWJDZEd4OU9CbzZPVjczdTYybVoxdjRBZ2diTm1WVzk3OWtLNElndUM0NU8yUDdsL2FOb2crZmNuWDZuWjl2WnJWczc0TVF5TmpLZEhueG9xQk1uazIvelhMNGRxWWlUODRPbUJ5cjZwNUYvbzZ3WEdYQ05nS3ZXaXFmaWNmK2ZhaTVyMmU0MFlxVDdQbTY3c0tRMDhRSkRBdkhMOWx0NmFJSW52My9YR1ZXbEpuUS9aanFNYWUxK3MrVWp1ZE9QbHk1cjJ1T0xvemVQN1hxMThmZDhQanBYZTV2RjlJOVBlVHpOZjZKdjVuSXAyN3gxTXp4OFpTVmR2WGxvNXdsRThhdFNvT1BKU1BUb0NDQktZdCtJRnEvaXY4ekx2K2J0OU03N3Y0cDhwT3pyUXlOR0Z1RTM4eTc2Ung3bVFIQjBZUzMvL3IwZEs5MVdqOE80N3Vpci9uZTF6UDkvbURPWWppMW9CZ0hQT0VSSzR3TVdpMlEvY3ZEcjFsTHlWOUQ4SFQ5UXNzbzJqTEpldDdYN3QrL2c2dnlEMTZ6ODhVdk4yMWFyZXRuVFBoemZWZmJzcUw5NWErZFA3OTllOGZkWHF4YmFOaXVjeUh4NEhDQktnb1JmNTJTeEdMVlB2N1lqWjJMcW11MmI5Uno0dWltSHcxLzl5cU9iRitJTlp2RXpsdDM5elpVMlFIQnNjVDQ4OU05RFFDL2xEUHo5ZUV5TXhuL1hXMHF6djYweDMzN0d1OG5WeGNXMUV6TWIrcnNwdGltdEFwbHFZV25hV0RTQklZTUdKRjhCbS9TdTZrU0NKRjllOFYwNmNxbG1jR3JkWjJ0VldXZVNaVi95K0tzNjBpWkRJMjdTNm83S0FOQmFKeHRsRVZUOTZkakFOalp5YUZCREZxS2kzaURidjFaSHhtaU15MWZtTW9Lbkt6MjBjZGFrWFZSRWo5ZmJOUlA2VTM2a2lEaEFrY0VFci9rcy9Uc1Y5Zk4vQm10dk05UlRkaUp3WXNVaDBjcEFNVEx2d00rSm10a2Q3NHI3ejk5K00ySHZpK2VHYTY1YVV6V1hJbi9JYkhERUJRUUxNVXJ6NHJsblpZU0p5Z1ZRV1VjWHJ0UUJuaDdOczRBSVJMNzZIZjNYU1JBRHpraU1rY0I2cXR5Nms2T3JOWGVsOWIrNnZmUDIxSHg2WnRPNGt2MjgyYi9QRVF0UHFXb3VIbnpoZTgzWk45VzJQcWZhRlJxL3hBaXhzanBEQWVTYXVYTnJvV28zbFN4WlhvaUZHZkYxdjM5a1dhMTFpeEdMU1ZvbEZ2dGFDd1B6aENBbk1ZM0U1K1puNjVvK1B6WnZIUDl1akc5VWpNdFhUZVFGQkFzekNtYk5DOXA3MW54dEhGY28rTUMvRTBZRFk3KzBQWUQ3eWxnMHNNRDFkaSt2dSs0ZC9lM0ZCUEllM1g3T3NvZWNEWERnY0lZRUZKSzZVZXZtbDVXczZZbkZvMmFjRm4wczNiRnVXM3JDcHAyWjcvcXFyTjJ6clRaL1owWmFPdkZKN0JsRGZNditMQWtFQ3pQbUZOeFFYbU5hN3JIeGNHYlg0ZGtwYytyeXFmM2xIMnJhMnUvVHpZR0x4WnlOWFFqM2Irck9nZUQ1M0JkZXEvRlZYcHc0dy80c0NRUUxNSUVoNlM3ZkhtbzJpaUpGNlZ4b3RCa2tqVnlTTmhhODdIenRhYzVuM01rY0dKaDlCaVV2TVZ4OWpmRjF2WDluOVhMWjIrbm1KMDQvbjhsazhQc1FPQkFuUUJHWFhBNGtqSGMwME5GSjd4ZEU3YjFsVitwa3djWW4zdkRPWGdpKy94c2hVKytKKzZrWFkrV2d1bDlzSEdtTlJLN1JRZkZoYzBZYSt6cGIrekxpK3hoWHJscGg4WUVGeGhBUmE2TG5EdFc5NXRISmRSQ3g2L2VETnE5UFJnYkY1T3lmMXJpMnllKzlnMnZuWThYbi9PNDByMkFLQ0JCYVU0bHNwY2ZTaTJlSk1sRmo4R204RnhkR1hDSjU2UVZKdjhXMHNpQzFiZzFKdkFlNWNUdFd0ZCtYWFJpOTNmeTdrZjI4N2J1enpGeHNFQ1N3Y1pWZFozYnFtK1pkaGp3QnBkUEZuMmJxUE9GMjQzb0xZT0kzNE45WXRTZXRXZFY3UXY4dFAzYnJXWDJnUUpMQXdQWDN3Uk0yMjFUTmMwRnJ2TEpmMWZaMmxwLzlXRFRYNEdUQVJUZE9kQmZPUEQ3K1UvdUsyOVUyYmw3aWNmSmtubmg5dTZlK2piRTRhL2F5Y0IvZThuSloyL1hxK3I5NjgxQ25KSUVoZ2ZvbG9hUFFzakkzOU16dlNVTzkrODUra20zK2huKzZ5OEQ5NmRqQU41YTRMVW5idGtuaDdJbjgvY2JiTnZidGVTbHN1K2ZYYWlYakxaclpuMmN6azB2WHhjNmNMbGVwcHoxUE5YNnl0S1hzY2p6NjFyNkhIVVR4ajZlNDd1Z1FKQ0JKWW1PS0ZmcXEzUHVKZjNTa2RhY25QcnI0Z3grbTZVd1hCamh0WHBQZStPUzdHTmpsdXpudyt6c0NrNTlMcTAzNWo4V2k5eitYSkt6dnR1YWlSYTdUazV5bCtkb1FZSUVqZ3ZCSXZjSEgyeTlRdmh1M3AwNzk3U2JwMzEvODEvQUxhcUJ1MkxXM29NYjdyamFzbXdxU3ZLUi9DRjBkU1pyT1FkODNLanV6UExVOTNmWGwvemI3ODUrRE1SZHhQUG5oaUFlOXRONXhac1BvSGI3MDQyL2VyaG9JSUVDUXdMMVRQY3FsblkzOVgzVE5MYXNPaHR6TGliWWloa2ZwUnNuNEcxektKSUNnN1V5WXZqb3hFakZUWHBjU1JuSHMrdktIeW9qdzRmR3JXY1ZKOVByTlZqSm5lN3NVMXp5WG1vdDZweEZPSjM4a2Zicis0ZEY4OC85aFhiei9RZkl0T0gzcm9kSDdEUzkrNXk2d0FBQzExOFR2dm1mUzlLN1VDQU9lY0lBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUVBRXlXaCt3NksyZHJNQ0FMUk1TV3VNUnBBTVRMcFJlN2VaQWdCYUZ5UzFyVEVRUVhJb3Y2V3RlN21aQWdCYXBxUTFEa1dRUEpQZnNyajNFak1GQUxSTVNXczhFMEh5MC95V2pvczJteWtBb0dWS1dtTlBCTWtqK1MxZGwxNXRwZ0NBbGlscGpVY2lTUDR6R3dlcVd4YjM5S1VsbTI4eVd3QkEwMFZqUkd2a1JJUHNqaUFaejhaOStUM2RHOTVreGdDQXBpdHBqUHZTbXUzajFRdWpmU0hscmtmU2NkSHJVcy9XN1dZTkFHaWFhSXRvakp6UmlRWjU3VXF0Y2Jqa3kvbGI5TDcrM2FsOXhYcXpCd0RNV2Z2eVN5dHRVZkRWdEdiN2dYeVFoRC9QeHRIOHJaWmRkWHRhMU5GakZnR0FXWXVXV0hiVmp1TG1hSTQvcTM3VFZ0anhSL2xiZHZSdFRTdXUrMUJhMU41bE5nR0FtY2RJZTNlbEpUcjZMeXZ1K21SYXMvMW9XWkNFQjdMeHBmeUd6b3V2VEN0LzYrUGV2Z0VBWnFSOSticXNJZTZxdEVUQnZWbU1mSDFTdUp3KzlGRHhScDNaK0VZMjNsSGNNZmprdDlQUWM3dk1NQUF3cFZqQVdySm1KRHlZamR1eUlCbWRMa2dxOTVPTmIyYmpiY1VkSjEvK1JScmUvNU4wWXQralpoc0FtQ1N1TXhLbjloYk9wcW42WGpadXo4WlFGaVNwa1NBSkhkbjRYRFkrVXJiejFORFJOUExDNDFtZzdFdW5CbDlNNDhQSDAvalljRXJqcC93MkFPQjgxN1k0dGJWM3A3YnVGWlhQcG9uTHdjY1ZXQXNYUGN1TEpTR2Z5TWJKeW5jekNKS3E5MHlFU2IvWkJ3Qm02RWlLQmF3cDNUOXBheUZJMmhxNG8xam9la1UydnBoeUYwOERBSmpDNkVRN1hGRVRJeVhhR3J6VHFKdVBaV05MTnY0bUd3Zk5Nd0JRNHVCRUsyeVphSWNqamZ5aFJ0NnlxUmN5MTJmamxteGNtNDF0MllqemdudlRtYlVuQU1ENUxkYUNES1l6VjN0L05ocy96Y2IzczdFN25mbWN2S2tWM3JMNWZ3RUdBRURJTW1VeUVRQzVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNouWVhuWfji5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFSVFUyTWtZNVF6TkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMVJUVTJNa1k1UkROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pWRk5UWXlSamxCTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalZGTlRZeVJqbENNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt1QitEWXdBQUJtSkpSRUZVZU5yRW1WMXNGRlVVZ00vTTdHL2IzUmJhQWdYS1QwdVJpQlNJQ20wTkR5YndZSHdoeXBNWU5UNFlUTFFZSGt4RW5veWdKUDVFRUZCNXNDSytLT0ZCVkNBU01hSUZiUGxwK1M4dFB4YTZaYUhkN3JiYjNabWRIOCtadVlXVzdzek9iTGZsSnFlem5abDc3emRuemozbjNETmNmTzFDR0VQem9OU2lQSXRTalRJZnBReWxnRjBmUUFtaHRLRzBvaHhGT1k0aURRMnd0ckhOMFlSY2xzQkxVZGFockVHWjdMQnZCT1VubEs5UXpvdzM4R0tVTFNqUFVWOFlXOU5RRHFHOGg5QXR1UWIyTWRDM1VWeVEyeWFqZk1uQWs3a0Fub2VxMk1jWjJoMjNobk8wNEJ4ckVMcmQ2ajdlNnFLaWFjdHdvT1BqRFF1R2ZTM0d1VTd1cWEycXlRb1lZV3Q0anZzREJ5cUJDV280MTJTYzg0Z1ZkRnJnbEtwVlljY0RPRUErVEhDak9XbnVocHFxS2x2QXZaTHNkL0hjdm9uVWJCcm9FbUxZL2xTRi8rRnJvMVo4d0NWczVZd2dNUHJweW1hQjU5VU53TStxQlBuVU1aRDJiZ2NRRTg1Zy9QbmdlYmtlaE9ybG9ONjZCdEozbjRQYTNaa091aHBaUHNhZjYwMjlSSDlLZVRMZ0ZrNmtleEIreGh6d2J0Z0tYS0R3L2ptMS9RSWt2OWhrRzVwZ3ZlczNBMSt4NElGM2lFVkEvT1RkdE5EazhwQnArYnFtanRPalRBTGRDZWNUK0kvTS9Lem50UTBqWVBYTzh4YUNiLzJIQUY1L1ZyRDYrZUFrOEx6eWpsazNGMlBpUmdHanZTeHo4OXhLMDlVNXJUejllUWJOK2Z5T1llOWZuejdidEM4eXJTSzJFY0NrWGIvQTExdUZXK1Y4czdsdlJHaHZmWHJvVExENjJLMG5yVi9PTURiaC9lb3A5Q3U0cUNqL2F6eDZ6WHFwRjVwQnFGb0UzT1FwNlVmRjgzUmR3Y1VJc213YlZtMDdCK0p1Zk91S1lub1Blb3c1eUxialVpd2g2aHBlVmx5d0FrOEVMRU5uTWdIaXRrMzZRck9qYWJ1d1NSd1RKREdUbXdzUW82N2hpd045L09xWnhXK2kybXN5cHlteXJrRTdtbmJWcnN3SjdJUElDK0hmdWlLL2s0YmRhTmpWdHBNVW01ck9KU3hiZk5YNkFmOTRQVHcvMTFGbVpRTTZsN0M2V3pVWXZRVHNFVGdvZHB3T1pnR2RMYXh1dXdhamh6Y1dJWmVYVlE3ckFIb3NzTHFaR1l3dUFoYkdscW5nRUx5TklYZ2ViK1hIbWhjSk5BS0h1VzhpSzFZYnJzdE9jTEhuSlhSR1RuOWtTZEdpNHdtYkMrZ2hSZ0xXNHJMU05kNndZNFZtakJvQks1R1UzSkZMV0ZwZ2RpT2k3V0tHd2FnUXNIeTFQOW1jUzFqeUJrN0N1SjNXM3A4OFJhd0VMQjBPUlpybERBdlBhVzdnTlBld3pBZzBMWG13SzBKS2xRaFk3QkhsM2x1RFVwTmxwTUZ0amROd2F4ZmEvZEpibHNESTlpL3VOWHVJbFlCVEtMRy93dEZmTEIzZzBycXNnb0lkYUdGSm5TWHdzWENNMkdMRXl2OVFOMStsS3VQaFVGL1RuV1Rxa2lsVVowZldFU3dUdElhYlViTkdUSWRDa1NaV0NWV0hRazhjSlh6Z2R1OWVEVSttOVlNTm4ra2J4bXpEclJtMDF0Y0RZc09uWnVVcjllZmJ2ZDhURzJNMGRoejdPM3NJa3JzUkY1WEhDL05tbG5yZG83STNiU0FLNnJrbTRNc3JBSHg1b0p6KzI5Z3BPTWtOV0Q3Tmw1UUJONmtFdEp0WFFkejFBV2poOUdIZ2NpeHhkTS8xOEkvNDh6cHQ2a2RzODNGZlJ4WEtpaUszNitrdFMyWnZMblFMTStBUnRtaEs2ZHA0OXViR3ZwUk01a0EyazN5NDhrT3E2c1licnUxdTc5NHBxVnI4VWNIUzNNaXdnMWlJaWJHTjNPYmo0dE9ZMm0rY2ljVFA0cXZZaFFtSE5OR3dOQ2ZOVFF6RXdwaTAreDZGYkhpb3ZWaGVyS0k5azV0VDBaN0ZTRXJweHQzMFlvSGozQk9rMmNHRzYrR2RmOTZKTnVLL1Y4RDRQaUphMXRhWXJkeW0vUk4yNUNPaVBQaEcxZFRYMGJhbmp5Y3N2djZ1YjlydmZOdGlhTGFOTVl5cXlLZXR3Rk5oQll3dlFWU1NtVi9nRW1iVlAxYjJBbnFRWjdnTVJYREh1eFo4bXhlamcvOXN1eExhUHlBci96SFltOHp2YXJhQWgwRlRmWmk4UlNYSzlKcVN3SUkxNWNYUGwvazlDM0lCRzBwSWwvZDE5dng2NGw3L1pmeVhmRnNIMDJ3OEhhd2w4REJvY25kVUs1NkRNaE5sVW0xSllONnFhVVYxRlFXK1JiajlkclFmVEtsYTR0cEFzdlZJZDE5ajQ3MSsrcDVCMGVnV1cyRDNtQmxvcGttWW5hOUlDRTZMamlwRDA1akdhYVVHZlFLZnY2STBXUGxFVVY3bFZKKzdyTkR0S3ZVTGZCQjN0UjQ5VHFpYWxGRFVXRFFsMzhVUUd6cmZOOWh4N0c2c0k2bW9jWlliaEpsR3U1azNTR1ZNY2UxK3AyUGFwdHBia0dtOEZLV1kyVHE5QlRjVFlWaFJrVFNsTUpBVTB4N1pKbVZlZDVsR1k4d1RhTFp5OHRWekhYc3NnaUVONWpHdEI5bVJ3UDNEb0dFWWJJS0I5ak5BT2c2QzhRbFhjeks1Szd1RnJXdUVKTW9BdmV3aFhDWWFsaG1jeUI1QXpYYWgvaS9BQUlOK0tYUnFLNEUrQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wTkRrNFFUVXdOek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBORGs0UVRVd09ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUTBPVGhCTlRBMU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pRME9UaEJOVEEyTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrRTdaMW93QUFJUE5KUkVGVWVOcnMzVnVNWFBkOTJQSC96TjU0VzVIVVVoUkpVYUprU2hSMXRXekpkcHpVOFUxRmFpTVFDZ2gxR3pkQWJ3OXRXcnNQZVdrZjJqNDBmUW1LdGc5T2dMWW8ycGMwZHRLcUtJekVhV0VsamdNMHR1WFlrU1ZaMXRVV0pkNGtrVnlLNUpMY0pYZW01M2RtWnZmTTJUTzdzOHU5Ni9OSlRwWTdlNTFETWYvdi9NLy9uRk5ybnZwbVdvSjZ0bjBrMno2ZGJZOWwyNUZzdXkzYnRtZmJTQUlBTnJ2SmJKdkl0aFBaOWtxMi9VVzJmU3ZidnA5dGpRVy9ldC9qWGU4T0x2S0hIOHkyZjVKdGZ6dmJidmQzQVFEdld5UHQ3ZVpzZXlqYm5tdy8vbGEyL2ZkcysrMXNPOTd2TjZ2MytYbGo3Vy84ZXJiOWN6RUNBUFJ3ZTdzVlhtKzN3OWh5QmNrWHN1MmxiUHZIMlRac1B3TUFmUmh1dDBNMHhOOWM2Sk1IRi9qWVY3THRIMVY5OFBUVmdmU3R0N2VrRjk0YlNtOWVIa3huSnV2cHluUXRUVFZxL2dvQVlMUFhScjJadGc0MDA1NlJScnBqMi9YMDRNNXI2ZE8zWGszN3RreVhQM1ZQdG4wdDJ6NlZiVi9PdHV0VjM2L1dZMUhydG16N3ZXejc1ZklIWHJ3d2xQN28xTmIwMUZ2Yi9HMEFBRjJldlAxeSt0eitLK24rbTY1VmZmZ1BVbXUyNUhKNVVXdFZrTVRNeUZQWjlrVDVBNy8xNm1qNjNXUGI3VzBBWUY1ZlBEU1J2blRQeGFvUGZUMjZKUXVTcnBtU3FqVWt2MVdPa1IrZEgwNS85M3RqWWdRQTZFczB3OS9KMmlFYW91U0pkbXQwS2MrUXhEVEsxNG9QZk8vc1NQcVh6KzlLbDY1Ykd3SUFMTTZPd1diNmpZZk9wNCtOVFpZLzlNVzA3L0d2VmdWSm5KWVRLMkgzZEI1NGRudzQvYlBuZHFXTDErcjJLQUN3SktORGpmU2JENTlQait5ZUtqNThMdHVPWmxIeWJyeFRMSTEvVTR5UjhCOWVHUlVqQU1BTmlaYjQ5eS9mVkg0NExxajJHNTEzT3JWeFI3YjlnK0pueFFMV1Z5OE8yWXNBd0ExNzdkSmcrc29ybytXSC8zNDYvZlFkeFNENXRXeWJxWThmdnpka0FTc0FzS3krK3ViMnZERUtodG9Oa2dkSmJMOWEvR2hjWndRQVlMbFZOTWF2cHROUDF6dDM3VDNZZWZUVWxZSDB2NDY3NkJrQXNQeWlNYUkxQ3FKQlBoSkI4cG5pbzMvNnpoWjdDd0JZTVJXdDhla0lra2VMajd6d25vV3NBTURLcVdpTnh5Skk3aTArRWpmS0F3QllLUld0Y1c4RXlmN2lJMmNuWFhjRUFGZzVGYTJ4UHg3cE9pbDRZdG9sNGdHQWxWUFJHcU1SSkYxM3ZibldFQ1FBd01xcGFJMWh4MmNBZ0RVblNBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFNR2dYc05sY3V6S1JybDIrMVBmbmo5eTBPeld1WDBzWFRyN1o5ZmhOQis1SVExdTNkejEyOXZXZmRMMi9kZGZOYWR2WXJUUHZYejc3ZG5ycFQ3L1I5VG03cys5ejE4Yy9tLy81WjkvNTR6UmUrRG5GajgwbmZ1NnhaNy9iOWRqUlQzMis2MmNYeGMvcCtoME8zcGwyM1g2NDhtUDdIL2h3MnBMdGcvSno2MWZWZnVwNDU2VWZwWW54TTEyUDlmTjhsL08vaGVlLzhmczMvSDJHUnJha281OTlvdWZ6WEExcnZTOUJrTUFpUlZpVUIrLzV4TUFleWw5enFCMGNSZVhQT1pnTjVoRTBBMFBEUy9wZHA2Y20wOVVMNDZseGJhbzE4RzNia1E5NnhjZkM1TVRGUlgzZjhYSmM3VDNRODJPM0hubXc4cm4xdmYreWZkUnJvRDcrNHgvT2liUFZkSHlKejJsTzJFeGVUY2VlK1hhNis1T2ZuL2Z6ZnZqVWYxdlY1M2VYZis0SUV0aGN5ck1hL1E3UU1lRHV1R1ZmejVtS0JlUHB6TnZweFcvKzc5a0lldVRuMHRqaCs5S3A3UHVXdzJFaktNOEFWWVhTK0RJUDJoOSs4dTlWUGg0elBzdTVEK1B2S21ZcDloNzlvSDh3SUVoZ1l4dlpQcnFpMzMvNjJsU2F2REErNS9HWVlZbkRTVld1bkQrWHo4eHNCdkVjNDdsTW5EbWRUdjdrMldYLy9oR2dreE1YMHE3YjdzeG54VzVrZHV4R2JSM2Q2UjhVZ2dRMmlqajJ2Mk5zYitVcjlYNCt2N3plWTZHdlg4am8zdjNwOUtzL1hwYm5GWVBoblBESVlxUnF0aWQrWnErZkd6TkJjWGlxYytocVBwZmVQZDExR0NaK2o2WE9EcTJFcXVkZS9QdGI3SnFMMTc3OWpYeG1wT2pkTjE3THQ1VG1YOGV6MHZZZXZzOC9jQVFKYkJRUkYxV0RVSy9EQnZINW5UVVZNZEFVUCsvZ0l6K1hMNWFOVitDOWdpUytwdGNoaER4STl0MmU3dityZnoxTlpBTjc1YXZlOXBxVldJUmFYUGRSTkRBOG5MYnYyYmZzcjh6N0dWalB2dkZLMS91NzloL3NIdlFMdjNmTXlwUWphTjg5RDZ6NExGR3YyWVE3SHZ2RW9yL3UwRWMvbVY3NjQ2L25hMGo2c1pnMU1wZk92alBuKzhidnVXV0JtWS9CN085L05OdkhuVVhLSUVoZ0F5a3VOcHd2R01McjMvbVRmS0FvZjE1bnNXeXM4NmhTZFlaTjhaVjVQMmV4eE9HVDJPWXpQVFUxYzBaUStTeWZsZGFaR1pnSnJGSTBGUWZKaTZmZm1oTWt1MjQ3dENZekNvY2UvWVVsQlZ3czFyM25GLzlhZXZYUC9rOWZVYktZR1ppcTlUWXg2ekZtNWdOQkFuUm1TV0tnaUZOR2w5T3haVHJqbzJ1Z3plS29PTURYczBIM3BqMjN6am5NRUk4TkRJL2tmeTRQZ2hGTU1ldXlrQWlNc3BqeDZXVnE0dEtxLzkyVlp5aTI3OTV6UTR1T1E1d1NmZjh2UFprZkRpdkg0bVpaZXdPQ0JOYmpQNHIyNFB4dTZkWDkrUEdmemN4S3JGY3hlQjU0OE5GMG9UUlRFNDkxQnVYeTRhcmlxL3I1Wm5FdXZIT3k2LzFiN3J4NzBiTU84NjN4V0dxUUZXY1U0bkJiT1JyNm1YVmFpcTBWcHp1ZmYrdjFmQWFySDFjdnZyZmdQbDZJMlJRRUNXeGkyM2J0eWY3dmEzTU9ONVJuSGNwaWRpSmVvVy9FMDNVN0ZqT0wwOXBQcWUrQVdRMFJIaXN4RTlVcmhzb3pMK1BIMzdpaHYvLzh0T2hGZkwwZ1FaREFKcmI5bG4zNTJTTlZhd2JpOFY3VDlERTdFYk1OdlJiTUxyUjJwV3BOd1VKZkF5QklZSk9Lc0hqb2wzOGwvL05pRnNQU3JYeElJczRnV2VxcHFwZlBuNW16b0RZTWI3ZUdBd1FKYk5KQnROYzZpdUxqdldaUU5ycjVvbXV4bDBXL1VncVNPSjExS1ljWTRtSnZWUmM1aTh2Mmx4ZlZ4bjExanZhNXh1ZjhpV09WcHlYSG1VRDlzS0FWQkFtc21CaEVlNjFCdU5HMUNVdTV6OGxDWDdPV0YrWmFLQ0xtL0QrYjRlRjgwV2VzczZnUzF5OHBCMHQ4bjUvOStkTno0aThXMUZaZHdqMFdtZlo3QTd5cWhhNXhqWlRsM3AvbGhiY2RWWWZvZW4xdXIxUEtRWkFBWGluUG8rcnk5YkVJTnM1QTZiVm9NeDZQMDQrTDF6STUrZHozS2s5aFB2RHd4eXEvUjlWZGtSY2p2cmJmcis4VkQ0QWdnUnQ2RmJzVVcrZTUwKzFHVW5Wcit3Vy9KaHY4NDB5YS9ROThPRjkzc3h4KytzeWZwYU5aNE1Vc1JmeE81WFVqY2FqczRJYyt2bWIzandFRUNheW9PTE9tY1cxcVJYL0dmSmNWajdVclZ5cXVTN0hRMTlXWGFXQ09HRm5zNmFwWDJyOXo1MUw3WFIrck9Cd1NDMURqRUV6eCtWUmRQajJ1bEh2Z3ZrZTY3cG5UY2VkamYyWFo0Z2NRSkxEdW5Nb0d2NlZlUDZMZnMyOTZYVlk4cmdnYjkwdnBKZFkxSEhqNG94dCtIOGVzUml4Q0xWOWUvdFgvOTNUMy9zZ0NwZXF3U2N4aXpYZGwyUHhuREEvM2ZUK1o2YW5KT1llREZuT3ZuZlY4Z1R3UUpNQ2l4SXpCc1dlK1BlOFpPNTB6UVc0a1NxWlhlUGFuTEc2c1YxYTExaVlDNHdNZi9jWDhVTTE4SWhUNldhOFJOeDBjTHYyY1hvdFVZNkZvK1lxMnZlNjFFOUVZTjFiczUvc0NnZ1NXelh4M1hWMnVLN0ZHSkx6OWsyY3JGMjNHb1pCaXBFU1VURitiekJkekxyUitZcVRpa01iYkx6K2ZENkRuMzN5OThtdGk5dWF1Qlg3Zjhoay84eTNxckF5U0htdHRZc1prMy9qWk9hZmdGdmZIcmZjOTB2YytMWitORW5kWHZ0SERQSEViZ2ZMdjU3bzBJRWhnVWNvM3lldm5wbm56M1hWMWZBbW43MVlONkZWaTBXYmM4ajRHMXZJZFptT0JaM21SWjFVVVJMQ1VyNU1TMFJObnJGUXRFbDBQSWpqT1pyRlVOVk1VTndYc2R4RnJoRWZFWkhFOXp2Ry8vRTdhZmJBN3R4YWFiU25maytac0tlUWlrZ0JCQW9zeWZxeDdFTDdReHd6SFd0eUhKUnorK0dkbXJxV3htTnZlbDkzK3dZL09PUXhTZGFYVHNUc09yOHcrcjdpajhIeGlwcWpYODR6dk5mTGNNMzBmc3RxNTcyQlhrRVNNbFdlaEZncVNoZTVKTTdKajFEOHNFQ1F3djdIQzdFYk1OTHo0ZjU4cURUWS9xNWh1ZjJIT0lMaHNoMmFtSnZ2NnZQTE4ydUxWL2xLakpBNkRITXBlNGM5M1RZM0ZIQXBaU1NlejJPaDF1S1lqUGg2TFRmdFpSeExyUUJiNmZqZHFkTzhCLzlCQWtFRC80aXlPOG1BZXI1YXZYaGhmdGROSDQrZkZZYUtxV1lLNGVtbGNNQ3pPMktoYUpCbS80OUhQUHBIUDhsUmRKeVRPS3BrdnpHSXRSOVhnSEljMTd2cjV4MWZrZWg1WEt5Nkt0bjEzOVoyQjQwSm1WYjlmMWFYNUk2N0tGMDZyRXZ2eG5sOTRQQjEvN3ZzOVQ2VytFZkgzdU5EdkFBZ1M2SExxSnorcWpvU1RiODRiSkRIbzNOVGpWZkJTcmdRYVo5TEUycENsWEVRdHZxYnFNdWtMaWRtaHl6MHVkaFlEZGNUYVNneXNWZGR6cVFxZldLZFJ0UzlqMzkveDJDZnltYTF5bEx6MW8yZlNscDAzTHhpVGNmYk9mUXVjSWp5ZnVOaGIxZlZWNHJvdnEza2RsS3JMeTRNZ2dRMG1UdXNzdmtLT203RjFMcllWaXhUbkcrU3I3cXV5VUpETWQ3K1JtQ1Y1L2h1L3YrelBzWHd2bStLOVl1YTcyRnFJTlNZSEp5N2xzUkEzcFl2dzZYVmp3Y1VNb0hHeHN6bEJNanc4NTJxd1ZRTnRIRWFLR0luZnFlcHdWZnc1SHRzeHRuZm1zZUwxWGVMbjl4MXNGWWZTVHI3d2czd1I3V0xDeFlYYVFKQkFwYXI3bWNRaGl0Mkg3cDRKa2hpb08yZTlWSjIrdVpoN21zdzd1N0hLZHdXZTcxNHhWVHI3NDJqN0V2aUxlYzV4NWRXeVhqODdyZzh5ZnZ5NzgvNXVFU1BGdzBpOTF0REVuNHZmNTY0K2ZuNi95b3RmRjFJMWk3SmE0dG9zc0puVTdRTGVEK0pza2hod1YvTjB6WWlSR0ZCanNlcGFuMTRiei91aHozOGhEN1BsRW9kTytoRXpVd3NkcXVwMWo1cUlramhqaUc1eFdHczlMRWlHNVdTR2hFMnZNenVTdjZLOTk2RTVGeDI3MFlHK0l5NUlGb2RRaXU4UHROY2N4T0dmT0tTejNNb1hRYXU2ZEhvY2Z0cVZCVm44TG5kLzRwZlM4V2UvZTBNekNiRS9Eejc4a2NySUtOK2tNTzRSMURta3NmdmduVDNYNVhRT0dWV0pkUzV4dzcycSsrTlVEZFNyK29xdUZGQlZ6N0hYSmViNytkeXF0U3h4eGR2TmNFTkhLS3MxVDMyeldYemc1NS9lWjYvd3ZoTm5oaXoyNW5xcnZjQVJZRFA1ODhkUGQ3MXZoZ1JTRWhZQWE4d2FFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFESzdMMzZyWlRKTVh6cWVyNDJmVDVNWDMwdlVybDlQMDFHUnFUamV5RHpYOHJRSEFBbXExZXFvTjFOUEE4RWdhM0xvdGpZenVURnQyajZXUm0zYkZCd1hKZks1ZnZaSXVIaitXSnQ0NW1RWElWTDdEWW9lbVdtcnR2R3pIMW1vRC9pc0RnRDVlM0RkamJKMjhtbzJ2VjlPVmMyZFNldU8xTEZDRzAvYTlCOUxvd1VOcGNNdFdRVkxVdURhVnhuLzZTcG80ZlNMZmViVjZGaDZEUSswZ3FiVmlKSSs1enR1Wi92TWZIQURNVmtqcGo4M1cyMlp6Wm10TVQ2Y0xKNDZsaTltMmZkOXRhZmNIanFUNjBMQWdtWGo3WkRyM3lvdXAwWmh1aFVoOUlOc2lQT3JkUVpMM2h3QUJnUDc3cERuN2RtWnJwTlRJM2pZYTZkTHBFK255TzZmVHpmZmNuOFhKZ2ZkbmtEU3puWEx1NVJmeW5WRWJ5Q0prY0RDUGtSUlJFdUZSYjRWSUxWWE5qZ2dUQUpobmxDMjhhUmJlUm9oa0wvanJyU0JKalZyV0o0MTA1cVhuMHRYelo5UE45ejdZR29QZkwwSFNuSjVPNzc3d3czUmwvR3dXSTRONWtPUWhVcS9QQmtseG0ra1FJUUlBaTNqMVB6dUVkbVpJYXAyM25YRzJrYi9RandtQzZjbXI2WllIUDl3YWx6ZDdrTVRNeUxzdi9HVVdJK2Rhc3lMeHBHT0dKQStSZW50bXBENFRJRFd6SWdDd05Qa2cybXlQdjdXWlFLbkZZWnYyMFlobW96M1dabHVNelRGRzMvTHdvNnMrVTdMcVFYTHVwUmV5SjN5bUhTT2wyWkYycmRYTWpBREFjbFZKSGlLMXpobXIrZGszcmNNMnRXYTdSR2EybEkvUnNhUmk3T2hEcS9wYnJ1cUYwU1pPbjB5WDNqNHhFeUt0MlpIV2VkS3BjN2ltRXlhZEVCRWpBSENEVGRKOWdraG5pVVErN3NZWW5JL0ZBKzF0TUQ5OEUyZStic29naVZON3o3MzZZaUZFaWpNanJYVWpOU0VDQUtzU0pqUGpibTEyRFdlYWlaS0JkRFlicy9OcmdtMjJJQmwvL1pYODFON2lURWd4UnB6YUN3Q3JHQ2J0dDhVb0tjNmN4TmszNTMvNjh1WUtrcmdDNjhUcDQrMXJqQlFXc0piUHBCRWpBTERxVVRLN2hyTmV1Q2JZUUg3WUpzYndUUk1rY1RuNFpyNmF0MTdZQ2d0WXhRZ0FyRm1VekJ5cHFIZVAxVEYyeHhpK09ZS2syY3l2eHRvcXJscjNNU3N4QWdEcktFcG0xM1RtWTNZMmRzY1lYcnlleVlZTmtyaHI3L1MxcWZhbDRHZG5Sb1FJQUt5L01KbVpLV21QMnpHR3gxaSs0WVBrNnZqWjJlTlQ5WnAxSXdDd25tT2tZc3pPeC9JVnR1SVhScHU4K0Y1cmtVejd2alN0ZTlQVWRBZ0FyTU11YVhidUk1YzZRVkxQeC9LVnR1SXpKTmN2WDI1ZkFLN3p4Q3FLREFCWSt4cVorWFAzdUoyUDVSczlTS2F2VFpaQ3BGWjZDd0Nza3lycGZ0c09rM3dzMytoQjBweHV6RDY1VHBpWUdRR0FkZG9reGJHNlZockxOM0tRZE80b3FFRUFZSVBGU1N0TThyRjhvd2RKOWJNREFOWjNpYXl1dXAwT0FLeTFWUXdTTXlNQXNMR3MzdGh0aGdRQVdIT0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQjRQd1ZKMDk0R2dBMWw5Y1p1TXlRQXdKcGJneUF4VXdJQTY5dnFqOVVySGlTMVd2WWptazBkQWdBYnNVdXlNVHdmeXpkOGtBelVaNTlWSjB5YTZnUUExbWVFRk1mcVpta3MzOEJCTWpBMFVwb2hhWmJlQWdEcnBFYTYzN2JESkIvTE4zcVFERzdiTmx0YTVVTTNaa29BWUoyMFNMTzdTd3JqZGo2V2IvUWdHUm5kbVQyZlJyWTFVK2QvNGdscUVRQlloMDFTR0svenNUc2J3Mk1zMy9CQnNtWDMyR3hsTlpxRjRtck9MVElBWUkxS0pIV1AwWVV4T3gvTE4zcVFqTnkwS3cwTURXZFBxTkhhR21JRUFOWjFsT1JqZFd2Y2pqRTh4dklOSHlTcFZrdmJiejJRUGFkR3RuV21mMXBQdENsTUFHQmRoRWh4Yk02M0dMT3pzVHZHOEJqTE4zNlFaRVlQSGtyNVUyazBDbHRuTFlrb0FZQzFqNUgyekVoaHJLNjF4L0RWc0NwQk1yaGxhOXErNzdhc3RLYmJXeU5mSkdNOUNRQ3NiWXdVeCtMOEpKVDhpRVpydk41KzYyMzVHTDVwZ2lUcy9zQ1JWS3NQekZSWHM3M05ITG9SSlFDdzZqRXljNmltTXk1M1prZXlNWHYzNFNPcjlpdXRXcERVaDRiVDJEMzNwK2IwZEw2bDJFcFIwaXpYR2dDd3ZDRlNPRXhUakpFOFJOcGpkR3hqOTl5WGo5MmJMa2pDOW4wSDBvNDRkRE45dlJBbTJZNlliblRObkNSaEFnQXJFaUw1ckVoaEppUWZnL094dUJNajEvT3hPcFphcktiQjFkNG5OeDk1SUUxUFRxWXI0MmM3ZXluYkJ2SzMrYzE3NnJYc1QrMGI4dFZxcllXOStVNnMrUThLQUJaZkl6Tk5NaHNsclpOTE9tdEdabVpHcmsrbnJidjM1R1AxYWx2MUlLblY2K21XQnorVTNubitCK25xK1hQNWZxcEZ1Tld6LzFQUC81QkZTQ3RHWW12T25HclVYSlhUamdCZzg3UklzL3ZQemNJWnJvVTFJNTJaa2JnQVdvelJNVlp2K2lESm8yUmdJTzM5NEdQcDNNcy9UcGRPbjJqRlJqTm1SUVptWmtaaXBpU2ZJWW1aa2J4RGFvVkpFbUVDQVBPVVNPRk5zLzIvczZmMnpnYko5RXlReEdHYW0rOTlvSFcwWWcwTXJ0V3VpaWM4ZHZTaHRHWFhXRHIzNm91cGNmMTZhNGFrM2pwc2t4cnR0NmsyT3pOaWhnUUFGdEVsaFhVamFmWUtyTTNHYkpEVTZ3UDVlTHphYTBiV1RaQjB4RUxYTFdONzB2blhYMGtUYjU5bzFWcEVTUlJhKzdCTmEwdXBlNWFrL1Q0QTBDbVEwaCtiTTNmdW5ibkVSbnZkU0l5Z08yNjlMZTA2ZktSMWk1YzFOcmdlZGwvc2lMR2pENmFkZHg1T0Y0Ky9rUzY5ZlNvMXJrMjFRNlRlNmc2ekpBQ3dpRFlwbnJHYVppNUlHcWZ5anU0L21FWVAzcmxxRnozYk1FRXk4OHRrTzJiMzNmZWwzWWVQcHNrTDU5UFY4Yk5wOHVKNzZmcVZ5L21aT2ZtaW0rUTBZQUJZU0w0S2MyQWdEWXhzU1lOYnQ2V1IwWjM1b3RYOFJubnI4TVg5NFByY2k3VTBzbk4zdmdFQW0xL2RMZ0FBQkFrQUlFanNBZ0JBa0FBQWdzUXVBQUFFQ1FBZ1NPd0NBRUNRQUFDQ3hDNEFBQVFKQUNCSTdBSUFRSkFBQUlMRUxnQUFCQWtBSUVqc0FnQkFrQUFBZ3NRdUFBQUVDUUFnU093Q0FFQ1FBQUNDeEM0QUFBUUpBQ0JJN0FJQVFKQUFBSUxFTGdBQUJBa0FJRWpzQWdCZ1BRVEpWUEdCb1hyVFhnRUFWa3hGYTB4RmtGd3NQcko5UUpBQUFDdW5valV1UnBDY0tqNHlOdEt3cHdDQUZWUFJHcWNpU0Y0dVBuTEh0dXYyRkFDd1lpcGE0K1VJa2g4VUgzbGc1elY3Q2dCWU1RL09iWTIvaUNENVZ2R1JUKys5YWs4QkFDdm1VM05iNDFzUkpNOWsyL0hPSS91M1RxY25iNzlzYndFQXl5NGFJMXFqSUJyayt4RWtzYkxrZDRvZitkeitLL1lZQUxEc0tocmpkOUsreHh1ZEM2UDlkaXBjaitUK202NmxMeDZhc05jQWdHVVRiUkdOVVREVmJwQ1pLN1hHZE1sL0tYN0dsKzY1bU80ZWRjWU5BSERqRHUrNG5yZEZ5WDlOK3g0L1hneVM4Syt5N1d6eHMzNzl5SVUwT3VTNkpBREEwa1ZML1BxOUY4b1BSM1A4aTg0NzlkSUh2bFQ4ekVkMlQ2Vi8vZUI3YWF1cnR3SUFTN0I5c0ptM3hJZDJUNVUvOUUvVHZzZlBWZ1ZKK0ZxMi9hZmlBeDhibTB6LzdwRnhoMjhBZ0VXNWU4ZjE5RzgvT0o2M1JNbC96bUxrZDRzUDFKcW52bG4rcE9Gcyt4L1o5a1Q1QTE5NWRUUjk5ZGgyZXhnQW1OZXZISnBJWDU2N1ppUjhQZHYrUmhZa1V3c0ZTZGlXYmY4ejJ6NVgvc0NMRjRiU0g1M2FtcDU2YTV1OURRQjBpZXVNeEttOXBiTnBPdjR3Mjc2UWJaZXpJRW45QkVrWXlyYXZaTnMvclByZ3lTc0Q2ZHZ2YkVrdnZEZVUzcnc4bU42ZHJLZkwxK3ZwdXVVbUFMRHBEZFpTMmpiWVNMZU1OUEo3MDhUbDREKzU5Mm82MEgzUnM2SllFdkxsYkd1VnlpS0NwT052dGNOa2o5MFBBQ3pTbVJRTFdGUDZhdGVqcFNDcDkvR05ZcUhyZmRuMkgxUGg0bWtBQVBPWWFyZkRmWE5pcEVLOXoyOGFkZk5yMlhZNDIzNHoyMDdZendCQWhSUHRWampjYm9jei9YeFJQNGRzZW9YTVI3THRNOW4yYUxZZHliYUQyYllqdGRhZUFBQ2JXNndGdVpSYVYzdC9KZHQra0cxL2ttM2ZUNjM3NU0ydmRNam0vd3N3QU9GSGNLWUdCSytCQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wTkRrNFFUVXdNek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBORGs0UVRVd05ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUTBPVGhCTlRBeE0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pRME9UaEJOVEF5TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrL0lLVHBnQUFCb0pKUkVGVWVOckVtWHRzVTNVVXgzLzMwZmZhdmJxeHdTQ2JHeE1aYklGRkJCSWxFalVhWWxCak5CZzBFUklqSmlyR1lLSUd3Y1FIRXY4VUVKTzVoSWNtalBnSEFpWnVTRlJnd0Fib2ROQXRheG12UFRxMmRXM1g5NzNYYzlyZmNGdDcyM3ZiYnB6a205N2MzdC85ZmU2NTU1emY0ekpMdGg4Z0daZ1d0QXIwT0tnV1ZBMHFCZVhRLzcyZ2ZsQTNxQU4wR3RRS0NrM2NvT3JRWmxVZDhtbUNMZ085Q1hvUlZKRGt1Z0txR3REem9CMmdVVkFUNkZ2UUZiVWRzeXF2cndPZEFGMEN2WkVDVnM3eWFWdTh4OG1lalExMWFob3pDa05DRC9vQzlIWUdiMFhPSXFCdlFCOUNlQVN5NGVFcVFxVHo4UHZlRE1CT2hPVlc3QU84WFpVUk1DTUtLK0JHa0NSTUhabHh3ejZrQy9aWHZsdVpGakRBcnBSWTlqYzRzcEpaTTZZQStteEpCcDBRbUJFaUM2SGh6M0JrSXJOdWpBbjd0bS9ZdjFBUk1POGJOVWdzZDNSMlBSc0hiVVdHM2hlK05xUUVGblRtcndqRDFDYTZUYVhWUkE2L1ZrOHViVnREZGoyN21CaTFuR3FVSEIxUGRxK3ZJUmZmZjR3Y2ZIVTVxU2cweWpBenRjQ3lLMmxaNDRMZWVrR1hjejVSTmFncU1wSHZOeXdqK1ViTnZYT1hiNCtSTFVmK0pyNlFvQmgyLzh0MXBIYXU1ZDY1NGZFUWVmMkhLK1Q2c0M5aHlRT21SeXFhM3IwYzUyR29nWXpJNjcrVUsxMmZyWHRvQ2l6YThySmNzdStsT2tXZVRnU0xWbWpTa2srZldTUmI4aWdURXdjTThiSkM0dmduNUZwV0ZDUitkUlBRcGlUUWNyQ1RRMDNPZ09sSlpKc0NIUFd1UnYvTzVDZVpibWNjdzdJM1JlaTlNdENwWU5GKzc3bWJmRGlZeE1ZVnI4RTVDV1B4bGRic2gwRFh5YlU2NnhnaHkrZm5rVktMUHVIL2VCNy9iN1k1U1ZpUUZNTzIzM1NSRDQ1ZEpSRlJrdmN5eTVjRDJ4N0RZRmN3Nm1Idmd2cEg0WVE1MldPT1EySzlCUW1HaWFiRTAwcGh0elIxa0VBNFJkSUNXNVFSUGJ6NjFuRjJkTW02TGFMR3NESlY0cURuMElOS1BMMSthVWwyWVA4ZmVaMTUxMzV0Umc5ckpFNVRxN1NPS3ZWME5tRmp5UmRsMUNDd1R1UzBGV3FLdnhMb2JNS2lVVVlkRzEzbXNGeWgybzdUZ1U0WE5sYlBvb3hhQk9ZbGhqV21NK0tyZ2M0SUZrTWl4c2dqTUVjeU1JWmg0QzVNYWdmQk5SeERNaldPamZZcENmNTBXaXNwWFVvR0YwV09pVEV5MFRyTVJFSmpNd21iRGVnSlJqWmFNVUsrdnBtR3pSU2FNa29JTEhCK2x6MmJzSmhnU2tkRXhjQXhSZ0dCSS9vaGUzczJZYkVhcUJuR0ZlMHozTFhqUGtZRWdVTjV0cFoyUm96NHN3V0xwVXZ0M0NQNXNCd0o1RjFyUnFlR0VEakkrMFpHdEs2K3RtU05kano5b09yaFZpbjB4MDlWSjkvQWMvVmRoTFVtem0ranM3VXd5RzJ4bnptZXJOSGFhbXRhZzRJUzZMWFZSVW1Celk2enlPWkdWclpuWTRPSU04emNybE50R28vem1sd2oyNkEzN1JFc0ZYU1gweXZiRnBrZ1pOdm9UcWc0c1VRYUJ6bnpPMzg1UkNSSlROVHdrNU8yNklJeDNlRldEdHJwRFpMdEoyVDhCQ3o1blNjUDRtV1VNYmJpS09nNGhwQ01idVNHNEM5WlZCYkpzY2JOM2taOVlmS0hmWmdzbW1PR0pPRkpTOWNRMlFZckJUVnpnNG41ZEZtZWdSU2JkZVRxZ0lkcy9lbGZjbk0wY2I0Ym5OMm5pOXAvUEFLSDEwR2VLY3Q4V05maGpQd0J3WkQ3OE0xMU96OFg5Slo1NUQ0YUYzRDNMVGl4OHlQT1A0Ymg0QUFGcG0ra0JFRURjSUdqdUxWeEx3eUY0L2R0M3dmNkJvWTl5SUpNbEczcU1oK1NUNkp1N3pYZDZmZ0xYc1UrV0phRVpoMFcrc1Mra1FGWktOTzlGU3BkTmNkc3BIYTlDUEdNWlU2RWVBN3lmdGVBcjNSeEhVeWVOYk1DSzRSOFJXMkg5MXA2L2p5SHhZUEV2bzhFcDI4bVR6ZU1sVHRZVWFBaEN3WGJON2hxMHlhSTdia3pHclArc2I0NXJZMk54cjUvMExQZGxDRnVSMzZLaDZtWENmVXlwbTRFNm1BWUJwWE9ZR0c1S1dLeXpvL08yTE5wVUxvTWc3WXo4NXAzTitoY3QyM1VzemRvR1pOU0FrK0R4aDI2QUN1RUpZdmpuRVByN3U4SjVaY1ZDTHFjckd6RmF0MEROZ2lCQTlZclIwOUJINzBVOXBZY2JOenVaZHlPNWFITjZFMHNkd2hZRGlvRDVYdkxWMVM1cXRldUJxOHZoZVczVVYyY2h2MjY0ZDZPM083VDU4eTlGM3BJN0RQWWJacGdkMmtZeUc0REtmcUtCT0NZZExnelZBTEMrbHdNc29nYXZjbFRzYXJTVjFwVEdUWVhsUXI2M0NJNFo1RllYa3RuV1NFMkhIQnpnYkVoaldlbzM5amZhVGRmYjdYRHVYRTZOM0RTV0IyZzFTQ2M4b0dWZmdtbDNzYTlOd3YxT001WWNPbWRROStDaG9xYnRLbUluaElvU0poNkQrY0VPUE1hb2g1MTAwb2dLWHBEejFXb3JsZ01pWDJ5TlZLdlcrZ3ZnaHNtUVpOSnNINEs2cUdBSHBvZklhV2d5Y3BheXJ5bUhrR05VVUFkZlFoZXhzTVJDaGVrRHlDbW02ai9DVEFBQTFraEFQTkJSZmtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xTlVSRk5qRkdOek5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFOVVJGTmpGR09ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVTFSRVUyTVVZMU0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pVMVJFVTJNVVkyTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgreEJWRzZ3QUFEejVKUkVGVWVOcnMzVTlzVlZVZXdQSEQ2MnRMclhWYUNwcGFhbVJxSkNYT3dpQnVSOTFOWW5SaG9qSGp5aUhCLzJ0ampCdmR1RllUSFlrclozU1NXVTB5MjhHWnBVakdoWUtZSUNiUWFZWi9WYUNVdnJZUHo2Kzg0dTNsU2wrbEx5YjQrU1MvQmVlKzlpWG5iYjY1dlp5MzRmMkRsOUxQVU11eks4K0RlZTdMYzNlZTBUejllWG9UQUhDam04c3prMmN5ejlkNVBzdXpMOC8rUE0zVmZuajN4TXAvMTlmNDVsdnpQSi9uajNuR2ZCWUE4S3ZWMjVwTmVYNlg1N0hXK3JFOGY4bnpUcDdqN2Y2eVdwdXZHMjc5NGlONVhoWWpBTUJQR0d1MXdwRldPd3l2VjVBOG51ZXJQTS9sNmJIUEFFQWJlbHJ0RUEzeHhHb3ZycTl5N2EwOHoxUmRuSjFycFArZG1rN1Q1MmJTek94Y3VqZzNueGFhemRSc05uMEVBSENEcTlWcXFaNW5ZMjkzNnUvclRVTUQvZW4yelVPcHIvZXFleGViODN5YzU0RThMK1paV0V1UTNKVG5iM2tlTGwvNExnZklzUk5uMHJkVEozMGFBUEFyRlRjZ0dqRUxDK25zekd5YU92VmRPbmgwTXQwNXNpV04zYm9wRFE3MGwzOGtibkRFczZoeHQrUkNPMEVTYXg5VnhVaTgwWkhKLy9zVUFJQktjY01pWm56MHRyUmoyMmo1OHNPdHhvZ0hZRmZjS2FsNmh1VHRQSThVRjg2Y1BaLys4L2xYWWdRQWFFczB3Ny8vZTJpcElVb2VhYlZHdWxhUXhHMlVQY1dGazlObjA2Y0hqNlR2ejErd3V3QkEyK0pQT2RFUTBSSWxlL1llU2svK1ZKQU1sNHZsOVBmbjA0SERSOVA4d3FKZEJRRFdMQm9pV2lLYW91VHRIQ1ZicW9Ma2pYVDVTZGdydnZqbW1CZ0JBSzQ3U3FJcFN1SkF0ZGZMUVhKSG5qOFZYeFVQc01hdEZnQ0E2eFZOOGVYUnF3NXVmWHJ2b2FVR3VSSWt6K2JwWHI0YVo0dDRnQlVBV0UvZlRKNVlhb3lDN2xhRExBVkp6RlBGcThkUG5MRnJBTUM2cTJpTXAvWWVTclhsYiszZHVyeDY0V0xEb1djQVFFZEVZMFJyRkVTRDdJb2dlYWk0T25WNjJtNEJBQjFUMFJvUFJwRHNMSzZVL3JZREFMQ3VLbHJqdmdpUzdjV1YrS0k4QUlCT3FXaU43UkVrSThXVmk0MTVPd1VBZEV4RmE0eEVrQXdVVnhZV0hZUUdBSFJPUldzTVJKRDBGRmVhelV0MkNnRG9tSXJXNktuWkZnRGdseVpJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBRUVIU1dMRlEyMkJYQUlET3hjZlZyZEdJSURsWFhLbDNkZGtwQUtCaktscmpYQVRKVkhGbFkwKzNuUUlBT3FhaU5hWWlTQTRYVi9yN2V1MFVBTkF4RmExeE9JTGtRSEZsYUtEZlRnRUFIVlBSR3A5RmtPd3Jyb3dNRDlrcEFLQmpLbHBqWHdUSnAzbU9MNi9jdExFbjNUbXl4VzRCQU9zdUdpTmFveUFhWkg4RVNUUFBoOFVyWTdkdXNtTUF3THFyYUl3UGQwK2s1dkxCYU8ra3dua2tnd1A5YVh6ME5yc0dBS3liYUl2QmxjK1BORm9OY3VXazFyaGRzcmY0aWgzYlJ0TXQvWDEyRHdDNGJ0RVUwUllsSCt5ZXVQellTUEhvK05meW5DNis2cDdmanFYdXVvUFNBSUNmTDFvaW1xSWttdVBWNVgvVVNoZGVLTDV5K0RjM3A1M2J0NlY2bDYrOEFRRFdMazVsalphSXBpaDVhZmZFanpkQ3lxWHhjWjczaWd0YmhtNUo5Kys0eTU5dkFJQTFpWGE0ZjhmNFVrdVUvRG5IeUYrTEMxVzNQbDdLODQvaVFsVE43KytkOEtBckFOQ1dhSVpvaDRvN0k5RVlMNVlYNnhXL0k1NTRmVExQMy9QOG9YZ2hIa2E1ZmZOZ09uYmlUUHAyNnFUZEJnQldpSE5HNHIvMkRsYWYvUDdQVm1NMDJnbVNjQ0hQbzNuZXlyT25lQ0hlWVBtL0JVK2RuazdUNTJiU3pPeGNtcDJiVDR1TGk2bDU2WkpQQXdCdWNMVU5HMUpYVjFmcTYrMWUrbTZhT0E0K1RtQXRIWHBXRkkrRXhKMlIrYXFMOVd1OFYvekFNM2srYVlYSjV1TEZlRU4vd2dFQVZuRXFYWDRjNUtOckJrNGJ2eWdlZEozSTgyNnF1TVVDQUZDaDBXcUhpZFZpcE4wZ1dhNmJaL09NNTNreno2UjlCZ0FxVExaYVlielZEcWZhK2FINkd0OGtUbE43T2M4cmVYYmxlU2pQemp4MzU5bWFKeDZsN2ZaWkFNQU5MeDd0T045cWc2L3pITWp6cnp6NzArWHZ5VnVUSHdRWUFOc0ZZTVdhOTlNckFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk4wSXlNRVk0TUROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTjBJeU1FWTRNVE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalkzUWpJd1JqZEZNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWTNRakl3UmpkR00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K281Q3JtUUFBQnAxSlJFRlVlTnJFbVd0c0ZGVVV4Ky9NN081MGQ5dWwzVDYzdE5BbkZiQ3R0aWxCRFRFU1VlRURRYTBmL0dCNHhPY1hSZmxpMUdDaU1lb1gvQ0t2UkZSUUU2T1FFSkdLRDBBVFJHaExnQUtoTGZURmxtNjdwVnU3NzUzZG1mR2MzVnR0NmM3dXpPNjIzdVNmVG5mbjN2dWJzK2VlYys4Wm5hWDFmWkpHTTRBZUFEMENhZ0F0QTlsQTJmUjdMOGdCNmdWMWdVNkQvZ0lKMHdPc3ZmQ2VwZ2wxS1lMZUQzb1oxQXF5SnJqUFNyVVM5Q1RvWGRBazZIdlFQdEJGclJPekd1OXZCQjBIWFFDOW1BUldxZVhSdmpoRzI2bm1uWTN6QVp3RjJnWHFCRzBBTVNUOWhtT3N4ekVCK2hOUVZxYUFhMERuUUsrbjRVTEozSEk3emdIUU5Xa0JNN0swaWk2U1JqTC9EZWM0ZjdycG5kVXBBUVBzYXBsaFQ4RmxBVm00Wm9VNWYwc0VIUmVZbGNWYTZIZ01MczFrNFpzWjUvNjk2ZTFhVmNDODREWkNoOE1MYk5tN1d3RXkvRm0vM1pnMERvZjE1bzlsd2pURUc2VzBLSjlzZTNvOVdXb3JKaDFYZThqQm83K1FrQ0JvSWpGbThXVHpwc2ZJZmZmVUVQdW9rM3grNUFSeGpFL011UThaZ09VanVIeHQ1dWNjdjJMdHYvL29JLzVta2VQM3g3UDg0dUlDOHVZTHo1S1NBaXRoV1phVWx4U1N1b295MG42bGg0aWlxQnAyeDlablNQMnlLcUxqT0dKZFpDRXQ5WFhrY25jLzhmb0RjNkVadG5tNHFPWDQwckd6amprdUFTbVNBZGdQbFVMWDg2MGJTSTdaTk91eldnRGVzYVdWOEFhRGF0anE4dEpabjF1eXpXVHJVMDhvaGp6S3hNd0JCbjlaSlRIY28wbzliWVh4azlvMGRCWnYwQXc3MDlXVUdqQ3RRN1pad05TNnJ5YktZRjA5QTRxREl2UWJtK05ESjRQRmRybTdMMkU2bU1rVzgyR0dXQ1l0VmVDN0RLL1U2OHFOZ2FqUDV1ZGE0bjZQbitQM3VCZ2oxS2ZWd1BZTTJNbStiNDhSVVpJVTc1Rlpyb0l3ek80OHoxQW9hbUZuN3ZJMXNDcHpFajFtTUNTUVhRY1BreHVEdzZvc3JSWjIxNWVIaVJBT0ovUi9aRVBHcUlYWEI4NndRN1kxcjREWlZ5ZGJPR2c1dEtBYVN6L1VkRzlHWVAvelhjbTVaT3pjcjJoaHZjVG9HdFRHVWJXV3ppUnNiUEZGR2ZVSXpFdXNybEpMOEZjRG5VbllLSENNa1VkZ0E0U09mSzBUcHdLZEtpd05iOGhvWUtPSmdtRk1xU1I4TGREcHdNYUNXNVJSaDhCY1dzY0doaUVzbC93Y3dPSjliTm9IbGVoTURPeDlBNm4wVmhPNjFDUVhWWWFKTVRKUjA3QlNlR28rWVRNQlBjMkl3TEkrRWh5WmI5aDBvU21qak1DaUllenB5eVFzTGpDMUdWRjF4U2JHS0NKd1pKRnZ1RE9Uc0JnTnRLUnhOUTBZc1k0UlFXQ2h6SG0rRTg1eGdVekJZdWpTdXZkSTZMK3lHQ3dIUm1SRjRGQ1c0SGFaQStNZGlUcHQyZlM0NW5TckZ2cTVqZXNTbjBvRDQrMXcxc1J6VkhTM2hqTzRiUk9YZmt6VXFXbEZiVXBKUVExMG9yR3hsVXhjUmpZM3NyS25tbmZpUnRSYjVtenZNSVltcnl0MXV1VndwcHpCa2tIYkZjYU91aUl3Z1R0MDBFcW9OSjJpZkxndFhqcDY1bXVHeUhGMzBnZU90QkczMTVkeXVsV0MvdHZ0Slo4ZCtVbWgrQ1pMd1BRVnNsSEcySW1qMHZFSFFqSTUvbEZ4TXFleUxNam56dG05ZVh3Qk9DYjFreVZ3eE1kRmN1RmFMOWtMSndVdGU0UHAvWFNSTlpma1dyTEowTWdZK2ZTYm8yUnNZakx1L2JtZVc2ZVgyVTk4QjVkNFB2TkVIMks2b0Ezbk9xd2VWZ242N0piMjVTOTlJT2pOaS8vSFFnckVYZC9JcXV2NzN6S0V2ZWdPL2ZnajNWMzVDWUZHNFliKzVVTS83T0drc08vL2dzVzVnV0Uzc2lBVFpadDl6SWZGSjFPekQrWlAzYmhVYS85NUwydzRoSVdHeFRseGJtUkFGc29reDYzOERKUStMSUUvbzFOS09YNUhpQTk3UmwyVzZrYVpZZlVMQWN0S0VYK2R2VzFQNloyTFozRk5rOWo3a1ZEQzJocjFsZHU0MzRDT0xDOTQvTmNyTm00RDN5NmRYNS8xam9BYmZKRS9kUk10MjBzWmduUGNaYWFGcVpVSnRUS202b2dwNUFwRFVybm1NWmVhUTN4dU9XNmZNK29DRUxyeVBJTm5tbm9QSGNnT09MdXBaWWRvR0pPVEF0OEY3Y2VuNUtTSWJKdm82amNINzl6MEdvdXRZWjBwSTZWWVUzQ2l1KzVXMjZHYTJ5ZFB3aHlERk5hdUJEc3JyTVZyV01JaXNSY3lDRmdCS2dQbGpWbFgxdHd1YkhuUWJTcXRoOU9zU2FPZkJpeitrYTdGNDUxbmkxMVhiNUxZYTdCaHVzRHVVRGVRRlg4Uk5TOFdBUndYSFZhR1NyRHlDaXJDd3FQSUdjeWoxb1pxbDZXcU9zQmJiU0Y5ZHFISUdpd3l5MFczWDR3a0Nwd2t1UG13ZDl3WWNqbXM3djYrRWxkWEh5Y0tQcm8zY0ZKZkhhWFJJR2tXWXRTK0NhWFd4dHFiaFZxOEVBczlKUGJXRTM4RlBSVTNvNmlJbGhJcFNKaGFEL2NFdVBNYXB4WjEwMGdncS9MNVRaVjY3ZXNrOXNyV1JLMXVvWDhSM0RnRG1zeUFEVkJRRHdYMDBQVWhxQVZORk5hU05abGFCRFZGQVhuNkVEb0ZDMGNvWElnK2dKVHFRdjFIZ0FFQVJEQW13YU5ZSVE0QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9iZXRJbmZvLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxiZXRJbmZvLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1lMmE0YWM2ZS9iZXRJbmZvLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9iZXRJbmZvLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzc2NjFlMmExXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiYmV0SW5mby52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuXFx0XFx0ZGl2LnJlY29yZCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRSZWNvcmRcXFwiKVxcclxcblxcdFxcdFxcdHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXRcXFwiKVxcclxcblxcdFxcdFxcdHAuZGV0YWlsXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDnjqnms5XvvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5wbGF5bGF3XFxcIilcXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOS4i+azqOmHkemine+8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLmJldG1vbmV5XFxcIilcXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOWAjeaVsO+8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLm11bHRpcGxlXFxcIilcXHJcXG5cXHRcXHRcXHRwLmJvbnVzLW51bVxcclxcblxcdFxcdFxcdFxcdHNwYW4g5pWw5a2X77yaXFxyXFxuXFx0XFx0XFx0XFx0c3Bhbih2LWh0bWw9XFxcIml0ZW0ubnVtXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICByZWFkeSgpIHt9LFxcclxcbiAgICAgICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcXHJcXG4gICAgICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgYmV0UmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JldFJlY29yZCcpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAgICAgY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcblx0ZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuXHRcdGRpdi5yZWNvcmQodi1mb3I9XCJpdGVtIGluIGJldFJlY29yZFwiKVxyXG5cdFx0XHRwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XCJpdGVtLmNyZWF0ZWRBdFwiKVxyXG5cdFx0XHRwLmRldGFpbFxyXG5cdFx0XHRcdHNwYW4g546p5rOV77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLnBsYXlsYXdcIilcclxuXHRcdFx0XHRzcGFuIOS4i+azqOmHkemine+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5iZXRtb25leVwiKVxyXG5cdFx0XHRcdHNwYW4g5YCN5pWw77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLm11bHRpcGxlXCIpXHJcblx0XHRcdHAuYm9udXMtbnVtXHJcblx0XHRcdFx0c3BhbiDmlbDlrZfvvJpcclxuXHRcdFx0XHRzcGFuKHYtaHRtbD1cIml0ZW0ubnVtXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge30sXHJcbiAgICAgICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcclxuICAgICAgICBkYXRhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmV0UmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JldFJlY29yZCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmJldC1pbmZvIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIG92ZXJmbG93OiBhdXRvO1xyXG4gICAgcGFkZGluZzogMTBweDtcclxufVxyXG5cclxuZGl2LnJlY29yZCB7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYmV0SW5mby52dWU/NzY2MWUyYTFcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gW3tcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvYmV0UmVjb3JkLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJldC1pbmZvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcInJlY29yZFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0UmVjb3JkXFxcIj48cCBjbGFzcz1cXFwiY3JlYXRlZC10aW1lXFxcIiB2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0XFxcIj48L3A+PHAgY2xhc3M9XFxcImRldGFpbFxcXCI+PHNwYW4+546p5rOV77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5wbGF5bGF3XFxcIj48L3NwYW4+PHNwYW4+5LiL5rOo6YeR6aKd77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5iZXRtb25leVxcXCI+PC9zcGFuPjxzcGFuPuWAjeaVsO+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ubXVsdGlwbGVcXFwiPjwvc3Bhbj48L3A+PHAgY2xhc3M9XFxcImJvbnVzLW51bVxcXCI+PHNwYW4+5pWw5a2X77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5udW1cXFwiPjwvc3Bhbj48L3A+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXGJvbnVzUmVjb3JkLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNjkyY2QwYmEvYm9udXNSZWNvcmQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuYmV0LWluZm8ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAyZW07XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQgcCB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IC41ZW07XFxyXFxuICAgIG1hcmdpbi10b3A6IC41ZW07XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9jNzY1ZjAxOFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0E7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiYm9udXNSZWNvcmQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICBkaXYuYmV0LWluZm8odi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIGRpdi5yZWNvcmQodi1mb3I9XFxcIml0ZW0gaW4gYm9udXNSZWNvcmRcXFwiKVxcclxcbiAgICAgICAgICAgIHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXQgfCBkYXRldGltZVxcXCIpXFxyXFxuICAgICAgICAgICAgcC5ib251cy1udW1cXHJcXG4gICAgICAgICAgICAgICAgc3BhbiDlvIDlpZblj7fnoIHvvJpcXHJcXG4gICAgICAgICAgICAgICAgc3Bhbih2LWh0bWw9XFxcImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi4vLi4vanMvcmVxdWVzdC1saXN0J1xcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c1JlY29yZCgpLnRoZW4ocmVzID0+IHRoaXMuYm9udXNSZWNvcmQgPSByZXMuZGF0YSlcXHJcXG4gICAgfSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4uLy4uL2RhdGEvYm91bnNSZWNvcmQnKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICBsb3R0ZXJ5bnVtKG51bXMpIHtcXHJcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bXMpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xcclxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+iOt+WPluS4reWllue7k+aenOWHuumUmScpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIOS4reWlluaVsOWtl+aAu+WFseWNgeS9jeaVsO+8jOWPluesrOS4gOS9jeWSjOacgOWQjuS4gOS9jeebuOWKoOe7k+aenOeahOS4quS9jeaVsOS9nOS4uuW8gOWllue7k+aenFxcclxcbiAgICAgICAgICAgIG51bXMgPSBudW1zLnNwbGl0KCcsJylcXHJcXG4gICAgICAgICAgICByZXR1cm4gKG51bXNbMF0gKyBudW1zW251bXMubGVuZ3RoIC0gMV0pICUgMTBcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ1OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHAge1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xcclxcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICBkaXYuYmV0LWluZm8odi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxyXG4gICAgICAgIGRpdi5yZWNvcmQodi1mb3I9XCJpdGVtIGluIGJvbnVzUmVjb3JkXCIpXHJcbiAgICAgICAgICAgIHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cIml0ZW0uY3JlYXRlZEF0IHwgZGF0ZXRpbWVcIilcclxuICAgICAgICAgICAgcC5ib251cy1udW1cclxuICAgICAgICAgICAgICAgIHNwYW4g5byA5aWW5Y+356CB77yaXHJcbiAgICAgICAgICAgICAgICBzcGFuKHYtaHRtbD1cImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcIilcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uLy4uL2pzL3JlcXVlc3QtbGlzdCdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzUmVjb3JkKCkudGhlbihyZXMgPT4gdGhpcy5ib251c1JlY29yZCA9IHJlcy5kYXRhKVxyXG4gICAgfSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4uLy4uL2RhdGEvYm91bnNSZWNvcmQnKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgbG90dGVyeW51bShudW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtcykgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+iOt+WPluS4reWllue7k+aenOWHuumUmScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5Lit5aWW5pWw5a2X5oC75YWx5Y2B5L2N5pWw77yM5Y+W56ys5LiA5L2N5ZKM5pyA5ZCO5LiA5L2N55u45Yqg57uT5p6c55qE5Liq5L2N5pWw5L2c5Li65byA5aWW57uT5p6cXHJcbiAgICAgICAgICAgIG51bXMgPSBudW1zLnNwbGl0KCcsJylcclxuICAgICAgICAgICAgcmV0dXJuIChudW1zWzBdICsgbnVtc1tudW1zLmxlbmd0aCAtIDFdKSAlIDEwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5iZXQtaW5mbyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuXHJcbmRpdi5yZWNvcmQge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xyXG59XHJcblxyXG5kaXYucmVjb3JkIHAge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogLjVlbTtcclxuICAgIG1hcmdpbi10b3A6IC41ZW07XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYm9udXNSZWNvcmQudnVlP2M3NjVmMDE4XG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYmV0LWluZm9cXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PGRpdiBjbGFzcz1cXFwicmVjb3JkXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBib251c1JlY29yZFxcXCI+PHAgY2xhc3M9XFxcImNyZWF0ZWQtdGltZVxcXCIgdi1odG1sPVxcXCJpdGVtLmNyZWF0ZWRBdCB8IGRhdGV0aW1lXFxcIj48L3A+PHAgY2xhc3M9XFxcImJvbnVzLW51bVxcXCI+PHNwYW4+5byA5aWW5Y+356CB77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwibG90dGVyeW51bShpdGVtLmxvdHRlcnludW1zKVxcXCI+PC9zcGFuPjwvcD48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXEV4Y2hhbmdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtZjM2N2E4NmUvRXhjaGFuZ2UudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuZXhjaGFuZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5leGNoYW5nZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLm1vbmV5LWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1tb25leSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWU/NGQ3MDUwMThcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5RkE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJFeGNoYW5nZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xcclxcbiAgICBkaXYuZXhjaGFuZ2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIC8vLSBpbWcuYmFja2dyb3VuZC1pbWcodi1iaW5kOnNyYz1cXFwiYmFja2dyb3VuZEltZ1xcXCIpXFxyXFxuICAgICAgICBkaXYuYmFja2dyb3VuZC1pbWdcXHJcXG4gICAgICAgICAgICBkaXYodi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJhcmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5tb25leS1pbWcodi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIsdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVxcXCJib251c01vbmV5XFxcIix2LWh0bWw9XFxcIml0ZW0uZ29vZG5hbWVcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLmV4Y2hhbmdlKHYtYmluZDpzcmM9XFxcImRvZXhjaGFuZ2VcXFwiLHYtYmluZDpzdHlsZT1cXFwiZXhjaGFuZ2VCdG5cXFwiKVxcclxcbiAgICAgICAgICAgIGRpdi5jaGFuZ2UtYnV0dG9uKHYtYmluZDpzdHlsZT1cXFwiYnV0dG9uQmFyXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJvbnVzLWJ1dHRvblxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLmJvbnVzLWJ1dHRvbih2LWJpbmQ6c3JjPVxcXCJib251c0J1dHRvblxcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5wcml6ZS1idXR0b25cXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5wcml6ZS1idXR0b24odi1iaW5kOnNyYz1cXFwicHJpemVCdXR0b25cXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHJlYWR5KCkge1xcclxcblxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9tb25leS1kYXRhLmpzJyksXFxyXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WGheW6lS5wbmcnKSxcXHJcXG4gICAgICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIGJvbnVzQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIHByaXplQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIGRvZXhjaGFuZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmcnKSxcXHJcXG4gICAgICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbW9uZXlibG9jaygpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBidXR0b25CYXIoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYmFyY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYm9udXNNb25leSgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDM1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBtb25leUltZygpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGV4Y2hhbmdlQnRuKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgzNjQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIG1ldGhvZHM6IHtcXHJcXG5cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5leGNoYW5nZSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLmV4Y2hhbmdlIHtcXHJcXG4gICAgei1pbmRleDogMztcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xyXG4gICAgZGl2LmV4Y2hhbmdlKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuICAgICAgICAvLy0gaW1nLmJhY2tncm91bmQtaW1nKHYtYmluZDpzcmM9XCJiYWNrZ3JvdW5kSW1nXCIpXHJcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXHJcbiAgICAgICAgICAgIGRpdih2LWZvcj1cIml0ZW0gaW4gbW9uZXlEYXRhXCIsdi1iaW5kOnN0eWxlPVwibW9uZXlibG9ja1wiKVxyXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJtb25leUJhY2tcIilcclxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cImJhcmNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cIm1vbmV5SW1nXCIsdi1iaW5kOnNyYz1cIml0ZW0uZ29vZHNpbWdcIilcclxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVwiYm9udXNNb25leVwiLHYtaHRtbD1cIml0ZW0uZ29vZG5hbWVcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcuZXhjaGFuZ2Uodi1iaW5kOnNyYz1cImRvZXhjaGFuZ2VcIix2LWJpbmQ6c3R5bGU9XCJleGNoYW5nZUJ0blwiKVxyXG4gICAgICAgICAgICBkaXYuY2hhbmdlLWJ1dHRvbih2LWJpbmQ6c3R5bGU9XCJidXR0b25CYXJcIilcclxuICAgICAgICAgICAgICAgIGRpdi5ib251cy1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICBpbWcuYm9udXMtYnV0dG9uKHYtYmluZDpzcmM9XCJib251c0J1dHRvblwiKVxyXG4gICAgICAgICAgICAgICAgZGl2LnByaXplLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5wcml6ZS1idXR0b24odi1iaW5kOnNyYz1cInByaXplQnV0dG9uXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9tb25leS1kYXRhLmpzJyksXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nJyksXHJcbiAgICAgICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+Wdly5wbmcnKSxcclxuICAgICAgICAgICAgICAgIGJvbnVzQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nJyksXHJcbiAgICAgICAgICAgICAgICBwcml6ZUJ1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgZG9leGNoYW5nZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2iLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb25leWJsb2NrKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBidXR0b25CYXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJhcmNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9udXNNb25leSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW9uZXlJbWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDBweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjaGFuZ2VCdG4oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgzNjQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcblxyXG4gICAgICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYuZXhjaGFuZ2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcuZXhjaGFuZ2Uge1xyXG4gICAgei1pbmRleDogMztcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmltZy5tb25leS1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5kaXYuYmFyY29udGVudCBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbn1cclxuXHJcbmRpdi5ib251cy1tb25leSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuXHJcbi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuZGl2LmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBhZGRpbmc6IDElO1xyXG59XHJcblxyXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB3aWR0aDogNTAlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEV4Y2hhbmdlLnZ1ZT80ZDcwNTAxOFxuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTAwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICcxMFfph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwV+mHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6ICcxMDAnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfV1cclxufSlcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRU16UkVPVVV4TWpRd00wSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBFTXpSRU9VVXhNelF3TTBJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1F6TkVRNVJURXdOREF6UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rUXpORVE1UlRFeE5EQXpRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K01yUEYxd0FBSU45SlJFRlVlTnJzZlFtVVhOVjU1dmUyZXJWWDcvdWlYVUpDRWtJc0VpUUdHMklUSEM4NEJFN3NlSnhoenNTUWM3eE01Z1NmR1dLUzJCT2ZjYzRzZUpMWUpqTW1NTVBrakdNSGlET1l3VGJnSlVic1FoSklRbEpMcUZmMVV0MWRlNzMxenYvZjk2cTdFWklzd0Vpa2VWZm5xcnFyNnIzNy8vZTcvM3IvKzFvUlFpQnF5NmVwMFJSRWdFWXRBalJxRWFCUml3Q05XZ1JvQkdqVUlrQ2pGZ0VhdFFqUXFFV0FSb0JHTFFJMGFoR2dVWXNBalZvRWFBUm8xQ0pBb3hZQkdyVzMxdlMzZTRDZEs3ck8rcnVWR25ENWhRTGJOdmg0enlVcU1ta1ZOVnREWDY4SnAxYUZFa3RRandHdURUV2VoTEFyVUZRSFdpb3pxTVJiTDFhTjFxMWFxblU5akdTdm91aGQ5SjJjb3VrSnZyZnczSnBmcnhXRWNFN0FxWTU3bGZ4QjRlVDMrUFg4QzE2bGRGejRCdDA3QmI5ZXBWbUowYjF0NmpVWWlTUkd4eXdrWWg1S1pSOC9mYzdIN29NcW5uNUpRU3B4ZG56dGV2WEU4Z0gwbDlxRWdHL1hBV2VlUURRdk1qbzNma3pQOWwrdnBadTNLekVUaUJFN3dnVVVqMTRkQXA1V2lPL0tTeFZEejJnSnN3TktlaTFFRzNSbEZXQzdFaml2UFB1OFd4ajV2bHM2K29CdnpiNEl2d21LVUNJSmZWdWFRaE1yQ0JlV1JsRXpZcTFyUDJXMC91b3RSbnZ2VGpWSklxTFpnRmVnUGd4WTlDcHN5QXZZbWtoUVFtQjhlcy9qOS8zZ1BZVWtYY2xCU1RSRFQ3ZHUxOXU3dC92VnpWOTBwc2QyT2ZtRDk5ajV3L2NKeDNkQW1rRFNFQUg2Vm9Ga0RCUTQ5VHFCV1lXUkdmaTM1c0FsbjQ5MWRmY3BTUUxMbTZKT3Fzd2hpVVVzN0diWUYrOXhlbW5uVHVyVm42ZDcwQ0pRNDFDVFhUQlhEZXlNZGZYdk5FNXMrbU5yK0xtN2ZIdmlQenQxRmFadW5QbCtFYUJuUnROekJSU25pRlFzZTRQWnMrTS9Hb05yMTZscFVxWGVFRWtpZ1NEaVM0QTh6WXBRVGdFaXhFaytZVHpvTExqK0pLbnA0MURNSmdLMnY4L28rT0IvY280Zi9uUnErcWt2RUMwUHVtNFM3M1JVMzFHQXFqUlhycWVnVUNhSnFWdnBqcFZyN281dnVPemphbWVLUGp4S1FKWUlENTdVN0VuQThNVWFjVU5TcE92aHBETkMzcEx2OFh0YUNDSzk1NUp0ZGNuTyt0NlNtOUQxZ2hhSXc1KzlERFdkZ1hsQi85b1ZMUzBQMUE4Kzg3ZUZBMGR1TFpUTmt1dVprdFlJMERNUlFuTmRxQ3FZSzlheHRjKzVhc1AyaS83VzNMS2xCeWx5YkN5V1NsWjU2WWF1bEE0U1ZDSS9uZ2h0WEFXb1RxSnlmQjdWNlRMc1VwMThJaGUrRTRDcUdqcjBoSTVZSm81a2V4cXA3aVlnU1IyWjRGNzEwSUZTUXZBRmpVWFhReCtDMnR0S1g3M2k0eHRTNmF2SFR1ejl4TlA3OE9OQ05ZNU1TdEFDakFBOUpaalRCUVhWcW8xUFhlVisrdnAvZWZFM3NXWWRUV3FlUUhJQ3U2aGdFVWlkZmpjNVppakRtVHFNcVgzaktJOFU0QlRvdTQ1Q1h6V2dVZWloR3RSVlE0N2hrQ1RXeU41NmJwSHVNa1plcjRDZU01RHV6NkZqY3crTWpqNzZGZ0ZzRWJDdUZZeW5zSzJtc2Fya2JDV3JNSGRzN0xtK1RYL0NxdXkrOWJhOTl0M1RoUmphYys4c1VQVjNCSmhGRmJPek5yNXhhKzFMTjl5Ky9Zdm9YazBUU1hheVRtcFQwUlpDRmpBNFNaYlNPY3p2MjR1Slo0ZGhUZG5RMVF4U3JWMW9XOXVLZEdjYVpvYlVab3l1MDlSUWVrVWcyQjdkei9aZ0ZXMlVTWXFMNDNuTVBUK042V2VmaDltK0QxMlhEYUI1ODNwYUxNMGtuV1dTV0NlOG51NVZKZFRpUk5PYTFiamhkdkZOWVQzZmUrczNsVHZaVzI3UCt1OFlVSlczKzdEU21SSUxHczFUdnFRaW4zZng5VnRtdjNyalZ5NitIZTJiU0p6S2N1SVh3YURYRktsRzJDaStzaGZIZjNnRWJsNUJwbU1BblJmMkl6T1FDMkpRWHlQTHFRYVNwYXAwK1JMSFNBbzN4ejhFcXZEcGJlcXFKMlBSMG5BQmt5K05vRFExQXIzTngrQzFhNUJkdnlWd3VDb2xucVZRRFl0Z29SaTBxR2IyNDd2Lzd2ay8vLzE3V3I3UTJxcWpOZVBEODg1L1l1RzhBY3BPUmJtdVlHck94MTAzVC8zUnpWL2QrbVYwYlE4Y0gzWllsSEFDbFZBcXJWZHg4TnRQb1hqUVJ0dXE5UmpjdVJwYWV3ckNKUkFWbmN5cFRzSWNndG1JR3hzTG91RVVOWGpsVndKVmtNVDZOSllxWENpNkIyKzZndU83aGpCejlCVmtOOFN3NGVZZEpLMHJTRHJMUWFLaVFST3JGWk1jc3hQUDQrKytzT2ZPejMyNzQ4c2R6U3JTY1NIRDNYY2xvRHpzd1JFVlg3cit4Q2MrZS9lNis5Rjc1VWxna2lUcDVOR2FNUlFQUDRXRDl4OUVJdEdQOWUrL0NER3llNTdEQUJxRU4zVlZmZlBCUHhFaVNHb0ZlYmJDdGFIRlhOaGtqMS81d1l1bzFVYXc0Uk1ia0YxSHdGcmtlYnZWWU1GSVVFa2ptS1ExeG42Ty8zYnJvVS9lK1hEWC9SdjYvVk9Tc2V3QjFXbE9Eb3pwdUdIRDVBWC8vZDd1L2RoMkxhbSthaERnTjhDTWtWUWFQaVorOGlNY2ZXZ0tLeS9mZ1o2cjFwQzh4U0JVVTNxdE1sUlJsc2FZYnk2QnNiRENDRmlmZ0ZWOGk5NjJNZjZUSVJ4N2VoZFdmYlFEM1ZjUmpRNFJicGNYUVRYWVZ0T2kyLzBZL3ZYdmptOTg0RURuZ1kxOUxsei9YUVFvYThYeE9RMXRhZ0dQZnNNWWJiN3B1bDY0OUdhOXNmb1pUSW83WXg2R3YvZVBHSDNNd2ViZnZCYVpqZDN3YkFOcXpDVDFxQzFLcERoVEtrZzVlOENYQUN2SXcvRnRpNlRWUVduL0JQWTk4Q1AwdmMvQXdJYy9SSURTMkhabGtWWk9EZW9DYzkvNWYyUFgzV3IzVGZzNTlEUjcwdjg2SDRDZTgrMHp5MVZRbXJmeDVVKzZmOVY4MDQ1ZTZYalVLbUd1ajd3S1BVNXYrUVRtOTBoQ0JMWi82a1BJWE5CSDRVWUNXanhGWU1ZQ3IxT29RY2ZwdWhaK3I1RmdVTS9jRis2bnlURjRMQjZUeDk3K3lROUpXcGdtcGszU0tCTVNTa2k3Z2ViZnVyejN5Ly9DL1RyenhqeWV0K1RNdVE1UmhpWlUvTmJXdWMwZnVIM0Q3d1BkRUtVQ0NZOUNna0YyakJQbWNSTVRqeitLMGNjZGJQdjRyOE9rb043MzQ5RE1lS0JpenpiMXh1R09Zc0dlZFZFZmRjajVLUVJTZFZiWEszSXNIcFBITnZ0YUpTMU1FOU9HZUV6U0ttbG0yb2tINXVYOWY3amh0aHN2bXR2TVBPcmFNZ2VVTlNTSEtQM3hBdTY4cy90NzZObElJVUVoektHeS9WS2dwRTNNUFAwNGhoK3RZT3R2L3diTXdYWjZPeUhWYkFDR09EdGpHWHEzenZ5WWxES2hiMEo5ZklLRXRSWXVpbC9vS1FXZHhsUk5VOUxBdEZ4RU5ERnRNMDg5SVdsbG1nUGFFZkJDUFAzeEY3di9nWGxrWHMvSEpzMjVBNVQ2eExTSFQzOVlmS2JyWXh0WGdOU1N6NTVqNkdVcTJRenFJL3R3NUxzaldQOXIxeUMxcG91a2c1d2YzdEJXbFRmbTlaQjBDbEdETlVYMzFlcUlyeWFiVnFjaGkrT0x0dlhzWEdDNU9KZ0dwaVZKTkcwZzJvNzgvUWhxUkN2VExHUmNLd0plaUNmaWJlV25QeUkrdzd3cXkxbEM1NnNxMWpXVjhQRmIrdjRVYUlOZkxNckpZcldscUN5QnN6anl3QjYwcjltQ3BpM2tBRmtrSGF5M0ZwSUI0aXc3cE4xMGl5Zm94d0hvelRteWlVL1Nhei9zNlRwTmVtVXhuanliSG83TnREQk5PYUt0ZmMxV0RQMzlIcnBQWHRMT1BQQTlKVS9FMnlkdTZmc1Q1cFY1WHBhQXNvQk5UUHY0amF2MG01cmUxOStNdXIwNFdSNVpvVndNMHovZFRmWXVpMVZYWDBqZXJFWmhpUkVtQS95ejdsSmErQktLRjYycEN2UmNEL1JzSHFKNERMRldsN1RqYWppVnlVQXJoTW1Gcys1MFk2YUphVnQxOVNiWWMxbWkrVVZKdTl3NGJ5dzY0aTEzZFY4TDhYb3o4M3l1ZDJYT0NhRHM5VFdyRlh6NEkrMmZoOUlNcjF5VkU4cGRZWSt4T282SlowNmdhK01XS0JuNlhUTVdwRmY0NHF4N0kreHdxNVBraEs2QTBVelgxdzVCMkJsbzZURm9tVjRDdWtTQUIxNzFHN2wzUXdxWk5xYVJhWjE0WmxMU3J1am1BajllaWNJdnRRVWZJVjZaNTNQdDhhcm53bmJPa0w5d3lRWXhzUFdhOXAxd3dpUzVkQ1lJMEpTR3lhY1BRYkdiMEhOUlAxd0szbFZPOG1JeDczcTJYVnBha2s1N3FremdrYnJOakVEVU9TZE1jVzM5SUl3bWlpL2RsV1JQOHh5QUw2UUF6Nm96TGJ3TlI3UXhqVXlyWW1VRDJsUDZBai95ZThUamxtdmFkMXk2UVF3eTc4c0tVTTZybDBvT2R1NU0zNGlCSnZpRjJxSzY1VGpSbTBYK1FCNjVubFZBTWthclhWOEU4NDMwRUNBR3kzWDZKWGpDT2toM1NrdFY3TlVjR0psUmt0UUJrdEo1Q2J6eVpzYmhRSVZwSkZwenZhdVIzNStYUEVoZUdnNFM4MGk4N3R5WnVaRjVYMWFBc3ZPWFZXMWNlbm51QTF6cTRkdE9vSjU4SVcxU1pXaWMxSlNPOW5VOXNvQkFrYXFXUC9jQ2xYdmFIa3BZdy91bEVFTjRkVmdrRW1wNkpZenNCUHhxUFZ3OG5BUWdqOVFoS2VYOVM2dVA2SmdMMlZjV00wUkNuSGxNU1pPUU5ES3Q3ZXQ3eUh6b3hNT1k1Q1ZRelVMeUNDUnc2WTdzQjVqM1pRVm9rY3pWWURmaUYyN0pYTW1xU0lTcVNVNk02U0YvWkFheFdETVNIWW5GdmM5VFNGNmd2cGYrYSt5SitYSW5SS0VZMDYrUHdDNjNJSmFsR05BNUlFR1VZSXBRY2lvVkFub1NTbUlGYWlkR2FRSE15aTA1V2ZySjIya3lUYUJJd0JiR0VJdDUza1VwRFVLalJIdEMwcDQva3BlOEJOdHpvVDEzQkM3Y25MbHlSUThTNXhMUXQzMkR1MXp5c0hLenVTMDNtRXloYUFmZXFBZ3pPVzRaZFFvbGtzMjljbTBwYWxnTDVDOUptQ3NJSjVnbUNpd2xMZ0hoeUZ5cloxbHdhN2FzSEJHZUFhdFFSYXpqVnhITGpjSXJrdkhTMjdDNG44V3ZXU2p1UHBpdDEySCs1ZlZ3cXNNeXlhL3FMalRUZ0I0MzZaVnp4YnlEUTUxcERFdEJGNXl1Y0k5VjB1cXBTRFczb3pvOUZPemhDcDFJRGpkRmlkZnNZREs1Y29XNWpYNTdjdGtBeWdDc1dwWGVpcFlZdkVsbllZSVZYWVV6VzRSZlU1QmVtWVBMNFl2UmtBU3h1SXZKZWZ2OEpPcXpCUkkyWGVaTmhTeEo0ZTJ6RklIUkJOVk1RS1gxa216S0lONDZDMUhkQ3kzWkZ1UWF2ZkJPbWlKVHVsNXBDa1ppTjVvMmJvVTkzMHowMWNudVZ1QVFBR0xPa3I5VG5DTjNXeFRGSVpBMUpMdTZhSXkwM0QrVmNxc0dDOFIxQlZMdE9aU0hGRGh6QmFLL25TdjA1WEJzczdYT0dQRWUzN0tzQU5VVmdaNWVjeTBNQ3N3ZFo4SG04YTVMWWFaTTJrNUhvamtlQ0dOb08vbVhZT0lVek93OURDV1dRYko3UFVsakZWcE1wUjVVbzJneFFSSkYzOVhZbFp5VWRiWitsV3hvVXl2S1IrWXgrOUtFTEF6anhnVmpMUmQySWIyMkcxNytHTXo0Y1ppOXpaRDFTc0lrMmxTUytBUkpQb0hoS1BTekw5T0VxcXBpOHNWRHlBMjJJOVhkSGhTZCthSE5aVXZaUkxUVFFpdlBWTWhKYW9jYnFtU1BGcVZHZHJXN3oxeTNyRlJ1TnFXZ3V5ZldEMm5LL0lWMG1FcEFXL04xOGcwTmtoZzkwTEl5UEdoVUtuQXVsQ2JOS3RLRUhzVGEzN3dVcWUwVWZreVRCSEp4TlRzb1hIRlFhZXlzQk5VS1dxSUpwY096T1BHVElRS1hKQzZVVUlVa2RJSVdVQmZkTzlPWGt4S0VPcGVGRnNMZEdGL3UwM0lSTjZ0YlpNbitrbFFlZitBQXFxTlRhRnZidG1oREZTellkU091U3g2c1FoMXFuMWpRUUJKdXVtMVB0OUczckFDTnhSU2tNa2FibkRQUGsyNUgwRnk0ZFZkV0hRU2xzbUdtQjQwSjhjalJVZEYrOFFWazYrYncwbDgvak5VZjNZcm1yYjBRRmJLanZ2YTZLZ1cydGI3dFl2YUZFU2cwVnRNRjdVaDBaYVFOckU0VVVTVG5KZi9jTUZJZEZ3U1krTXJpTmh2L0xvL0VrR1J4a1ZtcGpsZnUrU2ZVWjRwWTgrSDNJdGJVSkczMllpbzR6R0l4R2NTRFczVWxUMkxwUnFqckk1VTJXcGNWb0pxbW1LWmZ5WEpwaVFUVER6TXVKQkcrVGFHTG9pOEo4TDFnaFMvVWh2RU1hK2k3NmtxU1loT0h2N3NISzZzKzJuZjBRZVFyNUF6NUorWFpLWFNoOTR5a1R2YVIxR0ZYRnRudGZiS3dTOTg5UnFBV0VHOHhTZXJKSzJiajdKOVVXa0IwYUt4Q2FhRzkvTDlma0hXNkcyOStQM25HSGJUNG5BVW5UYW9UZFRFdHFaTHo1TnUyL0VBMFFxbndHSTJtcTlsbEJTZ0Y0YVp1RlV6TW55Q0F1bVNZb0hoaDd0VUxiU1VhMlJodk1jR094dHMrTFhRTm5aZGVRaVpOd2JGSDlzR3BXZWo1bFVGb0ZVdmFScDVjaWV0clBORmdhOHVmS3NISzE2VkV0VzdyQTFFVGFvUEZHTGFCazlhU0lFZXRqZ1BmZmw1NnZlcy9laFdwOEJicFNRZmdMZG1vOFpXRmNFajY0SDVvTXBnM05oV2FLYXN3WXRaTWJGa0JLc2kvcHpVc1VKeUdXdkxocGR1RDdTMHZPQ0cyRUxCekRTUjdTZzBKeFNLb0RMUlQxZEMrYlpzczR6bjZ4Q3VvejF0WWRjMEs2Q1NOVGptc1JRcHlQNHZxUGtWQi8xZ0J4Lzd4TUpLZGFhZ2txVEZTcDEyWDlRUmhrSXlIdWVKVGtaSlpHcHJEa1lmM0lkT1J4c29QWEVGa1pnak0rbUsxb0xKa1M1YXVZWm9iQ1JDWjJIQ0Qrd2tPZVN3S3dQTVR0SDR0c2F3QTlYMWhPNTVxU1kreE5BMkZRZ1F2M1FZLzNVS2hBS0hqVzhGWkV0V1ZjVjJ3MUUvUktQWjBmQU5OR3k3Q3hxU0dWeDdiajcyVEpWejQwUTB3MGdScXdlYjlrTmRzY251V2kwVE9STjk3ZWlrMGNWRWVMdEYzZEN3VS9OQ3JTcDZRbG8xaDhwbHhISHY4SUFZdTdrTFBsVHZndVJSbTFXcW4zNGZsY2hVT1ViaEtrVlF6VituN0NtZUxLRndwVDBHdDVybUlBYlp2MUpkVnBvZ2lsVnExNmhjRGFUVmtkWjgyT3dvbFAwcjJWUVFDNkxpTFpTZ2lYUFduNnVUZE9xUmlZMjByY01FMWE2Q0xNdmIrM1Q1VXg4dWtJZ1A3TEtYR0RVQ3dpaGIwOWdSYTNqTUFzemtKMXdwc3ROUUdmbEJ5eWQ3MnlCUEhjZnhuaDdENjhqYjBYTElWanFYVEFxZ0dTWXhUMFNHOHhmSVRoN2ZsT0VTaHFaeWZKdDZHYWVGTzBlZEJHVXV0NnBlV2xZU1dTUE5NVEdGS092SitPQ1RycGRsSm1Hb1NaWlZDbGpvdFlwVzhXaTZvamlYQzhNQTdwYlFLcHdhWFZKcHF0R0RkVGgvN2YzWWMweFNtREY0OVFJSkNBRktjcXNaNVAxVkRhYVNFR3RsRXRuRk94U2FWcTVOVzBPVjMySGxpNmF3WFhlU0hUbUJ3YXhxdHExZkE5dUtjRlRpMXBwQVYrWnFzeW9kZG83Q1h0RTNkSm51cEk2YlNPRk9jcUNjSGljT2U4T2ppK0RUenZvd0FKWWVTbVJxQnV6U1hUaFBzYWpCNTI0a3pSb1VDREZKZmZwVVBJYVdnbUVrSzhNd2dwQW1yQzJSbGcwdzI2QVJHbmVhY1lsaWF1SmFCSEdKSlVxOFRjM0FkbnlSVlIvTmdFcDd0b1Q1cnlTNjliUUk1M2hvUFBpdFZwUXFXVWtvT1Y4dEFSdExpbE1nVzYxWlFXZWdGaVFPbDRXQXhEYXhpNjJYeWtxdkVHSzFVenlMN0hmREFaNmNjaXhZS2UrM2hJWEhtZVh3S284c0tVRzZ2am92REtBc1o3VG1OaFUvMnkweW84bVI4YmE1S29VR2NWQytoYjlFcVYrZUNTVFhpVU5nTDBvTzhxZ3diT2Z5cHpNbXpuYjdtd2JVVnhCTUNUcjVNWWE3Z25MaE1WRFIzR3FnUzBHcFlNc0JDbjh4b1VNbzExRWx0QnhnSlVnZ01Ic1dwRlIrSlpCMytESm1EVkpPc2pGZGtuc0NUWXdtSGJiMGxxK3ZsemRnbklDQnI4L3d3RDFvc1NWcVlGYnBBQ3hnMG1Oa3ljSHhjT2JLc0FFMlJzQjBkVlY0dVRmbklaQlRZVGlOVUlNK1NiQlI3cVpWSkYwMThhbHZHRDRGS0ZoVEVDeTYrWnJsVXd6TXJjaUVFUnlWWWV1MnFSWnFaUURGVnV0WmZyUFlqd0RqRXlXWlZOQXJKV2RJODI0WGpoVjYwb2l3ay9UVzZ2OE9xazYrMmF2QzUxbGJURjNaK2hBajNRWlZRM1lZMDBuSkVwVVE4ZEdxU0Y0dDRVdnhHQmtsQmFVcmc2Smk2ZjFrNVJia1VjR3djZXc0Y3d3bWtndGd6aUFGSjdjNVhrTXlwRkptU0hiVThlWERJSjRlRlFlTG5Ld2g2bitWYW1sU3VadWRPSlB0Q2s1TmNxOWhTaGZPQk1FR2l6M1pSSnVONXE0eCtkOG9reFhWeVlHejZ1ZUxJOTZUZVp4cmM0UHZza0drRXZzcy84eTRPZWE5eWpNWjRNaXhXSlMxTWs2VE5DMmtsbXNtbmxUd3dMd3RsTFV4RDBnZnhQSGwwREh1V0ZhQnhNb3V6UmFYeXdnRThEZDJYRTlJQTFTYWJsVzBoTlppTW9UaFJDV0pEenorRlora3YxT3pJbjZYRDVNR3VPMUpLR0FJSmtCZkVzOEx4NUhFRzF0YWNmblBMTGt6eWdoWDJUQjF2OFh2VVBRTEZJRUI5OG93ZHl3NWp5NVBITzRrbUx6aU95RFFqYVVvZW1KY0dtTXdqVjlnVHowL05scFR5c2dLVXRTQS9vT21wbDlUSFVBaWxTVFR5OEJwMHIwb2hoWTdDckVlcVQ1R3JYNExhQVA0MFhTWWIyQWtpRmVnNzRUVlM0a2krVklGRVFrRjUwc0hCNTJheDkra3BETzhyVTVqRDZsa0p3QThsMmlVMWJPakJvM1BxTldjQmxOTjNYOUxJNHhieUhtSkV1MEU4TUM5aDRranlpSG5pK1dYMThWVDhuQllzbklPYUltS3d2VW5nbWYzcXcvc1B3SW5uU0Nya3BOQ0VrbU5SbmNnajEwVTJNSmxCblZOMGZ2alpHVG83VkI0N1JaeTNWUlhwMFRJNGJMK1M1R2loNXVQUU0wVzgvUHdNNGkxQTM2WUVKcWRLMlAyelBQTEg2a2hTMk1KVm9sSkZrMlRHeVB2aEIwMVpCS2dpL0FYZ1R0VjlMOWh4WVZxOVZBWk5SSHVGZUdCZStEUG1qWGxrWHA5NVdYMlllVjlXZ0VxMVM2cnZ4Q3lPUHZLVTlnT1lRbFo4QkxsNFFRNmtnb1JTZ2RtWnhNd294Wkc2SnUzYW9xU2UzTWwrMFlSYUZBK3hBOHJ4dkVjU3lpcVZjTUxJL2dwMjc4cWpXSzloOVNVWkRLNXVRVnRMTXpidGFFR21XOFdSUS9QWXUydU9BSEVsK0VHT25TUk9jSlpPbGo2Y0FVeFAwc1kwTXExbVo0Sm9MOHNxd01DTWhOVXN4T01qVDJzL0pKNkg0akVzUDBCOUthWEF3MCtxOXhXSGdYUXlsRUtPQXlrOHFRNVBvTFZmZzVOcFF2VkVLY2lyczBNaXdUdTVCL2FzenJzZk5JbHBVcTFKUThIY2lJMFhuNXpINklreU90YVoySFFaQVpoS29VNmhSTDFDQzhRMnNHSk5NOWJ2eU1LTHU5ajM0aHlPN0M1RHRRWFplVVZLdWt2T2t5K2NVNHdaMGtJME1XMU1JOVBLTkZlSFQ4aVNGV2xuaVNmbWpYbjh2ejlYNzJXZWZiRU1BZVhXbWhQWU02UTk5TkJQdFZkaXpWNVlCeFJLcVV1MnREQ08zTHBXVEpPcnIvSXVpUnVxWnZma0h0aFBpN3pYTk1XYm91cmhwV2RMZU9WSUFXWUhzT255SExvNnM3REtHcXlxdDdBdzJGWldpNlNpRWNmNnpTMFkySkpBdmxiREM4L09ZK1JBRmRtNEptMDRTK25yeC9SRFdqeW9aRU9ZeHR5NkZxSjVRdEllcU9nZ3JSdHI4Y0E4TXEvTTg3bHU1L1R3UlhOR09QYzlhdnpYOGpqRmlFbGZKZ0trUjBoU1docVpSbk8yaE5qYVFVd2ZMY0F3TmJsWjdZZDJhMmxYRkY4K29HVDhpSVVYWGl5Z2JqcFl1ejJObGF1eVVoSnJaVm9NQ3lIUTBtdkprU0xBYWtXQmJEcUZUZHR6YUZtbDRlaDRHYS9zTGFNMkwyU2NLdnpYajhtME1FM1RRd1hFMWd3U3JXVkpNOVBPUERBdnpCUHpkdDhQakx0YU1zTEJlV2puREZCMmpqcWJCVjQ0b3QxNzd5UEdmck1sakRkRFZjVXB2OHFoUStoYVk4SnU2a05oWkk3Q0RnYlZlNzBOWlFmSVZWQWwwTnBXRzFpL0tRc1RNZFJLUWlZUGhPZWQwYW5peisycUM3dXNvcnNqalFzdVNjTlBrNk5USmE5WmFvM1hYczgwTUMzRjRUbEpXOWRhVTlMS05NdlAvU0FjaXhOUGYvTjlZLzhMaDdXL1lWN1B4MS9EUHFkSDh0bitGQ29LMjVVYnZ2OW5wUWRXOW5zWUhkZUN3N0ZzTnlrT2pHY01xS3N1dzhnVFE4Z3BFMGkwWitIVWZGa1R0SFJ4Y0wyUmJnVFpIc2RHV0FEOTVoYWFSbUdMcHROaWNFU3dKNkFvaXlmMENTZ2pxYUkyVlVSQmRLSC92V3ZnSDMwRzlaSVRiUC94VStib21yNGVEOGVHTlh6d2pzekhGQlVQNWxLTGdDN2JJL25NWUhOYW9GUlZIdnpjWHlYL2twL3QxTVlQYlhLREdJL3p0cFY4RGQ2eDNlaS9haFVxeVJYazdNeks2ajdQV2JSbmpUalZzY1NDblR5bG1qeUxMaXNpTEpaWVh6NHcwZyt6U05KdTBwZzZqVDAzUEN0cDZidHF0YVNOYVdSYUEvc3YwSmJ4T1dlUHozODkrWmZGbXZJZ3FWdWNyNzlWZjg0UE1MSjJIZXowOGVPOXhoL2M4YTNrcm5qS1JWd0xKNU1tVVlzblVKa3N3RG4wREhwM0RzTHIzb3laWXdXb1doRDBTMUJsSE9yTGNHVUJIUGN0OUlYN0xkNUxIdFdnTWFkcGJKOW82TjI1QWk3UnhMUXhqUkp3b3BscGo2ZGQzSEZQOGlubWlYazduMDhWT3kvUG5PZlZ1NzdQYy83bjQvSGIvc2VEaVptMkRsZDZqOUttaHFCVzUrcW9QUGRqOUczT0lYbnhsWmdlZGVCVWl6Sm5MdHpGOU9FdnRVdnBGSElNSG10NnpFRnkyNVhvSVJxWUZxYXBBU2JUeW5YRVRQdTNIa3JNM1B0WS9MWjF4TlA1a3N6ellrTmZzNUxVd0o3T2xkVWJ2L1daNHYrNWJtZGRHeDdWRjJ5dFBCRk5ObFVobzViYmVoR3FhTWZzaXdlQjZSRmtPblM2UGk1dFh2RFl0bC9HS2lNN2FpaXljcjQ0UmZGSFd6OWF0bTFBRXRNbzduMVJwdllDbTdtb1RnZjZYRHk2Sys3OXE3L0kvblpUMnY4TzIwMy9GUHZpNzRvbmljbE5ad0oxcXFDeUd2N2NmWitkdit0WExySndmRlJmVXZvYWxKVzQ1SUJrMS9SQTY5Mkl3a1FWNVVNSG9CYm5rR3BWQ1FUZVJ3MU9yTDNoaHhxSVlGdE5OZGhHazBiSWsrUmxtNUJldXhHNW5pUzhzZjBvRG8xRFR4dkJDZ3lyNVhtWXdWNFgvN1RYeE85K3JlbnpGTDUrcmFQSmY4MnppZDZWZ01vTldmSnd4MmRWUG5yeTcrKytiZjdQM251eGhaRUpQYWdiVXhmZFk3ZGs4WDQzTXB1MndsYmJVTXRUM0RqNkt0eXBTWmhjNkpCUjZmdmtxUGpxUXBMOGRKc0Y4bkdBS29jYk5xd1NweEdKam81T0pQcFdJTkdhUnN5ZlFXbi9Idkt1NmYyTXVYQXp6dnJ3eG5WL3Q0TWY3NDdqOTc3UmRBZUIrSldlbGpQYnpYY1ZvQTFRSitaSVVqM2xENy82eWNLWGJucFBOVDZWcDdpdlNrQ3JpN1cyblBKeml4N2liU1pTcXkrQXF6YkJxcENIU3RKcXowekNtNStHWWdmUFJlWXp1ZnphMkJlWHV6dU5JajBPVGZoc1RGTTdZbTJkaU9XYVlTWXBmUExuVVJrNmdQcU1CVDJyMGJYYUFwaWVyeUNUOE5IWjV1RTdQMHRhdC8rdjNKMnFJdjc4RjRINXJnUzBBU28vTjdkUVZXNzU3SytYLzhNZmZMRFV6U3BzYkZiRDBxZWtTbUE5RjI1WnlNY0JwbGF1cFAvYUtSYU5TVTlWZURhcFlBdkN0Z2hBSjl3NzVWSmdMaG5odjgzQ3p3bmtlcVVZVjdYRGlORUtxRXlqY3V5WWZJeWZudVpxQ0gwQnlNYngwTjRXVDU1OStTOFBaeWErOWtqbWozSkovNTZ6ZlU3dXV4TFFoazJ0V0FwR1pyUnJmMjFML1UvdnVLRjR4WVg5RGtiektzcVdWTXRMS0E5bTJxdDU4c21uQnA4dGFtdUhsczBSWUltZ1pCVHFhMFdVRC9WeThwMTBLWjhmdFdhbTRaU0NKN2hxQ1czaFQ0b3NoRmowYzlyMDBkZnE0NlVSQTE5NUtQdmtEL2JFLzZTdnpmdGgyaFNudFprUm9DZlpPQ2JwMVdsOVZYdkcremUzWGx2Nm5adDNWcG95Q1dDVWJDMC9WZVRrUjhVRWxVUmhRc0FPa3Y0TlcvbWFCeUNIdGxXV0JzV0NNNnJLU2RYMmpiQXFwZ3Ywa1RvdDFZRnY3MHJOZi9OSG1mdW5pOXBkSzlyZElVWEJHMG9jdktzQlhTcXRzMlhWbUNtcEg3bGluZlY3djNObDVlcjNiYXdaYVhLTVRwQm56SkxjT0FUMnl3bGJBdUZNa2VSMWtpcXRrS1AwK1A2RWMvL1BVejk1OHBCNWQxdkcvNGVXdE8rY3JWUkdnSjVHV25tV3grZTFIbktZYnJoeWZmMm02N2ZVTHIxaWJUM1IxMHplS1RrNHN4VExXbzRTSGxOOG83d0U4bWxTMk5KQ01TU2ZZeG9sNSt6bmgrTzFSL1lrbnFYWDcyaUtlTENuMlJ2REc1VEtDTkF6cGJNVVdldEZrcW10Y0QzbG1rMjk5blU3MTlRdjNiN0NHdGpRN1NnZFdTR2RLbjc0Q0ovajVVUFdidU9aRzB2VU10K0h2OGVoUjRMc1pzd0lFdXRUUlFVSEp3engvS3ZtOEs0ajhlZGVIb3Q5WDlmRTQxMDU3MVZkZmV1YjFCR2d2OEMremxYVjF2bUt1aVdYOEhldTduUXZXZHRwcjF2ZDRmUU10TGhOWkhlVkxJVVhyRHFOOEE5RE5ITElERFNyNm1KTnhYUkpFOE96K3Z6UWxERitlREoyZUdoU2Y3WlFVM2MxcGZ5OXpVay9yN3dGaVl3QWZaUGdzblNWNm1vSDlRSDZkVlVtN3ErbWNLS1hnTzZnM2tTcU5FV1NGcE9uR0h6RkpvZXFXcWlxOHdUY0ZMMk8wWFZEeFAxUnV1NDQ5V2xkdzl1eVN4TDl1Y216VFBDejlEVWwvU251OU5aekxnWC9OVnRKRkdwNnl2R1VKQmZnQ1NGNTVDMU9sOElleTlCRk5hYUpTaW91YXJtays3cDcvbk52Yjd1RVJ1M2N0dWhQTmtlQVJpMENOR29Sb0ZHTEFJMWFCR2dFYU5RaVFLTVdBUnExQ05Db1JZQkdnRVl0QWpScUVhQlJpd0NOV2dSb0JHalVJa0NqRmdFYXRRalFxRVdBUm9CRzdaOUwrLzhDREFEYUtLWGhRdmxxV0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUlJQ0FZQUFBQ1liaHgxQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTXpnMFJqZzRNVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJNemcwUmpnNE1qUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWXpPRFJHT0RkR05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZek9EUkdPRGd3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNmU3Zzh3QUFEMlJKUkVGVWVOcnMzYjJ2SldkOXdQSG5lZWJjM1NqZ2hqaUtMQllxQTFVcVRJK3BFZ2taS1k0QUUxZUFaQU9HSW1rUUlpNUNJdjRBcjR0RUtGVVNMeEtLb2tpcGdvQWFTRWNEdUdPQkJsZThLSHZ2bVhueWUyYWVPV2ZPN3RYYUVvaDdOL3A4N05tWjgzTFBXbEI4NzIvZVR2N3EwMytTVW03LzVsUmlYWEtzWTJPSTdTSFd1MUxTTUxSMVRtZkh4MlhJK1FQeCt0UHgxRlB4TSsrTjlUdFR6bThyS2QxTVRVNEF3UDNxc3BwU3VwZHEvZlZVMDArblduOFU2KytQVS8zMldPdjN4ckZPKzJsS0YvSGtQcFo0bk5yanNXM0h6MCt4L3B2Ly90bkp4Kzd1ajNtTCtCTHlXSVlXOFpMT1d0Q0gwb0orSzlhZmk5ZitLcFozTGVHUG4rNC8yeHFlczVZRHdKczF2ZFowTTlZM0krYnZpTzAvalpBL095MEIvOGwrcVArNkgvT3J1Nm5lM1k4UjlseFRpZDhBOWxIejNLSit5V2Z1RGpIdmNUNkV2QVU4bGh2TDloL2RHTXJmUmRnL0hVRy9zZXZSYis5ZmZ4R1lROTZqZnFEc0FQREFkSDZNZW0xaFR4SDFXRkpNMzdWTjRlK0txSDh4Z3Y3WEYyUDkybm5KTHc5bGVxT01yYmxUeWhINHkvSzZPMHptUGVaTHlIT0thaS9MVUQ0YXk2dXgvZmk4eXoxZVg0TisyRVhmeC9JaTVBRHdsc00rOWUwbDZEM3FmVGY3ZnNnM2RtUDk3TERQSDQzbXZsVEs5UFhTOTRMbjdXOEd4NkFmZDdIUE1ZK1ovV2FzYis2R1hVVDhsWnU3OHVJYzl2NzZmRHk5SDJjdmZVSmZkclVmOTdYck9RQzhoVUc5OWlrOXlqbXRZVzh4YjVQNjJIbzd0VVkvSGxHL0U4MzlZRW41ODlIWWZjclRKVUZmajVuUHU5Wjd6TStHUDR5UWZ6MldEOTljcHZRbDl1Mjl3N3FydmNkODNjMSsrSzFCemdIZ3phTmVsN0RYZk5qOVBzWDJWR29hV3REYmNmTTJQSTlUNzIxNk1aWmJrZG1QeGR0LzgwRFEyOW5zNjNUZUp2RTJtVWZFWC91RE9lYkQ4bHpiemQ3UGREODVFUzR0Njdubm00NkxPZ0E4UE9ici91emF4L1hhWXQ1ZWlYV0pKNGY1UkxqYW01dlQ4ay82Y0x6MXRYamJzNmxONmlkQjM1d0UxNCtiMzQ2Z1A5TmlIbEZQWjd2bG1IbzcyNzJVKzA2Q1crTjlFbk1BNEdIeTVpajRQQkMzWGUrNUxzL0hkbTY3MytjOTRmRmMyNzJleStFOHRYanBtZmpqZG15K3VQM00wcTRyYjdGdVo3UGZHTXJISXVZdjNPd254SjF0ZHJmUFo3L256Y2x3S1IrT20rZDBYQUNBdHhMMVRUdjdJZXpTcnp3YmVuTVBlOUNIM3VSNVQvcThmdUUvUHZHZTUwNkNQdlJqNS8zU3ROdjl6UFo1Ti90eS9mbm1KTGh5ZWNnQmdOOCs3aWRoTDhzbDVYUFlOK2U1M1JnT1Y2SGQvdmVQUC9uSG13bDl1UlF0WHZqN2RtbmFlamI3ZWxPWjR4bnRwN3ZYaFJ3QWZ2ZGhYemUyOTRscExaNmJ2QjRpTC9QbDVlK0k3YThjZ242MjNOTDEzVkgrVDUydE41UXB4eFBnanBlbWlUa0FYRW5VKzNDOTNvWjl2V2RNTEorTUtmM2RmVUp2eFMrZmllVnN2Vzk3V3c1VGVSRnpBTGpLcUxjV0grN3EyanZkKzMzV0dqNEh2WDNSU2hULytkMTYvL1orMTdqMVd2TzgrV1F4QjRDcmlQcnhycTd6blYzWFc3VXZ5L1BmK1BpVFpmN1d0SGh3YS8xU2xuVTMrM0p2OXVNMTVXSU9BRmNUOVp5T1hUNThLK3J4eTlSdXRaYVhlUENoOVdZeDJ6dkFsWFI2QnpnQTRJcWl2azdwMjI5SFhidTloUDNwdG43L2NMaU5henJlempXNzR4c0FYSit3SDcvWmROdnMzdkNuSXVqNWZkdHZUVHU1dHR4MERnRFhaa3BmVitzeDlYTDhHdlAzdFFuOWlYVWlYeTlvVC9uMDN1d0F3RFVJK3lXdDdoUDdFeVcySGx1Ly9yU1l5Z0hna1pqV1M5cCs0Mmwrck4xWjdrYStMK0xPYkFlQWF4anlkSHArVys1VGUydDVPUWwzdnZ3SEFJRHJFUFY4TXFWdkcxNTBHd0FlL2ZHOVBERExBd0NQVE1qVFlVSUhBQjU1Z2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdEL2Y0SmUvWThCQUkrVXVnMjZrQVBBSXgvMmNoTDRldHl1U2c4QTE2emI5VGlZMTlNaHZVd3BuZGQ2dXNmOTVBY0FnT3N3aEQ4d2NMZXQxdkRXOGhKYnYxeWVxTzJKa3lrZEFMaUdZVjhpUHJkN2VWeC9XYWFhZmo0L1VYdk0rN2hlVlIwQXJsZk1MMm4xMUFieWFIa0V2ZjV3T2p5eGxQNnlZK29Bd05WTzVldXFMWWR1THczL1ladlEvMmRjNnQ2ZjdDTjhkV0ljQUZ5ZnFQYzIzOWZzM3ZEdmwzR3EzNTVpcXoweDl0clBFL3VhYzFNNkFGejVkRDVQNWFrM3VtNjYzUm9lTFMveDRMdjdxZDRkbHlmbUY5WVJmanVsaXpvQVhFSE1UNmJ6dnF1OU43c3RjOE5yL1Y0Wnh6ckZnMy9aTDArbWZUMmQxaSs3MWcwQStQM0UvRENkYi9yY1duM29kalQ4TCsrOFBwWDlOS1g5T0wwYXkzbmJqc0RQeXpLcHg0ZE1mVW9YZFFDNGdwalh1Y1h6cnZhcEhqcmQrMzNlR3Q3ZVdpN2l4Vmp1WG96MWE3R2tpM0ZxaitmcXI3dmZweXJxQUhBVk1aODJ1OW4zUzdPWFZzL05ydi84RjNkZXZ6c0hmUjdYNDRYemNYbzVSdlEzenZzYjkrMk5yZjUxTTYyTE9nRDhmbVBlRDRmUFRlNkRkMnYxM094eCt2TDZJKzBZZXEvOC9NSkw4WVlXOTNTdjE3Lzk4Q0hxVXovN2ZiMmdYZGdCNEhjUzhzUFo3UE9kVzN0emU4ejN2ZFgzbGdFODlWWi80ZGs3cjcreGZzYndaMDgrbG5KT3NlUzIva0ZKK1ltVTAxUHhhUG5tbHJ5OHNUMnVlZjJ4ZlBKOHlzZi9xT3ovRndCNDY5UDRaaUkvM0p0OVB2a3R6V2V4dDhsOEhyejNTOGovZDFuLzAwZis3Y2RmM1g3RWJqN2xQZDVZOGhSTCsvcTEvSVdvOGhPeCtVeUw4M0ovOTVMcU1LVmRGTDNFbTRiNUY0RDV2YkZlUnZXY2ovK0JXZFlCNENFeDMzekJTajJ1cDM1NTJyZzVacjd2ay9uRkhQTXgzZHRQL3huTDUrLy96RjM3RFNESEQrUjRjMTRtN1BQNDQ3blkvRWE4OU9mckx2YXppUHJVWWg0MW42TGVaVjdxTXRsdmh2YmxrUjN4QVBCbVVkL2VOR2E5QTl6aDhyVHhlQUxjZkNoOFB5Ly9GY3R6OS9iaitRTkJuMCtCVDJ1TTU3cTM1MzhUbXgrSjVaWDR6QmZXZy9MVFVOSVFVL291TDVQNkllcHAyV1cvbEwyYXp3SGdvVEUvYnF6Zm1IWnlOdnNhOU9NSmNHMzV4emFaUjh3djJzVCtZTkRyNFg1eS9ZOHlYM3dlVDEzRW55L0did25mR2FmNnlyZ3JqN2UvWURlVnRHdVQrcnpyUFMrNzN1ZVkxK1dZZTUvV0FZQ0hGMzM5MnZMMURxM3paSDY0WWN4eTdEeEMvb3QyQWx3c3IvV3d6ODlmRXZUK2EwRTVScjB1cy9wNnV2eWQrUEJ2eHZLVi9aQS91UnZxalczUVN3LzY0Y1M2N2FjTE93QmNNcG9mZDdOdnZnTDFOT2pqZE42dU00K1EvMjFNNmhIMTlmcno1ZksxQjRLK1hPZVdUNksrL0NWVEgvMUwrL0JmeFBLWml6SC9Rd1Q5cFFqNjg3RzhzMnlpdnNZOFp4MEhnRGZyZXIzdjJQbm1STGlmenJka0g2ZmIrL25HYi8wczkzNGQrcjdmdy8yQm9NLzc3L01tNm5uN0YrUVVQVS83V0xjRDgyY2wzOTJOOVl2RGtMOFVJZjlBVE9rZmlwaS9QeWIwOThiNlZ0VDg3ZkgyTTlNNUFEeDhTby81K1NKaSs2dkk2OTBZb0g4MGY1MzVWTC9Wdm1obCtaNlY0NTFiMTF1OXpsL0kwczlydTkvL0NUQUF3Y0k4YUdVRHBZb0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WGheW6lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWZRQUFBQnNDQVlBQUFDY2xFQVFBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJPVFJDTlRWRVF6TkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk9UUkNOVFZFUkROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZNU5FSTFOVVJCTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalk1TkVJMU5VUkNNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtGSVdNd2dBQUovRkpSRUZVZU5yc25UMnNOTXRaNTZ1cWUyYk9lZC83WWhiZkRTd3VCQnZBSmtUWUVkSjZzVVN3a3VVTmtJeXN0WXpFbCszRkVHeUVWcnNFR0VTS1pEdFlaQ0Zrc1RKSUpDQ1JXWUEzQkpOdEF1bGVSR0l2K043MzQ1eVo2U3JxZWFxcXU3cTdxcnU2WitaODNmL2ZHcDg1ODlIVE0rZTk4NnYvVTgrSC9PSW5mMFlJS1lVVVJsUlN1SXNTb3BaME1XS2o2Q0w0c20ydkcyWHYvMWl0eEU4cktUNWFTZk5qOXVjUDI2Yzh0ejkzd2hnaFRDUDQ1eG9wSmFTcTgvZmI4NzJFVEhNUVF1dDFUNmJQa000NW5OdlM5NTU4dkxFMzYvV2ZJd1JCRVBUZ1pOcXZmWGxycjc5cWpQaEhiY1EvTkVaKzUyakVYeDJOL051REZ2cWdwZGpiQy8wODJBZlN6Nk85Mk1jTCt6anhlMy8ycmQ1eGF6bzBJU2pBdkZZQjVBN2cyMHFJSGYxMHY3OWpMNzlxNy9zdm0wcjhTT1doTC8xekpYUE5IWS9QZURVYzZZUzB2NUlDK0FVQVI5Q1VCTStWNTB3d1Y2Wi9ib3VoUHZqRm5IQStFQVJCMEFPR3VoVGFtSjM5cHQ5Wm1QK1F2ZnlFQmZyUEhoMjQvNSs5L08rOUZsL2JhL1B1M29OOWIxRklGd3Q3aTZ1eHNhMlpuZDZkMTlaZWJ6eThDZUk3Z25sbDZQcUhyeXJ6V3hibXYyVHYyMXFZTS9DdE0rZm5LYnJZWXlnNW9MSVdLOTFsSXlTRkNWUjFBc0J6aXdDWlBwNXU3SzNOQ2U2Y2Zwb0Y3bnY2VDgzT1hOOER6T1BGRXlJREVBUkJGM0huenJRNVRHcERjTGZrczkrNUZ1cldmWnNmc1VEL0RRdngvM2FyNWRkdkd2R2JHeTIrVnpXQnQyUENNZEFka0ExWmRiR1JCRy9CSUxjQUY5Y1ZRLzNUVjhwOHpmNytkbkRzUHV6T0J3N1BwNE1Ib0VzUEJvcTY4MW11NFFxZE9VRjlFYlJMWEh6bTlrWVRSbGVlcXhMOTFZdzVDZXJHTGk0WTV0VjlnTnljdUJpQklBaUNTc0d1bWV2R0E1MWR1emdZQ3JOYjNtcTV0WmYvV2t2NTZkdEdmcW1TOGsrcWhyYklaUkovTmNGNEk0VjM1ZzdvMTViU0Z1YTF2WHpsdWpaZklMQno2TDF5MEE5aGVaVUt0ZE4xNVYyd3NyNjlXYmtIckxRRnBabUI5L2xnWTNqMXNlSjQ1TTdwQXhrOTEweTkyRFRNNVIzQ1BBZHlBQjJDSU9qeVR0MTB3ZXpnZ2JmMi93NUtjbWg5bzRtNTh1MWFxVDlXUi9FZkxXMSt6VDdzbUhUb25Qeld3dHdJNjhZSjZNK2UxZUpQbmxYbWt4Ym8xcTI3MEh2WVZ3K3VQSVRiVzVBVDNJWmhkMGxRUDY0QWplRkZnb3RsTDMxdTlJbkpFc2JhOVJHOWxsb09MMW5WTHBJd0F0OFVLR1VhbEViYjg5Q3J6dU0wbUFQb0VBUkI5d0gxOEJYTGFXZkdjUGk5SVpOTmUrbGtvTzMzTkxQV1lsOEorUVVsMVRzV0lUOW5ILzU2QlBSSytnejJTbkNJM1VLOGZxYjBONS9YOHBQWEZIcXYzZTBodzczeURqMkUySlVIUWV2S2V3eDFLZlBHeUJYSlhZMTlkak9kMFQ2WDdDNExIeC8yejVjbXo5dkZocXdyOTc3bEhBRE4rRnhNUDRIT21HUC9XQmNGK1hEQllmS2ZJYUFPUVJCMEdZY3VRMnE2YytjRWRkb0NwK1M0VUhWR09lSnNudGxBNjAvYTM3NXBuL1N6OUxDK1E0L2RlY1dYcjE1WCtsTlg5aURQckgyL3NrZDA3dHh3QmwyOGJ4Nis3NldTQ1diS0NPcVZDNzJmd3AwU2dKL3cwWm9WeDVaMW5WZzA1TXJXRXNsNDBqdDFEM041SnpCWEU2c2ZrLzlEQU9vUUJFR1hnVG9uUW91MllveGNPcGVTRTh4Tmx3VFgyVEQ5S1NQVVYrM1ZMOFRIVTJIdm5HR3V6TTlkMStiejVNaXZsUlk3ZWJTZzE2NThUYm1TTnBjTTF5WEJFY3psNE1WR1ZLSnM5UldoYzk1UEZxT0RGeTRHNUpJWFdnZEd6c0tYRTZ1UnNwQ0MwY2ZMQTFPNjdZODFueVVFUVJCMGdhL2wrQkp0WVN2ZkF5WXdkOHNKNnFaTlZyOTIxei8vaHovL0h6N1RCN3IwOWViS2ZIam4zSGx3Nmhib2xERFgrRkM3QzdlM0lKZCt6eng1ZWtPUVNMZlh2SnpvV2Rmbzl1dnpsNUxIOE9OTXRIQlk4b2ZnOXlQRjVJckR2M2VSKzR6SW1UZDNBWE1WWWpVemF3czVFeTZCSUFpQ0xncjNDT3loTkp5UzBRZVJkRUdzSm1aLy9YTWYvN2NwaC83Ymx2cHY3L3lUUE9URlJqUkNtV1ByeXFYL1B5a0xOcWpqeDVDYlZRdGQrZ0IwUTJDZkxlaXhGS2owUHBLZDdPVDg1eEE5MWpuekM5YWE4NzhNdFJER2dEb0VRZEI5Z3IzMWc2SkxRQTlRRDJEZmNRSzcrU0VMOVMrM2FQTGg5QisxZC83aXR1c0l4MCt1ZkdtYW9wSXVDeDhwYzEvNXNzQ1ppdWwycmpsWjkzeCtpUGVQdjl5ZGIwUmluMkYrY1JPOWg1UGF6QmE3Y2pXSUlwU3lHK0NHSUFoNlNGQlhQa3JlZ1YwRXVQK0NkZWsvR2p2MEw5ckx4dlZ0OTluc1NyUUhZRzVSU1pXSDZ5ek1jODZWMjZNdWMrbnNZdWVERktzdjA4ZFB1Zk1xNm1BM3hiOEp0MDZ2cVpzTC9VdVF2aGUrQXFnaENJS2VDTlNEd2E1VTE5ek44M3RERFBkQVo2aC90aDNDNHAxNTdXMSt6R2pKSGN5YUZUQWZ1TnRGUkRjVEVEK0RGb2JiWmIxTlJ3dEszWHB6WEZlWHY4Q1ZTNStBV0JUVldPclNFWGFISUFpNmM2Z0w0ZWV0ZUVadnBJbkIvdG5mLzl6SGxiSjNmc3orOGs3dFkvU1Y2cnEvcWJqN1crQWZ3VWpyQXBpbkV1UXlEbmZXcFd0eGlmVHNwY2x3bEFnWG5HOFdsbE5RcDNwM0NyVmZRdDZWejBOOFNlaGRBT29RQkVFUEFlb1JrME45T25kdWRaMWUzeUdXVTZlNFQ5USt0QjdDN0NGZUg5djlIZ2d0bEdRb2c4ckNQSDhUdVZ4enVDbHp4OXdQN3ppOUNGZ0xtQ1VaNWx3Z3VCM2NKUDBwbXZSN2pXOG1tQi8zRjNIbGJwR1I3dnBHNTJoSzNtT3lESDJpTmgyQ0lBaTZPNmo3ZGlBZG82VTM0SzZibk9YNFR5djd5MCsyVTlPb2tOMVBUVk55WnZRSk9VM0swRjRJOHdESEpRbHlacGdKTG1YL3N0YWhMOGd3cC9OMURYUVN5WDY1cEwwVzdQb3l6cHhkZWJYR1l1Ty9FQWlDb0VjSTlzQm5acldmbE9vWWJqNnE3QjAvSGg3UXRaYkx1L1BZT1k5cnFNdkN1UXcvcXVNdWJUWmovSnp4RXdIZVArYUNvVEYwbnJ6M0x5ZUJtQTUzMjgvcGVIdmVXbk5mMTgrTG9teXQrOXg1eVFYL2hNNFlGWUVnQ0lKV3dUeXVOSk1SdC8zbHg2MURGeDlSOFFqVTlza2w0WEJ5bm5zUHEzbVk5NXErdE81U0ZMN09jZXB0THI2WXBpbXVBYWZ6SEdlTjU5MTZ4UElMd0Z6NXNqazFBOWdTcU1PNFF4QUVQUzZ3TzU0b01TeHBjeXgvRVVBZUlzcUx6SmNPNFdRekMvT1JHRXlGTHphS0JKeVlKRmNhYnFmenE2Zk9VMmJoeVRBL1Y2MTVjT1ZUSGZja1F1OFFCRUZQSHVxaEVsejIrcnkvVUZLYTdYQnJXQzc5dXFkczhYaVB1QVRtTktLZFhYcmhYbm9MOUxzdFZ5TTMzRVlTSmtQK1VkTVlPallsd0oycjFsejZ6MGt0SFpKK0xwZU9zRHNFUWREOXUvUEVOM0s3WFc1WnpyQ0l4cDR1aG5tQUdJWEVDZXFGTUcrdmJiWkZZS0FHTUpObFprc2k3cVlwYXloRHJyamVwa0UyOWI3T1dXdE80WDZLRUNoMUlSZCt3bDQ2SnJCQkVBVGRHOVM3Nno0TXI3Z3VmSE1XdDhXaDl3aGtzcWcyWGFXaG1ZSkhBRWdLMGt2T1U1ZjFiNWYxTG1xZldqWjhoVUIrbHZJMHY1aVF2V1M4MGxqTTFOMW5jTlhHQU9ZUUJFRVBEUFNxdGV3YzBqMEQxSDJvZWNud0ZsbWE4VzdPTlMrOHBDNWJPV2M4dHlBWnd2eHdleVpYdnN0L0puTlFMdm5zRjV0MkE1QkRFQVE5VU1jdVJKZlU3c0c2c1pmcVpMZE9VT2NzOGdLWUwzSHBMcU4rN3EzTlhFTG0rZHlIdE5tVko4SlI4eFp1SEhNaXpEbnhiZU0raTVIN0wybXpXL295UzRCdmxwWDRRUkFFUWZjaU5RSUV1Y05xczN6VTZjQkpFOXhNcWtWc3hrR3lTNTlMK3FMajliTFQxOFRkelh6bWVmZ01aazI1ejJhM2k1Zml6bmZaMTFUT2xVL09qVDhsOUw1Z0w5MEE1QkFFUVk4VDZES3hyMTF0cDB1a1NxQitDRkNQSUpNRFRhaXZMZ0xWQ1NWclJYdm4yMFIzdS9STHNqTS9FZWJPbFY4TnhwMFdPUEd6dW5UalFCNFdUUUE1QkVIUUkzWG95WHRyRDdlVmJwMGF3aHh2Smxxc3lqRklaeUlEaS9hb0V5MWlaeFBXZVA5Nm0xOHd5TUg3WTVpdnJEV25SUXlGOXBONzlaZHc2Wm1JQlozL0tQb0JRUkFFUFM2Z1Q0Vm11YmVjQjl6aUdtZ3ZhanpERURiellDTHVrbE9kd2srcUovb1EzTG15TXRycm51bXB6b0NkcytYU2daQmh2ckp4RERlSjJWeDFuNnRjQ2VaRkxyMGJKbU1Dd0RYY09BUkIwQk4wNlBrR0lyUy8yeVpyTFlZNmhhWDMrZGVKdUNucmdyMzBrNGF6eUdsM25nejd5MlNrWUZXdE9YMldkdEhBRjdYV2lhOXo2UlFwWVpEckJtRjFDSUtncHczMG5QTUxDWFBCVlM0UHdaTXpkazVkenJKSmJTZGN1dCtiWHlOZVZFeUVsZFgydWlpem5XRytwdGFjRmd6Mk5iSzVDVkpNUjB2V3VIVDZ2RUlqSGQwZ3JBNUJFUFQwZ1Y0SUQ4cEl0MUJmNDlhNW5DMEdZYTdOYUx1UG5WRTJiRDVUc3Ria0lkemJWcGh3L3VaNFdMNmc4RTFpYU1FZ0Iva0k2eHU5ekR6UEQ3VGhMUWFFMVNFSWdwNjhscWV4QjQ3UUhyQ0ZFOWVHTDloSDVuMW40VnUrWmcvdUFPaG1ycHZDRXpvQmdpRTVUV1l5elAwNThJSmsvMmJoa2tseFhrQi9XaHYzbjgyZm9wbHc0ak9mQjdmSE5RWk9ISUlnNklQcDBLZmN1Y3p5a0pyUU1LeEt5czBHVU8vdnFTY096aU5MNnd5MC9EN3dFcGhQOUlMbjRTdHFlb3JaR3BpM3JqelpyRWZtWGJxYytGeFNXeUdVZUtpREcwZFlIWUlnQ0E1OWdmdnQ1cHBUaU55RnE1Zk0vbWFuVHU2Vjk1UFRHZW0wMzJ4dUVvRGljcmlEdmIrZVBMYyt6dzlwMEpFNzMxMG4zbS8wUG1qL2Z3bk1PZkV0M2lzM3N3NmJ6dGxrUDd1VWJUY3UyVEE0Y2dpQ0lBaEFMNFBVOUoydTA1dmlzYUdsMmQ5bWYyTmgrbXljMWQ1MnJYUEFUeWFnaFFWRjZSNTA1bkd1ajN5Vmg2Z0ZwcjR0aHprM2lkbnNDbXYzcCtMcnFRL01oZElaNHVjYXpRcEJFQVE5Q2FrUzZKVTRZSGU3Y2xuY3BRbHpGazZhblcva1lBZlBZK0NueEl1R3dtZ0FPZlBNSWtQdW51Y1hCUmFnK3ZaMVdRZzdsS09SMng5VkFjakZuL0d3Z1kwYnlicHZoOTlBRUFSQlVBL29YTTZVQkpZc2R1ZWpXd2hzVkFKVzBveUd3c1paQit5eTArVjJEUFhocU5aSmhXenZFY3lmZFZzSEJPVGhLRlNDZVFrODdmdFV0RERvTmFWWkh2b1lMU3lNRy9qaWh0MGNWamV4Z1NBSWdwNithb1pFbzRXaHZmQksrUkdxODN2bk9aZmFYcVdhOVYzbEc3Qk1aNnZ6L2RhcDU5dzROWnN4QjNWQ2k5WFVIbjI2ZDN4NGYvcjIxV3hYdVhZNkd0Zk5EOExubzJpNkZDVjc2YTZmK3RGdFd5QzVEWUlnQ0NvR2Vnc1NTalJyZkdKVzVlQXU1eHoyL0FRdjE0aW01cDd1VXc0ejdKTjNVSThqQkJVZngreGY5NTlEYzljTDNtUnFUNTlyNlRNUkJJYjVYSzI1VXE0UlRTODdmdUdlZU84Y0c1L2tka1NTR3dSQkVIUUMwQWNBTk5vSVEyVnBYTkpWTUNOOVluWTNPV3haUGVja3VDblgyMEg5K2RnMWswcy9xdDZpZ0RMUERZWDNKeExRdU4zcE1FT2RHOWZVcTJGT09RTHN5dWwxVGFwSHZTbDA2UzViSDBsdUVBUkIwRVdBM3RITmwwVVJ1SHkzczhXOTAyVUhmRTRZYXpZT3NCa1hPb1I2Vng1WDgwaFhvMi9FdWhNWUFEbFJkejRMYzNzdWlpSUljYWkrb05uTDZEM1NaMHI3NHBod0JrRVFCTjBKMERzQ3VTbWIxQkNHOTQzZG1OTjJQMzNDblEvaHludk9WeFhETXhlQ1o2aFRvdG4ydXY5c3Frc2ZkcWFqYzhzNWREb3ZQUWkzaDFENUVPWVVQWmlDT1QzdjZxMW9HOEtVUVQyWWNqOFloYmNldVB6c2lZWFY0MzhEMkRLQUlBaDZvRUNQdjZoNTlPYU4rd0lucDhvVHloWjJrSlVFeHhjdVllNlFkdHg4SDhFL09qWm5vdE5lK20yM2w2N2Z2QlRWOHg5TUxDeTYrM3RjRGdOWUl1aHdsN1ZEM3ZsektkN21hbUZVd0xlTGJkeFFGRjZrUEdiUXlZVVQzZ0IxQ0lLZ0J3ejBBZHpiaGk4TWRqVWVxRExUd3BUM29lM3oyQmtQOTVDcFJ0MjZlSFg5QTczTWVtWEIyZ3dmWDFvL0gyYVFENkNqYjE2bFE5OGNKYmppMGJIdUxac2t0TWNRTSsxa3QxVlQyUjRFdERQdGFKT2NOb0E2QkVIUW93VjYvSFhPTmVIdXA2U005TGFNcTRBaHRKOU4zZUFzQUVjdW1aenR6ZnRDV3FqM09MdDdacDMzKzh0NU5heG50OURScjcrZlRFampMSGlDZVJUT24yN1A2a0ZPb2Z2SGtPUW1mWG1pekFCOEN0YWwwUndJZ2lEb2NRRzlBN0IxcE1KZWJvNHVnWXpEMjZvZ1E5N05DZWNoS09TK0k3ZE1JV3Y5NWoxMjZ0M0RYWHZWOEZpQ3U3cCtNVDRkZ3I0L0ZqZTdxVGM5NE5EOW81STJqalRza3Z2c2lSUG41aS8wdnJuam5YbGdZMHBsTjczTzhUbzB6OG5iYlhPdTg0ZERoeUFJZXNSQWo5MFpBWk5DMlg3Zm04ZUhoc3p5WE90WWVoenRrZCs4N0pXM09hajNvZDJPVjgzTytwWWpTUGRnUG5pTnNGQklMUXo2blBJdW5RYTJjRW5jemYxbnF2ZmNkZ1R0aVphMi9jOEk0SVVnQ0FMUUMrRE85ZUsrcXhwM2FOdGVwY0hyZ1Nrb201eEhyTjUwczhndFFGdW8reEk2U1lsemVqK2JaYzhsYiszK3ZvZDV2TGZ0cDZPcDdYemlHMlhEaXpDcTlENGNhQ2doSEVLN2RkNG1BVzRJZ2lEbzZRT2RtOGJRMVF2ditjWkpkRlJLeG1OTG4yVmRNSmVvV1Fqcm0vZmJNalVIOWZlRWV2WWg5emo3Zkc2Q1F4Y0w5emdUblV2c0NMcjhPbDJqR3YzNnZiNHpwM0kwU3J5THU4WWxRT2pLN0pyaVNYSm5FWmNHK3FZK2NXbmVxT2Y3SFlKN2ZUTThDSUlnNkpKQTU3S3dTcmx1Ym15Z3FaMHFBVFFHMTNucnBnTVVBM0Jwc0ltYlVEWnc2NVJsZnYwaFRvd0xUVmc0L0g3elNxaXI1M3gvR0s4NmJBTnJmQ2llOXMwRHJIdjkyUW4wZlB3WHlkQzA4YU5LeWMxZmJHODgzcyttUmN4Y1Z6NlQvUVdDSUFqNndEdjBBSlkyZjhwQmhjUFVNbktBbExVZEo2dlI5Vk9uZnpFMEczYmRvVVRNRElhbXNGdTNEdHFCL0dWYkNtYWFIY09jbXIwMEwvLy9lT3lxa293OGJnYmpGdzl0NHhoYVJGeS81UnJrRE1CSXJWamJzYTduekZRUGJydjluUllqVmVlOGV3c0cweTBxTHVLeWtiQUdRUkQwTklFKzkvM1BDVzBoNU90YnNWS0oxckIxNlNraGFmdGNUcUlUUGlPZE10bWp1bmFHdDRXd09SNTVTQXZCM1lYS2xRdTFFK1RySGJ0Y2N1c2NnZzlaOXBIVDVwR3AzTEJtRTcwZjQzcXFIL2VURFdhS2VVbFJEMG9BbEFQM3pTQXRkOW56WlhKM0ljVFlJUWlDbmd6UWMxLzAvUTV4N290ZmtvT21VSGVBa1ErSDkxejVuSEUvdUJuZ2t1RHFaNDA3VURvUUd3dHhBalRWa0ZPWE9BSzNmdlhQUXRMckVEaU5XMWhVWE9wbVJQUHFYeGptRkY3dlpidjdCRGt1dDFzeTVXdzRKbmF6N1FhMVNOa1BwVDk2R0FMbUVBUkJUeHpvR1RkSE5lVXE4dkxVblMyKzM3dG5ZNW8rTTRhbFg1UkVSMjdmWGhxQ08wODR1M1lMQ2V2Z2xYMFIyaE52TE1pcjUvL0czMmZhNDBsZlIrN0M4VDd4alVMc2ZzSEJtZmZIMjJtSXR6WDBKb0wzbFZzMENKTjNzRk1kNVI2NDFrVUY0T0loQ0lLZUdOQnpYL2FSQ1BBdDVQMTkrdGdmakVKUThYdlpMZHk1Ny91dEg2N2lKcDZSTzZjd1BUbHdSWlBjak44Q3NJc0ZDc1hUN1FSZzNrZm5mdXEzK2FFd3RIY2ZONTRSUHZTdjBoK1JNYVZBZTF5Z00xUGpZT0hpSVFpQ1BzaEFOMks2cmFqay9XYTVxM3M5MjAxOWRGM1lJdEJ3RXhmdDk4TTVlYTUyV2V6Vk05Zms1WEJqZVY5elFodDFlcU5NZU5jUjdyMytBb0V6NjYvNzV6VWNNbU1ldy83Mm5TQWUvNVZBRUFRQjZFTE1qVlBOM3NOd3JmcytrZmUvSThCUTV2dit0ZDliOTRsb3RJL1BQNlhQaGovd0hqejFjUThRbHNPNjdoWFFlcW93LytBc1ZDQUlnZ0QwOHp2MExEUUg5ZC9EK214T21IdkxaWkZ6Zi9kclRwVGp4alAwMk1ZNmVMTnpiajRDbGFzeFAwYUhWY3ZHZzBLbHF3T1V4MEVRQkQwS29JZXM3cExIY1RLYTdwdGhPY1o3NnhLYlk5ZXJQUU9MMEVxMmc0ZDJKV3ZObnBQejJuMTVLbHVibWtmTzRmWjQ5cnFaZE9hdHcyOFhBdWRjRE53dkFNL3F6Z0Z6Q0lLZ2h3VjA1Mmc5YlBoTE91b2NOL3pTamdIdkg5czY3Y0l2K0tsSGNSMDVnZFR2ZWV2Yk4rNDFHTjZTaytHb1Z0MTF1bk1OYzlUdWhTdWRDd05WYmwvM0QwcUxBTTYrWDRCY2hybm9Xck9XdUZXcDJuUHFSUVh1R254bmZ6MWt1VU1RQk4wLzBLazBURm5JU2VlZ2piWndwSkpxYVgvS0RHcnZDa0RlL1hKeW0yL2ZHdHE0MHY1NHFDK25zalY5KzVvN3J4bFRPYWhiUUZOaUhKVzFOUmIyTkVPZHA3bUpzQmN2ZkRPYmwySlZhMXNmYlRCQ3IzaFB2Tk0vemNmYzFMUjRKT3BhZDMvMlVEaGdEa0VRZE85QVorZEtZVzFONFhNVE9lbjdtQ1FtdXlFcDlWYW96WGo2R1lmaXVTZTdHL0JDTUhmSmIzc3VNNk5HTmdSLzZpWm43RSs2bjhCUGs5cGs5VWJJcTdlNlVqU2x1UFROTFJCdTJ4QTlmeWFYV3JTMHh6V3pmRFFMUDdzVzlISzBPdkFQa2ZPUkdMQWJnaURva1RyMCs1WWZoY3BYcVhsTXRjbkF4dmR3cHg3ckJCNGVyUElEL0h4eTJkUklocnZJbVZlK2JleU9iNjlldk0zUWJsNS8zeTBHS0dtT3ByeFZXOWZTMWtNdXpHSVBEVzNDWkxqWjVqTVBSZkZDd1N4a2NYRkNvQ3duTy9iUElRaUNQZ0JBNS9ualY5R0VzZW5UNFBubDFKclZKOGd4K0NtRTdsdkE4bjc2Smk1cE0vdzdRWm5HcjZxckZ3eC9kdlo4Mnl2N25KdHUydG9BUXRJM3YrR2JhTEZCcldSOWQ3a25DYXJpOXdSSVF4QUVmWENCSG9XQzJRWFRoREhPVkZNWnRuUjk0TGs5SzJXc2gweDNLYm5yVzNEeEJHWWV3bEs1RWFrTy9HNWZuQjhuRmQrdi9UNDhoZHZkMUxiMzIwUTQ3aVpINFgzZktuWjArcjRlbnZmZStYWGQ1RG1YakJjY01VQUhRUkFFUFVXZ1I0MWJLUFJOczlhblM3djY5ZWpzb3Zldit5VnJEUE1YblhQbWthNitsanpzdS9zWjZPM3o2SFl1Zld2YUVqdnFMRWV1blBiVXcxaFlXamcweDF2WGdDWVQ4dWRUb0wxNWVvNWRsS2huZnZScU5KYjFvbnZ2RUFSQkVIUW5RUGV0V0IxSWZjaDZhWG0yNytrZTlxLzdNSCtyQjNORGJwd1Q0M3dXZkJ3TjhEL3BkZ0kxMWJNVHdEbTg3dXZYNlhodXBLcHBGd09jT0VmOTIrdmRZSkpjRnowWUtSckZLa1B0ZkJnc1l6VCtoVUVRQkVHUEFPanRRQk1YUW5jWjZqSmp2QWRkNGVLbU5CeGVmNTJGWUJ4bVp6V3VwV3VJQUV5NVlycWZlcnpUNDNrazY4YVZyRG1vditBKzd6MW84NExpNFBiUlE4MTdFdWFKQ1d1MGx4L0s2emlrNzRiRjhBSUZjSWNnQ0lJZUJOQWo5K3M2dEJHOEVuWFNNKzFjK3hDa0ppOXZmS2hhSjE5ekNIUEtkdS8ycjBVTDZPeHBiNjhaNkd6Q2IxOWI1bTdhOGkyQ05pWEw4WjU2RE95UVVhK1BibVFxWmNVdkNqY1l2OEFKMnc0YjM4VnVBSGVFNXlFSWdxQTdBYnFVYlhNWDF4cTFHajVnN0xiblFDZWtEMGtmSEdoelVLT0phRmZQQnpCM2s5TmFJQ28xR0xJeWNNekMxMTZUYS9hTEJ2M20rNko2OW9QZHl4RFV5YW5mdmh5M21TVUFheGNOb0Q3eERHWit2YW41NXlrajcrZkVWOTFFTnpmci9kQzF3NFdEaHlBSWdzNEtkSGJnbFdNNUFUektSbS83bUplQ08ySFkyZm1TUzlWTmZoMUJpd2NhYnlxcjNtdHk4bGtFWFU1aUMvZjVQdTdPWURmOGV3aVgwK1BhMERydGxlOXZoTnBlOWFIT1pXMnZ4L3YzSHRpMEpVRERYcWpoVGFpYlA4Vmx1K2x3bGN1ZTU4WStSL2M2dVdnRkJFRVFCTTBDblJQYUtBT2N3c01XTVpWeVhlT2tLSStnejdsMDdwVis2NXpwRk9pb3RJMWhLM3NMQ1pjd2Q5Tno4TDNISEtKRkFyL1czaC9IUDR3ZTcwSEplK3BScmJsYng5ajdkODk5bDdrMzZiZklydnJJM2Vnb2xOOW0xNDh0K2VqcStENFR2UlhxVGU4akVkU3h6elFlN3NmOGNCb0lnaUFJaW9IT2JyUFNEbnJNeUNWdFgwdG9iNko5OHVuamNyZTNkazg4ZHZtMGIvNnE1MXpsQU1qamM0NkJXWE80dkRkOTdmYWxkZVVmNmtVYzZEcWRBOVd0c3lQUHZTUEtacjk1eFNEdTc2K3YzUk9QUjhUeW0ydlBPOVM5dDg0ZCsrNFFCRUZRMXFFdm1KWTFHWGJ2WmE0M25DMmVER0hublBrb3djMUJuWTR6ckVrWDFiSUVmWUsvaVVlb2NvTGFyZXRZTjN4L3Z1dGN6cW1IUllGcDdPWDFlNzdVYlR1WU5GZm16cWRQbWg0clhSbmdDTzZEcVhjUUJFRVFnSDZhRVIrWG83a1NzVVB4WGpBN2MyNnhPZzdiODlDVWdWdW0wakJaNzVZQm5XckxCeUYvM2pQblpqTzdVVm1hQS8yMFUyK1BFMHJkd3Y3Nm92cDdVM2lYL3lXVXh2a1o4L3g1dCtOcEVaNkhJQWdDMEVmT01VL3huRXRua0JNd0p4TGUrdFQwN1dEakpMTVJMRzh5MXJXckRaZWx3MFVTR2ZIYXVuQlZiVE5SZzYwL2g0SWU3dVRZZmIyN0d3NnpYZXpPZTRzS014a202ZDZQcEVHc0twcFByOXY2ZHdpQ0lBZ09mWkZMZC9YVk44c1N1Q2dSYjNzMTdzZ1dRWTFEM3NOajBpS0E5NjBISURUenBXVDB2TkRKclNPNjVxRXQ0MXB6MDBLZGg4QllOMThFU1I4U3B4NzAzQjgrVjFZM1MrMkZDalBPT2NGUmRYQnYzVHRDOHhBRVFSOHNvSnVZM05NdW5SOGJYUGtTMFpRenpoSlgyZGZKN3IvTFJPMDU3MmZ2QjlFQ2FneXpHenpXOTVnM3plQzE5cnduNzhMNHFmYXVOZGZFTTlSTG93OVVIbmZqUnJtS2V0T0Z5VE13bjU1RnZoTEdCSGVwMnYzMnR1WWRlKzhRQkVGUFRtb1JNRXdFL2VQQmg1aVh3WnhicnBJYkhrMWI2OE9PNTVDblRwaWR0SWt1emhXbm1zS2s0S3NHN3I1OVJjNkF6dzBTTjEyam00bnRnZVJUYWNGRFUrTm9uNzAwREc0bVlENnhLSmo1NUMzYzNmNjdHMW5yRjBaUzRyOENDSUtncCtYUUIvdTh1UjdzQlBLVnpVOTRiem5VbUNmTnY3dVI1NVhublBBSVFBdWRaZzVnRkNhL2Vja2pWdFB3OUZEMHRlMmwyZnZoT1B4NFd2eFV0ZTkvbjNIbkpYdm5zNkF2K1JpVWI5cG5YS2tpbkRzRVFkQlRBZnFNWmVSOTRjTUpuZEUybzRZeEthaTdFclUwek9Yc252U3MzZlY3OTgrUzJlc21OSTJaR0tIcXptTUYxUGtKdmtlOGZSMkdlckl4elgxSStyK0Q3TU45eFVJQmdpQUllbWhBRHlWa25PUjFXc2N5THVkS05ZeUplVXMzYVozSmFuZk9tanVxdFJuZWNyVkxwK09Za0VRMmZOdjdHK3ZTcTh6Q3dad085UUIyQ3ZGVCtKc1dEMHFWTFVhS25QdkNCVTZHNzkzZlNBTHVFQVJCancvb3c0bGpUWGtTV0E3Q294S3VuRFUzWEVLV0MrVnpZNVhZMFJiQkpmTVkza2V1MnhHc1E5anlWRFpxQXl1bk84QnhyYnFVL1lZMVN4U2F4Q2cvdEVWVytYTmZDOVBTTXJsNXdnK0tBQUIzQ0lLZ2h5UTFMdmZTdnA3OGNEck02MTBIODVsNTRyUDE2MHFKYk1aOTA4emZIckx5dzNrb05RMWFUdmJMdE1HTmJ1YjM2TUcrV3ZSNnZNZGVPamQ5UmRlNUluYytkNytNNEM2UlVBZEJFUFNnZ0I2N3RRQ3lncjdyMDkvN3lqV01tVzNQR2tLNVRUN1U3dUdiTFNrVEp1MjBoZWoyL0ZNMTZiUUZNQUYxYmlhVDJtWkluQUwzbGQrczJkL3ZPMTd1RVUvWi9jTmNoYldaN2FlNjZKS25BK3dRQkVIM3B2aHJXdkV2UFBmNzZCenRxUkJRSHVZcU16Yzg0ZFJwbk9uVTY0YU03TDQ5TnQydk9XZlB0NXVzMjVSVEFBNWJBTE9BOHcxb2FPUXM3YXNyZGVKZko3VE8zYzh2ckU3NFd4bHpoa0V5RUFSQjBJTUJ1ekxSc0k4NHdMenFhNXVkTk1GOEptRXQ3Z2JITTg2YlNRYzRIdHF5QUM0bWZ3Y2Z0MkRrYXpyeVByNVIrc2pFV2JMWDI0ejRlSGI4S2U3Y3pNRGNnTnNRQkVHUHhKSDNlUzI5UTlkbXJ3ZHNXZ1YxSHBoeTFkVTJ6OUdoRFRFWFpJbFRzcGc1OVNNd1kzZGZBTjcwRFBmOElvV2dyclpYNXl0SjB5R25ZVDhSaGovVlZadlRqb01FT1FpQ29EdUZlWHlqNXVDMzNGUEkvWDJPV2d0MzQ1cmVJakswVGUwTlhadUhlZ25NZTFQVlRNb1lud2FUb3FsdDNGYldGRVVjL0ZFWjZuTGhpTmRac1BzYTl2bEJNUUFzQkVIUWt3Vzc2VUN1T3l5K3J4b2ovb2x2TkZJRXNNY1d2Z1RtSWt3ckcyMlptNHhURnQwZThlenhxMG5UYmVhT1lacjU4NS83OENpU2tHb05tOGtKNkFhNzdCYTNpcDBIdTJ2d2szM2ZNekF2Mmp2SGVnQ0NJT2lCdW5USDVnQnlZamN4bkZpdTdKVy8xNEgwb2JJcjV0VWtERGNkekRNd1NBSEVoREt0V1podmZPYTRtUVRjSEl5VEVmZHc0Zks2ZWVnNmQ5ek1nRE05Mk9Yc1VEZG1IdXpGZEVhNEhZSWc2T0dEUEpxU0hURFF2L3k5ZGVqeTcreUY2RzZKYjM4SzJjRjlDcllFS1hhM1p2YTdmd2gxNTNZTHBLcWs4MTBDOVBrb2dDemU3K2JTdWhsWG5uemZsNEI2RCt6SEROaVhUSFNiNGphZ0RVRVE5QkNnSHZqTXJCYU8zWTdoOGp2cWFNUmZIY01OT2p6WVFUM3Awb09qVmRYMEYzNEc2aTVydktCNUNtWE1KOFB0Zll0dFpsclNtb0tXdGUzMHNkbFBNOVdhTmczeUVUeFZQWjlWdi9xdnJBZk5jSmI4ODRBZ0NJSWVpenVQR1UzTUpuWVR3NG5sRnVqeWJ3NWF2a3MzSER6VUc5UEY1bnVwWUw2VnE1QnF0dk5iRXVwWko1bUFMTGRCbGRuR01Ncy9qdkZpb0wxd24vaXlCRFl6MDBVdTZZTGJmdldWV3d4SmRhRy91bTQvNCtHbzFvdnNuU1BjRGtFUWRIR1lkKzdjTWJueE1EOTRtRHVHeTc5VkJ5MjAvZVdQN01YZTZLSE9EM0pXdnYzZUpnaTFlOXE1TC9RSm1JVVJvaVVRSUJjN1RGWTdHZXd6enlXZ2w3aG4vejZNWGdqekxoemdJeHpxZ3Y4Q3RJTTdaY2Fub2dXTDZJMjljd2lDb0h1RnViL1NzQk4zakNaV003T1ozZktQZnVVYjM5YUtmdGxyK1RWNzJmczcrRUVoL0U1UE5BUWZEend6T3pRazRWeU5XRGJBSkV4V3k0RmsySmQ5clpPTWpzT3ZWeG9PSjJBMit4N0lpMkFldjcvcTBsQTNMZGpYUkZNZ0NJS2dod0Z6NThxN01Ic0VjdUwzbmhqT3ZuVFBONGgzYjdYOHVyOU9EMmlkdXBZMGFuVEQ0MGE3REx1Rms4RDBjZEdnbHk3OGJTWko0L2JINTdPNFRZRGF6R0pnYmc1Njc2Z1UycVpMZHJFZ3BoYzZMZFF2UEJOOUJIYnNzVU1RQkQwbW1IZWxhWTdOTWFzdHUvL2dsNzd4N1hjWjZKN3c0cWFSdi9tbWtkKzdkUTl3VHhDVk9JcmFaY0RyWWRwOG9WUDNMVXpMYVU1SmQ1dDUxKytvV3Raa3BYVGZucmNVeXBQV2tsR0hiSnZZZE5UQXpVT3Y3dUJmaU9tZ1htRFlWMFU4SUFpQ29MUER2UEU1Ym52UDVzQnBZclpsOS84SXoxVUhJOEtEdm5mYnlDKzlhUlRCWGR6b1N1eE43ZHk2VDVSclF2T1p0bDU5Z1BWVXpYbG1FbHJlblZjemJ6VzZuQnB5VHh4YkxvRnJteGN3RlV5WTd5ekhuZmJPMlZWdUNkZ04zRGtFUWRCREFIbGNYeDdDN0RITWI1MzU1Z3V4MmpMNzEzLzVHOS8rWGpoRzlWUC8vdDhKbXFWQ3Z0VCsvTC8yOGhFTHRZOHE2czN1YjI5TnEzRmRhdmgvTXZyS2oxeXRqRy9qVWF6SFpVQWZER0tSRTQ3WkhBL0ZVQzhHSmlYOU5Rdk9tZmJmK1lOU1pVRE03V2RUc2h4L3FQcHUvd25KM2w5dEh1Wnc1eEFFUVdkMTQ3RWpGOTZWaDhUMFl3TG1yeDNRZi8vbi8vRC8vRzU4dlBwSTdsd3l6RVZsaWErVS9IV3B4VWZVMFh5S3Z1WjFGUld6VTZJN3VkTEtBdDIrQ0QxSGVhY3NoMUFQNVYxTHZ2K3A5dHpJTEVDR2NOZWxXOElMdG81cHdXSUl6bm9CV08zQ1F0WXFnbnBKdi9mRTQ2aFV6MzZvTk1yMnpzQnB1dEk5TWRmdUZ6Q0hJQWc2UDh4RE85ZkluUjk5R1hsdzV5M01qd3p6UDM5emxMODJQR2JOZGw0VFJ5eWdDYWlOMmR1cm43SDMvYW05Nno5cC96M2VWRnk0THJiS2hkK1ZOS0pTa3A4bkk3TVhvR3VPVFNoZUwzZm5jbU9mSThzK0FUNHZPZjM0OW9IU0QzNHZZUlc1N1kzOWZiL3NMOE5RM3czakZOSEJVeU5sWmVJRWxILzk0OTBDMUloNXNJUG5FQVJCWi8zYWpkdTVocVl4WVl2NzBDVysrVEE3dy93dnJFUC9qTDJNSUZVVHBNa1Y4NlVKWCtYbXRWMHgvR2Y3Q2wreHgvdTg5akRmMFU5N0E1blJtdHk1dlU1UWR5QVBhd3o3MDVBN040dGd6c2x3Um5YVFlVbytESDczc3Voamswc2kvL1k4akZITGdLcnBmUi83OWZOTDZyLzc3ZmpvVDJPZjN0eWZLNVp6aXhJSWdpRG9aSWNlSnFhRmRxNVIwNWlEejJaM0NYQ2MzL2EveUpsYm1COEk4Q09naC83dE1VaDlVOVdEZGNCZnNDRC9hd3Z4cjF4Vjh1MmpmY1dOZmVoR3VVdmxvYzRsM0RReU5EeWJxTC8weTUraUEzb21JVTMyQVdPT3NzdzFhdW1OWitrNVZYYXhzRERzVG1xYVFlZzl0VGVkMjFLUTR6ZExTWWk2dWY5UXQ1Unc1eEFFUVJjQXVqYVJPeGN5Z3JrSWRlYmt6TDlMQ1hBM1duNHpPUFZiblFTNmN2eFZmcGtnWkMvVHpnTDlqNDlHZnV1b3paZnRTdUVYdGtwdU4vYXhHK3ZNS3dxNysvMzNzSi9PdGVFK0RMNEU2ZEk2VW5GYzhDeHVjMW9JR3Q0V01OT05YSWJIMGZYaURIMzNQSjNvUVorQjlxenJkZUZ2OTVucWUvN25CM2NPUVJCME5tY2V1Zk5vQkdyYm16MDBqYUU2Y3d2eC8ybXZmL2ZHZzN6ZnVGRDhDT2pHUjYwcE9TNUEzVVFIOTAzZnYzdFU0b3NiTFg5bnE4eVhyRHYvckwzOGNHVkJXVnVvQjZBVGRKUnhibjJ4QTdTdWVCdytuemdPZlFyTkF0RHdvbVhKZWRYc3VKZTdZeDh2YWN2ZmxyankxT0c0L3NDOVdhM3hYd01FUWRDVEFMdnN1L00relArUjJybGFhSC8xWU1TNzFwMjNOZWlobFB5WUJIcFlKWGlvR3d0bzNqN1dFZFR0bGIyRjRiWVM3MjZrK0Ezcnp2OTdyY3pIYWlrK29hVDhTZXZVZjh5NjgzZWtGbTlKem14YmlIUXFrVE5xbVR0c3BBdUxsNjRaNkxGcVdjeEFOSFh4TUpuaDZvRmRlaXJCYk1sZWRHOHhZYytGVmlXQU9nUkIwSk53NmRZOFV5dVlsNWF6NzFyTS9nT05NN2RBLzBzYXRPTG5ySGlBVTRjNDU5cUowOEZzRC9XdkFnd0FWbVlrWXN5Vm8rZ0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+Wdly5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlRQUFBQkdDQVlBQUFBTlpEd1lBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEJPRGN4TmpJMlJUTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwQk9EY3hOakkyUmpOR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pjek16VkJPRGc1TTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamN6TXpWQk9EaEJNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtOemRjOEFBQUIvWkpSRUZVZU5yc1hXdHNrMVVZUGkxZDEyN2QyTmptR1BjWkZDZUlSS2dEMU9BV2pZb2dMQXFCRU5CZ0pJNC9Kc09OaUJLeW9CQ0MvTkdFRWczK21DR1NEWUlvVG8wR0pDaUlvQ0lCQm9FNHQwWEczS1c3dDNTejgzdk9kajYrbG5ZOTNjMnYzZnNrSjkyNmZwZWU4NXpudk85ejNxNkc2cUo1TEJDU3NwZVpsWWZsZlcyQjBpWW96Y3dJMFF5SEtRZ1pDbGlQZDA5WFV5M3JjdDVpM2UxTnpPdHhNK1U1NnJJb2hqTHUrU2EvSjZZcEQwVmR6dHA4Vi9WbDVuVjNVQytOTXBoOHlORFRVK21xcVdDM2E2OVR6NHhTR0RVL0Z4RVpDTVkrZGRqUzFYUXpuOGhBTVBKc29zZjducXZxRXZVR2dTdkVDay9qVFNXTGNGRnZFRGdobGl0WkJmVUVRU1dFL2QrT1p1b0pna3FJOGQ0dU4vVUVRU1ZFTFBPU0EwblFwSjBFQWhHQ1FJUWdFQ0VJUkFnQ0VZSXdPZ2xodE4zRG14N3ZLMXBnaXFTYm5iajFLLzdZOXZNeDFueWtPT2pnWkJTV01VOWRGV3M3ZVpDNUw1Y1ArMzJsYlhBd295V090ZjEwaExXZi9JZ1VZbGlZbXA0MW9PUEdyU3ptZzJPWm1zVzhuY052eVNmbGJXUG05Q25NTkRhVkdhMEpwQkREUVlTVU5lL3lEcTdiK3pycnJxdVFQamJ4MlUzTU9xTzNhTmhkVmNGTXFWTjRDd1pQOVI5aG5kOGZ0a1ViV01MOEpYZnVQWGs4RVdLb2dRSENERWRMZnZFdFZyOTNuZlRnak0xWnBmNE9oVURyRDE1M0oyc3MzVFdnWlFYWFMxNzhXdTg5dHpSd0FzZlBlVkpSQ1FkcitDU2Zsb3loaFBQb2grcWdvdU5sbEVFTVRyandWSjBmTkJucTl4Y3daL25IL0hjb1ZIckI0UUV2ZWFRUUFZQVoyM0VoaDgrNGhNZnlnZ1pxQ0NBUk00aGx3bE5YelJvUHZOUHZNaUNDVGloUXg0WGp6TnYrVDNneHl1cmQvTDYwWk1EMTJwWG03V3hsS1M5dDRqRkYrc1o5ck9YNGdZZ0xNblViVkRaL3VadExPcVE0enI0cTZNQUtNcml1bmVka01FOTVXQ3JveExsYnYzTkkzNDg1Y3lHZitZSU1JSjhnZzBEbnVZT3NidDhibkNoOHlWTlVKRzFqU1VTcGhXN1RUc3pjdGpOZk1FOU5SY0ExWHZ3OVljRUwvTEh6OTNJK0szbUdNWDB1YS9xc01LRFVDd0poOXNxb0E0aVgrSFMrVC9DSWdMV3g1TTJBeDNzcVQ3TzZEMTVtS2V2ZVYrT1lqSUlTbmlxRGdPRXEwa2pEMEhwNGUwL3oyYU82TjZTMGc2TDFJZkEzMGNsUUVraTJHRFJ0UUdxWnVaaWxyU3RXMVNSVTRJZnoyaDVmeXdrSGtnbjA1NEVFREhSejE2akhRNVZBM3ZZZlA5VWxNWkt5bCtuYm1CSkVpSitUNnpNby9rcWhsV3lzNHhoNHpFeklOVWlCb0ZOa0lKRDZwdEp0L2FhOWlibnJtZldCUisrNkpvamtkYlh6ODhrQ2NZcTRmelRjQjBqbXV2b0w2N3g0WWtTTXM0aGZNakFvdG9VcmZZaUFnVVN3SmhPUU5oNUs1RXJCNVhyTDF6d09DU1gxL2dxalRVM0Ywb1RsUml3NTRhSytaQnNiKzh5ci9EM2dQU0VXUVhPV1Q5SlY0R25TbXlJa0xTMVVBemNSeVF0TGVQS3VjM0plUmtPMVNpQkJCaG1waDhJZy9zRDFjZDJPMzc1WDVUMytrYWVDcWxUSSsxSE9CYUtpZ1hUeDlzV2NyRkFjdldVaHVsTUlTTFYyWnJaK3MwZnFPTVFJbHZ2dHpKbzFYeVdCVUphV2IvZExTek95Ry9lTlh6azV0S2pkOFZ6QTE2ZXVkNmlxVWJQWkh2TDhPQzhhc3BidStodVVaY2hrRmtDb3dBc0VpSnVkdzhZa3B3ZDBKRUdFdGxObGR3MnN6RDJFZTh5QURERWxHNkcwVXdLeWl0RGRVS2xJZS9GZEpIQmRPYzNjMTg3b3RzUEpoeGhDSUNnMFd1SjVwQTlEcU9YRVFXYTAycFRuYk14ejh6cHpYejAxcU0wcVFvVDRFS0V5RWhnLzNHeFNDQ0tyTUtHQ1cxRjdNVno0ZS92enV2TWk0RU5FZkFtZEtUWHp6cEpSUStvUWRVdUcxamVRQ2dLVmJFUWdaZVZtWmZrb0R1dDYySHZ3anpjd2N4c1B5U2xOd2hNcmVIcUwrM0Flazk4YjBhdUZyYjhDbVRESXdPVmQ0dzBNeENmd2RqcURwb2RhYndUcGNLQ0NuYmlIRmpIV1p6WUZ5azZRWHFhOXNwTTdsdTJuUzNVZjQraU9FSEQwakhHSlVxODFUNXJocytrRWRGejRnZnNJMG9Ub2FBdzVrMk15N3VVRERrczcwS1paZjBqTVdkdm5UT2FHdGJ0S2hCQ1pSQmplZnJ5OVJGMDJVRlFMUHlJMmMxYnYxdmtRU2pLTUxleVB3TUZzUFo0bFBjdmhsWVM3dS9wL0kyS0RTbXd3Q1VNS2N1dzh2Rk90bjhEVzgxQ1RGQ2t2djY2aUVySklXTFJLVFpjanBWREdHS2xrME81ZVlvOENzMVlFZFdLbmN5Zy9MNEdTZnE1S3FKdVVPQysydmdWaFFkWklRVVFSQXA0RDlnNEVHYkJwaENvcGJTQW9haHY1VG1kaG1WUk5wcXhLZ0h3OGtKeTdQS1NQZ1RvSTRZMUVrbGtXRVU0bEluWGIvRHlmR29WZzlaT1FadFJFSkMvSlY4dllVSmVKblV0VVZRMW1jTEEzZ25PSGluTjQybHE2aTIrMkRZVlJOcExRcFZPSkdXYWVPbzkzYUd6bWJKODZDTVFKaUJsQ2JXVkRUVkRHNzcveEJTSjExZjdKclc1UDlTVys0NmdOOXJRVjFjT05jS3F2UmdLNnE1aUNFcVNzM2hyUWl4QkVrSzFMaEJLZ1dncVJ2aTE3cVJydGcxeG9vdWJDZjFDaTRkTlhVYk5rd0RIc3V2V1hTZ2pFQ0xjckx3MnExRXdVcGtCMUxGbTV2QUFHdmdKSUlRSlNuOWRmT3pOeTcxZUhWcnZ1bGd4SVBmWW44QUdhNGM3YnRRVzZCSjBXMlVMcVJ5b3FKekpFaVE5QklFSVFpQkFFSWdTQkNFRWdRaENJRUFRaUJJRUlRWWdPUXJRWnhwaW9Kd2dxSVdvTk1SYnFDWUpLaUl0akpLdWNDYU9ERUovSEpHZFFUeEJVUXBTWlV5WXdvOWxLdlVGZ3h1YXpSejNNWUh6Yk9uVVc5UWFoTisxVVNMRWpadHdFUjJ6R2RPb1JJb1NLM2RiSkQ3TFk5RXpxRlNJRVY0bEtaakRNdEU2YjdZaS96ODcvTVFkaDlNSEhrVkpJY1VWNTJKaVV2ZXhHVFBMNFBmaVNlSHd2T0w0SzJ1dHhNOVpEWC9nYTdUQlVGd1grdjRzS0tjekt3d3FsNVNsdHJ0SW1LaTJHdWl5cTRmaFBnQUVBVll5NXpvTE1FSDBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJUUFBQUJHQ0FZQUFBQU5aRHdZQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBCT0RjeE5qSTNNak5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEJPRGN4TmpJM016TkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rRTROekUyTWpjd00wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tFNE56RTJNamN4TTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrUVFqSlV3QUFDQnBKUkVGVWVOcnNuWHRzMDFVVXgwOS92N1gwc1kyTlBXQXYyUk1IaU9CQUhoSlExQkJpb2lFalFFeGNvaExJZ0Q5SUhJaEdkS0NRT0dRa0EyRUx4R0Nja1NEeWtrU1JJRk1XVGNZeklBdFQ5eUtNelkyTndyYXVvMTFiNzduZHI3UmIyL1d4a0Q3T043bmQ5bnQwWGUvbmQ4NzNubnU3bjZ6NzJHZjdBV0F0a0VKWnZheTFzSGFOdFJPc25mcXlyTXd3WUxiQXg5V2REZ2ZLR0JDV1kxL3RBN1ZjZ0RFUk1oQmw5TzZGa2l6WXlhSWM1Q28xcUdNU0lDRXRBNUtlU2dkQkVJc3E5dTdadmFtcVl6Z1FQMzlURGxGakJGQXhJT1JFUkVqQmdHS0JBTXpzWVlCOU5aZ3NJQ2lqSUdQR1hFaWVtRm5PZHUrTXl0L1M3QURFK2U4cVlDd0RRcTBRUUNFUUVLRUdCVy9zd2NTZ01MTDJpRUhSWnpCRDRxVHBrSnMzRjJReVdZWUVSUVErWUZEQXlJQXdVSVFJelNpQjM1Z0YxczhXN0dNTFJNaGswUG52RGFoanV5YlBuUGMrKzdJT0R4UG9MUXR0eWFUR0hnUzg0Rmtid3k1NnRWd0drU3dyZFB4ekhWcWJHOWIySE4vK0VRRVJqbkRJTUNOWU00R1NlVWEwQ2ZWWC8yQWV3N1NkUWFFZ0lNSVJqRUVvRklQUlFtYlV3OTJtQnR5MWdvQUk0M0FoREhwSGhLS3pwUW0zTG8yZ2R5WjgwNGNnczlhZFJFYUdUc3NMVkxNb1FvUTVGZGIwQVREUXI4TXRTUVFFTWNHaEFJc1pmeVJUU1VQU3g0MkduYVJoSWlCSUJBU0pnQ0FSRUtTUUJrS01UdUdOUkVCdzVlNnE1bTNDVzd2ZFFwTzc1eWFrZjNBYUl2T1dVKy82b0lBc1hTdFNuZ1BEM1d0ZW41Zjh6aTRRbFdyUVpFNkZkcDEyVkY0TGdxVktmOGF2NXpEMWRjUDlNNlVFaEM4Z3BLMHBCWGxzSWpTV0ZIZ0ZSVUwrTm9pZU9vZC9yMnVzQlVWaUJtdXJYUjZ2Yjd6czBmTkhUcGtIY1F1WCt2MjNFUkErQ0R0SVZHcjRWWjVjOENrMGYvNjZSK2VOVzFJRWlVc0tiRDlqaE1EbTlxcnQ3NE9XcjdkQjc5V2psQ2NDT1dXMEh0a0ZFd3RMZUlkaVI0OTBaV0Zrc0lmQkcrbnIvL1RxK05vMW1WNGRqMzVuTktKTFdBT0JWNnoyMG1LSWZmNFZpRiswd2lVUWFDRFJNMGhwb3IrdEdlNGNLSEtiQnZDY25PMi84QWowNE9KWk1IWGZwWkFRREtPTTlpTmJlVWlYeHliQTJBV3JYWGFzQkVOM2JRMkhRWlU1eXlQVGljOTk3OGRTNnYxZ0dXWGdsZHYxMnpIUU45OTBtdU9sL1hFdkxlTmZIOWFjaE16TmxkWVJSdTVzYUQyNDJxblBrQURxK09rUVJZZGdBZ0oxNzNpeExSb2t2RkhrZFAvOWN3ZHNIZHQydEF4U0N6N2txVVlSZDlyQmtPTFFNU2wvdlMyYUJJdmpKeUNHcEFVRUlXYjJZbjdsdTRva2toNVdId1NUN29ITmtHSnhDcUd3TjUzb00xb1BiZlRyTlhtVmoxVlJCTVJvMUNMR0xTcHdBQUU3VXBtVTdwRWhiYW1NNFpFQ29aaFVVc045aUZTYnVMTy8wSzlVZ1pWU2loQlBNQ0tNWDdtVmgzeEpSdTA5Nkt6Nm5vZjRxUWNhUGF0bGREVFpBSkpnNkxwd0V2Nzc5ajNLQjhFV0lhS256Yk9tQWpZS1FMTW8rWWlSaEI0Qks0clIwK2JiSUpBaVMvdXBjcitLVC9lcktrRi8rNVovSnBtbE1nTEN4NUVGN3dRN3MrZ0tnT2laaTVsNW5PQzBJb2tnZEo0N3pIMkZ2OEs2aGkvektoUWhSbkZrTVdJbnRkZXoxRkl5RElMdTY5WFFXMXNOK3IvUFVld1B0VkhHVUtFcEZGVWFNUFgxOEN1MjQwd2xpT29vN3VUNzc5UkI3MS9uL2I2UzBkQ09uYlBVSjRDOW5SVjFWV01oSUR6VTBJa3U3QXpzd0p4aWxtYVlFZTFRUjdOdC9nR0JsVTV2NWtYc1U1dTNzNkpvZEFNUmlLQmVRcWNZbisxd3hUMFJyOE1NTDZXTUp5VDd1b0czblpQNmRqR0loU1ZlL2I3RzBqVXUvVWJkeGdWT2phMG5zNnZ1WmtVOUhUNVRoR0R5QmdaZXU3Q3JZTHFxWnJvRnFyZUxYR1FnUjRqYkZadEIxTVI0bHU4blRoNldzN1dYZmdWZDNVWFBnZWpwSUFJQ0dRaHZURmJzL05PMnROSGYyc1RyRVpIWnoxcW56bWttTTd4TUplWnhxU0NGQzExYUt6K3hyWjlJVzFkQnZScE9RQXlkdmNRNUNxdy80UFEzU3BycHBNOXdoRGdRZkVYMmhzTTJHSERpQzFkSlNjSXlkZHZ4ZlRZb2NFVVZMb29oQmJHSGNHb2VuMzRWWWhldTVCTmY5dFBoenRaUDRxeW9TZGNOU2NzMzhHTnhVUXl1eTlUV25PR3JxcnlwWk9MTXExbmZNMnk3TWpWbnhIUGRmWmlJZ1BCU0dPcFYyUy93eXA4bVo0YkRPZ2owQ2VnWjNFMWxZNlRBejF6Z01uNk1GT2dyTUtwZ1E1RDBMUTI4MUsxdnVnNkd0bHN1RGFqOU5MeTNDcmFWMWdFSkJFYUN0SGQzT0sxRlNDRGd3bGhQUmhBWUNiRFVqZk1Mc1F2eWJXc3BFUzRPMkdCbnUxc25nZkE0cjMxb1JxeVh1RHBYZWcwRWhBZkNpcUcrZFpYdHpVYVAwRnQvQTdxdm5QVzU1by9uWWNPb0V6bjlOYjRBVjVXYXhUdEZNcVN1MUZ4YTRIT2xzcUg0WlpmN0FyMVNHVkFwby8ySG5hQ3R6dVlmb0JuTldnSStGNllTKy9VUnprWWhtR293YWtqbk9CTk9hS0VmR1hvTUxxTHB1akR5YTVHS2IvaTdBbEg4ditIL2ZyZ0NZbFVpYU9RQy9mUHpNSlBSWkFHZDBReGF2UWxlZkxPUS9tRUlLVWpyRUNRQ2drUkFrQWdJRWdGQklpQklCQVNKZ0NBRmxTeERHZ0ZCc3QzVEUyUWNCUU1CRWVZMDhCdThzaGFoMU9DV05nSWlqQ09EbWRGZ3dtYTJnQ1kySGpkZkppRENtQWk4SnpoT2J1R3RuK05UTTNEclNRSWlIRm5nYWNJQ2hzSDdnRnZrS2toSno4SmRSd21JTURTUUNBTkdodjRCNjAzaHMvTG1neUNLVzZMeXR6eWkrM2FHQVFTUFU0U0Zwd21NREFoREw0TWhjZEowakE3bERJWWRlQmdId2pTWVN3eWloZDdCVUswMTJFVUdUQk1ZR2VJeXAwQnUzbHc4N0F2cGVBN0VJMGFMbnNOZ0JpT3RtQXJSTkFGOE5JRXdDTW9veUprNUI1SlpaR0M3OTdIbzBPUUFSSitSMzhRVERDYnJyWDlKSVFhRVRBQ0ZVZ1BxdUhoSVlxT0psSXdzRUFTeHFHTHZudDJicWh3LzhJeEFsQzlidFg0dHZYVWhMU05ydUNMNENtc25jRFN4cjZ6TVlEUVB0d2ovQ3pBQVBzTjRYRnp3QjZFQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFBL0NBWUFBQUF4QmV5SUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk5EZzVSa1F4T1ROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTkRnNVJrUXhRVE5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalZGTlRZeVJqbEZNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWTBPRGxHUkRFNE0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0Nnc0ZGQUFBQzJSSlJFRlVlTnJzWFhtTUZHVVdmOVZkM1RQZGMvY2NPOENnRURZWWlTS0N1aWhLZ3E0b3NPc3RtSlVWaGVnQ2k5Ri9GRHpZQkJFQkV5VWl5NUpzQUEvSUxnaEIzSUJYc3BwQndFU1F3eUVnY2hrRzVtS21lL3FhbnI1cTMvdnFxNXJ1bnU2WjZwbWVycDZsWHVhbHVvNnY2cXYzKzk1WjMxUUpUUTgrQ0gwa0UvS3R5Rk9RYjBFZWpUd011UUE1RHd6U1FwM0lQdVJMeUtlUkR5Ri9nL3dEY2xUTENVYWVMNHhiRi92UWlScmt2eUkvaVR6Y3dLUmZsTWZaZ1h3ajhxTjgrMFhrcmNoL1I2NVBWOHUwVWptL3dGbmtKUWFZQTByRHVZelBjcG1YWnhyUW1jaW5rQmNpV3cxNVo0MnNYT1lrKzFtWkFGUkVRNzRCbDl1UUt3ejU2a1lrKzM5ekxIcDBrNktVZXA4ZDkyMFhBR1pJaGtCemdoQ0x2eUNvTllKc01mM3BhS2dZUWEwa01BMHg1aHlvTXlLeXhSUTFBNG9OMXBzQi9tQ0lMemVKc0NHTU5BSGFLY0dmc01Hemh0aHlIdFJuRWF2WjNUUzQ4WUVIMUpXV2lGQlpicFpPbWVTOHlLQWNKNHh0bkpmQ3BqR1Q2d3NhazJwb3NVbGFhWUE1cVB4cFdhVTV1aUxPNUVveTBuQWhaQnBsRVdDT3NtN3c0R0RFN0tuL0R2T05pdFBRVVJlS0JEUzFpNFMrbFFJTjBsZExSY0pPL3NrQi9WMStKTThtU0U4WTRobWNSTmdSaGlxZ2YzTUVKcGtGcURaRU0wZ2pYc1NPTUdRRkJEUzNwdjAxM252MTdwVDk4Y2ZaMHYvSkoybTFLMW04R0RxUEg0Zmc5OTlEMU9sTXEyM0JNOCtBWmNRSWlMUzBnR2ZkdWw2UEwxMjJEQ1MvbjEwdjhQbm5PUVZxcVVuNlBTNitJWjlweVRQQmVEM0xlOFdMRmtIQnZmS1lDcDQrRGFGanh6UVBBdHNkZHpEdXZQdHVhSHZwcGJTdVMyRG1qeHNIb2ZwNjZPMytiZE9tc1dOWkg4K2RnMXdyaHlLR0UraVd5T1JhclJnWDZka1o3OWF0RUdsclk3L0xYbnhSVXh0VFdSa1VQU28vUG94MmRFRDcrdlVEMnNlaW1UUFprdnFacmhYSkJuRU1yU0lEVkpCMGZaSkNwcko5NDBad29JYVpIUTVtUnR0WHIrNVp3TTg5QnlhYmpmMzI3TndKa2ZQbkI2eC9oV2lhcVYvTVgrRnl5TzdkeWU4REI1YnZ5eS9CdTNsejlnR1ZNYlNhbUpvS1lOZDdoSFYrOXgwRWpoNlZUU21hVU10Tk42VTJMM2ZleVk0aG9qWURxVEhVajZLSEh0Sm1OWENBRmR4M0g1aEhqc3k2L0RpR0ZwRUZTWklrNW9KUGNLMVpBMVViTmpEQkZEN3lDTFJ4Z0JOTmJjbThlYXI1b3phUzFQL2VKenNIWFV0eEFjeXNmL2hoY3Y4NmNhTHFYOGxhaE5ISDZwR1BFcGFpa3BEcTRzanZ1Z3RNUlVWeDIwSVhMNEpZVVFHZGRYVmdtejQ5cWZBVTgrZXJyWVc4MjIrUE4zc2VEM1R1MjVkUzIvSW1UT2dLOXl0a1QyT3kyNkZ3N2x4NWtEUTJRc2ZldmJJL2YrMDE5VnBPaklLVG5aZnVRUUhUZitBQStMWnYxN1hPb0N1ZzVUMUVwU1d6Wi9jZUhhY3doWmRUQUVwZ0ptdERvQ25iS2VMdFBIaVFnWmszZWpUYjFyNWxTMUl3YVlDVUxWb2t1d3lNemwyclZ1bGVPTHFxU24yUzE2dHRvSzFZQVphYW1yakIxZHNBc3d3ZkRrTS8rMHhkYjFtNlZIUDZsVWxpZ09ydFA3MWZmdzN0NzcvZnIzTTQzbmdEYk56MHBib2ZMNXBEYjR4SlZOcVFWall2WE5nVk1hTG1sYi82cWhwRmF3Mkk0a3kvMjYyTFhJMWlmQklLb21ZMXpaOFBRM2dRNVA3MFUvRHQydFZWWVhyNFlkVkVONzN3QWtSZEx0bWtvejkzWURzOXlRQzBoOXk0cDNWMU80S1pic2x4UU5NWEE3ci9MOG9KSHlwbHVBOVNodHNrOWsvUzBIZEpKN21LUEt2V0dWRXBzMzNvdzdsTXBhVmdtem9WOG0rNEFWb3hRdTJ4ZjRtL2xmVlUyNjgySDFxRWdpVFdpeWhGR2ZyUlIzRVZJcTErTVpmODUxVVpGRmt4VGJGUmRXZk1tTGhjVXlFcUVQUXF0S29xdGd5M3RobytOSlphM242N1crbVBKZllMRnJCbEJ4WGVEeDZNMjFmMjlOTXM1MHUyajJtTXg1UHlmaHhMbGtEQnBFbmQyMUNkZHVkTzhILzFGVnZQNStWRTJrN1hJZ0JqeTVDV2E2OVY5OGR0SDlYMUZOSTJaUXFFcjc4ZWdpZFBRbmdBbndUbGxJWUdrcFRUeEpnbkZZRzZPdkR6dW1vaTJPSG01bTc3ZXMwdlViQUtvQUhVUkxHOG5ERnBtbmZiTnJiZGpnQXAxMUR6VG15VGJDQllVY01UajFXb0JITlZvbmJNWDkxWEM2REpLUCsyMjlUZjRjdVhNM3B1UlFOcFNiNnZZdmx5Qm1paWhxZVZyM0l0VHJuZjU3dTZmYWcxUmtPRHFLR1pMaFlvbXRpVDFiaVlvcmhQTk9TREQrSUdnZWVMTDhDOWFaTlJXRWhGdHZIalpURHI2M011Z2l5ZU8xY0YwN2Qvdnh5aDMzOS9uSnZJQ1VCelpSWjR3YXhacXZueWZ2dHQwbU1TRS9kVVRMTUd0RnhUNi9ub3VhZmlGLzBZa0xXdVdzWDhNUFczL09XWFFjQlVSMi81ZFdtb2tnVHJ5SlQ3bGNaTSttTCtMdG14eVJMK0pGeTllalZVdmZNT2UzS1M4amlONTZKelZEei92SnFxdEwzN0x0dmV0bTRkNnlzRlJ4V3Z2NjYvSEhQRjVKb2NEcWg2NnkxVk8xMDdka0NVendMczYvbm9YUG1qUjRNNGJGaS8rbWFmTVFPcTMzeVRuWS9BYTE2MlRPMGJUVFc1d2gvNzBiV3FFR2lUdzZHL3lZMWkzM1NMYWlkUGh1bzFhOWdvWjZZV2ZWTnZnWXVXTWw1Zm85YllRZUY0NVJXb1VOSWsxTXpHeFl1N3pSY0sxTlpDMjhjZnE2RFN2ZEE5WlpzVURGbVVHNUlnWUJXZ01Kc2FhY1BrdmZDZWU1Z1FGQ0l3VzFldTdMRXRDWllDRTZyMGtQWWtIU1JqeDNaVmZqQlNUbFZvb0xsRXNUNVVMVVdpTHk5OTdESFZZcEN2YkVFdFRXVTFQRGdBd3cwTnpDeFQzNnJRcC9xblRnVW5Sci9abWpCR0dDcUFTZ0ZKY0ZvRktTdUFWcUpnOHErN0xpNTNJNUJjMjdlRGI4K2Uzb3NETklrTWhjYjhWb3FrWHMwN01YaEpCS0VjdGE0d29VZ1E5ZnRWSUl1blQxY2pXVEt4Ymt4TGFNNXdiOVNCbXRxQWtYa2xna2w5czQ4YkIvYTFhelVOMG93VWFSQkR3cEpNcnRRZUZTNWxTenVwWEtlQXlZRGN0UXN1elptakNVeWlWdlJUSktTZTZxZ3NxS0pJbElLWHhCcy9mcnpic1RRamdmMzJlbFV3cVgwRFRmaldBS1k2TUZFYkcrYlBaL2RFNTJVbHhYNjZENjNFTVpSSVF5T05FZFBwNFdKMFlqWXVUTUNKMWRYUWNmZ3dCSlBNdSszVlY2REc5V2ZFZCtDQWNsWEwvMmdYcGltYnVLNW9NZldOZkc3RTdlNVQzMVRoNGlEd0lLamlOZGRremVSZVJnd0pTd0kwZEtoVFBIUkxYdmlwYkdtcEs0MVJuMmxpazdON3VMNGZUV2VtcmhQcFI2U2VMdjNZS2RJTEgwTmtjb1AvZE9jZDlzczIyS0JCU0lRZFl2Z2pZY2tBUllmcU9oRTA3emRFTXppSnNDTU1DVXRtY3BIZEc5MTV1OFpYaEthWjJTdHdEQm9zRk1FL3dvNHdaQ2IzUkkyVFhyVHIyUmV3L0Z3WEZQY1pJaHBzMmludUord0lRNG9aVFR5aDdrQnVYdTYwYjBIVjlSbXZpeGtjVEZndGM5cXBUTlhNTVZScnVXUjJXMCtHekwvczhGbi9aWXo3d1VHSTFiWlRJVE9sSzYwY1F4blF1aG9uQVU3L3lWTy8wbVhmZXpRb0hqREVsZHQwRERGQ3JLZ2FVOCt4azJJMWxFQU40cUlGK2RjRlZ3bzNuZzJaVHhoaXkwMGliT1lqUm9RVnh5eW83RXQ4ZkVaRnpZdWVxSEJtM3BYQzlSZkM1bE9HK0hLTHpvWE1Kd2tid2dqa2p3M0V2UWc1RGxEVTBnZ1ZjbWdRWEltWWZwN1pWUFRla2FCNDBCQmpiaEJoOFVSejBWckNCdVFQRERqbHpDVUcwTVRJNmFjYVo0aXI4V20vSkp6NWMzUFJwazJlZkNQNjFUbWEzWXdZRUJhSXlTOGdmK09saFdNVlIwbG4vZUdCd1J2cnk1cjQrWUx2dHR1Q3UvM1drMHRML1grOE9TOThxOGtvUG1TRm9xaDlSenJGSDVhNzdQOUJ2MG5CendXdW1RUm1NRmtiNFd5U0YxTW9oS0JhY0VHUC8razdJalJkdkdxc05UeDBRWEZnTWdKN2M0RWdsUmhpenp6NUpLRWRnVHp5RDNkKzdmR2dlSm5ubWI5eW4rbUsxVXpFU0R1Z3ZBRnBJejNhcndUNXEwcERDR1JSQVBzTWUzRGs1UHpRYjBlSWtacHlrMVJaYUpKS0xJSmtOVFJZdXdhR0pDSG9qUXJ0clZHaEJZUFErdHFBNWN3ZXYvVjhXR0xCRHNVekRUdzFJVGZvLzBtT2M2RFBnTVkwcEkvQzBLd0dlZ0w4Rzc0c1JzNEgrWU14SW1jQmRIeXp5aUFqeFUyR09aTVpwYWtrYmw0c2FPSkxieW9UMncxUSs5Z24wK2tBQVVWbW1LWWNGSEZBaXpuUU5nNnNHWXovREU5RFNWbVVHdVNsT3k4SGs5akR0NFVnamY4bkUvc3dvb0tjUGR3TVdEbGJPSmlHaHFhdm9SRU9uQ0xiRUdqOE9tRWkvVStBQVFCTHkvRmJPUThONUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2iLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImV4Y2hhbmdlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcImJhY2tncm91bmQtaW1nXFxcIj48ZGl2IHYtZm9yPVxcXCJpdGVtIGluIG1vbmV5RGF0YVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leWJsb2NrXFxcIj48aW1nIHYtYmluZDpzcmM9XFxcIm1vbmV5QmFja1xcXCIvPjxkaXYgY2xhc3M9XFxcImJhcmNvbnRlbnRcXFwiIHYtYmluZDpzdHlsZT1cXFwiYmFyY29udGVudFxcXCI+PGltZyBjbGFzcz1cXFwibW9uZXktaW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5SW1nXFxcIiB2LWJpbmQ6c3JjPVxcXCJpdGVtLmdvb2RzaW1nXFxcIi8+PGRpdiBjbGFzcz1cXFwiYm9udXMtbW9uZXlcXFwiIHYtYmluZDpzdHlsZT1cXFwiYm9udXNNb25leVxcXCIgdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIj48L2Rpdj48aW1nIGNsYXNzPVxcXCJleGNoYW5nZVxcXCIgdi1iaW5kOnNyYz1cXFwiZG9leGNoYW5nZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJleGNoYW5nZUJ0blxcXCIvPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImNoYW5nZS1idXR0b25cXFwiIHYtYmluZDpzdHlsZT1cXFwiYnV0dG9uQmFyXFxcIj48ZGl2IGNsYXNzPVxcXCJib251cy1idXR0b25cXFwiPjxpbWcgY2xhc3M9XFxcImJvbnVzLWJ1dHRvblxcXCIgdi1iaW5kOnNyYz1cXFwiYm9udXNCdXR0b25cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJwcml6ZS1idXR0b25cXFwiPjxpbWcgY2xhc3M9XFxcInByaXplLWJ1dHRvblxcXCIgdi1iaW5kOnNyYz1cXFwicHJpemVCdXR0b25cXFwiLz48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXFJlY2hhcmdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtOWUxZDhiNjYvUmVjaGFyZ2UudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYucmVjaGFyZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5yZWNoYXJnZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5teS1tb25leSB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLXN1YiB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT80ZDU3MzY2N1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxSEE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiUmVjaGFyZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cXHJcXG4gICAgaW1nLnJlY2hhcmdlLXJlY29yZCh2LWJpbmQ6c3JjPVxcXCJyZWNvcmRJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwicmVjb3JkSW1nU3R5bGVcXFwiKVxcclxcbiAgICBkaXYucmVjaGFyZ2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xcclxcbiAgICAgICAgICAgIGRpdih2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiLHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5SW1nXFxcIix2LWJpbmQ6c3JjPVxcXCJpdGVtLmdvb2RzaW1nXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5ib251cy1tb25leSh2LWJpbmQ6c3R5bGU9XFxcIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVxcXCIsdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0g5Ymv5qCH6aKYXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkuYm9udXMtc3ViKHYtaWY9XFxcIml0ZW0uc3ViXFxcIix2LWJpbmQ6c3R5bGU9XFxcImJvbnVzU3ViXFxcIix2LWh0bWw9XFxcIml0ZW0uc3ViXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5yZWNoYXJnZSh2LWJpbmQ6c3JjPVxcXCJkb3JlY2hhcmdlXFxcIix2LWJpbmQ6c3R5bGU9XFxcInJlY2hhcmdlQnRuXFxcIilcXHJcXG4gICAgZGl2Lm15LW1vbmV5KHYtYmluZDpzdHlsZT1cXFwiZm9vdGVyXFxcIikg5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX1cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxcclxcbiAgICByZWFkeSgpIHtcXHJcXG5cXHJcXG4gICAgfSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgbW9uZXlEYXRhOiByZXF1aXJlKCcuLi8uLi9kYXRhL2V4Y2hhbmdlLWRhdGEnKSxcXHJcXG4gICAgICAgICAgICByZWNvcmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmcnKSxcXHJcXG4gICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmcnKSxcXHJcXG4gICAgICAgICAgICBkb3JlY2hhcmdlOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nJyksXFxyXFxuICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgcmVjb3JkSW1nU3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDI4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ5NSAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb25leWJsb2NrKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBidXR0b25CYXIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDUyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTA1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBiYXJjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYm9udXNNb25leSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzcgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJvbnVzTW9uZXlIYXNTdWIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBib251c1N1YigpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxLjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggJyArIDYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb25leUltZygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0yICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHJlY2hhcmdlQnRuKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzY0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBmb290ZXIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcxMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcblxcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5kaXYucmVjaGFyZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5yZWNoYXJnZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5teS1tb25leSB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLXN1YiB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xyXG4gICAgaW1nLnJlY2hhcmdlLXJlY29yZCh2LWJpbmQ6c3JjPVwicmVjb3JkSW1nXCIsdi1iaW5kOnN0eWxlPVwicmVjb3JkSW1nU3R5bGVcIilcclxuICAgIGRpdi5yZWNoYXJnZSh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXHJcbiAgICAgICAgICAgIGRpdih2LWZvcj1cIml0ZW0gaW4gbW9uZXlEYXRhXCIsdi1iaW5kOnN0eWxlPVwibW9uZXlibG9ja1wiKVxyXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJtb25leUJhY2tcIilcclxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cImJhcmNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cIm1vbmV5SW1nXCIsdi1iaW5kOnNyYz1cIml0ZW0uZ29vZHNpbWdcIilcclxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVwiaXRlbS5zdWI/Ym9udXNNb25leUhhc1N1Yjpib251c01vbmV5XCIsdi1odG1sPVwiaXRlbS5nb29kbmFtZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0g5Ymv5qCH6aKYXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5LmJvbnVzLXN1Yih2LWlmPVwiaXRlbS5zdWJcIix2LWJpbmQ6c3R5bGU9XCJib251c1N1YlwiLHYtaHRtbD1cIml0ZW0uc3ViXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLnJlY2hhcmdlKHYtYmluZDpzcmM9XCJkb3JlY2hhcmdlXCIsdi1iaW5kOnN0eWxlPVwicmVjaGFyZ2VCdG5cIilcclxuICAgIGRpdi5teS1tb25leSh2LWJpbmQ6c3R5bGU9XCJmb290ZXJcIikg5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX1cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nXSxcclxuICAgIHJlYWR5KCkge1xyXG5cclxuICAgIH0sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9leGNoYW5nZS1kYXRhJyksXHJcbiAgICAgICAgICAgIHJlY29yZEltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC86K6w5b2V5oyJ6ZKuLnBuZycpLFxyXG4gICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmcnKSxcclxuICAgICAgICAgICAgZG9yZWNoYXJnZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZycpLFxyXG4gICAgICAgICAgICBtb25leUltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgcmVjb3JkSW1nU3R5bGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTM2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyOCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ5NSAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vbmV5YmxvY2soKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidXR0b25CYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmFyY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9udXNNb25leSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib251c01vbmV5SGFzU3ViKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvbnVzU3ViKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEuNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAnICsgNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb25leUltZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAtMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWNoYXJnZUJ0bigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNjQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvb3RlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcblxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5yZWNoYXJnZSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbn1cclxuXHJcbmltZy5yZWNoYXJnZSB7XHJcbiAgICB6LWluZGV4OiAzO1xyXG59XHJcblxyXG5kaXYubXktbW9uZXkge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmltZy5tb25leS1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5kaXYuYmFyY29udGVudCBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbn1cclxuXHJcbmRpdi5ib251cy1tb25leSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuXHJcbmRpdi5ib251cy1zdWIge1xyXG4gICAgYmFja2dyb3VuZDogI2YyNmEzMDtcclxufVxyXG5cclxuLmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5kaXYuYmFja2dyb3VuZC1pbWcge1xyXG4gICAgcGFkZGluZzogMSU7XHJcbn1cclxuXHJcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XHJcbiAgICBmbG9hdDogbGVmdDtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIHdpZHRoOiA1MCU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogUmVjaGFyZ2UudnVlPzRkNTczNjY3XG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiA1MDAsXHJcbiAgICAgICAgc3ViOiAnJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzEwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAxMDAwLFxyXG4gICAgICAgIHN1YjogJycsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMjAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6IDIwMDAsXHJcbiAgICAgICAgc3ViOiAnKzE4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnNTAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6IDUwMDAsXHJcbiAgICAgICAgc3ViOiAnKzg4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTAwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAxMDAwMCxcclxuICAgICAgICBzdWI6ICcrMjg4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJNemcwUmpnM09UUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk16ZzBSamczUVRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOalF3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPall6T0RSR09EYzROREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCszUS85S1FBQUVqOUpSRUZVZU5yc25IdU1YTlY5eDcvbnZ1Yk9ZMmZmVDl0ckc5WVBjSW5CTVk4YWt6YVFJa0lMVVZYUkpHMXAxZnpSVmduL0pLbWEveXIxamZOUDJxcUpxcWhxVUtxbWtVaWFKbWxVSlNCSUs0SkZ3QUVNeHZaaWUyM3ZldGY3bnZlZCt6cW52M1B2akJrbU03dHJJQjVqbjU5MWRHZm1QdWJPL2R6djczV3Vsd2tob096YU1VMWRBZ1ZVbVFLcVRBRlZwb0FxVTBBVlVHVUtxRElGVkprQ3Frd0JWVUNWS2FES0ZGQmxDcWd5QlZRQlZhYUFLbE5BbFNtZ3loUlFCVlNaQXFwTUFWV21nQ3BUUUJWUVpRcW9NZ1ZVbVFLcVRBRlZRSlVwb01vVVVHVUtxRElGVkFGVnBvQXFVMENWS2FES0ZGQUZWTm43MEl4T2Z2bUI3U052UHhrZEtGWVpTbFVOT3FQM1RLQW53N0ZVME5DVkV2QThnVnUyY3pnZXkvN2FuY0hFeFNVMjNwWEZsbCs1UzR4b1lOMW5abGpQVUovSUpIcnNoRWhsTldhbWd0V2NxQ1N6NXNyRWptUnhhckswOHN3eitiTzMzMlROblR5V1B4MlduUE1MYzFXOGNkekZiLzltRndiNmRaeTdvR05pSW9YaFlRYXVHL2l2NzB5ajRqQWMrcCt5QXZxTzNRYkI1QUtZV2RXeFhHTFlQTUMzM0xQSFAzanp1SGR3eDdaZy83WmhObUYzRzMzREJBQmdjQUlkQ2N2QXZyMGV2VThBbVFGYUpHUC9RMjlCeDNMS1pZemVsY0RCQjhlQTBNUWRoWEhmMXZVTHI3MlVlL0dXbjg0Zk1hcjVIeGNXaWkrc3pPa0l4bTB3elZBS2ZiZkdXRHltbDNXWUdoTDM3M1VlK1kzOXppY083S3JjdjMyTGJocDlhWVRWSkZ6UGhPZnFXTHhJcDg4WmRGS1NaM0FnUFFxOWV4UnNsVVBUZGVpcExvZ2liUkw0RUR4RWFjV0RPTytCR1FHNjBxN0piR3k3NjRIMHRyc2V2UDBSUU1mY0s5T24rZzh2ZkZjck9sK3ZMSmFPbXYzcCtJUVUwSGNHMHdzWXBoWU4zTDNUL2R5ZlBsVDg3TDAzTzV2TkxxQ01RY3lWVFBCVndDUTNiT2dhQVNQeEpRUkJvNStnY2VpWkxoaWo0OUJKbVN5WkJIY0NWQllYSVppRjlOZ0l0SzRNYlNkL3JnbmhCZ2hJc1c1dUJZV2Z6Q1BrSjJBUDZCaTlkZmZFNkswM2Y5N1B6WHgrOVUzMzM4KzlkT3F2Yy9PVkUxWTIvYjRCeWpyNTUxWDNieHFNbGlMNnB5UHZHT09mL09YeWszLytXL2s3dEJDWTlkTGczVnRJWlVXd2NoR21HWUpyRkY4VEZwSlpDMzVJcjhuVkdycUEyZDBIdldlWVFEbmtYaDF5MlZYYXJvekU0STMwV1JyWkxWbXdSQjk5R1IzWXNNQXNpKzRJTzdxbmc0VkY1Q2VQb3JSNEJyMjNqeU83ZllJK0QrR3MySGp5OFdmKytMbW4zL3pxVjM4bUZORDE3Sjd4WkJ3ekNWSUZ2YU1QN2kwZS9ZdUhDd1BubDRHcW5rWnkwd1NjYzlPdy9GVVltVFNNcEFuWDU4aXR1SlFzR2VnZFNTRTBHS25RSUxkTFRqTnJveHFRQmxNbTBwdDZZZlIxQXdTKytEcUI5RGd5Vy92akgwMytQTnFCMVlLMXpNYlM1TVpQbmNiWnA1N0MwSDA3MGJOanM3dzZ0UFdOK1BKbnZ2blp6M3o1OU44cm9PdllvVC83ZEpUVVZIMGRaNC85NkluUDNYM3lENGJJeFM3bWljUHVQZkFXYzlCV0xrRHZTcE9McFR6VzBHRFRoZWVVTlpYelBpekpvU2NCdThkQ1NIQXFkQng3cUp0WU1RVFZrT0ltZzErdDBMRnVKZytRcFJ1SGcrbWtUdDJHMEV6NlpqTStyazd4bDVGeU14cXFyNTdDaGFNdllOdkg3eVNmUVo4bmI4RHNzVExHOXZ6TCt5S1lkalNHZnVHTFg0bVdQbzIvL01NUDdhd1dUcUpDV2FraGN4MUJzYTVhaG03cnFOOTBVWnlWU3V0T0lySFp3dFN4RllwL0RGMUROZ0p5djhWWkZ6TGlsdWRMcE1aZU1EL0EwaXNMNk5yWmg4UllDQkk2Z1UxUmtzVEo4eVpwNkREc2tOU3ZSNWt3S2g3czRSNWl5eENXQzVSZ0RVYkh5L1NsVkdQaGNzeWtzZS9nd2VPSFh3ZDZLYlFGNURaWmRRbkcwQ1o0NVpCT01veG95bjh5R1ZwZUxHSHUrQ28yRFNjeHRNVkd1ZWlEVjEwTTdiUmdkREdNM3JrWmZUZjJJVG5haTUyZitnQTBjeGRLSndoT01BNFdqTkV4ZW1HbDA3RDdOWUpKMzA0QVlkRXluY1RzYzYvQ0dFbkNHdGhFbnhmb3pNWXcrK3FVQXJvUmUvak92WGpvOWwvQ3B4NzlBclRTaS8zanY5cUxuMHdhR0tDa01waWZnWXlzeHJaZEJKaFU2anBSMktzNmxLd1VBZ3pRUlRjcFBoWXFwSERLamprVm5JeDFRd1FKbEJmTGxPQ3NJamxzUU9zWlJIbTZDc09zd3N3a1lLUTR4V0lqY3QrUmd6SXBNZXJwUVpoM01QZTlwK0VtY3RoMDcyMjBqdHl0ZlJPOG1ST1lmLzZIWEdXNUc3Q2RhWVpWeHpiMmRGZS85ZmluOGJHN0h0Mk9aMThNRVV3dVkweVUwWjhsVHpnOEJKZVR5M09yME1pRm1oUUhFMTFHbE5ob01sczFDUnBkZkxOdmtNcVdHMGhWQWFyNUNrR1hCZWd5dE13d3JPUWdNcHQ3NmZaTnhmNWNOaDEwVW1UVmgwTVpibVgrTE56OE5NeGhDNE1mbERBcHhsYnpLSjZhUWZudy8rTEVHeWgrK0VzaXEyTG9PalpLOWVHQlVmNzlRdzlYSDhnTEMvblREajY4WDhlNUxZTllPTmNGUDFlQ05iMUFHUzFEWXFBWGhCT2hiOENoMktkektsa29ic3ArZ3FBc1ZTdmtvU1dYd0RKOVNQWDNJYjExSzNnNWdGdHl5TFdTY2owcVQraW1DSDJQbGxUV2VFVlNmb2tnVjJDUDJlaS9leCtkVVJyTzhnemNwVmxVSjAramNES1BoRWYzaUphc3FNYkNCdXltTysvOTBBSHp5UWV5bEFnZG45UFJTd2tPbi9XdzFmS3hkVzhDYzhWK2xISlpsRW91eW1WeXY1U2dHQVF2TGVNZEtZMVJwa3FDaFU1S0Rid3EvT2szd2JwSEtCNG1vM3BUZG9zMHFsbUxNN05Vdy9MbzE0YVV6V3BwSGRZSTdadk9SZ29PS2k1eWt5ZFF1WEFlMWRsRkJFdVVOQkZyVGplUGx1WXl4RHJYUGREUjBkRjF0L25LUC8zejZMa252b0V3alB1dGtLMC9peUtuSThBS1ZRd2xCRVlIRFpRR2JFcEE3YWc1enlsamNzajFDaUtaWkE0Q3FtR0Y0VU1UcEdJZVVLbFJBazlRQXBUdUlwZE1RR2lkakwyZXJGZnBoUzA3UzI2QUFxbWZ6VXloc3JDTWNLVkErUThCcHlSWmVPVEFYYnBoTkRxSGhDeFhoVHczdnBIZnN4R2JtNXU3ZGhYNjBRZnV1UGhYL3dxY21hWHMxdmFRS3dnTWpoQlZSeGI3REs2c1o1WUNNTzRqUzFDMEJLMUw2YWlFWnRRUGtNTUxoVXdFcU1ZazljbTRTTW9VdVhtSWNsNUtseFJNdFNlQjl1bGdYdG1uTE5lRFFUZUVYK2FJa21lU0g2ZjZWUVFHbFVDSVFHcFdmR3lkeGZsRm9hcFBLWmU3QVR2MmczOVlldURoTGh3N1oySWl2d0ovTW9mNWJDK0dCelY0cEJoZjF2dHlIbzFnQlhUeFJabWtRbkFaWFczWkdwUVhQRkVySVlrYnBVYTBudUFLQ1NZb2dKUDBaYWN2ak1EUnRvSUtJTXFJZmQrS2RwTDVvTnduNmdpWlVVczQra3p1bjVTek5KUlJIem1OTnk4NjFtT3FiTm1BZmZzZkR4WDNqR1Q4ai81ZUQzSzdSNmdFQ2ZIYVU4czQrNFpIdGFPR2RGYUx5c09vUmNQaXM0MEF4NU9sVWNlSXhFYUFpQjhsTHdGRnVyQTJBbGRINk1ra2l0VE1EUUl0RlVqdW1hU3NXVlRSeXVQS29kZU9qWGphTG1FU2VFTmdhWVZqeHQ2S3FkU3VILzd0MDlaSnBkQU5XTmRnZDNuNmdsL1p1NTEzMzNlM2hhbWRZeWlkTCtIa2xJdlRVd0ZHU0tuREl6cVZpWXh5SUVaWnFZamd5WUZhMkszRGlHRGpyVmo4dGlGcTI5YlhpOW9xS1g2Q1I1Z2pkMXR5TkN3VkRZclZRSDdSUS9xV0FYenNkKzkrN09MQ2R5NTg3Vm4vVU5QcEN3VzBxUWJPT1V4R01nY3U2L2FYSE54SWdUSzhOWVV0dTVKWW5QZXhkREhFd25tNjZHY0ZNaFpIbXR4Z1NzNWZwd1ZNMlJNd2FyeEV6ZVh5MkYzV2w5RUk2MjQwOHEvUnZFN2dNNWtYMFdDb2VqcGNMKzVPaFRVMzNwc01rQjNnbUM4WEtWTXU0UDZQMy81M1gzdjIrUzgyd1dSWEk5eE9BWTB1eHRkZnRiMVBQQlRJSGptNHJzRXAwblhKT2NpU1Mrd2IxVEN4eFVURlpWak9jUlJvWGE0aVVLWUxmbUZGVUEwcVlKc2ltdURtZ1p4OGkrTUhhMUFocjhYSkNMalFJeFdHZ1lqaFM5QXlvWW9tN3VvM0RJZXB4WXFkcDV6S0R4T29sQ293VTFZOVBMVUMxd2hYWEc5QVdmUHJjelBpcGR0Qy9McE5wYU5ENVRzajErcVJXcXFMOG9vSFViamNUS3BrQkZqR1BJOWdsS3VrTUNveFpHTytXaFh3L0pvU0pUQWVTMWJRZlNJL1Exanp0MFRYSk9vU0dFVlVXSExKZUV5SjFnV1U3Y3JFeTZOajJuNklBbVc5aWVFRXVlUitMRTYrSms5VmYrdFd1VFN1T3JCR0IyQTJMdGtMcjRhUDlmZmdnL2ZjYTR5a1pLKzJSREJZblB4SVpVa2VEcFV4b2h4R1NwU2ZHUkRSQTJUeUVOMjAxSklpdnNKUmhodG51WkVDcFJwREVlMFhMZVhRNG1QSzlmS0dDR3BaclR5dVJmR1VGMEtjdWtqdjc5Mkx6ZnYyb2ZENkpJckhEdE1XZzBiYzRMMEVrNzg5S3Y4Y1dIRTlLWlRWUGVRVEw5c1hWOHJ1Z2VVVi8xdjdidFgzRGZSU25FeFI5dXFLS0xhOXRUVmxwa2JObFRiR3lGWnhrNy9sYXVQWHJPRjFEWHp0MExxYzYyWWhxbmtlemNOV2gwYVFmZlEyOUcvdlJ1NlZJNmorN0FnTWoxVnExNm9Pa3RmT3Z4bHdJOHlPUURVNjVHcTF4dkc5eWNUeWprM3V2OTIwRy92T1RNZnF5NlFwQzZhUnN1TWRvcVFscU5XampVZGlEVWRzTk42d1RXMEgyWHlJSGtRaitySkdkVXNjcFNvbFIxWWFiSGdVNWgxRDZMMmhDN1pZd3NwVC80ZmlxVEpzK2NTS2taQ3RQNnNCWnF2UnJOYU9RRFd1c0NxYlllcjFRV1dKdVd1SFRvbUl3TXcwUjU1Yzcyb1JVWUppMUdLZnJBOXQyY2JWNHVzbTUwYVpIcnZaNklyV2ZIU1U5RVEzUUloQXdndWtndVZ6dlN4Nnh0YlZiT2tHd0ViU0VOMHBwSWRTNkJraVl0NUZyQjc1S1JiUEIxRk5hNFVHMGltS3MwVVE5dWlCVVBrMVlXMDB2cTcvdGthNEhZSGFDWmRiSDNXWThod014NFdvVUJhYm91Um8yMVl0YXQ2VXFLZ3BsQW1DVkZFb0d6Y0V5NCtUR05udWs0cmxQbDF3RmljK2dTZHFmV0VaaCtVaksvTDVXazBtd3ZEbCsxNExtZTBTRW4ydHJhT3ZoL1oxVnlGV3pxRDBYQVVsT2VOR1pZemhtblNIMFRGTVdTWlJGcXhGOTJRejBLRGh4cXgvMXVnZnJsbUZ0bktPOVNyRHFBMXphaEdUdVR3QkhhVHlaVEhxNDBVWjdtQTNiZGhMQU1sWCtqS3JsWjBobWN6SVhycnNFSEU5NnI5S2NWWTlSQXFQdm9SMjFpMGRDWk5CUHVBWFBmWEFLMGdhSVVIMDRNeTRjQ2ZEcUJrZnlxNVNZRVZsamp5V21ZeGpzcXhKWll4ZHJSalRrSk9rUHc4emFQaGRXRU9aVnd5c2NZVmpaMXVGZnYrNGRYelBmM3ZmK0tQZk4zNG5OVUJ1Y1ZsRWNWTzI5dXFOZ1VpWk5Dd2FVaTRadXFTYVdjOXc2YlY4ZkpiVnMxeE9rR2hRaHV5VGNvVnNEQXY1SUJsUmtKMG0rY3lTSEhKdlBXN3VzNGFFSzJYSlBqSEgwUm5iL2U1UiswczFoVFlyVTJzcVZacExHbjZseTVoT05CWmF4ZEVJNnVNL3NnN2x5Mjdoa3cvcGY3SmpGNm1MdGd3cGxsYmR0MmU3OVdhOGJBd0lyd1k4ak9Oa3ZXeUpCNHNINGdaRXRGMXROaVhxSE5WeTAvcERHL0prYkhLeDhtSHVmSVhoK1Rjeko3LzVzdjAzTDAzcnM3V2tLR3dCc3hra2I2SFlLNmJTWDlnaktMWDV3K1l5cGE1S3MyRllUY1BZUHhic2VuQy9lT1RnYmV3ajI4ZFpLcE90bFNzZWo5dDBYaTN4cVFPc2x5VFJhL0hXNnpwYzBmdzZsblRrSmhpUFhDdWo0Ym9NS3lXR1UvUFcyZWRQVy8vNUh5OWJQMmlJaDJHVHkvVnJ3MnRhK3JYMVlVT1NkQ256L1VYUGgzWUM2S1c0MlFLbTFiRGVHT3ZpUGZmdER1N1pPOEVPM0xnWnU4ZUcwSmZOeUttdE9MWnBNbmFHSWlwbG9nUXB5bkRGSmJXaUJyRXVReFkxNWVQRUtmQkZGSVBMbFBVV1NJMFhWdlF6cHhhTVYxNmVOZzcvK0xUeFdvdjZjaTJnamFNUmFIZzlBTlhYQUZwWGJSMXFmUi9XWllua0I4YkNHeWFHK1k2UlhyRmxwSmR0R3VnUm94bGJaSkkyTXBaQmlhbU1oU3hXbm9RWjlXNGx2Tm9zRFdYU1RzbEJxVkRSOG9zRmRuNnB5QmFtbHZXVDUxYTA2VGZtSTdjcTJzVER4bm96MkNEUTRIb0FxalVCTlJ0QU5nUFZHNGJXSXFsaUxkcUphUE4rTFd2VmsyMU9iRVJUN1ZtSDFncW0xMG1GWHNta3FOMGRIemFWQUsyMmJVeEN0QmJOQ3JiV0JNQUdZWW8yNXlxYXpyVVJMRitqWVg5TjluSkZteHBOTkhWWW10ZlZMNkRlM0Nac3FtZWJ3VjR1MEhZZzBlYm00dzNxQzFxNDF1WWs2SnB0em9zV0hWYldBTFg1NGhtMWRYcVRxMll0bE1yYXpPUzBjOFdpemJtdEZUK2JYVzdRWXRUVjIxSEZHbGNJSm10eDE2L2xqaHRodGxPcHRrWThaZTlBb2MzcTVHc0FiUWUxblN1K0pxZlBHdHRoelExczNzTE50bE9udGs2UzFBcnNSbUo3SzNXMmNybGhpeEltYktQUWE5cmxOcnM3M3ViaWhTMDZTV3dOZFdvYlZDaGJKeGxxbDkzeUZva1JiNkZZM2lLT2ltdTU5ZGNNdGRrVjh5WmcybVdBWEUrZGJJUHVWclFKQWEyVXl0dEE1SjNNZHE5MEw3ZlZqRDdIMng2NHZEU3YyQXJhZXE3Mm5XUzZZaDNYeTl2QWJiWHNpQ283M1p4djVYNUZtOXFTcjZQQWQ2ck05Y3FXOVdJcTFxaEJPMXFMZHVveFRyRk9HZEV1SHJZclVWcEJYS3Q3dEY3cHNoNWNyRk9hWEJkUC9WMHUyRlp3c1FGNDdhYXVOdHIyVzZzK3hRYnF5NDQrbTN1MS9PRXBzVWJ4MzhwRnJ3V1F2VWZuc1piaXJpcUlWeVBRdFM3T2VtNVpYSVlpTCtkNzExdW4vbS9MZXdoNG93RFl1d1I1MVFOOFB3SzkzQXY3YnY0VGtjRDczQXhjZXlad0hWdEgvNnlOc3ZmZTFKOG9WMENWS2FES0ZGQmxDcWd5QlZRQlZhYUFLbE5BbFNtZ3loUlFCVlNaQXFwTUFWV21nQ3E3WlA4dndBQnlORXJQUFI4UHB3QUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzBRMEV6UmpZelJUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMFEwRXpSall6UmpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOak5ETkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalJEUVROR05qTkVOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtaNGcyY3dBQUdJaEpSRUZVZU5yc1hRdU1YRmQ1L3M2OWQyYnV2UGZoZmRyclJ4ekh6b01rRGlFdlFvQ2tKRTZCUUFNazBOSldnWlFXUWRXS0ZsR3BWVitvYWtHbFZWRUZsZHFHVUJCVkJFRXFsRlpRR3NvakljMDdUcHpFVG15dnZidmUxK3pPN0R6disvUTdkMmFUOFRDN2RocmkzWGp2a1k3bmRlZk83UG5POS8zZi81OHoxMEpLaWFpZFBVMkxoaUFDTkdvUm9GR0xBSTFhQkdqVUlrQWpRS01XQVJxMUNOQ29SWUJHTFFJMEFqUnFFYUJSaXdDTldnUm8xQ0pBSTBDakZnRWF0UWpRcUVXQVJpMENOQUkwYWhHZ1VZc0FqVm9FYU5RaVFDTkFveFlCR3JVSTBLaEZnRVl0QWpRQ05Hb1JvRkdMQUkzYXo2a1paOU1mTXpJeThuSU9GeDJQWC9HMUNhYW5weU5BejJBVHAvbmN6dzNnQ05CWEgwaHhHdURLMXpLd3hnWUJVM1RwbmNES2pyNzhuSGd0Z1dwc0lEQzF0bHV0QTloMklJTlc3d2J1K3YrajE5TjFpajU1VXdxOXZRSzN2R016QXRmSDFKVEU0UmNxMkRFR3pNNjQrUHEvbFhIVlZWbkU4b25jenQwOTV5Unk1cmJqQlgvMExXL05qL1gyeDNNSG42MWw0d2g2VERNd3BWM1hVQzNMVXNHeDZxNVczVDRjVkNZTEtQL3dRVzBtblFobVo1YTB5ZjNqK3ZIeGtsanFBTk52OWVYNzNaZ2JtYUtYenkySlJ0bkI0b2txdGc3Rmh3WjM5cnpwWTMrMjQ5cWRsdy9zM1hGZS9IVlcxZXJ0eVhHOHBROTMwWWQwTEl5OU9RRjRmTXJodUFjcEJQVUVlNEdUdzBPam1zQzJRUTl2dk1nSEQ4WE1nZ2V2WVZlZUhROE9IcDNXOXgrY2pEM3l4REhqZ1VWUFRDQThTOWpSd2RoMUw3L3JpNkg3VXVqSkF6ZGYzd2V2S3VGbjg3ZkhCMUlmdVBDNnNWOHcrM05wb0FRc2x1RVVKRUV5NEZveHlDQUdYWXZEaU1laC9oUk4wNkVaR3R4cUdSNkJkTDBBWG1FQ2RyVUt5eGF3eVh3LzhDSFlvZnRJbWhMQ2NPR1ZHNWllOGUySFhrZy80VG51L0NVWFp3WjMzM1RidVEycnVEUnhZUHpMUDNsaytpL3UvbTdkLzhOYkEvbkZlNEJrVXNEUXUvOGRENDdQUklDcTlydHZqU011WFh6NHQ2LzQ0TWlsdzUvSzdjeGVCUFRBTGIyQXBhZG5DVjRHOGZRUUVqMkRTT1J5RUFRUkJzbmprMHh1RFhhaGpNYkNIS1Rud096cGc1Rk93UE44V09VSzZ1TXZvRkYzWWRzQjJlcWlZVWw0dm9SRk5qc3VUeUVEOU9jOWJCdHlFY3NLOUYxOUU1SmpZeTNWdFdGTmxKNnA3WC80SFJmZFdSdnY5NlEwVGF4TFFOZVY1RG8xRisvN25SdnUyZjJlM2JjQnRYQWdwMzV3SDBSUlEvN2NpNUhldVFzd0thdE9neTg1Qks0RzRYREFZenFzNlZsWUZSZkpVUnUxeVZsVXB1Zmh1eHFFb094eXp0WWFQdXAxQjlWYVFOWlN6cTBBcGFMRDF5U3Vlb09Cc1dFZ1laREJUaDNWb1dzSTVpalFlQXFJWjhua0dNeXgxQVZtYnUvRG4zemIvMXp5dC8vcVRhVTNtK3RTZmRlVW9kZnNHRDdwOFovK3daN3YzdmliYjc0Ui9tUFV6aXltL3Z0UkJETTZ4dDZ6andPYkFzaXNackdTSUhvNkF0dFhJWlJTNjZBMlZVZHExQ0VyajhPZEN3aVVnOUx4SXVPd1RWQURWQllJS0ZucGtKSHpzdzZLUlE4T1QzYkxqVEZzM2kxZ3pSQm9CYnFRU0Y5MkhUSmJjK0huMkNjbTRWUWRaTGZ6dThhSE1mbjQ4OCsvNFJlZjJaMnNCM0pUandnblMyZDc1SGpFMExDOTliYTlOd0wwSkNLRCt0UUVyS05sN0h6MzIybEpLS3RWeFZnZHZvcXRUc0M0VjRmUWJFaFJKYUkyY2hjWnFCNmN3TXk5aDlIN3VoRktyd1V0SmhndlRWUUtOU1N5TVFqYnc0a1RkZFFjQVpGUG8wZTQyTHhOUTJPV2NkWlZBZGlEa2U5RElwTUl2MC9weVVOWWVtS0tjeW1MOGpOejZMdW1oaTE3ZCsrNjY0OW0vK25qSDMvK3cvMWI4cHdTY2wzeGRGMFY1K3RWRmE5aUpBYTVrK0Nna2xtbzJYenE1SzhwZEoxZ05sTklJV0toOGdXV1RtVTBZZmFhU1BRbUVjOGxsRU9Dbm1TZzQ3RXFUbHFlaXBYS0dBbVVxd0cyamphbmRORHlzVUpuWEtXOEdya2tKWHdTNWYwRmpGMTNQVWIyM1lEZTdaZWc5TUJ4MlBOSGNQUEg5bjdvenRzek44eE9XWWh6MGxEeFQrb1JvQ0V3d05FZi9JajNCam5JQXViQUlMS1hqdUhJOTMrRW9GQUI4dmt3bHVrWkF6RktuWkZNUTlQNytBY01FN2V0cUQ2Zmc1SGRqaTIzWDREa3Bnenk1ekQyMFlrR25vMVVYa09sYUtOYUQwS2o1QWNDaXdVYkk0T2ltWnkweWd1U3dKc21Kd3RCYmt5VTBIZmVCZEMycUlKL0FxbUw5bUR3OGh0UWVtaUs0RmZ4a1UrLzRlNkU4RkFzdVpUeEFJNzlVdCt3Z0RvME5LcmJEdk5FVzZKeTRFbVVmL0pOZ2tCUWtlRUFYb0w4bGNPWWV2Q0hLTjMvRUx5S1ExUEUySllnV0VhTTZZbEtPVHpvcVRqTS9CTHEweVhVajlvb0hwcEc0VkFkWGkxRDFnMGhTRzZHU0tUaCtEcXFEYVkwZksrZU5wRktLVURsaTk3R0p4WnhUaGpwVU1hOU9OSmoyMm0rT0VRQmFWZm41d3dOb25mM3RTajk5RGo2ZC9WdStmVTdOLy9HNGh6bFBxc2huUll2OWcxYldFanExZWFzb2pUVzBUdmllM0ZaZk9BWlVaazlnZDY5RjlDRERLUC9kVmV3TDZDMC95aEtoKytITnQ3RFFkL0VubSt5TkpFTTlUSXhzZ1ZhZkFtMWVjblVKb3ZVU0M5OGhVUFZnak83UU5VVi9CeURVcTFjTGhsSUppVmlyWkpCaTZRQkhZNnZKOVNMNnR0QnBIc0lkZ0RKM0pYMmtjZFFZcmR2Z2JVNEJ4U244ZDZQN2ZxVHIzNWw5aDhucGdPa2t1dEQ3TllVMEhlOC80NXdLQzFYeC9pQjcvMGxZZ1ZxcElieWdSSWw3d0hFdHFSaGJobEFabXdiOGhmdkpITmRlS1V5L1BJMFBIc2FUcG1teDlZWnQxUWNwZXNWT2hMSkpJOWo3amsveC9NeVBXazRxSjg0QVpzcGkwT0NXM1RHcmdLT3ROUjA0Q1NUcng0WUJ0TWRId1laclNSZXBVNkJvL0c1QVBGZU5ST3F5SjEzUHFyUDNZOU5WMkh6amJjTTMvN2xMODNjcyt1OFpETVdiMlJBUC9YWkw0UzM5Q3Y0OHp1dU95OEl4cUhIQ2JGbndDMlRNYy9YNEJ5cm9ab2RSNnlQUm1ld0grYklJSktEUFpSUERRbWh5bmdFMldxUVJRRjBwd1VLV2FpWkhtSk9EVzVsZ1UvNVZGQTY1QmdkcVNGRDV0cENIYXFkdE5TaWFhcjZ3NVRIVXk0NkVab3BGV05GWExHVWp0cW1VNllKVXJtd1NOSlJGU2Z4S3g4ZS9mMXYzanQzVDkzaHhJcEZxeTFoVStOdzJiWFhQbHQvNHVHcll4cWxqUU1lbXRjZ1J2ZXFhck44WExIaFRVNmlaa3hDU3l1ZlFxUFNsNEtmTkFsU0FtWkdEVFluQWhudWFXcVNXUEJFQlU2R1hOUTFCRXNTeEFSZWd2ZUpwcVR4OGhrMGhmYVNLVktBQnBiRFZNZ1A3NGVUZzVLcnFLZkZhdkE5azRDbkllc1ZwSVpIT2RsT1lPZUY0dkpMOXVZdWV2alIrdE9EQThiR0J2U1dLeS9oZVBrWTJQTjJ2T3Z5eC9yTEtSTXpaUjlEZVE4VlNxbnlJZ3g3SEc4T3ZtVDhZLzRJSjB3NzZZa29wM1MvdWxGbTU5TTh0cUh6T0dXWDJjbFhnaHFIUlVjYk1GN0c2alF1ZkcvTkY0Z3piWWw3cWlxRWsxWkVGYmJWc29Oa1FyMmJRSG9xejJIODlGV2F4SmtWZVBDdEZGV0VyNWx4cGtKNXhFVUI3Mzd2d0lkKyt0QUxuMGpFTmppZ3p6MjlIOFdHYVZ6NHdtZS9NYlFWNzdycWpoMzR4cjBteXJORjdCaHdvUk9naGlmQ05FTXhLV1N1d2tzeFNkMVJ3ODdYUWdiek9VSGpvb1czeXNPSTBPUVl2Z3lkYW1BRmpMYzhsbUFxMGlueVdSYi8wYldtNENwQzhyTU1uaXpHeWVLSDlXRTNuSEJDZlRCbmw5UXE4Q3RVQkRwejNXd2drZThIcHVhdzkvV0pXODhaTVFpb3ovZHVZSmM3TWpxTWEwYUNiMy9tRm12ZmtveGo2WEFENzcxVng0RkRRM2o4MFFwNmd3Ylo2aU9UREVJRDQxRk9GYmhCeTVZMndXMjdEY0VrWU9FaUYrOEhJanlPWVJFYXdkSjVEdFcxOEZpSllsa0IyaUpwYUhNMWFLNUZhU1dJNUxkMGJNWlBBWThTNnpRTXBMYTd4RGhBZmFwQlIwM1o3ZHNFYTg3RWx2N3F0cmZjMEhmWjRZTzF4L0k5eHNZRjlQd3JyNy91bXRqWDk2bWl6clBUT2dFa1dDY2NYTmduY09HdEdSeVp6V0xpb0FXM1lNTWtjN0ttUkRZcEtZbFNwYUVodVVUTHFZWWd0c0JVWFRsT1ZiUVJyY0pCdU1DcFdNbm5HM1JoVlVldGliYlYxMVZhdzE0clcyU3F4NVNLOG1wYkVNeHg2bk1ObUVNSkxENDREaU8xaU56NVcxQTlNb2ZHb3NlSjBVTldWM0RScGVsM0h6dFNleXliT1VzWmVqcGJLci93OS84d2N1enVyNFZoYW5uNVdNU1prelpvakRpdzJ3amNPVmNZcU1vTXluVmdidHJIaktyTWxOUjZKdU1jdFZOVkJRMnlMVUVtcVJDbU1nM1JBalZjSGlNemF3eC9TM3gvZ1dudlFsMmdVTkZRcUdrNFB1czJWOGRhQlBWNGJDeE9PWlVFMDNVZ2FsWFl6RWtUZmN3L3pScHE0MlhFMGpYa3RqUDNkUmFvRmdra2N3T2NKUnEyajNodlM4WHNQNDVSOWxmNzIxL3RYUTFyeXRDYjkxMHg4K203Z0NNbmdGN1RRWWtTT0RETW9XM0lzUHhucTN5bVFCWUVMdnBJdDAzcXRURURkZDhJVnpsVXR3bGFNM2EyZ0dUTUN3aTJwNWswT1FZMEdpSlI5K0NXUEtRWG1PWXd0MUZleDJrSUxKWjBwanhhS01OQkMxaU5PYWdXTVBkVWVhM2RZRm9xNGN3ZlkzNDdnTjQ5ZzNDcU5weTVldWpOVlp6V09hUGNSUTNEeWNwbG5GUjk4MFc1dVBydTBMTlljZzk4NSs4SysyN0o0c0N4R001ZFdvUjdxSVRaWEMrR0JqUTQ1WUFwaUpKVUVkcFBUeTJUMVNUQmNna3dBVlFiRGdoa1FtOXRCbExaQmUvNWZFM1Y5SVZURG5OVHoxYUZldzU4amNhMHdWeXhSbWtsaUFibHZWUVJLRmNrZW5QMFB5M0hheEFrcDFTbHU2YjVxUmFSTy9kOExPeWZRbU91aUhnbWdjSlRNNGluOUphZ1VDbU1BRFpaMzI5VTRtWXFkdVV6Qi9DZkc3YVdlKy9uUDFPNWNEamozdnpCSHBUMkRGTldmVHoxWHdzWWY4Wmgzc2MwSTZjaEhtc3pMVm9MWU5VTlZWUVNZUm1QWmhRZUFmRWFWTkRsemp4R3VnYmpvV0tTM3R5YVFnb2JocEpWaEVVQWk1Tmlmb0VUSUxHY2lLcmdhOEJlTEhGeU5NaDRGMzU1Q2RrdFcxR2RhTUF0MTVBZHpZVFNJQzByTkZacWQ0UnYxWGtPc25RVHJqZzB0WUZYVzdJRCtkckVsRnZ2OFdxNDRZMHhiTHRwRkFPWFpuSHdxSU1mM2xmSGdjZHNsSXBCQ0dvbUxaQTBFY1pKSWRwRVRiU0QzY3hibFNOV1hUMVdPZXF5dTFYZDBHVzRkU1N1YnZuYU00ZUQ4TDNLV0tuekJxRjc0blBXSWpTbkNLdTRoSGd1QlRQVEQ2OWFDNnRJbFlreUdlNVFNWXJ3Q2xNUU51bXZ4ekhhNTEvbXVSczNEeFdsaHFncDB3bGI1TjFDQXp0ek92eExVeGpibmNROERVdGh4c2ZjY1k3M3VFU0d5WHlhYmppVlVPREtFTmdRM0ZhMUwyZ1dkTUljMDllYVBZeXJyZGQ5eGxxWHpMUUpXTjJXZE1naWZPMjVZNVJ4eG13RnRwSjFkWTQ0UkppeUJQVjVCSTRKbjBwaDltYlJtRHFCUk14RklxM2U0OE8xNXhpZjFlWTBmaEdhcksyRHdhNFVQNk95QVFFTkNmWXZUNXJPKzkrcHJLWEsyelUwR005UWFpQkh4OW8zb3VIY3NSZ0hYMkNoRklTeHJsU1hxREZ1VGkwU0FBSmt4aFNTYXMxVGhpbktjaFZQdG5iWXVxMWlqOE9QcURzQ0ZjYlNKWkpwaVlaSXVWL2xycWVZdWhSNHZrMjl6VlJHbmNSd1pXaklQTVYwYXg3T2hDcE5hVFJRU2kxOE1sc0wzYkVqYWJKY0dlNGdkSG5lZkVadUg5a2tCMllYeFB4R0FmUm5mbWR5YkZJK3N0ZkgyMDFtQWcyYVI4RVk1eEFFYTE2NUlDOE1sMXZVNWdVQ3JPcTdqdHJFUUdCc0cyR1JRVlY3MUc2RWNHOVIwRnpUbENyR0tjQThoYmNNVXhpZEtET05EUUZXcjZzSm9GTmpTMlRXWVNyQTREQkJVaE5LTFgrU3daNHF5UFBEMDNSZkZuTWV0YVVwbkNqOGdNVlppeTdaUS8rUVNaZnQ4TndHTXhlbEltcmRJTmlLQlcxREFDcTYzSXIvZmRML2VIOFBYdittNjQxaG1rZFkxU1lBeXZ5RVVzbmVvQ1RLbWg4eU1Wemhvc2MwUk5ObjVsWEtrbXp1NjFFYjNrSXdXenM3QTFlR0RGTExaZzBPdU5xVnBHcTR3cWVaY21pNFdqbnNvODhHdVBweXJSV2JSVGdwWW95VnR0RElZcG9laW5EZ05LMjBBbEl0cjNuOGZ2UEg2OGdObXZSUmxITXFnQW9GZk84dzFuQkQ5bG94OU1YZm10ejl1RG16V0xPdldWaDB2M0hacGZwbFN2clVUZ0tYTEFtTDV5OGVMY0t0SVpBdnhjcjJIblI1SExRWTZ5cTJ0alltQ0syNVFUcE9FTlFDZDVMeVBsVUlNRGNYb0MvZjNGaW9QaXRHS2FpcnloRmRVa280Y0JzR0ZZTFBMYW10bndKRFl4bk0weHdWcHV2b0hURHBjdU44VzRCY1V2YTNmZXN6RHFxMlJsSzcvSU9oVVBtK2RTaXg4TUtFL0VyREFvNU1TRHgzS01Cc1FZWXh6cVRKVU81V09WMmpWWnhIcDhOdFAyUDdUNUZheFFhdFZYaFFKa3JGM1RTQlNSc2VFcVN4MmdsWWQzVThkWWpuTjBVVEFiWDhWbGZtU01KU094YWtRek1WTk11QWpLTXEzM1hLRHJMWkJKSVpJOXhQSEtnQ0I5K2NpQVVaclA2enhkYzhRN3Y5Q3V3a1FGVm5maGpidlV1SHk0R1puQWl3Uk9rdFZoQnVrMVJBcW5YU2hLR01VRk1tMGRweG9IYnFLWmtOQy9ZdGpRN1pTY24xS0kwdUFWRlZJRVBGWmNiZWVsWERraGRIemFCVWtsbXhUVEhrU1AwblppdTR0bWFGcVl6YXU2MWszeVJMYXpSckZUNXY4Z1c3SnBGTWFTSExuYm9icnViRUdmTTlteExzQldGSThEMFp3OG0vYWp1alRGMEx5VjN1eTJDcTcyQTBiTWc2WFd5SzVtajdOaTJjN1dxWGU3bEdFQ3hWNG1NY1ZHQzVUVk1qcEd6RnlTQmtvQm95ejVHdHVyQ0t3eXBBVWdwNXExSkxpeFQxK3VLSWJkRVpkelc2WkEwOXdrZStXRWRwdG83Rk9SZUhqeVZ3d1M2NlhxdHB6dHhLZ0VTUDhrb1NXV0dqb2lVNU1lcGhWY0x6bXI5bFV0OUhmV1lzWkxXRGNpUFJhQVB4ak11dXNRWkFMak5UV3daVEZVYVB6dU5RYVltQURqQjltUS9yZUtIREhXQmMwM3BsdUN6bUtsZXJLa084VmJsL21GcUVxK0JOczJReDVpcUdoeC9DTjJzeHZibHYxa0J6R3dwMVZDTjk3WXFMeFlLTEphWkRXa1dIVVRXUUNqVDgrSkVBdTNkb29TS29mV0VxN3FaSTExcmF3T0o4SGRsOEhOVTZXVjJ2UW1xeDBJUUpvaG5vQ1VvTTR5M1BXM05FcWUxdmxXYzZuaHBuT0hhdXlOQnZQeHQvOXNKL2Q3NzJrVjh6ZmptMWlXbkpnZ3hUREZYYWErNEVhVXFycXVQRzJkWGU5b3dxSHNTV0hTNmFXMU5FMCtVR2RFTysrdVZabWZIT2J1NjIxOGhLeGZZR3BWZW9QVUNlQVZNVjVwUE5iUzkxeXNDaG93SjdkZ0R6aFdiVnllWDdzMzBCampNMU1ZdEZKSG9IWUROdlJia0lQYzc0MlhDaGoyeWk2NjVqZ1JOeXNTb1cycnhKMENhOVoyMWhvVnNjRFVIOXErL0ZQN05VczhzZmVLZitXN3QyNjFBbFZ2WFRCOHMrMmUwdUYrTWxLYVIySzRTQSs4MXRtTXRwUzdNTEFpdENFeU9sQ0ZmS1ZDa3dib1pyMmZESjdLQmxvSlJDeC9sTm1FWmh4K1ptRFZuSnZIcFBvdUlqMjIvZ3hMaUxiZG9jM053Z1pESk5ZMlJCRzBuQm9ERXl5bE9ZV1VxNE0yVjlIQ3RmdytGVkIxWmJBekM3c2ZWRktmN2kvWW03UHZGNS9Pb1h2K1I5NjZuSGc3cmFJcHZPTWNmTE04bFBOWXZxbW1oenUrMjEzT1Z0S20wOXJPMHUxM20xWm8xWEZYcVV3VXJTUWVmSnp2Nk14R0EyUUUrU3hvWU82cUg5a1Bsc3E3NnI5aW94Z1IyU0hxeGVFMGRQQkVoV3B2aThBMk93RjdwS1phWW1rS0E1ZTN3OHZuK1JHUkIrOWxvT09Oc1ppbFdBRlkrY01JNDg4aTE4YnZRSHdUL2ZzTWQ3MHlYbmltdDJic0dlMFVIMDVaZ1VKQlBOM1FvS0lNVk1WWU1ORFpLL3pOeVhmcS9TM0Q4a3c0N1dmY2R0VnBnVVlnMUxRN0VxY0x5Z1R6NC9aeHc2TUswL25YMU14bmFNdWg4ZDZGRmxRWVJiTjIwaWRVNmZpNGRUYVFRekRXenZuY1dTUFJ0K1RwcU1Wd3Z3OXoyZCtJKzFCRE1jMEZmcjU0U3RWZnZPUWtKNzNGVDJQdDdSWTYyK2JKYVczeU95Y1ptOGVOUS81OXloWU5kd3J4d2I3aFdiTi9YSWtZd3BNOHhUTXd4bnVscEowVVRURktrbExsVlVVQTdVODVybFFlYTVEUTU4dFZUVHlyTkwydVJjV1JRT0YvUWp4NHZhM1BpaVZtZ3phN2p6YXVjOXYzZWJlNVBHOFZsaUhGVWJyZFUrWUl0cHkvM1BKOUZINmJoNHVCN0t0TXFUNzNvZ0t6LzMvY3h1VjVlS29jcy82VisrVnNPTEY5NTR0WGNzbkdsQXRRNUFZMjFBZGdLcXQzVnRKVGF2a01DTDA2bFNkY3VIMjQ2WG43amUvdWdkKzl4cmswYUFTcVdaWjJaamxONDRIZkhCTkFyVE5mU2xYQnd2NTcydi9qaDk1N1FkZkFmaFJ0TVh3VHpqZ0o1SnllMTI2WmpsSzQxb09PbDNZRDl6YkVmOXAyc3NYbkVCb012am9DTjIreDJQdzgvK20vc1NmMTIxeE9RdlhlMjhMMjlDcjFKV255dnl4c0prclY0N3ZLRHRQSExRUHYvZ1F3Y09QakZ0THg3dU1EM3liSlRjbFFwMG5kTGJlYXUzc2JSYlVXOGxZRThGS0ZaNWo5WWxiMXllZE8yTWM5cHUzYmJiOXQ3T3pyT1NvYklqTDFzZVRMOXQ4Tm9IMEdpOXBuZE1BdEdGcVdLRmxaeVZHQ283WHUvMnVKdWF0SVBxdGg2N0hmRnl0ZXNhblJXRkJYUU1XUHNnclNiSDdXRHFLNWZlVjR5bnAxTWNGeXQ4aCtYbXQzMGYyUVpZSjZqdFBlaUlteEpuYWVtdnMxQWRkRHpmSGxPN0FhbDNLVWlJMHpCSzRtVXFpT3d5OFRxNzF3RnM1K00xQVhJdEpMZXpVaEtzSUc5K2wwcVNXSVdkMm1reVZLd2dmM0lGaHJZelUzYVl1TTVidnd2d2EzS2R3TFZpYURjcER0RDlBb3VuQStTcDJDbE9nNWx5aGNmQkttenRCbUt3bG03M1RGZUtaSmVscGFCamRVSzBQYWQxY2NuaU5PWDJWR0N1eHRCdWdNb3VvQVZkamxuVHEzZXVSZW12bS96S0ZYTEw0QlFNL1A4eUU2dkk3MHJBZGhxNkFDdGZZM2ZOY3RHMTJzYTUyanFoWENVZXJwU2luTTVWcThVcUF5MWZKcmc0UldxeVp0ZWlXdXVmSEo5cUFWaWVJcmQ4dWNXRTFkaUpVNEN6a25sYVY1YzBYeStYaHBOZGt2L1ZKUHAweW51djlIdXN4cmgxZTEzNjlYZ0JaTGxDZFdlMVlnVitEcURLbC9uYXVyd1E4bXZobXZOeUJiQk9Cd0R4Q29GYzl3QytGZ0Y5dVFNclhnRUlyOG4vcStXMUR1aFpEOG9yYWV2cUV1VlJlK1V0K3Mvc0lrQ2pGZ0VhdFFqUXFFV0FSaTBDTkFJMGFoR2dVWXNBalZvRWFOUWlRQ05Bb3hZQkdyVXozUDVQZ0FFQXdPZzFGQXNwM3NBQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzBRMEV6UmpZelFUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMFEwRXpSall6UWpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOak00TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalJEUVROR05qTTVOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCs2WWJaa2dBQUpUZEpSRUZVZU5yc2ZRbVlYRlcxN3IvUFVFTlhWOCtkN3M0OEVVS0laQUlDUXNJWU1JQWdvd055UmZUcTQ4bFRyb0p3QndOUHJ5QjZWWVNuOStPaVBnZnUxZXY0bENjK0JjbEZJRVFnQkFJaEpDUTlwRHM5cE1mcXJ1bU0rNjI5ejZtdTZrcDNwenJwcEZ0U0o5L0pxVHJuMUJuMnY5ZGEvMXA3cmQyTWM0N2k4czVabEdJVEZBRXRMa1ZBaTBzUjBPSlNCTFM0RkFFdEFscGNpb0FXbHlLZ3hhVUlhSEVwQWxvRXRMZ1VBUzB1UlVDTFN4SFE0bElFdEFob2NTa0NXbHlLZ0JhWElxREZwUWhvRWREaVVnUzB1RXpGb2gzdkc1N08yR0hQRVdkWXRLYUFxQTdNVm9HNURsRHQwa3JIYXFrWHpxSzFodllIZEJXVmlvS1FxcUJjVVJHaXk0dEU0eUN0K25qMzRCemNjV0RRNnJvdUxGcmpkSDJEMWhoZG9JL3UxMEduTmRNOU91bGUzZlE4KzJoZmV3Q0lCOFR2QzNqWGw2Y2c1MW1iYnVvaURhaUR3RTB6ZEZ5eFpDWXVzTk9vNmg0Z0pHdUFVSmpPOFhXS1JTMnMwZE1IQ1RwZDl6N0x6c0RHQlBDUTc2WUoyTGEzRXJCeU1jVjFtZGNiRERyZU53UWs0OEI4dXIvQzBOMFJ3elB0SmphSGdKOUc2VEFLQlBkNExleDRaODZQSnFHWlBRZUJqOWNFOExsM3I4YlM4aEt2a2ZzSnpBQUJHWTE2NTZpYTE0STJIWE44SU1RcnVOemJyL25IK1doQSt2c3pqeUMyVFBFNlNlWTZKT1h5dTBhclMvdHNBYnhCNENicE8yMHJJOVNKNkp6WEd0Ry9yUnZmcXdBZW9FZnRjYWVKaEU0NW9MNTZuVXRnZnUrQ1piajR2RE9CZ1JpRHlUVm9JUlYxOVJvQ0pES014RU9obGhaYlZXVUVISzE2VUlJaXdPU3VCNWJyK2lneUgwQWZSQUVPOSsvbjJKYjhBUmZmdVBodXlwTVpYY3d5MHJCSi9Ibm10N1NxcWllNVhUMjBKV0RMNmV6RlZVQnJOL0Q5elRnNHhQR0ZXdURmK0lrT3FOQ2UxRDduOVFLLy9NeDFTNnZYcjNhd1pZK0QraVhMTUhjV2dXcXBTQnNLMGltYjFKNEp3N0JobVdUNDBoWkJJWXlsQ2tjWVE5dVYrNlF4Tk1WbmswQng0TGdFT2hsWDhkMngwckl6aUgrdVkwbWtYRTRHbFBTdFk1bDBMYThkckhSYWZyZWRySFJuVkhzNDdJSGIwa21HbHBUdDFTdUFGWXVCcnowT3ZObUw3ODRBUGluNnpna0pLUFBzNVVYOXdQLzc0bTNydEZPWDF1Q2Y3bjhCTmJWaDFNL1FFQjlNVVVNNlpMZW8wVWtmbW9aRksrbFkxeWFBSEFSRG5EcUVLMVZtUU0rcVduRmhjUXNoc1dJckFNaEltYmlueTBlcVlwNzVUZVpZNXZmK00rWTJqMURMaGlGdHFXUlBUVzNBN1JjRGF3blVXeDhGWHUzQlV3M0FlNFRRbjFDQSttcDJiU3V3NWY3YkxsWnV1bVVkYnYvYnI2SzZJWUVTQWtob3hGREl0MlcrZEdoNmpzM3oxYXl3b1J4WmxldnlrUUJraUE5SGx2UXdIekJ4N1l5eXlCQXRjVjFobzRYYVpybkdQZWNqSDBZYUdDVDE4dEpMd04zdklTcE9LdmlUajVDazl1UDNkY0JsN2drR2FHVVRzT3UyYTliVzNmUGdSM0hqaGp0Z0RNWng2cW5rRTZTOFJoTXNsdnNrU0lEaFNSWWpGYXNTS3hYSUNadXFTUldxa2UraUU5VlZTYjA2RHZmT3A2MTROOXZPQWlxTzJZNUx4MGcxV3k2QlRaL2wrN3Z5K29yQ1NVWFRQUlV1OTR2enVROWlSZ1ZuQ0ppd3FXTHBJRXBlUjM3TWorOE1JRUVBZitMYkpucE4vRXNsY09lTEo0amJvaEszK05sVjU1OVRkKzh2djR2K3B0MVlzVzREcWtqVjJyWVFQVk5hUjAwUFVNTzZLQ25SU1ZyRFpMOENDT29Nd1FEWlFCSkhsYm4wbVM0bWZtS253TncwbmMra2VIRXByb0lsT2ZKYTNQOHN0clpsU3hVdWJLeFl4V2VIMEhJYzczZkNIalBxS0pZdDdMRWw3YlpCdjVIMjIrTHl2RFNwL0NUWmJORXBoTWJvVDdyWU14akdSYXNDdU92R0lkejdXTzhkYVlzL1MrLzYyM2U4aEs1ZzdQcTBxdjdzMzMrNEVhc3ZQQWtkZTNzeG8wYVZoSWFSZlhUU2ZaS1NDa2JycEdOd3pMZ2tUK0l4SGFLWTNFeDRxczhWa1FHUHdycWtveVZUZGJPMmt3bXl4SDJLd3JQR2svbnVEWk1xbHNrTHN4eEdLNndmVThUejVCeUQvM3VtU1NMRzZDWk1NbW5aOWVTekgreXpFUTJUdmlDRWIzMHdocjM5N3Y0OW5NOTd4MHNvM1hCcndPV2J2L3FGLzN2Qm5VUXFTa3FCUnNLd0xDcFVuYWZLaEcyMGZOc25WRzhpNGJzZHRDTmxlS0FKWWN6NG9obTdtSEUreFhGeEREd24wT0RtMk5EY2FJQVBXRUQxQ1pUZktVcUNuaThxN2tsS3dqdE9Qd3dvV1lZZW9KY2g0VVdTekVRMVBYK0tWTzU5dndMMjlhT25qSHpxRXlLd2NJWWZtenNBUEhYaEVsejBwUzk0b1AzZ3gwQjNyMGVDVElNaGJYSVlwa2FxVHRoQlo5aWZ6QUFGNXRzemR3UjNnZTlhRGt0cWZpUW5uK3hrZHFvNUpDa1RvRkJZRm14d1V2MEVjbG5JbGk2T1RuN3dZSkpoeFJ3WE41MUh0cDg2M2IwL0E1NXV3K3V6Z0N2cGNzMHZuUWcyTlBPS000RU5UKzNCaXpNZndlbGYzT1JGYUg2M1E4V0NFS2swMG5PQ29EaXVUZzFuSXh4MGhuK242MWxnMkJoaFBhWm1XU3ozR2ZEd3Zma1lZYXJNZFh4MTdQcEJDbkdOSlBuQ0tUTUFsckRSUnNBcTlIeUdyYUFyNWVDS2xhNlUzUC81YzJCekczWVFtT3ZvMW9OVEZRNmNzbGl1MEdaRTd6Zjg1M040WS9rdk1PdU9UeFBsZjh0Rlc2ZEdObFdvV0dLMHNrRVY2YllNZzhaeXBNei9MTlZrVGd1S3pxSHF2clRhMmJCZ1JoM25nc255T2xvKzRFSktVNmFPaU9JUUF4YkVpZGcxaVhOenA0dFBuV3ZqNnJPQVQ1Rzc4bFFyWGlNdzEwOGxtQmxUTUNXTFB5UXlRTzdtMWQ4Z3A3eWppL3k0bXpsTUVibHhtUjlqNWZJUk0zNmo0dnVnd3RZSnYxUklLNUZoQkVMZXZoR3I1bTBsdUlyM1BST25sYXQvRFFIODhMbkt5RlVHSXhRUGVVMzFETEs0WjJjL3NIS09qVnN2QSs0bk5mdEVJOXBKNDF5cVRqR1lVd3BvQnRRSzhzMTdPZTY0N3dIZ25MT0I4ODl5MEhYUWxiRmFSb0NLTlIrc0RNQUNFQzJRWFROQU1KWUZTYXpJQ2U5bWdKTWRnbnBVSU9qOVZzMEFuM01mWVVlNWJDSkZkaTV4ZkNqTkVGWXNmT0VHanNlM0FvOXVJejhVdUp4Tzdab09veTVUUHNBdE5HQXQ4UFhOZS9HWFgveWFIUE9iaVZXR0hCbmgwZFFzQ0llQXlrZUNHZ3lQQkRFanVTS3dFQi8wSkh0b3lBTmJnQmd1OVk1clFRL0lqT1NQQUZRWEhjRjdDRTNqTWhiY0g3TngreFV1RXNTMnYvUmJHYWkvZ1c3MTZuUVpRcHNXR1F2Q2tGUDdmdmloNzBNeXlSdXVjdEhaNDBoUW1PcU50RWl3dEpFcTBiV3owcWlIUEZDRlZJbE9NRWhxc2JVVk1JaDkzclpwSmI3MisydncvaHZLMGRvRXhHSUVsT0tCTHYxTUowL1ZhcjQ2VnJOdVRvRE9QZEREc1hHbGczTlBCZTc2a1J4WStBYTVKeitmVHVPaDAyS0FXelRJZlU5ajcyMFg0cUZ2ZlJ1ZnZ1dnZpUDQvNTFERHF5aUpRSWIzUkRnT3Z1MFRBTVRJeFRIVDVFWlVVV2VvSm1QYzV4RWV3VGd0a3A1ekw2bEVTZjBNTEg5WEJHdXZWQW1jUmZqWVA1OUJ5SHdicmIxSk5PN29RNXdRMFJYUDV4WGdDaEFWYXBGUUpBb3ptWlJSQnRsWjZMbzlnd29heWl4ODZuTGdXNlJKWG85aHgzZWV4dWZ1dnhEVGFwbFdPVVZraS83eDF5L0QzTE1YK09nSE9RYUdQRnNhQ0hGUGFqUlBDa1h3WWRHeUtweC83YW5TUldtajg4Ky9jZ2t1dkc2UmRQS3YrdkJ5M1A3b1ZmaklwbE93NXZLVFlUY1NNOTFOK2xaYmhnOTljUkh1L05ZeS9OMC96SUZONTNhUVF4d2lNRlBVT1JUZHUvNnNoWXVwNHppZWxJcmdBVEhib1NFYmQxL2pZanZkNndldkFnM0FOWmlHeTdSS1FmbkMwNGgvOWtKODQ4RkhjUGNqWHllU2RIb1EyM2M2cUs3MlNJMFlnK3hwQmxhY1dZNS9ldXdXbEZXWFlmZnYvb3lXWGEzWStQbXJ5TDNvd2J2WFZXUHBLVE9ocGdiQVczcWx4OHVxcm9kaVBRTzcrMkU0Z3dlZ1JNN0F5aHMrajgvRU5sRm4ySWx6cjErRzE1NXB3cjkvYnhEZFBRekx6MW1CeHRlM1N6VU9WeUZYeXNFdDV6dFlTQ2hlUzJhQk1MK0hublZmRWRBQ0ZuSkJ2L0tYZG56bUQ1c1J2dWs2QzkzeGVXRE9IcVJJd000NGJ3bks1ODNIbXJQRGlFUjN3ZDRUeE9LTkg4Y3A3LzA5bExkZlFxamlXcHg4Y1JKS3JBdEtpd29XV0E2WDdZTTY4Q3hZelFvWWZadkI5RlVJaVJodDUxYTgrN0tZRE4yeDBDSmM4cG03Y05MWmpUQ1NMblROd280L01TU0dPSktHaXd0T2NmQ1JEY0FYZnd3MG0zanpmejJOTDJLYUx0TXVqWE1iNTdFbzhKMkgvZzNZL3FxQmVmTm00WlVEdGFpWVBROTNmZmM2L0xkTmM3SG1uUFZRdXVhU1pRM0E2V3BHK2tBQXBsSUdOYkVIb2Q0cVdPMjlzS05YZzVVUUIwMjhUYjIySEJZNVNLNGRSN2o4SExCZ0JFYnZLMFNZVG9aclhRL2VZVUdKVjJISlNYL0NpclVoTEx2Z0t2ejlkNzRHdlhRTmVtTmhWSVJkUFBFaStaczdaZkxZWnpDTmwra0dLTHY4VkJaT3ExaDEzcnVCZVNkWFlmNFNBL2M5L0NWY2VmTktPdG9Hdk5FQ0piVUVnZnBQSUJpeEVUajRVM0R0VWlSTGx5RVplNEplNkdTRVFqTmh1Q1NsUnB5STBueXcyZzJ3MDNzUVZ1ZVRtOVNIeE9BdW1FWUtTdlFXQkVwT28vTUhvWGZlQjZXZEtMQk45K2wrRWd2S0g4VW5idHFHMnorVndGc3hodDRCNEdGeXFSYVg0OTdQYnNUYVVTTEMwNk1CcDBQV24xaisvbW55QWE1RGJjc2dmdnMzRitDc0QyNEVLdCsxRHZVWHZJL3NIMUZaM2dCRzlremtnUEIwTjZsT0d5ejFNcER1QkkrY0NjZnVncDA4Q0R1eUdBSHp2K0RHeUY4cFBZTyt2d3NCZnBCYXZ4NHVpWmZaOFJWaXJiTVJxQ0c3eW9qZXBzaTNxWmhQOXZiejRDVWtyVFViNEJ4NGdOeVZFckNaRlVEVXdoTVBiOFVUUHdIdXZJcHVUK1RwbnAvRGVyNEZuM3Y0VDNqNEt4ZU9uY1o1UW1iOVpjS3lQSWdHa2U5NjQzcWNmTmVuZ1JlM1IzSGFock5SdjJveFdQeGtxSFdmZ0IzN0U1eU9INENYTGlXeVFweWs1dzJ5amRkSjFhcDAvSkpBUG8zbzU1VndrcS9EN1gyTzlHTU4zQm1YSUtnR1lYVVRtM0g2b0tWTnNwbEw0WmJPZ2R2M1F6bWd6Y1BMNENaMlFpbFpTZVFyRFNYWkFhWHNBcW1hdWQySjlNRW4wWmxVOE1hVDdaaE50bncra2FPdi9BcjQyYXY0UHZtaHQ1SVBiVTZYTk00cFY3a0NUSktUT2dMenZ6NXdMazcrOGliZzErVG5QZnRHUFJyV0xJUXlTQ3F3N0h6WUE4UklraVJOTlZjVCttK0M5KzJBR3prYnRqNERwcjBQYWZZMjByd0p4aUFCYSsyRlB2ZDI2Z1RYSXVEWUJKSkk2aVVmWlpDT1YxK0JsTFVONmY0L3cySjFzSU9yeUk1cTRMVzN3blhKbGlvVllCckJGRjFFOXZkNVdqdFFNdk1tTExyd0x0UXNCbjY4aGZvUnNlMU43d2R1WDQ5YnlPVjlwcCtvOUhTeFhjbzBBTFAySVBCbkFuUEpwcnVvVjc5RTBybTdtbnpLTldCMkVJaHZKclc2RmF6M2wrVDAxMEpUQTlBdGhhUnVNVUxSTlNncFlZajBQb2xJeGMwSWgwdWdwMXJnR050Z3Q5MU5QcW9DdGZveU1CSCtFU0c4MEJ3RVVsdFI0dWdvTGR0QXY3a2VKZEZ6RVNBcEROTFQ2TndpaGpzREdxbHR0LzlwSkx1M1FRM1drTVMzZ2UzYmdqTlgxK0k5ZndQOFlodHdzQnU0NVJKU3YrL0ZXU0dHbDNxQU01VVRHVkFCSm5rTU02aGR0bnlRd1B6SHp3T2Q1T1IvNVFIZytrK3Z4NFlieTZEMDJhUUc1MER0MlFvMWVoRVU1eW55TDErRzZ0WkJxVHNUU3ZwcDhDRUN6MHdqN1pRaGFZZGdPUkVDWVEzWnRVNlNybjF3MC92QXpkMEl6UHd5dEpyYllHcXprYVNicDQxZGNHSy9veFlJa0czdWh6NzRNdlN5ZGVCV0wxUm5BQnBURWFxNW5GUnVQOUxkVDhCTmRkT3BxM0Q1all0UmYyWVVqejRCR1dsNnp4cmcvZzlnWm9XR0xaM2V3UGFKQjZnL2dGeENEYkRsdmF1dytMUC9nN1RwSVBEQ3pqcmM4ZlYxdU9SU1VwR3REbUNSVkxua2VwQmtRaVBsMXZjTU5YQVpuSW8xc0ZLYmtVN3NRcXF2RTJidHplREdjd2k1QVhKTEZzSHFmd0dzOUtQRVlsZkFQdkF3QWZjNmpMYXYwajI3U2FLWGtuUlh3TkVxa1U2K2hCU2RhMWRmVCtyM0FOblJMYkNIZHRGOU82RUZROUJESlNTbGYwRDVqRlBwdmgzVVNZVEdtSU9yTG5mUUhXRjQvQVV2QldVVmFlZXZmZ0RxM0FoK1F4MzBSdVZFbEZBQzgwOFhuSXhGZDMzT2k4LytLL21kTCsrcXgvcVBua3FzazBDY1E3YnpKTEpPMVZ2QVo2WGhSRitFWFJlQ1dkVUdLMEFnVkswR256Y2ZTbmtqU2Q4cEtLRnoxTEtYa1F6U2J4WmZoVUJ0QTB5MkUycUZCWHZXT1FpVlBrNjI5bEdrNHc5Q1g3QVJrYm82QkRRRkxOb0d0MkU1N05wcTZqKzd3ZXJDc0paOWdzalVIT29VUTRqV2hJaGN4UWpjRGdUTHhMQkxHblhuWG9ZdlAxaU8zemVUK24wV0dDSkpYYjRBdU85Nk12RUJQRVltOW9hcGF0amp6bkxQSkpaTHZmaW5DNk40LzcvY1QzeUgrTWNnU2VkdkhpZXlRVmhjOWI1U21LRmEyQ2tYTnRrOUptcFkxSlRNNlRFNTJVOGxBVjAxNExEWmNPMFlHV0VSc1ErVG05RUJWeGtrS2FvaFluTXE1cHh5SmxyM1BrTlNSNzh0RFpKTmZBbU81Y2hSOVVEMEhKZ0RqVWpIZWhDdHJJVVRYb2g0ei9Pa2Jqa2lFUldCeXJPUml1MkJNWEJRanJqWWFhOGlqWWtFY1BvZXJTcUJheVR4SkpuM0NKR0FhOC8yRXJycnFSOXVKUUgvNXovS1Y3MXdCK2ViMy9HQUxtZnM5bEJFKytZRDk1UmgyVElIQi9aVGd4TzdMSTF3R0VQZWtGZUtBRTdFU1owNWZycWw1bWY0T2Y1b0MrbHJLK2tuWUx1ZW50RWlNdmVhVkNZMWN1bHM2RlVLQmp2Mnc2SnJCY3E5ZXp1RXZ4cnh6bWZpZDRhb1pZRk00eGVCK1VDSm45VmdldU9rVUwwc1B6RW9JS1JaeEVtREloL0dORWppbzZpcjB4RXVEWkR0SmtvbHlGb29oSmtOVWR6enJVYjhiR3Y3OXYyY3IzN0h4M0twZlc5ZE1YOFdMcnJqWVZpOWFaUXU3eWY3Ukw0ZnRiQmpER0Mrekt1MGlNakVSRm1Sak1wYmhEUzM0akpmVmdRWHhEL1hTcEdVRElxY2Q5ak1sa25TS2ttMHpzV1FUQlZTeGdGb2JnTjBWNGZCREptY0hSUU5MN0xwSlVxQ0RIRTZSNGNpMGtMSlYyV0VxQzF5ZzZtbk1Eb3VrcjFGRXJhcWwxQm4wYjBSQWpxSE9Zek9GU0RxMUtFNHl2eFVRNFdRRDFlR1NTT1FyNHoyS2RHNnh4MVE2dlJOaWFTeHhPb2pOeUZVUmcwU2hxNXJVRVExTDllOURIY3g5c2tVYXNSTURZVGw1WVRKRkNNLzQ0dk9zKzA0clFsWmlpMk9COGwvWkNTbWhoVkRtUFlIVkhKaldBZ0dxV2JiU1pHMGVkK3A2OEJ3aHVSMXhQbGlueXBFVkNRUWNTOHpXM1lZMjZ0MzRDTGJYaVNDMDM3SDhyTE9PUG0zSXJsYmhVZ2NjeEFmU3NuVXp2NUJqcWEzTzBUTWQrQ0VBRFFBTkE5MEQ2RGo3ZDJZdTdnQkd2WDZwaDM3OFAydi80UVFJYlhtZWx4TlpDb29UTlN1a0M5SmtxS1FkSXBzZW9Va1I1UTBxRUdSeGVDU1pERlB1azJkSkoxSlhhcUdEYThPMU5BSURQcE5nTndmamFUZVpYQlNBVm56QXRVaU5XdjdtZldrQ3l3RzI0Q1VaSkZSYjl1aVpNS1d1VVNpN05BVTVkejBlNXYyaVdQeSt0U1JVcWFMMmZWbCtNaE5hNmtES1dReUJ0RFROU1Rlcy9ORUFiU3hMNTVHMS81MnpGMVVSVDRsdlhsTEYxN2YraFpPV3VMWnhVd3lkYVpBYU5oV2lrWjBaVVdDbDB6dEM1U29naERFUmI2UUlEMFJ6emRLRDNwcEttckEzOGV6KzF5ZXRabVpoRzFaTnBxcDVHWlplNTNKSE9SZUV1SndhWVlZL0I0WUVOa1QvWERTcDVGZFZkR3lyeE5kYVJzaGI0NkdkejZnMU42Tm91c2VhRHlBTTg1YkRDZHUwRVBZSUM4RDFYVjVqTTFQbEI3T2dQYzA4ZkFLNWdOaDVQaGh3YXd6NXFTOEVnclJBVlEvdDFlVTFUdFcxaUZXQXY1bm54dktrZ3M3VzU2WXVXK0dPN281T2NBeXc1REFYalNua2pSTEhEeWxZbjlMTDRqUGdUenB0MDhJUUtrTmQ0dHR5OTREeEpBR1lDY3RDYWlRUEpFTEpOSSszQndRTXlVcnJwL2xoOXdDSk1WcmZPWURtd0VabVhwUkoxdUE1UHBTNy9LUm9NaDdaVkk5M2F5MGNpZjd6SWRrNXJPUnBmcTE1U0VFZUJLSkFSdU5qZjFRdlZ1OU9hMEJYYkJnd2FUY3NCcllTKzNlMTd5M3M4b2lRSVZ2U0I0bWV2cENhTm1mbHRsMXF0LzdSV05ybVR6Y25Ja3VjalB5RkphdDFGYjlITnRNQmJlVnlqYThYdXAzQXNkWG1iNVV5cXcrUFZ2c2xDbUhjUDBPTWF3WlJobjFFKzZNeUNDTUJsMW9UaHpkeE5yM05nNktSaFdUTnJ3NUdXM1cxTlEwdlNWVURIdlFUWGUyTkhhdjYrL3FRVGlzd280UDRyVFRUOExpMWZPUkdEUmw3WWdvdjNmRTBKWXNVdklxbGRJcEM2bEVTaFl2Q1hkQmxneTZsaVE1d3NWUk5ML09VOVNJMHZlQXdXVFpvWEJGVk4yckR6VU5ManVSYlhsaTU0cHJ3WjlkQlI1QkVrWEJWdWIrcm9lOFkzTjV6MXpwRmpZK25XYW9DQk5KTW9mUXRqK09qbTVEMk04M0lDZDFlV2VyWE5uSGUrZlBSMGx6ODg2TzlzRjF6ZnZhSWVaV0NCTVFJZDFBV2JnYjVRRkh6azRpR0sxTFFOaCtxYlNZb1VRQUoyWXc0YjV4RXcyY1Rwa1NGTTQ4NEFVUVloWVRyK2FGWUNZeE0wUU5Jdk9xc1IxUnRFdEFPWm5hVXBkbkpWQnFCYThUQ0NibXloT3l0ak1YVEZsbFR0L05JUVdWUVJOMndrYnovZ1M2SFpsOHZZUGU4NUN5bWI5MlFNZE0wYUFldktPYkdyU3RwUnNybHBRZ0ZPRG9iMi9ITTcvZWc3SlNuOG5pVUxXWG1kQWkxNjR4NVZEN2hyeHpwTzFWYzVxWEgyb1hoKzEyWmk0am5pMks0anhiRDVPQlI1eWJJdlpUU1V5NU1oQW4rOG14dThtUU02RFJxVnZHYVFmKzF3WW9POXgra3JadHB2QS85L2JDUHFzV0trbFZTQThpUVV4UjVNVU8xNERtTkdnK1FTbDAzL0JubmdVTGZPemY1NUtsTWEvbDI4K0JJV0s0dFM2aWVsS1dXelIxZVBiWlZaVG5NVXBoVzE0NzhPa09LQ3Rnbi94dUJ3SnZLWWJSdDZlbHZhbzNIWk9KcmhXVnBLNzJreURWZWhMS01UNUloZTdqbzVRUjhzT0FkYmpqbVRjUkdmZFZFUzVpLzJoc0IxcDc1S3ZzUzFaV3ZwMUQwTmtZMG5sTWdOV09BNWdzZjErc29TR3BreDF0UFdDdTZ5UVNOR2NtMlowcThtSjJlSzZMTExQUEtlbkxNRjZlVzBiUGMxb2o1elBQbFVSa1AyZXF6M0piTUJjZ05vb21HRzNOMk5JMGdSbWkzOHlzOU14c2N6ZlFaVXIvYzB0Zk5NckhVTFZzRElubDB3WFF3MGtsRzJ0Ynd0akxIZDE4WFNmMTdNWHpnRkt5UlFrampKWU9UUkloTVR1SlpUbVN2V1pJQzh0eElTVElidlo3cHJVVWRTUnczdndMeko5Q1RobEd6N3VXVDY0Y1BreU9YTW1jZlZYdmpnUXpNNWVEV09Oa0xDdm9jZzNVRVUzcWdMc1B5TUViUkJsNy9qQmdzbU1wclpOdFE4ZVNTcGIvV1dOczZ3QzFraGd1czA0SHlnalFWV3ZuNDV3cnpzWlFYMHhPT1dNWWx1ZGlrQTVXd0dVOFZiZ2JNa1dJUEgvaHhraTJLV2NaczhqMThHS0JndVZtRmk4bTYzanVTMllxRzlkelllUVVjY0xCY2NTVWM5NTVjc280MXgxSnNwQ3RPOVg4R2h1RmJPWnNZbmRsRVdBbzVZVy81TjAxN1Jua3VMcWpnRHFldEU2cGhMTERnSmtQNG9qdlpFZTNPK20wMWRnRVhkUndWbEpQVDhVNjBMRm5PelRGa3FkeDByOEtOYkNZREZmTUw2U1lKb0pDRnp2Q1hVa2o0SXVOcnBMYkUvVEV5aEZBcWM2dytuUlVSdzZ4dVV6K0Q2NjYvcHhFNDd4Wmpwck9WNzhDYXdHb3FPSnVJUDlrQnEzYjlnSnR2Y0RGYSt2YmJyenp3Kzk5ZTl0Ly92QytuNml4TVVETGwxWSttZXBYTzQ1Z2psZ0g2K3M3bE9ibVhmdjM0elJSaUZ0YlI5M2FHc0R6VDJ4SGRaVS9sUnNibmZqa3gzZVJvNDdITkFKOHBFc3pGdWtaN1Y2NUxTMnVJVWliQ0FFdm1PSHRpNFVqZU9Sck5oWnNtRHNuc216d3ErZGRzKzd1Wi8veTV6WFBObXFkQllBNXFhQnF4MEROc3NNQW1vbTRDanY2U3VzQmZsb2IyWi9UVjFPUGJ3QzZxZWRYMUhnWjZtTVJFODRueGtyenQ3a3RsaHZTeTQ4Zlo3YkQ4d2k2WGtjVDh5YUpVYUxaMWNDQnBJNXJiZ3JKc1Z4clppMlNiNzZHVUdWVjFiMWZXN3o1b211Ymw0MnZCOFlFOWJoSzZPRVk3V2hnS3FOOTF4VGxoVDdidWJtVkFIMzNXZDRralYya3VzbzdQZFUyUEYrQ21zTjRjeVl0SHN0dEdWT3EvZUczM0RuN01zUktndVVITWpKYk9YeW5hSmcvVjBOTnRZWmFXc1VVZFNpdFFTU3NrSmxJb1hmSVJkTkJDM3FBb2FvL0FUMjRERXF3Rmd0WHQ4eS85Nk90bjczM2Z6dmZSTTZVcXdYYTBpTUdlREpaN21oRVNCbnZzeDBPdjVpT3g4MDlieU1nN0doTnRaY1cyZDQrY3FocW1NbjYyOXdweVROc2Q0UWsrZy9oNUFRb2JEOC9LVE1SWk1ZZXlnbVFYZSsrR1hZcmgvbkl1ZnpZZXhrdVd4OUdVT2RReGZTZ29WSmcza0tpc3JRMUNOZ1FQZkNNa0V4d1NyZnZnMFU5VFFRWWFtdkRZT2xGdVA1REJ6Yzk5Tmp1Ui9xc1FESm5uQWdqd3lhamZzWjBVTG5qMlV3bFp6djhPVkZUMDZFa0VtODJOdktWUFNTWk0rdUJSYk9waldaNmc5Qk8zZ0IzWnZDYjU4UlZNL3R6dDhNcVFzMjJudUlQVUE5UFhKVmhyMnhrSzRyem9qWDEySFJsSnhvVzFxQ3RLU1ZMdkpscW9LeE9oZHZZVEVUTFJZZ2VNaFNxQk90VndZSU45Rm1GTXZRbW9pdVNzRHU2b0RrelVMSjRRZUNLQ3hxdi9kRWY4ZGhod29CVHBuTFpCSUJVeGdCVFdUSFRxRjUzbXJWODRSeSswaHdxaTVhVGQ1NnNyRVlEQWZxK2FFTG04cVJ0aHQ3R1huUzFrUXRqdStPU2wveUI4QkdCaFFMRGhibkhWcDIzakd4NUo5S05EcmxYaXEvNnZWZGdXaENLNXRKM01lT1pKbnNORnlNMjVEdHprUUlobnlNTko5VUNGVG91T2FmeVF6LzY0OEIvK05LcDVLbGZUTGJFSHF2QUFodEY5U3JMbzRsTFAzdGQ0cjh2T3ptMFVpV2xGZ3JwMEtwblE0blV3RXFUUzFJM0E0dFdWc29Sa1hqeld5aTVZU0VDRGRYNDZRT3Y0YmMvM3VVTms3SHNuRUxDbG1aU1F3NkpzZVZGa2pnZkdSZDIzYXhyd24zYktpUmN6TFZ3dzhZWE1QK2NlblR0RXpOL0JoQ2dBMElGY3haQUtGSVBGbzJTcGdqQ1NUdFFhMUt3alc0WUx2a3UzRVRQejNlZ2N1bGl1RVlQU3NzVzRNeFZkZXRYTE9ndGVhMUpUWXdUV0poeWxUdWVkQjZ5TDJ4YTg3NXpVL2R2MTY0S3plMFpvTWJvdFJHb0VGMlZtS0ZJdmxKYVNJWE5JRjlSRjVPWFFnMEVVYkhxYkpodGpZanYzSU1QL01NWklyTVR6ejN1SlFHSXVJSE0wNlZ0MmhyWkdxNmIxKzE1ZGlBODkvdndIRWpNVzNWL2JxS0xicmdZVHZOVEtGdGZqWkxUb2hqb01jQmtoTW1HeVdOdytuYUFPVFZTTjhlSkJLSFJKa0F0V0QwSnBKc0g0Y1IwVk15dGh0ay9DRFBpSUJBeGNmcnNvWTJ2TlZYOGNoUXlOT25xVnp0S2FUeWNHOFBxZFhmcFF4OXMzM3JTa2twMHRIRUVpUi93Z0k1a0xJMktpQW9IY2JocERjbjJMb1RubFZMamNGblNwNmdtdEhBSVJ0eDd6SGZOaitPc1d6MzdLZjdzaGlCUllxalU4SlBEV0I3UnlSMHFHKzVwVHRabjFYMlduQUUwcUhwejE4ZWplOERtVmVETlZ4Sm9xTk1RMFVSMklZTnR1YkRFeE1ucE5IWElmcGxsNzZSZDJIRkhKbXZiSW5QUVZURFVVRWZxcUFyTTdJTGR1UitCV2h2Um9McUdidldySTNCVEpnenVzUXo5eWZYVGY3dnhhdDc2Q0dKSmtqMDdBUmJ3cGhVWHRRVmlUai9SS0VxWmc4aXNCbklWYXFDWFZ4SXdDb3orZzlSNHJZZ3NXNFQ0bG1mUiszWWJPRG55dWo4cGxHajhhTVNiMDlhYjhCalozTjA4UUxtYjVaZ1NkRDhMUC9OM1h3VERKU0ZEeWhRUzM0NjFIMjlBKzEvU0dLUjlRd1JTdXA5SWtQalRJZ1NWMEFxdVRlclc5R2JLVGduWjFUZ0N6RWE2MVlKOUtqblRBd2ZCcUdNbSt3NmdSQTJob1VhZG1hZTFwbVhvcnlCSnJwckJZdFpnaUNRdmdWQzBCQTYxUHIwL3dxV2tYdlVRU3VhY0JJY0hrR2hQSWxRYlI3bzdCaGF4b0ZTck1KczYwUFc5SjZIMWMyeitTd0N2N1RKUlVRWnZhbkxWTTh5Q3RhcEs5by9uY0Q2R0l2TlZyWkJzeXdjeWJYaEFpckpBb2NhRk94T2w2MithbmNUU1JhcTAyU21TeklUQzVaOFBrVE5vTSs1Ti82cUtWQllYR3RGeHpYUmtOcisrY2haTWVpK3p2NE0wa0Nuanc2WHRCaHJLM2Vwak9jSnlQTVpEaDN0anp5dVBwUzc2Y0JXNmV4d01kRnNvczFJSWxvZGhLaXBzbDJ4TzV4dHdxMmRBcnl0QjBtNGs5VHVFOUo0dUdNMjljT0tLc0tneW9iNnBYLy9ONjcxS2k5dnRWb2dFQXBLT1NzRlk1Si9VNEZ6c0MyZVY2dmloR2Qra0pvaTV4cGpYRDB6cUVTTFRuYk80RXZ2MUgrMnpiLytrdG5xd3o1dUszQ0pwWXlTTk92UFNWOFIza1p2RWlmRnFOV0hxcEFwNGVSbTVMeHEwMTdjalVSZVI4ZWFBem1Ba1RKSHNIUnhGUW84SnNOcFJxdFhETGtremxGS0pEZGFTYzE0OVU0T0JjaGdwR3pvM1BZZGYvSkVjQWkrZGRLVDZkZEsrcndscXJJQXIvdjZZOFI5Ym8vLzY1OTZ5WDZBK0c1eGcyZTE0c2VUeHNCMG13MDZla2g1MGt0M2hLRnNkSmhzZjY2Rm5FQ00xSnRsUmNsY0VlQ0pCM3haVmNXRUNNRWhiMTRJYTZ3QTdtTVlRUFgvQ0pkdExCTStJR2FpY0ZVUlBqQnNUYU51alVzZkhQRW5zcWRlMUp4YzlaLzNod3ZYYXBaeFVsQkVuaGl1SHJzUmZSUEwrRUlBc1liQlZXZllnZ3FTa0ZsUGRNZGIrV2t2b3VjZDNsdjdxclc2OUI4ZHhHcG1mYml2WkhQbG1JbnJEcGZqQW90bDhWbm1aNTlzNEtVNGt6Sk5TUlR3M21SR3J6NUZ6RGlaTUJYMVdtSmRWYTh3bVZkdERuYk1xRWtRb25NVGUvWUd1NC9Yc0JaY1RMbGl3Z0kxSGZrWUxJT1N1VjV3VVgzYnVhZnlERGJXWXB5bThOcUR5V2JyT3F6WGl2STdENDZrVTJyb0gyYzdXSG1YbmpqYjlyYTNOb1phQnRHS1BFbUZpNDdoS0UySGpmSlR0SWV2bHkxTHZXbHp2TEp4UndXZFdSbmxsTk9TV0tvd3pVcnZPWUlMRit1UG9qU1hZL3VaZS9jMlF6c04zWG1mOE1BQUxyZjBFY2srYU5BOXc5LzlwMk5ocUJyZjZRWVhjTlRkdG5JL3lUQ0l2bDA4Vm9JZUU5bkpXTmUrem1yZGZIZVU4Wll4bzAxZys3eEdwM0R3dzg0RjFSOW5tcms3KzltTnJoeTYrZUxueHZxN3U5TUZlYmVuZXgxOEpiMysxdVh2ckdFQzZvM1NpYVFmb21GSmFBTERLRVFJNkVUdktDOWdXQ3Vob3dEcWo3SGNMbE02akJuU3liZWlJWWNSUlZqZnZ1RnRBNHl0NTIrTUo2RVJBZGNmNEhUOGNhRlBGY25tQjlxbFFVTWNLVXVldXVhelB6WlBRSXdGem9xQzZZd0NiQzZCVG9PUWRDWmpITFRoZmFKQjVQRkJIVzVTOGM1UThJTjBDQVMxRVFvOVdTbm1Ca2pvZXFQbjdqbHB5dFVsU3NlTUZtWG1CMGpnYWlPNG90aE1UQVBWSXBiUlFTZVhqMk1iUkFNWW9BR0l5VmJCMmxKSTVYajdwYU9EazIwWVVBT1pFWFJWMkJPcXNJQmRtQWhMTHgxREI3amdTaThtUTFNa2dSZU1CeTBjQk4xOTZSN09UeHhyTXlRUjFMTUFLdGFlVFNwQzBTUWFUalFJa3l3TUplVEhOZlBaNnZNQ2NERkRIWTdYdU9NY21UU0luQTlCQzZqYnlZNUdqQVpzL2xEUWVlRWNLWnFHbGZJV0NlclFnajJXbko4MmVUcWJLTFNTbzdCWUkzSkdRbjhtUTBJbVNwU01CZXJ4N1RKbktIYTFNamhVQUxpOFF1Q1B4TXljTDBJbjRxUk1GdWhBd3A4eHRLUVRVdzluYncyWGQ0eWlsY3FMVjA0ZVRWaHhHYmZJQ1BoOHpNSTkxNkE4b3JGaG5JZ0dDeVZLekV3VjBJZ0VKRkNpTjB6SmpnWS9Tc1BsZ1RxUUNhNktTZUt3QlBWTEpSWUhIcDUzYk1oSG1XMGluNEVjcGlXeVNBRHhTeVozSXNXTWlxZG94Nk4zanpTbkFqeUkrUEowQW5RaEEvQ2p2UGFVMkZPTklXU0hnampXaVV5akFmSkxmNFVqUDRaUFFpYVlOb0lXQXdNZVJzS050VERiSjBua3NnZityQXJTUUYyTlQrUEw4citTYUUxcit2d0FEQUNlSmZmMXFxb3F6QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC8yMDAwLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd1FqVXdNa0ZHUkRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93UWpVd01rRkdSVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakJDTlRBeVFVWkNOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQkNOVEF5UVVaRE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0wzM0lhUUFBTWRaSlJFRlVlTnJzZlFlY1hXV2Q5dk9lYzI2Zk83MVB5cVNIQUVrSUpVRG9SVlFRRUJFTHNpcWY0cm9xbGhXd3JLeXJncXU3c3BiVi9WelVSWEZYVWNRT0t5QkZFWkJPSUFrWmtra3l2ZGM3dDUzeWZzLzdubnRuYm9acGFVRDQ1dVIzY3U0OTk5VDMrWmZuLzMvLzd6dENTb241NWJXekdQTk5NQS9vL0RJUDZQd3lEK2o4TWcvby9ESVA2RHlnODhzOG9QUExQS0R6eXp5Zzg4czhvUE9BemkvemdNNHY4NERPTC9PQXppL3pnTDVHRit1MS9IS0JRT0JnWGs3c3c3RUhyV3JBdHUxNVFGOG1BTVVNQUlwREJmQThvQWNPcERnQThPV2szK1U4b0s4TWtPSUF6SzZjUVlzUE9iRHpnTTRNcHBobU81UEpsZE5zeFRTZjV3RTlSR0JPQjZTWUJkaVpnSlF6YU9naEFmVTFCZWh4WWxJN1d5OTl2VVdPVTFzTUxHZTgxdWdCVlpaQUZWdTEwalN4Z0d1RXhEak9OV1lZS0dLVEI2WFVvVjJRVFMva05DYlhjV0U3RGh6cGNaVkljcHZ5UEF6eHAxNXU5MlE5ZFBBaVBmeStjd1RZMFdKWlBZY0sxUDl2TkxUZWNkNjBKSWIzTlN6QjZla0VTa2FUUUhrbEVBb0RKbHZCZFFGUElXZXBjSWN0YlVJamFIRHJ5UWw5bTZ4MjZndkJWS0RxcmNldHl3dXBjdWNJVVhTNXIzOFV5S2FBa29nTy9BZVhwWjFIbTBad0J5LzlQd1EzZFRCQkZhK2xRdXZKR3Zvc05iVEJjVTZLQXplZWZoek9LSW15a1l1QXNUU0JDd0ZocnRRZ0RacHFCUVdFQXNUTEFhZjJVMnZIRjNXc0lDSlMzVWNkdzdaVHphZStHcWJRNnFiTzkvV09xczFqRFg0MkRWOWdoZ2I0blFESCtEM0FhejNTaEpZbmVuQkRyMlhkUEIybyt4cUh2dXlBdnNRc1R1UFUxR3RRZE9OVWxnVnMwMFZzandxMlFRVi9xMko3TkJqS1RCS1hnSWt5Tmx5WWpWWkNBTUs4dkhxaGtNb3I4RU9RMzBNQkszZFBvcUZ1ci9IUXIyMW9rTlFOTFNJbkxBT0JzSWxBeUtUbVdvZ1ZCYWl0M0JmZ1JTSUJDa01Ba3FnN1dadVg0bzFvVzZYbitNQVNNYy9OUXQ5ZXVzaW1rNUNPNXd1QjhMVStUR3VRcERBTjBSaFg4dnU2YW1CTE4vRGpKL0MvSmNDN21peXIvelVGcUhKV2ZGK1RmdWFLNmdBdWFLekhtVTRhNWIxc2dBcWF4N0F5V1ViK1JYMFhHUXI1alpWM2w5TmRmdkpycXUvWmJNNWNPcjRHcVNXcnJxc0E0T2NNZngrZ3VVd21hTElybGJZS0RMc20zQ0FCS1RlMTV2azJtSUJTTlZWYktvMVVHaTQwMlA1OTFDTXBUVmZQS0h5NVFudS8vN0kzdmhYWTJnNTg1cmRvcFc4L2E0ZGw3VGpzQWMzdklWTjRYMlVRZjMveUJxeFc1bEUxOGlEQkRCTEllTncvUnZrNzdiZGMzeitwWTlRcjVQMmNaVTM0dXBjQW1kdWZmd1N0cllZdkpQbnJLRE9ydmxOWnRmbDBGUEFaZ2t1ZjYzRmJGcU1ROFpqbjlnQ2pmSzQxU3dVaTRaelp6WmxZeTVJYWJLTmduN3FsQmp0bjFoWEFQWHkzZ1RiZ2hrdUEzLzRWK01JZk1FUk5QWHE3WmJVZHRxbS9uSGxkUkRDL2YrWWFuSFA2Q1RSSnd3SlphY0dpK1Z0NWpFV2lJclNKTTlnNmFxczB4ZUkrS3hEU0RhbDludWVEcFUxb1hpMmsvMUhtZkZ1ZVZycU9yVStROEgyaDYyVDF3WUlYc3pOcE9HeEVtVDlYK28ydk5MZTdqMXNDUzFuRDVhY0RyYjNBRHgrazVTZ0pvamhxOFh4ZkpTMmxqYVpQangwK2tOSldqL3NkZCtLQmJNZC9uaGY0NHNsaDROWlBSdEExa2kzOXppUHUzZXNjNThobmxWUWNEcVNvVUVQVkM3TjlUcWYxK2NWSEwxMWRjZG9HRnc4M3VhaGR1UWFMR2dpcWJTS2RNWkJPT1RSN1dXUXlEdXlzaTB5YVBreDdLNW8vWmU3b3E5UStqNDFuWjlYbkxFRnhTWElJT2xWRmZYZnR0QllHOWM5emJkMndIbjJkUjN2cjJsbGV5MjhITzUzVzN4MTNRcnZ6cGowUzhjSGQwd1VNaytDOGVSMzk0SExnWDM3TDMycEs4YVpUcTJHU0dodktVaGpDOTlGVWZjbDcySHhHOVV5ZUZIcGZPczA0aC90Y0tiU3B2bkJUQkFzckJhNzdWZy91MnBiK1NidGx2Zk93MGxEaGs1NnphWFgrOTRZUG4yb2R1Ym9TLy9EbFIxQlpGVUZ0eDNZOE9KSmlRN28wVTY1dWdHekc1cXJpQW9jQXVTUXRTZ004YlRLRGdRbFRpenpweVpFUm1Rcy9sSmtVT1FaYmFJcWw4Q21VWnFnNU9wVWpzWG15T3I0b3M1emlROWVXMHZUUzRkMnhoYWFsRHJqNUt1Q0ROdy9odis4Y3hzY3ZKb0d5ZkQ4Y0pxRUs4OWtDdkdDVTJ5QzExalFEQkoyQ3hvY0swTkk0bm9uaGhJZDBZaFFaWVRFUVZwWUQ1eDAyWVl2UzBKeVozZGdLUFB6bEQ1OWpYSEhscWZqWSs3K0tpcm94UkFtUXNvaUtFV3BmbHRNT0sxRGc4M0ptMXMyWnJieko5ZVRlQU9TSmo4UUU2Y216WEhYdHZMSElFeTBkWWxpNThHUlNQa2dVK3VTY09SK2hlWG44Y2VCVHJ5Y1ZMd2MrOEYyZ2s4KzBib25RV2hyaU0wZElvSWdqWWlGSktzNHQzeXVjQTF6ZEw4N2ZqMW9JTFFSZnZoMjRzeG5QMWdLWFBHTlp6WWNOS2VKN2xPMEN0bjM0a28wMS8vajE5K0x5Y3orSnpFZ0NSeDRKSkZKK282bjNrQ2dJK3FYZnJDNVZ6bEZNUlNxZmFta1RhakYyVVgyZkpzMnJTeitsajNlbE5tV09Nd0dvK3MxaDJPRnh0VzJQWVB1K1RhVVUxUFVOdy9kL3BpSDFmblY4anNTT20rQThBY3ZtMnJtVGxMeUdvTng2VFJCakJQaXFiMmN4NUNtckljYUptS0dGanMvdUJCRU5PVFRIVXNldHJmU2RIejNUd2Z2UEFhNjloUnIvSWg0b0YrSjFPMDNUeWNlbGg0UEpOY2t0Zm5iUkdadHFQditMNzJGdzEzYXNPL1ZjbE5QVU9vNVNQVCtXc3dKQk5xeUhLRzFWbVBGS2hLSWVVdkZna0Q2STZtaVNnSVNVOUt0VG5CU0VsK2J4UG8yVVdsMDlIUStxYThuY1o3VjF5RWFVQ1ZmK1RQczBmbmFKbHV2NjV5bC9MQ2dveXVmWlJFMzU3UXpQMGY3Ymx2cTRORTEra2o1YkNZV3lHSU5KRDAwakVaeDlUQkRYWFQ2S3ovKzRYNXRhbGJ4UXo2ZFd4N0gwSTFrMEJ3YWZzM3NRT0htaGpYZWVDbnp4TnVCMmdqbHNXV2NQSG1EVzZHVUhsUEoyU2RBMHovbmcrOHJnZGY0bmttMzkrTVFuU2pXaEVmU1BianFoS2FsaXRHNTZHRzQyb1NWY2FZWkxpaW16WTc3Z2V5cVk5eG1qWjlna1FDcW9uUENkSXBmRjBmbTh2RjJHbjlKVEZ4UUJaZkw4RElNb1lMUndsVmszK1R3RnZ5RjNQbjJjSW1LS3RZcGNpb2lpcDRIcVljRGEwU0t3b2RGQVE1RkE4NGlINm9nWXQ5V2VzaVNXcDhPaE1ZWS94ZFRVejE3cTRiWS9BLysxR1Z1bGFaNTNNSHBpWG5hVGU2d1FDN1BDK09FUmpkNloxM3lBSVVBUll6RXl4dUs0bnlKVHBrejVSanZuKzVURkdSdkxoUjNja2NyNG9DbGx6TWVpZWIrWWJ3YjF1L29Oc2lEUjRCWDQwRWw5SXVwak1KZm0wK0VQMTJqSWowWFZQWDFDNDJ0YTBKaGc2Q3J2cThLUEpOMUVSZHhQVU54NEIvMXFKMzFLaVVBdzdMK1RwSERZV1ZvWWtqeEJsZTdvOWZDNU45dUk4ZnlyZm9yaG1CQkh0cGhtOThSVFRxU01YL1VtbCsvWEdwTGVXWC9laFhzRFA4RFpYL3djVU0zQTdwWmJnZDUrbndSbE13THByRVFtYTlIVUtUL29qc2VUZWFDUVM5K05FNWdDOWlJeG9hbVRPeXZGVkoxZnVYeXJLT2pjVXM5aGlBbXdJUU02OTFzY2RuU0lvOUtKSTBtQmRRczlYTUdZTkVHaCsrSXZnVDhUbHZweUEyYkFkNTZLQTlnWlUxOUhFYnYyWG9rTE50aFlWQVY4Nkhza1EwSmNSREQ3Q3JycERxalA5R1VITlArRTljQzU5emJoc2ZydjRyZ3ZYTzluYUg2LzJjUVNVa0doWWprU0I5Y0xzT0VjUkVMdStIbjV1aTh4bVhrVzRtTk9zRmlaWThEajk1Nmgra2ZtOUVMa1ZDV2ZoMDB5Rms1Unc4U1lnellDYS9ENU1vNkI3cFNMQzlaN1duUC82ZWZBUTR4UGF3bW1vVmhzT0toZENQK0RWR3lkenpRNEpyQ3d6TUZGRzRHYnFNa2Rqdmpzb0drK09lbDFEcy91TTJXSmFnanFiUS9oK2FOdVI4TW5yd2EydnVDaHJjdENkYVV5c1VMM2ZpZ1RwY0lXV1NDM29nQlJrZFBHUWxCMUwwa2dwNjFPUWZjWEpzRGQ2MXFGT0U4Q1hHbHBLcXM2U0YyQ29vZ1QyVFhWZVhlWGh3K2Q0dUROSjFMVEdLN2MxNjc4b29HczlNT3NlRVVsRW4wZDQ4S1ZwdG5OWkR5OCsvVVNmM3dhdUw4RGZ4bTF6UDg3UlFmNkFmV1R2bUoxdWJrWWZvaHU1czAzM1V6NlQxUDFnZmRJWkZYbXhoTzVIS3Z1eEpySWsrYTdvMHpmZkNsdEpSbjJmWlU1YWJYOHJRWTNaL3J5ZVZxOTVxNmhnQjgvMXRoN1ZmdUU0YmV6U3VXcEIxSDM3Q0lWWGIvUXdRZmZ5Tmp4WjhDOWJTWVdOUmhZZTJvRUZWVitiMG9vVnErVCt6ckdGWW8wU1Z4OHZLdmY1WHNQQzRkczkrK21xSWc0dkR1NEZWeWw1QkFkRXArODhTdjQxLy80Qm5ER2lTNys5S2lCaFd3ZzIvRWRaMkdmNUxnazVrQVNCU0twTEZ5ZStPU1QrSXFsT2dXOUhycnZVN2szeXdkVDVFeXI1MHpTM3R3OWJNZlFRbVVZanI3dWFGb2dRbGI5dWNza2Z2c29jRE1ONXJsdnFrSnhjUi9DdFV1eGNrMERlcnZHVUJRTllxUmRZR3hVQ1Nsdy9ISWJKNndFL28ybWxyenV5NE9HMFQrRmRvb0RaYm12ZU9XOGFrTUs5ZGZ1MzRHLzNrNVNjZFY3eUNyRHJzN3dLTCtUNzNxYXZPcHFBc1BYTW90YUdvcE1hSnBhODVxcm1HZGl4TmZzMFZFZmJCVWZxbzV1OWJzVndualB5T1I3cUd0TDZUK0V5cFdyWFBEZ3NJT1BYZURwME9PTHZ3R08yMWdHS3hxR2F5eUMyOHNEUTNFc1hnb3NPcW9lRjE3NUxzUXJGNkIvMUVSNTFNT0R6MU42QjlFeUdqWnZ6Ylc5TVFuSS9Ta2hmWFVCbWpjVGJOOTNmZk1IZmhYQlpSZDU2T3B6TlNqQzlIdGFORmpXM2liUmN5YTBNUkQyUWMzM09ZN1FMTGEyVWh2SVBqOTgvWHI4eTEyWDRHMlhsYUIxRnpBOERFMVU5UFg5L3VpOVRhMlZNOGZtUkpnVDVMSHRmUkp2V08vaWxDT0I2MzdFMEdSWk1VcXJGSU5kQWlrYTRZa1UzTDRINEdZc09NTXBScXhQNE93ejIzRFpKVGFhZUUvQjUvM1lLU2lyY3QxcllrVXdwOURNdzl2a0ZwcmVHKy9EamcrZmhXOSs0OXU0K3JxUGsyUTg1TExoVFVSajBPazlsWTVEenZjcEFJWnBzTEpwRXBGeUNrT0ZYOTZoVEtaaW5EYTE1NVRYbFNGYVc0MmpqbzVoNDRVbXdWbUcvL09sNDRuTXQ5SGFuMFR6NWdFa2tnVFY4R05lQmE0Q1VabmljQ3lPYkRLcHN3eGFXSGpkdmhFRGRjVTJQblErOEExYWtsMHlpSTNMR2NKWXl4Z0w5OUtzSmlBWXZCcXBmbXBzRnViSWt3aWtzaWhmdmhHTFRra2lGbjBPN2R1QTg0OUZmRUU1M3YrTnU5eGoyajN4b1lSaDdNQkxLdzRQWDVOYnVKRDFmdmFYVHlEYnhGZDg3enNraGtZOTNlOFpERXRmYXl4ZkMxWHlZZG1hY3B6eGxpTTFpMnpqOFdkY3VCSm5YYnBNQi9rWHZlc29mT3ptaS9EdTY0L0FzZWV2Z3ROTVpycWQ5dFphZzNkK1lSbXUrY1lhZlB3ekMrSHcyRTZ5VTBZWVNGRTRqSUIvL1lhbHl5azRycStsS280a3N4MGRkZkNwU3p3OHpYdmQ4Z3l3N3BnUzJGWTFzdTRRNCtaTzJIWXZuR3dLanRYQWJZOU9SOHJnUW1wckdaek9TcXcvZVNNdS9ydTF1SE1MVUVjaHZla0tITGUrMUx1bjJIWFBmYzFwYUg3NTNIMUlmT0lzM1BUMTcrSlQzLzBhc09tNEVKN2U0cUtpd2ljeXFnK3liemNiODRRUy9NT1ByMFJ4UlRHMi8vNVAyTE90RlcrNDlpS0dGMzA0K2RRS3JENmlIbVpxQ0hKUHY0NTRSZmxiWWRnUHd1bjlGdHlSZGhpeDQ3SCtzbXZ4MGVIcktReGJjTXBiMStEWkIzZmh2NzgvZ3Q0K2dhTTJyVVB6YzA5ck13N1BZQ2psNHNvelhDeXRBOTVDdDdEaWlEcVlVZFBQT3pNbU1nTDhibmwrWllKVnduMTkzTlpUelR3NDFGUWpYZ2xSdFFtaG9oYlVyZHFNdS84S1hIRUM4SlhMVWZ5dnY1WS92Yi9GdVhiSXNyNTlVTG9sWHkwMVJaKyt6OS9lZUJaS3FEU2RYN2tLa1RVclE3anBsc1Vvc3BxUXBJS3RQV1VsU2hZMzR0aVRJamo2TkpxNzNTR0k1WmNoWU4wRjg4VVd1S1Z2UVNyK0VNemhia1Q2VFNTQ0sralhkc0xLaEJHdFBCcGpBL2NUaEFaRUFpYU00cVZ3M0orUXhiWkJoTjhFVVhFcGRqM1dqRXpTNC9WczNQVHhMekhzb0pWSUJMQ2t4TVhuMytYaEM2UXl2MnV4Y055Wks0bHpKWnhNcSs0VXNBSVJoTUlsQ0xyTmlNWWJFU1hEallXeWlFZGRoSUlTcFRFUElYTVFaV1dMRUc4WXdlYUh1dkhFN1VQNHV6ZjRsWUhmdmd2NCtSWjhjOUN5cnNubk5BcFNmL0t3TmJscWVWTEs0VGp3blcvK0ovRDBNeGtzWHR5QXA5cXJVTHBnTWE3NzNxWDQyK3NYNGRoTnA4SG9YcVRxb09GMjcwYTZQWWlzVVF4enJBbmgvbkxZSGYxdzRtK21UeXNCeGw2a0dhSjVaSURrMGM5RlNqWkJoR0xJOUQ5RndyUUtudjFXeUU0YlJxSWNLMWY4RWVzMmhySG16SXZ3NmUvOEN3SkZ4NkovT0lMU2lJYzdINE0ybDZ2VzF2S2NVWnBTYXJxWG9TYVcwYWVyVG9SK3VGWWRYSmRiWjRqSDlPck84MkMwaGlhNUZ5RUdzSjZrYzA4dHc0bWI0cEQxQXJjOTZQZVhmcFR4N0h2VzQrb2F4L212ZzVDd2VWVXQ0dndqUlNSdDRwalRUd1lXcnlwSDQ4b01idnpXRjNFaDN4aWlEWGgrRDRuSFNnUnJyMkx3N2lEWTgxTVNrL09RTEZxRDVQQ2RmS0ZWQ0ljWjFIdmRNRElKRXFWR21ydHo0YVNiRURISlJER0FzWkZ0Yk9RVVRlR1ZiUEMxUEg0RWdhNGJZWFNRQWp1OFQrODkxTXFiY2RVVlQrSmpIeHJEQzhNQy9VUEF0eGhTT2UxRFNDYjc2QUxvSjQyc3ByOEdrbVRpZE1neEJtQldtdmZzZ0l3dmdoZXJJY0FkM0plRlk5cmMzNHBNaXQrajlmamdKNWRqTTAvNTBUMStQZkJIM2tDYXZ4YnZySEtjSDc1bVRPNU5sNkpxendoKzh6ZG40c1IzOEFYTGpqNFZ0V2RlVFA5SEtpdnJhTjRvZjVrTVpMb1hJc0JBUC9VRWtPNkNqSjFBcmVpR2sreUJFMXVPWVBZQmVNT01WNHFPNS9lakVXVGpDMUN6U0hLeW5mOU0xcm9Bd1VyNlZVRkFVb3h0U2h2cGI2K0ZqRkpiSzgrRjIvNFZoaXRSaVBwU0lHN2p6bTg5aWp0L0FseHpFVzlQOG5UOXo0RnRTWU14Wmtobk5yeDBHcUdRUmRQTGM2aXRxaTgwSG84aVJCWm4yQ09JQmlTQ3d1KzFJZWRDQlExSE1ZblI4ODlKUkVqd3psbm5kd0NVYzk5WGZ3L2MwNHl2dGZybWQ1OU43cXVtakZPR1VOZVJ4ZjJYbjRaVjExME5QUFowSEd2UFBRbTF4eXlIU0t5Q1dYTVZZN3Mvd3UyOEJiSm9OYjNNVGpLazV5RXFMOVdtMWVqOEJVRmVTd3A1SWR6a2MvRDZIMks4VVFtdituWDBYeUhZdldRejdnQVZpRVFtdkJwZTBVSjRBei9VSGRveXNnYmUyQllZMGZYVXZEU01aQ2Q5N0puYU5FdW5DK21lZTlCRkFKKy9wd01MNk1zYlNZNysrUTdnOXpzRXlxc05YWVZva2h4WmJNdFEwRUJFRldvYnRpNDNpVVdpaURFMmlqT2tpWVZOeEVtcG8wUXZFZ3Fpb1NHR1dGRVFLVGVJUUNDRXBjc3JjTjhEYmJqNmhvZmNGc3NLN0ErZ3I0b3lUdXBKVFc4V0Q3ejlGS3k4NFhyZ2gvUWt6WWxhblBlcHBSQkRiT1RTalhDR3lFaFNERUFyMzh6dEx5QUh0bE16TjBFR3F0bm9XM21oRnltZGNZaVJYeUFnRFFRV2ZReWVsNExsREVLU3dPaVN0SkZkeU5SOUFITG9Oc2pCWGRSQ0JrcWhXZ2piaGF6NklMelJQeEdjVXZwRmFuZDhHVEQ0QzlyWUtDM2tGVmkyYUFHNmRuMFV0NUtMZnZCTWF1bmJ5Si92a3ZqUjVpQldITDhRc1hpUTRVOEEwVWdFc1JoWGdocUxCVkVVRDZNb1lpRmVSR0NKY0V3QkcvRXJNSUw4SENMWVp0cG1ISjJBdWFJSy9mY01xeWZ0UHl6RGxoeVlWVDNBbjk1Qk1LKy9EbmppY1dybjlncGM5dEZqSVJ5YXRBU1pLZU5RTVhBSFJQSDdHWGVxZ2lPRDIrVnNkQjRUNWZjMk9xTFM5eERZSFhCVGUrQ0tBWGh0ejhCYytFOHdTOTRJTC9HTVgvNFhYb2hnNmxHWWJnQ2lqT0dmRWRSMVIyN2ZiZnBwcExRWmZsUXJ0WUk5ZUI4eXZVK2lxUGJOTk9WdENPeHN3UWticWpENk43MjQvVmZBMjQ4SHJud2RVRjJTd2sxM042UDhpQWFVMEdZR0xaZm1NMDJ5WXhGZ2s1OEZ3aUdEVmtMb1dxS1FaZWhxeFlDcU0xWmhEUjkvNllJaXJGL0xNS2RqQkx0ZjJLVUtMd2J5YmJSa3laTERBMUFGSmgrOHVoZjRDOEZjL3RscmdTN0dLLy84RmVERDN6d041MTVlRE96aUVkR0ZOSzJQQWlWbjAyVGVTekRwZ0R4cVZrMDl3YjZQV2xoTWhwbG1DTUt0RTRaQmhoR0lMWUZyL3k4WjdrNTRWaVZrZGp1QzlUZkFJeG5LcFA5RTl0a0JNN01OZ1d3YmpOS0w2WnNIWVkwOEFWbDhLdHl4RjJDSkpJOHhhYzdQcDVBTUl0MVBJU2c3bHZnZmcvTXZiMFo3UnpkdS92MG9QbklKOFBwajZmdUtIUHJWUFdpTkNnU0Nmc1dmeXV1cFZZRm9pWW5hSWlPM1h4ZXZHSDR2MDZrYnEzSDY4WFVZN3U3QjdwMzlDUHRERHc4ZkRjMTFJRWU3Z0ljdlBBYkxQdkVSSURrQ1BMS2xCcC84MmtxY2RoNERsMWFhVjF2VmNwYjRUMm1SOG5jOVNQLzVMbmlsRERmRy9vZU4zd00zc1pnNi9oNkk1RU5zaUZwcVpCMVN2WGNUZ1BlU3hhNkQzZjR0WHFNSWR2LzlNSXRQWkl5NG1oclhoQXpERFhmb2x6VFROVEFyU0liR0hvQXhOZ3BudEJ0V0pBUXJ0b3pBQkpGb3ZRTWx0U2ZEVG5YU3ZOTXFKQmJpb3ZNN2NOMERBcjk5Uk9MaVRjQXh0TTVmZlR2dytWOUtKUG1zSmFYQ0h4K2o4c1dtdjFXa0o1QmJGWkJtcnA1WURmRllUQTMxVW9Qb2F4OUd5NTRoQldoemNYSHhmZzNmZjhYQ0ZvTDV4ek5YWWRsMWYrL25aLytEY2VjVDIycHgybnVQcFBra2lBc1pQcXdZSkNWOEdMSWhEVGYrR0p5YU1MTGxiYkNEajhBcDN3QzV1SkY0TjFQN2prQ1V4NWpGVHlBWjRqbkxMMEt3cWc1WnNRVm1xUTJuWVJQQ1JiOUYxcmtaNmNUWEVWanlCc1JxYW1nZWFicmpiZkRxam9KVFZRSGIzQTVSUTNPNzVpcVNxWVVRUmFOa3NtemV3REFDNFU2RVZCc3pMS2s1NVkyNDRlc2x1R3MzY1B1ZkFUWFc5S2dsL3NBamMwQWlOU3IzNnIvTmZ5NGNVNVB2bmxOb1ZjWXRNdkVFV25iM29DZGhxMzdpRnliSi81eFRnNjlFVFJGb1puKzZPbzRUci9tSW4xRHY3dks3c3NUZ3M3am55enVSRFZmQlNTbi9vb2I0cWM3bHAzVk5UNVlhRXpCK1RTblAwRTh1Z09jTTB3bXIxdm9DRzZtVGNlRUlHNmlIRFhVa0ZoNXhBbHAzUEVoTkpzVW9vdWtkVkVNY3R1aGU5V0Q4MThnT05TTTluRVc4akQ0M2NqTVNmWCtCSktHTXhUb1JMTHNWcVdGcThWQ1A3bkZ4MGx1MHhnbjdON3BZT2w0ZWhaZEpZaVdqcVQ1Nk8xV28yTUp0SStYd21qT0FMOTJ0T21HRjdxWlRsWVhhOUdxVDY0OTN5UmRaSzJCSCtBb2xZWVpnMldIczNEa0FpaVBveFo4UEJBSWlFb2w0MDNTbnlWY05vQlRtajFYRXJMZDk1blBGcUcxMDBkNmlCakRiZVB2YkpUS2pxc3NyZ2RSSUFtTnNKTnZOZFVwYnVRby9OOWZid3RlMGsvMStRYlhuUzRrVjg0YzFPS05kREFVczlMMzRJa1k2VzhBd0VNRVMvOTRNRVdIRzFQRi9VYVUrdXFlNUo4MUEzKzdRaWZsZ2xGellkR0ZrSDlMOXBNaFZNYWlxZHFYTnFyRkNvWkFXam5CUkNkNzNlalZtTklna3lWdlFEQ0lURHVQOEUrTjRiS1FadjNxcUMzVzFwaDVQcXJycVBEM2tVT2p5VHljbjJLcGlNRVNKaVFjeTlOTjlhTjQ5NG8rZHNxeG5wK2dQbFhNQjltVUhsTzM3d1hXTkRUajdrOStpWDB1ajZDaUdGUTVqUDdhd214bENvNjZydEVsa2h0V3dJcDJWdDRtMHRCTzZYbFlsRnpSUHRGUFVraEZWODA1bGNIU1J0RW1ORGtqVkpWT09WS1lkbGxlSGdCZEFSbVIwY1hhSURhOGJWTlZpV2tHZFdMZjR1NkZIY2ZNM0l1cW8ybUJLaXVEdnF0aGJGV0diZ1NpRkplRDNFQVJWOG9EQVVQMkVHYUJBU1JUblNnME55MEtrTEVLTGNBdWZ0UU9WcFhMY1oxbzVYK3I3VDZrSlVzb21vZWI3VkFTVGFHOTFzSVBDemJ0czdhNm82REVNWTZvcGNhWXFjWk92S0tCOHIxMWp5Y3hLZTRDTU1Gek1Cb2t3cUxaZ3FORzhNdUJYdUN1YUtBdzJZbjRNaE8wN0VWMWlsSi9zd0lYakpMaU82ZEhUZXN5UnhhYWxtbWJzWVVTNFAyaEdFUkJoWkdpYUhUZUZvT0YvcCtnZzQ0N3E2NmpqMVQ1VHFhZ2ViKy9ueGJYQU9INU5yRlRWOXFvUW5QdGQyNjg2azY2amh5R2FVSVZqTGhLaktWM2FPVGdpc2V0Rit0dmMrRkpWQzY3bmE4aFpFcVd0cnZCcmVnZHBNUnBLWFZSSGh2RnNzNGUyUHQzUi80aE53WkJTVGpWamlwaE5XMTkyUUlQQTdxSGVJWFMrdUIyTGx0ZnA3TXF1elR2eGc2LzlCS29WTE0vM3RLcFN3UkJxN0lxcWNRM1M5Sm02bXQ2ZzVxZ2hEV1pJK0YxVytqaENsQTFRMDRWdU9UT1M4Y2VCWnRnd2pGbU5vTVB6YkczeTNKUWZlOEswYVdhZFhMOEdiWUV0NEdTZ05WbjVQY2RSUXlZY1hhaW1oaDFtVmNVWHozZGNSLyttcjA5QlNtVTlMS2d0eHJ1djJFZ0JNdWd5aHREWFBZcElhTzhCditNRGYzUCtVN2tPTlN4VmxhYW9BVXQ3R0w0by8xa3N4TU5DaUttbWxwdlRsRGl2QktETkE0azB1bHM2c0doWk9VdzJhQmZmNXJsSFg4Q0tsYjZmekJkVDV3Y0lqZnRLK0lsczR1d1hVK2NVU2pVTXJiYi9Rb3IweFB4WFRvLzRaU3BtTUxkUFR1enpmT3M1WGpTbXJxK0hqZVpIY29zSmY1MnZISlIrRWVMNDBBelYrYTBxL0liN0IrR20xOUt2bXRpenN3dmRhUWMxUlg1WW91UE9ISmdhRGQ3WXlZMlVNMXgvYUtMTjd5OTJhSmNPTHhCNFdEMDlTWkhFMUhNR1RsZnFxYisvN0lDeXZadEphdEhlM0k3alQxL09PREpEcVhMQUtBTVZOWk1jUks1UWVyd0MzcmZFNHl0eVE5emRUQUdMRGswRVk3U3kydXdwQVRCenRiMXFXTDFyVHpTQkVkemJpT2toRjg3RThNVDhmZk1wYjYrZ0JsaUhJZ1I3MmNJeVdwWUVaTXBrSE5rUDhqbVVVK01WZXkrc0JETnl5UVZWZVpHeC9aSGdpNnZJOGlrVVRRU1VSUCs1Z2FxcURzUFhVQU5UVDF3MUk2Z3ZPNkI4Z3UxcXUyZEhPeG5TRUlOOFd3T3FORS9WQXFtVXRGY0FZdjZKdlZ5Vkh3b0hJQmwrNHdzeE1lWE0rRkI4YjJJOEROemNkRE81b1lDRm9IZzVIK2RyejRTMlNyZWdKZVhVZ3BZZnFsOVZFbVljbWNUWWtJUG01a0VkcGhURkNWQTBCMkN1eGxlRkxRRlZvNlEwbTNTL2p0dmFNallJbTZLTllVOVVpQWNkMDFRZEpnWW14cmxnWDBDZE02RDdtbE9jYnFrQWR2QnBCM2J2NkNxM0NhakwySVFSSnVPNU1QYTBwSFYxblptVGZ0WFlsam5oZC9LTldWaVJsL2RMdXNGQ2ZrbG5mZ1MzblpwbytFQlI3clhkQXRIUENZNElUQXgyeWcrSHlFOXVNVzRacGdqcmxhYXBDc0o0eUlQbEp0QkwxcjZqZVFScWFHaFp1Vzl5elp5SkZ2blVYMjZyQmxuVnNURXFpNEhmUGU0bmI4dE04d0d0eUVMSUdXTE5tVFQwRlVuOXBYalRMWHVhZTA4ZDdPNURKR0xDU1l4ZzdYRXJzSHhESThaR3NucnNpQnArNzZxdUxWMXI3UmRjcDhuelUyTXBQWGhKaFF0NnlLQm5hNUtqUWh6RHlvM3pWR05FK1QyWUVUbWY1WkJZK2VORHN4bXBoY2pKOVVwNTZscklGV2JESjBocVVMQ2R2Ny9udDZIclNIM1BRdTFXUGo2ZEZpaU5xTVRBS05wYUV1anN6YUEwN0tmNDhpV2dJcDlVeUF1bHFTTXpMSzZraHZNYVRlMWF6b2JHU2tzZjFySnNLTytLNmJSMEttSWtYZ21XcTErbnY3RVIwZDI3dDNSMmpKeTZlMmNIMU53S0VRSVJabkJkSE9sRlNkRFZzNU1vUnVzUkNDYzNWRnE1RmQwejR0Z2FKTitmU1lLYzFhQkk0UU92Z0ZDem1QaGpYZ2d6MVN5anhpQUtmelMycXdidHFza3E4bU5MdlluWndHRDRJNjMxOWRWRVV2cUFDZDlaQ0tZZVpjN3YyVkVEWmFFc25ERUh1MXZHMEVzb1ZsVlpXTDdFUW5XRmhTcXVrWEFRZ1pKS2VGVFhaRHFGenM0TUtsdVRhR2lnQVBSbm9ieFBSSWlIN0Znc0N6OWN5WU01RzZqWWI1Tzd2d0JPdFZDQU4vZXlRZHYyOUdMZHlpakNRWW5Camc0OCtNc21GQmZsbUN4ZWF2YnlFMklVK2pWaHZOUy9ZZEl4UnI2TEk5OE04cVYrY2R4djUrY3lraE9Eb3FTY0dBK1RienAxYklyc3A0eCtzaXlZb1ArVWVHSzN4QmMvRU1aRlowUVFJa2sxMVVRUlliNlFLcVdQYzV1aFB3alR6bGFIVmFvTDZZNmQ2R3NiUWNXZlgwRExNNG03YlY4Nzg5bzNIYWh5bXNUQ0lXTzVzMDRlVEcxN01xdml6eDM5Y0U2c2drbXRDZ2RDR0NOVFZIV3g0Mk5BQ3hwME1rR1o2Nzd4endXVEwwSk9mMzRoV1pyMldqbi9PVFJLaGx2Rk9ES1F4Ri9iYXZIcHk3cFF0N1FTYmJ0U3V0aFhtTFE2TlNhODV0MXdHWitGcStzUkRwZEI5SnNRb1RwK05sRmRzeFczUG40ZTFwVDk0YjVKekxZUVRERkZQSHJJVTM5aUR2djBkeWNZZk1ISVpBYWE5blNVOTZlSGRhRk5hUm5OVlFzVnFTbzNteVZtQm1tdSsrUVV3d2psTEdETjluditUVlRGZlhsTW9vaGtySFRGR3ZRT2RDSGQ3TUlTUnE1M3hWYzB3ZURZc0R4K1YyTmZMZTFFcGZMZGRDZVN3WEEyNDNySmtwTEJYRDVCVE5KUU1VdW1xRkJURDFyWU1oT1lldnVXdFltS28xZDc2K3Bxc0tFaVhuVE1aNzhxZ3EzdGFUVjdGaGJXQXlWa2hTT2IvZEJGRDdNdkdOS1haN3l5Y0JpOUxIaXpncyt5VUJNeDhWbktsN1pHSVVCaUNrc3cxWnIzcFdtQ0dlWTU5UXc3L3RRRU5CNzdDQnJQcVVYM3pqR2RQZ25TQjRlSXRCUkJoR08xRVBFNExVOElidHFGV1VsaWwrbEZ4dHZCaTVMaC8yeVhuUnZzTDZkZ3NWT05TcHYyanhSWWgxZ3J4WWFTeEJ1dmZzdll4MWV1aUJ3bnZGQThIQTdBTEcvQW1TZjI0S2MvM29rdUJ0VExGek51aTZySkpDTFkwMmxwSXFSbUo3RnRWN1BYUEdrUkJTR0VCdG1iK0Q3dWVNeEo5a240bXVKUElXZU1vK2RmSzBldVhEbE9qdnhla1p5cDkvWUdNeitYZzFvVGhLQ1VsNnRUNGNrUjV5QzkvVjRVbjFLQjZObzRodm95OU1GNllqaGs1VERjZ2MwUWJxVis2TVFnQVcvbS9tUVdBKzBxalZrRDQ4VnVWNGhGaFpvNVhTWm8xbkV2MWlIeW42SW9uVzM4NXJ2NzdqMStYYml4ZDZnWTJUNEhrUkkxR1dJQWJpYUxJMWE1cXVkRmp4Q3pqd09LQ2VneEd4dXg2WUtUTURvd3JLZWN5V1JzUDhTZ0RUWWdkVDVWaFJ1Nlk1aVJ2d3BqTk52VXM0eXBlaUEvRitnVVREVGg1MlJkUDN6SlQyWGorU0dNbmlKT0JUaXVtbkxPUDA1UEdlZDVlNU1zVEhSUVc3a3hOZ1lmZmtIWUw4ZE1wNXNRVzF1S3JVK05vYTdHUXN4U2VXYUdQNlRCdHBwQ0o1MkcweitvKzF2ZHRJZjIvakJxYXh3czNiUU9zVFhyK1h0alpPV0RqMVkzOVpxZFUzUnE3OU9ZVWVzZ2F1YzRtSXRDM3BxdnZMMXo4NG9WWmVob2t3eXdrL0FZWlNlSDB3eE5UUHJJTVN4dERPbk82K1pkL3VSUUtoQlBEWGVpcytscFdJYnRWOTNRL2hwUzZzbHcxZnhDUmphTGtMTEZyZ3BYMG5yK2NEMnEybVRZRS9MVnlsVkFtZTY0K1hSTlYzZXhlVUwvRDJsNnVUbUpabml6QWpNOTJmenF1WVlzZnhSM1hZa3FFZ09lNmVuQUdlK29ROGRmMHhqaG80OTZCdEtESkVHcU1JeWlxT1RHYzJodXN4TDlwQXdubkIzU1BVdDJmUldTVzU5RnVLeGMvUHQzbHY3eWRXL2RjL0lNWWNxMFhXWUhBMUF4azcvOHlBY3V1RlEyL3dlR2tpUUJUaEpDUmRrcXZsTnoyN2xjS2FVVlpIOHJsaGVocFdWVUQ4U3RxcUhVMjBQNHk1MVBvNkk4TjVXYm1KcjRUTTd2b3NBY1Qrc0U1TjRoelhTa1o2cDc3Y1U2aEUvYVZBcDRTYlcvcjJrN2diMHJpVFhMVFczR1U5VE1NVVlmYWlKSlBaZVNrUDVFSUNhM1NocG9MY2FNQUFUTmJ5QzBCa2FvQ2l1TzI3UHd1bmUyL2UxWC9zZjl6aHhBUGFRMVJTLzVpd21WTldMWUxnNFJ1Q1FDUlJFNE9qTnVJQkpUV2hsR3JINFpna1VyY1BUU0VyU3FQQ2JYV2dKYVYrZjNINWJTM1JSUjhtTnhmeDRqdFVaaWZtNVVoVFZxVlNVcmdWQnVHL1JUZm9IY25JRDVkYTlCd3ViRUU0cEpjV3ZoL0g5NjVMWTVzVlh0YnhvVDRaT3lKb00wdDZxWGFBRkRTalhjdm1tWGcvLytkUllwVDZDblh5SXhUUGVRVUtrdER3SEhnNlc2VnpMY2w2UTVGMzczanV0bVlVWEtZWlhXTVhqa0M2V1g0WXIzTExvMlpxcmExUU1yOFRuWWpGYjBQWGxMOHZnTHloRlpWWVRoR0Y4bVFFa3M5NUFKcUQrWE1JS3hycTFJMmgxWWYzSU1BMndRQmFySzRhclpRN3I3L1Jvak5SbVZ5cE1xN1ZVellLb2grdms1aWZLVE91Wm5zZzRFSmxaMUhiVVdmbGJYVmR0d2J2YnIvTkI5WVV6UVNtVVJWRktLN2s0UEJGYjNIUmdDZXZ0QWtQaE12VUJuRDAwdDEyMGtwOVVVc0FYVVVEWGI5b0JaaTdjZWwwRWtMbEN6MEVRb2FzQUxHSHAyelRTbEloMjBrQ0VaZEdJaHYyd2hOK0dTU2dvSk5UL2hXTGRPaU1aV0xBbGNjSnA1NFN3RllZZVVGRTM1aDJtU2RqaGxrSjZYV3hJbHRYd1pXVXlmUjdxdThxNHFYWllhaFRzeWdNV0dDNWRQMFBTaUwvbVZGWDZkVFVmSDNsMVY0MHhXVHN6Zm5wK1NQTTkyOTRvamM4L2g1aElVaXFDVWxwbFlzTURDNG9VV2FsZFZJbHhjb1orNHIyc01xVEViQTZNQ2V6YjM0N21uaC9YME0vaytXTU1vbUhBajEyMm5CbmN2cjJVTVNndWlCZ0N2UDQxbU0zTWZIdjFkQm5YTGVKOEdobUhGdmlOMlV4S1p0Sjl1TkdoKzlxUWN2MWRZK2ZGc2lwNUl4YWRwWFNCdUlvRHpUeSs5OUxiN2gzOVNFTUxJZlNubHRBNml5UjNYME1lM0czK29mOWo5L2FhVHpmTUYvVWdxNFNLZ0p0OTNwTTZscWpEQnNRMlVVYUtYMXB0b1pqRGVSeTJvWnlNdFcwRHByOHVWYjB6cTRGYXJuZStyTE9qcXl2K2UzNDQvRU5YeTRyTUZUajRoaWdodHN3cVpySW9GTUdLVnNCbElobXFxWVphVTZXZEs3SDRCMFk4c1JiQ3VBcmQ5OVZuODd0WnQyaDhxVGM0RHErZUc1RnJFWjIyczhzM3QvVnVCZDc2TE1lZ0dQd2IxTWdaZWVJYmFSNXN2QWhaZFM5UlAvS3U4c2doZ0pLaUM3Q0Y0NlF6czBSRllkaGROY1F2UDYwTlI4UktjdUtIMmxPVjFnK0VkblVaaUNzMlVCeHZRbWY2azFQajZ1NmJZME8rYWNObmJIaGxkczI0Vi9xYW1BbzM4b1pvTm92N1lUUlg1QWVOdU1ackpvS1U4WXBvdHplN3FkalZ4VTdGQWVaV0pCbXJTSXE0bGl5clpJQlhhL3czMmpURVl0NUZJQ2ZUdDZrZFh5N0NlRVhxcWp2Qmt4c1M1NncyY2ZrSVlmVU1SR0tNT3pGTEZOTWdzOWVSQmV4Q3VydFlOYktyNUc0SWhsQjV6RXJKdHpVaHNhY0xiUG4yODlrVlAvSEhyWGowckN0aitoTTlzRjFUNmYrSGhwRGVlQTI4UFk5RFRKMkxRNGpvL2xQU0hWaVFnU3Z3WTFNNFM4TjZNL3FNRVFmWFhlZ1o3RUNpdGdVd09Ja3ZIbkkyNUNNYXlPSFhweUxrN09rdC9WZER6TzlWZmFacFNldzlWWWtIdnYyMUwvSVhidHVBZk1ORngvNUkxM3BrK054Z0ovaUNkRUZqVkdNWGZYemtIVFhxN3Iway8vOXF6dVB1MmJYNVNJSGZUTE1PQnE5L29ZTVhLRW5TMnFkRmdTY2hjeUZRYVk4aUVCTFhEUXJLakc1SEZSUlFTRmRlV1VtZ1VTUWtqdzhaT2pYcEk5QTBqVmhyR2trVVc2bGJTUkpkVWFDM3Q3aGhEbkdHVlZjYVFhMGMvL2YyTFdIUFMzR1BRRUsxVmYzMEZHaXJvWDBmcGtLUERiSWh5aUd3M25LNFdCS3NjRklmTkRYeVZPNllBYlRvdEhmL2RPbGhtRnROUG9qVFZxc0VNMmM2aWY3dGFmdW5rWTMxTnN2c2NSUGRCazk1NjdmRklrSlRjL2JPdDQySEZtaE9QZzB3OGdtRWRNbzFCQlAxSmtsVjFzNXFoVERXcVVld2kxbEJIczE2SkFBVkZGUWhrcUMxUFB2SThpdDFPMURidHdKdE9DQ0o4V3ZXTWdyWHlyS1dvMjlLR1pVZDVjNHBCVlRKRFZ5SDN1bGhJQytRT3BKSHUzb2FRUVVBcFdNbUJka1ROTU9xcnlMTDJyczJZQ3RRRExoSVQreEhHVEFlbXFMVGtxdSs4by8zZUZTdkw5bHVUMU9NZnRTQ0IxZThtMHh4UkJjc0dHdGRMdEQ0WDV2RmpDTWVqY05YODd1clBWaFZSS0FKaFJCZXVZR2dVeEZoSEV1R3FCTks5dytnYVRxRHIzb2V4WVltSHZwRUlzZ3hMNWlwWXB1aEM1K01lNnN2RnJER295OThzejhGb3IvckRBb3pGUEJPcFRBb2lQY2ozenVwc1ZWRUhpVldKVjFFUWkzb3pnUGlTdjRwNHNNZTJ6QWxNdFg3NHZlZGNJQm1yK1pxVTBWcGtxUDh0WTF5VFJJQ2F0SUFCcXRLa2FDVlZPcWcxS1RteUI3RTF5NUI0K00rUXZXMndhS0tyR1JLdFhSbEhiOU5XYkx5d0hOSFZjWXdVVVJ1RENZUXFYV1JEZnNpVTdIb2VLWWZuMUtTUjlKcXh2V2t6ZXUrNEM2dHJEUXFXQ1VOTnNzekdWNEpsSXNOV1N1aUV1aElzR0FNVWxCRjRiSGlaOWdXcm9pYUNYbEUvcHhqVU1VS3dLdU1vVzFxRTFnNHk3NURRYWNzeE5lR1NLL1cwNXBteExNMnpGNXhHUTZmenA0ZTBCR1ZHdjVvSHRxU2NGaXExYjVva1lqYU1DaFBaWFozby92NDlzQVlsSG5zK0NGbTJIaHZEajJuaGtMUnhKZ0dvQ2toVTFETmtRZ2t5REJVQ011dVRHL1VuUDNiM0k1MTB0ZEJrMG5SWDQ0SzFieWJhU2JkcXdRcHQrd3NpOVFJUldwYmhQbDVUNVkyejlLTVd3eC9HT2FwYzJGRmpkQ0lXTElKb01YenJhWFd3cUpZQ05DQXg1bVVRby9abmhqTW9hd2pSMnNqMEhNQ1VoNkszWlgvOUtucWYvWG42Z2l2TEdiaTdHT3ExVVd5bkVDcWh1U09sZGFoSkxqWEpxNmhHb0NhS3BOTk04enVLZEZNM01nVERUU2hkTm5XaC9mM2J6R2NYSDJtVWJhZ0pMMUxDVVZFV3hWT1B1emgybzZra25hYlpRVkFuNHRYZmQvR25OZGNGMlk2cGJVSlIzTUZneVlFSlZwaUNkY3NEcFk5dE9qbFF2N1JCTHBndUJwVzhoejNnNmhuUVNsd0RPL2ZFNU9JS2lCZDdIUFJSY01waklZUWpTZXhvQ1hUTkVjeUQwc0V0OXRHblRubU5wQjFLN1lzbXVlbGM0VFZvdG9LZW1ybzA4Nk9IaTcvLzFGajgxOGNGdDcrUlp2YWplZUdvcFhBMGJ3OWpJR0VoR3ZZbllOVEpCL292UXpGaUNvMytnd0twTEJLSjUzRFNoUWN1V05zN3pWLzkwei9HL25EeDBhbjF5MnJjWlRWbHNyNjBTSlNyRWZtR01JU2RrZTdJV0hob2VBeTlvMG14cDMzUWVvNWhhdXhERjdrL1d4eW4zK2ZMOVRBMGEya0RmdjlNK2ZmMkFjeFh2T3BQTDNjK0UzaGdkV1AydnZQT05NK2FpeWFwNUtudElOMHpKRHFmMlIxNTVEZlB4MzY3WXlDZzV5SkkyY0gwVk1KUlZ1bm0zbGdSRWh2dVpPRlFDWnVRaVFNVnJKOCtGdi8zbjI2TzM2MUU1bGZQUlo3QWMvaXI3Z3pOSmZseTV0T2R0TlZyTERSeStTbXI1V1U5dmFudW9kQlJUYjkrcXVpcDNkbXVSekhGL1BOejBGQTU1MWxRbGl4Wk10dWZORFlLUTVJcFZuT0tyWG42NHVTcXM0L3gzdEpRTFJlU3BGYUdMYTgyR0pUbEZwdmJjZVhZV0JJZEJISGI3aDd6aGMzdGdlMVB0SVphUnpPNS9yWGN0V3RpYnRGbjNwSzY5c0xYbVNjcTRVZ2twQjdHbHhjT3RWVm16MU9mSGFsanhGU0dFY09nNkg2eU9mak0wcVhXNG92T005ZnZ5N205UTZKamMwdmd6Ny9iRXJ0OVcyK3dvd0FzZHdvQXB3UnowanBkbU9KaDVyL3h2ZGYrZ3dsb0laaGlHakRIZ1p3QjVNbm5GQXFMT1lWdkhtZk82Mm95alc4NDFqbHZVWTJzQ3dka2FUUWdxOE5CcjlRU01tQTdNcGtZUTFmbmtORzB1OXZjVHVGb2VxWTkySnJJR2xvVmVlNmlOMnh3emx0Y0sydENBVmxXZUs0U0xKN2IyVE5zYkd2cE5iWSszeDdZK25ocmFOZHdXczAyOVJMUUNyL1BCVWh2QmthTFNabzZVNEwra0FFNkZ5MmREdGlaVmpIRkZwT0FCV2FmVEhoeWVZZWNKbWNxcDJuc1FvRGtMTnJvVGdMTm5RWE02Y3lzbkEzSVErVkRDeHRycXRXYjlMczNDOEVxUExldzFzYWJCQ0FtWFV2TWtIZkdMUDVvY2dOTzFlaVRWM2VLejg0MHg3dVQ5c3RaVW54ekJuTmZBWlZ6WkxaekJkV2JCY0RDNjNoVG1GeDNHdTJjUy9HYW5FVmI1VFNhS2FmUUxuY1dNK3BPczM4dVlNNVdOWC9RdXMvbVVpT0tXVUNkcnNPOThKakM2bkZSQU94MEFCcHpTRlhLT1dqcGJLWjNLbURtNGl1OWFZUmxUbm5hUTlGOU5oZXRuVHptUXM1Ukc2Y0MwWnVjTXB3aTg3U3Yycm12Sm5jbVRaVXphT1pNZmxMTzBBMG05eFhFQXdGMHFxSGgwOTEwS25BS3IyTk0wV2hUZ1RuZE9oMkl4ajY4QzJZQmRTWUxNeGVOOVdZZ1Z6UDFjKzR6a0FlVEZNMEU3RlRqTkNacnI1aUM3T3d2bVB2YUkzUXdRSjJKRGN0OU1MUDdEZUtoTXJsVEFWdG9NcjBwVE9aazlpcGVCakFQcHFiS0djQ2FEY2k1eEpiWXRXdlhJUWQwdHNrY0poT2o2WUNkUEFoSHpDV3B2NDlnaWpuNm83bUNlcUFnNzFkcytVcVozTG44RVRadmpzQ0phYnJkWmlJL0IwTkQ5NVVzN1EvUWM4bkp2dXdtZDZweGltSU80TW81QWpjYmlITmxzdnNES09iUThISS9nWjVUZ3YyVjhxRnpBWFUyZnl1bVNTVk9aMUwzVlN2RlBqYldiTnFLT1dSelp2dDh5TUE4MUtrL3pBS3NuS01HenVRcnhTRjQvdGw4NjF3MWVDNkppNE8rV0FlcEFjUU1pWVc1Z0NyM1V4TVBOYUQ3cTdtWTQrOEhIVnpySUd2bVRObzZGNkdRQjZpSjRpQUJ1TCthdXkrL0hSSk50UTZCZE04MHg2czhnUHp3cXduUWZRRklIdUM5WDFFZkNzeGhIb0Fad0pXejVGMW5BMDRlNUhmWTMyUGtRUkNpL1ZyK253QURBR0NrSUtocTluUFZBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpOalF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZek56UXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQkNOVEF5UVVaR05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pCQ05UQXlRakF3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNTZGR09nQUFRQVpKUkVGVWVOcnNmUW1jSFZXVi9uZXI2dTNkci9jdG5YMkZFSkpBQ0FtRVJRVkVRR1hSd1gzRGJkeHhSc1VaUjhjTjBKbHgvenVPNGpnNk9vcUt1S0F3QThvaXlMNkVoSVNzM1Vtbjk3MWZ2LzFWMWYxLzkxYTk3cGZtOVpLUU1Qci9wL09ydkwzZXJYdk8rYzUzemozblBpR2x4SW0vLzNmK2pCTlRjRUtnSi81T0NQVEUzd21CbnZnN0lkQVRmeWNFZWtLZ0ovNU9DUFRFM3dtQm52ZzdJZEFUZnljRSt2L2luelhYTndZQ2dXUDV2ZUlJM252TWtzMkZRdUdFUUY4Z0FZb1pCQ2lPbFlDZnAxTCtSU2loOVFJTFVqeVBpWk5UWHBmL1B5amhuNHVGaWpsTWpEaENUWjg2Z2NkTHNIL0pTbmhjQkNwbXVTOW1lWjhzYzErV21hQnk5LzkvVmNMakpsQXhpeURGTElLZFNaQnloc2w1dmtMOVMxWEM0eXJRNlM1NnBtTXVrMVB1S0RkUlJ6dEpmNmxLZU9RQ1BVT1VqTnNxLzlhRnR0MWNDYXhnUUx2WUJlb3RnVVkrWFdlYW1NOGpZZ1ZRU1hJWk13VXFwRUJRU2gzN2h1UU04R1hiS0RnT2JOZUZ6ZmRucEt1UEViNDB3T2M2OGk2NmVaSStQdDZmQVBaMVdGYi9YQ2RKalRjT0xQZkgyOER4TnZBRDljWHhCdnp4R2dZcU1EbmVJTThxcGh1ejdhREFNZHZTRzI5YWpaZmpIUFhIZTlBZmIvL1JqUGNGczlCNXR2MktKVEc4bzNVSnpzOG1VWlZJQTdYMVFEZ01jR0xVUmNKVk14SHdkTUV3dmFHclc3ZkUxcWFxc1hxZ1Bzc0pnc09ERStJZGZENWllTThOandQNURGQVYwWm1Sa1dWWisrRTlDZHpLVS8rWWs1VXBOMGxUeHp2dWp6ZWt4c3Z4T2NYeFdpcTg0VXp6WkdLdTQ3VW54K3p5MXVHSlpNbDRoNDVpdkVjTmt6TVZpWlZhNk5PK2hiYmE5bG0weUJ2T1B3TXZxb3B5MEJWQUtzdEpDUEorMkxzWTRlZWZIT2tMeFo4STlieFZuQ0RoQ1VwZG9WRGZvOTdEc2FqaHFJY21UVWVkUmswUUxadjNhU3A4d2xDdkdaNEFSb2Y1bU9lUDhYR0E1M3A0RHpvZTY4ZjFBNWIxbmVLNHB4dHZNRVRsQzNsalVFSlRRMUpqVjk5WEhLOTZYaWxuOGMvMXIwMldHYTlCQ0JMK2VEMjdtMzI4RDNHOGozdmp2V2s2b1I1cEhIcEVBcTIxN1d2WE40Vy9jczFyb3BDY0RUdlNpbmpjUUUxdEFJV2NpMnhHWVkrTGZNR0ZvdzRFT0FrQytieURiSlk0U3V6SlpJbWxCZDR2ZUJkZXlLdkhCVTZVNEJ5b0diWDFaRWpPWGlHYlE0N256V1ZzcE5OWjNwYzhGeTJoNEUyUW1tdWxNTVg3QWROVG9td0JCWjZPNzBhQWx4QUtXUDUxVUJycWtyUThwSmY1MUVvbGxLS1pFSmFCUU5oRUlHVFNjaTNFS2dLMFZqNFg0RWtpQVNwREFKSlN0L09UNDVVY3J4WXNCK0U2ZVo1S1NkcEJQcHVHNUZ4b0pSQ2UxU3YwNG1WZ2xHQmN6OGZyNkp4MjBISDg2SEg4ZHhYd3hqMldOZlNDQ0ZSWnlnRnErWXRPcXYrN0Q3MWpNMzcydTEzSUlJWmxLK0xJcG5KNndBVmVaSXIzODVrQ0o3MmdoV1lGMUxsZFhpUXZuT0oxMUdRUW0yeDFvWng1TlNrT3IxZzZ4UW55OUhSd2xKT1RkdEJZSldFVGtBWTRBWFVLemhWa0djVUw5YUE4RlBJbXEraml4VFNlZWVwbHFzZGFPV3dmM2gzditidzZyeElBNytmeUhyeW5rNFRzZW1XdEFtT09DWWRvVkY5cmFzdnpNRmdwb0tNRnF5eFNXYmpRd3ZhK1J3MUpXYm9hby9DUnFrdUpqc0s5NGErQW5WM0EzOStHUS9UdEw5bG5XZnVPcTBCTlQ1ZzNibHhVOS9FZjMveGVmUHZyUDhidWcvdlJHQU15cWNuSjFIN0g4S0ZLZVA1b2d1b0pIOUtrT0l6K3FjblRCaUs5Mnc1ZTJGQzN4UHFUNkcraTNpU1BVSmhCQ3JLeTBqdWY4bmRGUDF1MFRuVUpSVDluV1pPKzdqbUNMRUsvbUJTK0dyTmhUSjVId2F4NlRHUFY4R2tyd2Vjb1hQcGNsN2Mxdkc0YU1MWWZCTVk1cnRWTGhYWTFHblo5aUxVc3FZVnRsRHduaXZQaXc3b1NjRCt2YmJnVHVQNHE0TFpIZ00vK0QwWnBxYWZ1dHF6TzR5TFFUUnhsTC9EbXhsam9CM2YrOFhwODk2cy94Zi9jOGhqT1BjL3pRNjd2ZDlRa1NtRnhVazFOQ0F1MGFUdXYvSXZKNTRTK0VwTXpwWHhQb1VDclU1WktDOVdXUVVua2N3NzJkS1d3WVpHTjg4OGtKSTBScHFVRmkvRFgxR3lScUFodHdRWm5SOTBxUzdING5CVUk2WW5VUHMvMWhLVWh0R2dXMHJzcmk3N1lkMitPd214bFFmQTB6Ykh6K3MzS2x4ZHlXZTBDWlBHejBwdDhwWHg5Zzd5bFlEbnBXRjRMSEJvQWZ2QkhnWEJWRVBHb3hjOTdKcWw0Z21WNjlGaFJkV1d0cnBUNm1vc0RLdGplZUhhUjc1Ni9BUGpoUnlLNDhlWTgvdlVoNTlsVzRKU25sVlljYTRHdUZtSnpwRHI2MEU5Lyt5VXMzM0lXZm5UOWx5RTBNU0NJMm1uS3lkQmFGN0JjUktKaFdpa24zM0RJRUQwL1l4aWVEeWx3Rmh6U1BJY1hWTkNReTBQNUhONGVPRGlHLy9oMUc5NzU4dVU0NzNRSEQrNXgwTHh5TlJhMlVxZ0ZFOW1jUWQ5TUg1ck0wNGZhMnVmbTZDU0Y5bGFFUHdWM2hIRDFuS3Y4Ymw3ZHoxTW9oSGo2YjR1bW9oNDdoYXdldC9ybk9nVTlzYTVVWTdENVdwN244dWFoa00zcXg3WXphZDFGYUk5RVBPRWVwSmFQa2VCY3VZNStjRG53ejdmeHRhWnF2T0xjUnBpRUcwTWhoU0U4SDgzcmxDb080eGpWbUpTQ3ErY1VwMUN1UjZHV2tzRXJ0MFN3b0Y3Z3VtLzA0NDVuc3ovcHNxelhIL1BrUEkzd2lsTWJnbWdNM29yK2UzNkFTODROb1licUtWeGVjSFpjYTdTMGN5aGt4am5aRkJKcFNEcVZRU2JOQ1JRS3FpUTRsekFWS2VKOWwyTVR0aHFseDMzYU80Q2JicGY0OUh2UHhTa24xZU1mYm53STlRMFJOSGZ2eG4ySkRDZlNvY0k0ZWdMeU9mcm1uSzAvbUNPeENvV1ZCYmdhTW91aFVkRUVOZW54eVlqMHd3OEZrOEpuc0tWUXJMMUF5TE5jL1ZySS85d2tXWjM0VTdDY29VOXZyaWIwMHVIZHVvTnhiUXV2NFYzQWUyNGF4WC9kUG9ZUFgwRUNaWGwrT0V4Q0ZRNTR6Q3pLMnlDdDFqUURGRG9WallNS0VHbHMxOFJZa29ReXlUa2t5a1VDQ2psdzhYRUpXellLRVNIS2ZQKzhGYmo2SHo1S21DWGM3TnJyK3k0ZU9mb1VKVERPTlpKSmoxeVEzQ0tUOXlaQ3dYR3VJUFJFcWZ1T2YwdEYxZWQ2ckVQaXh2ZGZpRGRkY3k2dWZlYy9vYTRsaGFqaHNWakZDTFV2ODYzRENwVDRQQjltSFIrMmlwRHJ5c01GVUNRK0VwT2twOGh5RFdQU2x4YUpsZzR4TEQ4OG1aSVBFcVUrMllkekZYcy85aGp3OFpjQjh3bkI3LzQyME1NeHJWc2l0SldHT09ZSUNSVGxpRmhJZ2g0RU1WNVgyQmU0K3I1S3ZyNkdrS3VVNE1aYmdOdmI4SFF6Y05WV3kybzc1cEJMZ1VMTkF6MzByZGVjanlzLyt5bmdZNThFZnZ1Z2lmbVZpZ1hTLzltRVBVZjV0RHhra1JLTElnY1JFeFB1K2xyditnUmhnQmI3M2lzMzRSKy8ramE4NGFLUElKZEk0cFJUcUJnWmI5TFVkVWlVQlAzU20xYUhKbWNycGlLVlQ3VTBoRnFNVjlSYXAwbDRWYkN1Mys5SURXVzJQU2xROVpyeTN5NlBBalV2bi9kOG0ySUQ2dnlHNGZrLzA1RDZlZlYrbjhST1FIQ1JnT1g5ZWU1SkFFMFV5ZzgvR3RSSytxNXY1akhxS3RTWW1BUXZudVo0SFR1SWFJanNuK2RYY2V1aE1lQkRMN2J4emdzNXI5L25KTy9GdmJWQ3ZIUy9hZHJGdVBTWVFxNmVVQjVOMUpqL3ZBK1BuWEVienZqcmE0QUhIMVZXWnFHaWtoZnVHaHJUd2tIUEFxVXNzbHFoU1ZPUk9PbWczWDg4bXBCNHhmbGI4T2xmZkJjajdidXg3dHlMVUV1b3RXMWxlbDRzWndXQ25GZ1hVV0pWbVBGS2hLb2VVdkZnVUZtOFM5aHllWi9qVXg5aGJDUGNMTi92MFVndm5uVjFQS2pPSmYzNzZsYUZVd3JDbFQvVFBvMzNIZHNMcVhSY2FTc1l0N1RQVTZHWTh0czVma2I3NzRMVTc4c1M4dE1xMkMxNGtEK1NkckVuRWNFRnB3VngzUnZHOGVrZkRXbW9WY2tMTlQ1MTJMYWxoMlFSRGd5T3MyOEVPSHRCQWE4L0YvamNUNEZiS013eHk3cGc1SGxtamVZY2gvS0xha01DQjM3NVBWVGVkei93NWU4RnNLVEY4TmdxWTdOUUtLdXpPVTRSQWpWbjk0U3JoS2swV3NNdFlYbzhaZUMvZm5BSlRuL0pDdlRzRzBKanZha0pqYUIvZExMRG1wSXFSdXRreDBpbWt2cjdOWVNUWE1sOHlsTTJWd1h6SG1OMGlkR2FxYnFUdmxQNFdSeXRRVVdZOEVNa3lHSVk0V1VZUkFtalZSY2dERk1uUkNaZWcvOTUramhGeEJSckZYNktpS3FueDk0L2JLTXlRcnlnaE4vejFURzBKVnhlbC9CZ1hJZG9RVzJaS2h4SzVZU211ZDkrbDRNL2JBVStmdzkyU3RNOExTRTB3emdzc1g5Y00wWDF0bjNwUzAvQzcyNzRESER0eHdVNmU0T29aZkNmSXh1TlJCU0xsTDRsZXRhcHI4VFAzaWgvVzlCeEk5a3IvZTJxZVM0KyttNGdXc0ZZakRLTVYzb3BNaTE0NVl0OTM2ZXVKNVh5d3c0K2tjbDVRbE1UVll4RmkzNnhxTnZxZGZVYVpFbWl3UzN4b1ZQV1JOVGRvSi9tazc1U1JFTmVMS3ErMHlNMG5xVUZpLzdXei91cWEwclRUZFJWZWh6aWhsdnBWM3RJbXFvRWdtSHZtaVNWbzVBbndwRGtLWUYzRDdqNDVKVUZ4UGo1ZDkyTXNaZ1FwM1NZWmgrbWhPL0hYYURxL1RXMi9SOWZmUS9lVXQ5STNQK01oWVVMdk5BaUVzN1JMN2c2RUZmYTdmakpBaEgwL0thNmNJWjRPcFJnaUltQklZa3RpeVErOTBsUGFOLy9vWHJPSTBGNWFuQ1cvam1YdDNTNlQ0VTV4WGl5S0NqNDZic0pBbFBDWGlRbUxiWHNpbk9abWdTemhDUVZFeFNHbUJRMlpFRG5mdU5oVzRjNEtwMllTQXVzVytEaVRlZlQ5MVBwUHYwejRINkdOUE9xVmJyUVN5NW9vZWNJNFZUNmlvaURyZ0dCUzlmbWNma1p3UHUrUytTenhZdTZUZk5oVEhxa3c1WUlqM3RORWJYcGZWLzZkM25sOTcrQytJWG5PWGpnVVlHNkJvOTZLZ0lqZk10UklZb2ZyOE9NRkJGTEtCZXBNMHlWY1lFL0hnQys5VzBKUmJaVWh1WjMyMHdzSVJVVUtwYlQxaDdneE5tSWhKeUpLeXpXZVltcHpMTlVQdVlraTVVK0E1NFE3QXpWUDdJRWp0MWlNcDRQMGxUWURDMU1wR3gwVXJBR3g1ZXpEZlJsSEx4OHZhc3Q5ek0vQng2Z01KdHI2U01WaXlXcFVDNUVCZTdTWDVRWVNRa3NxTEZ4K1NhNkxGcHl0eTArTVdLYVQ1UlpIMzdobHM4NlRUT1R5dHVmK3ErYjhkV3JyNUI0OUdrRzhnVkRoeGFtWjhRSUJyMGt0Sm9NQlpmNWNhQzZ5VUtlRXpETyt4dk9hVVI4ZmxRNzFWLy9vZ05yYm5IeGtROENPM2U1aEhHTHZrZEJyUEJXYm9SM2JsbXluQzFLSkNwOGF5d1ZxbDRsQ2ZqV2FwY3NmMkZTdUllZHExVE9Vd1N1ckRTVFZ3dWtEb1dpaUJQOUlrM3ZRSytMOTUxajQ4ck50RFNHSzNkMzBYcERCdkxTQzdNcTYrcVJIT3llVUs0c2tVa3ROTHpsWlJKL2VBcTRweHQvR3JmTWZ5dXpnUDY4MWttUHF0QjZ4TEwrejQvdlIxK0N3cm5xRWtuSXJmRFdRVG1KS1Q3WDFRR3NQMmN4cnJuaDFiams2cVU0K1pRS3ZQS3RtM0hlcFV0d3hubDFXTG01QlJXMXlxSkQySERlY256NUp0Si9lcEIzdjFXRlFiYUdaUy9IcWpQRGszblM0bktVNmNXbHlsclZzbDNRWDRNOTdMQzhXeTFjdzN0Y3pOUHF3eitIR3ZQRWU0M0REL1djdHhRb2RDcFBEVVI5Wnk4WjR2b0ZOdDV6S1dOSHd1enZPMDBzYkRXdzl0d0kwY3BiVFFuRjV1bmt2dUdIY2YzREVsZHNkUFMxZlBkQllaUHR2bmVhNm8wWHpFSVArMUlxK2hkdStpRytjdDBIWGV6dHI4Tklid3FaWkJKTFRtcEZzS1lTTDcycUVXNzFPRUlYWG9obEc3Y2pteXFnZWVVcENEZnVRcDRzeUU1RjZSdEpET0pCMUsxcndBMWZITUMzdmdhOGFMT0RQejVzWUFFbnFHQjdqck4wVFhKQ0UzMGhpUktWZE8xSjRsTk00aXVXYXBlc2V1aTFUeFViV3A0d2hRK3RldFhPZmU1M0ZHeERLNVZoMlBxODQxbUJpRkhBSjYrV3VJMmU3eVlDNWtXdmFFQThQb2h3ODFLc1hOMktBYzVGUlRTSVJKZWdnaXNsWlV5L3ZJQXpWd0pmSWRTUzE5MDRZaGhEWmF4VFBOOHFocU95ME5YcnBCQUx6Vy85b1EwRHY3aU5rekhjanVxTnIwTHRnZ1g0OERjdXhqVi9leFppTldmVFZIT1F3d21Tb1Nwa1J0SndSMUlRNHlieTJSaHNxNUhNYjVTeG9Jdlc1ZlB3eEZBUXQveVNyTyt0WkpWaFIyZDRsTjhwTGoxTlBYUTFnZUZabVVVckRVVW1MVTBkUmN0VnpET1o4Q3hid2IwU2lvb1AxVUszZXQwS1lXSmxaT3AzcUhOTDZRMUM1Y3BWTG5oa3pNYTFMM2NaZWpCKy9BMko0NllhV05Fd0hHTWhIQkllaENxeGFDbXdjTTA4dlBLYU42S3lmajZHZU0yMVVSZjNQVU1HUElLTzhiRDVRMy91alJucXJIQTBsbnZFQXQxOG5oVHhLaGlCUWVmQ3RWVUluckl1aGkyWG40ek5HMXJ3bG85ZlEyMWZDbWQ4TVdkeVBvektaVEJURDhCd2w4QU9OaUNiNlNhY1Z2UEk2NWpTdGVOd0EwMXdDcU00K2ZUNStQcjN2Q3FDcXk5MzBUdm9hS0VJMDF0cDBjS3lEb2RFMTU2MHhrRFlFMnB4elRGQldEeDBpTlpBSC83K1Q2M0hQOTl4RlY1emRSVU90UU5qWTlCRVJaL2ZXNDgrSEdvdEg0N055VEJIOFlLdVFZbEwxanM0NXhUZ3V2OWthTElzanVvR2srYTBoUEgyWXJMNURKekJlK0dRMWRwakdVWnNqK09DRjNmaTZxc0syRFBtNWJHdlBRYzFEWTd6MFZnRnpHa0swVjc0bXFLT0I1dzNMS3pBOS83Ky9VRGo0aEJhWG40cFF3MlZrbnNUeG50dVJuN2tqOGdGMWlHWGJFUE9iQ0xqN1lXWkdhTmdXdUJhVVU3QWlFNGd1S0VsT2lIZ3VCV3dJaW1ZOHkxODdaczJydnN3U2NZRERpZmVSRFFHbmQ1VDZUajR2azhKWUl5QWxTZnhpdGNDRlhWZWVZZUNUTVU0VmZMaW5KZldJTnJjaURXbnhyRHBsU2FGc3d4di8veEdTdWFiT0RTVVJ0dTJZU1RURktyaHhieEt1RXFJQ29yRHNVcmswMm1kWmRES3d2TU9KZ3kweEF0NDMyWEExNGdrN1RLSVRjc1p3bGpMZUEwRGhOVWtCSU5YSXpORWk4M0RURHlCUUNhUDJ1V2JzUENjTkdMUjdlaDZGcmhzQXlybjErS2RYN3ZET2EzTEZlOUxHc2ErTWhXSEx4emtIcmpYZWN2OEdMNzNiOWNUd2hoUTkrWlBwUmxVRVZvSm9VTy9JYXMwNFlTVkVMZkNTZEVpeFVJVU9FdjViRHNGcnBheGFKbUNFb2l0WlJoVFRTdEw4dWpqK3pOWWVQSTgvT3BKZ1QyOHhMZTlUbUowM05Ycm5zR3c5S3pHOHF4UUpSK1dyYTdGaTE1MWltYVJuWHovaTE2NUVpOTU5VElkNUYvK3hqVzQ5cWJMOFpaUG5Zd05sNjJDM1VabXVwdDRhNjNHNnorN0RCLzkybXA4K084WDZHcUlIckpUbGJiTVVEbU1nSGYrMXFYTHFUaU9aNlVxamlTekhSKzM4ZkdyWER6RjcvcitWbURkYVZVbzBHM2tuVkVxY3cvanpBR0dhUm02a2xiZTl1dDBwQXd1b0xYV3dPNnB4L3F6TitHSzk2N0Y3VHVBRmlycGw5K0VNOVpYdTNmRkhlZWlZMm1oUnlUUVJ0dStodEhHdjMvblJpK05kOXZkZFdnOWVRWHg3VDZJUUFRaThRdVliaEJXZkIyc1pEc1o0Y2tJeEZiQnloMmduMk1zSXNjZzgyMXdzM3Q0d1NOZStpZXdpRWNyZlpWRks3UXhmMGtNWDJVWXNIa0RzT1dNRUFhSHBQWjV5azhxWDdoM0YyTzlSVlg0aDU5Y2c3Lzk5bXZ3eVgrNUVCKzZiaFhlLzZVcmNNM256c2Zudm4wbVh2T081VVNFVWNqOVE1Q0hPTkRhdjRKUjFRbDc0QnR3OW5kQkRDN0ErcXUvaVE5OVlqM2UvdTRBYnZpdmRYajdCK002bTlYWktSaGlyZE1aS0YxaTRob01wUnk4Zm91RHBTM0FEWXczVjV6Y0FsT2xrbFRlMmM0U3B2bllXa1EvWEVFbG5lK3RHVnZ6YUdZdWJGcXFrZXVGQ0o5Szk5cU1sbFhBblhzSjEzUVJYM3dENGhjc2tEZFgyL2E3WDlDcVAzVmRQY0RiT1kvZi9kY3ZrTFJRYXovekwvUk5YN3dDSjU4WlFtR2dBcm1NeVdEYlJpYm5JSjJTblB3a2tua1RpV3dLaVo0bmtNQUdNcjUycE5PQ1ZqU0NuRmhINXR2RDJMU2JsMDJMdFJvZ0M1MVFadlBRM1gyNDhlMFNxMWVHOE9YdkwwS0Z0UWRwR3RqYWMxYWlhdEZpYkRncmdsUFBJOXdkQ0VFc3Z4b0I2dzZZZXp2Z1ZMOEttY29IWUk3MUlUSmtJaGxjUVRUWVQ0VUtJMXAvS2xMRDkxQUlyWWdFVEJqeHBiQ2RuNURGZG5LeVh3RlI5MnEwUDBvWGtYWjV2Z0srL09IUDY5V2swV1FBUzZvY2ZQcU5MajVMS3ZQYkRndG52SGdsNVZ3UE8zZElMd3BZVk9aUW1JVENhVU8wY2pHaVpMaXhVQjZWVVFlaG9FUjF6RVhJSEVGTnpVSlV0aWF3N1lFK1BIN0xLTjU3aVZjWitNMDdnSi92d05jWkRuNTBTc1pJcGY3a01iVlE5WVorNEhXTlFYejNpNThnZTFzQS9IRmJNOTc4NGZNNHFZM0FNUEhEb1VEb1UyU3dDbTdxRVRneUFqdFNTVisybGVUZ0FOem9xVENkUGxoR0V5MlI5TjlvcGg5TVVvQmtDZ2JoV3NGdW5wYmo1bUNGNjdCc2NSaGYvdzd3MU5ZY0ZpMXF4Wk5kRGFpZXZ3alhmZmZWK090UExjU0dMZWZCNkZ1b1VoaHcrZzRnMnhWRTNvaVRnTzFCZUtnV2hlNGgySlZYMHFkVk1URGVTNkpBZUlRSDc1R3FMUkNoR0hKRFQ1SXdyU0xVL3hWa1R3RkdzaFlyVi93QjZ6YUZzZnJGbCtQdi92V2ZFYWpZZ0tHeENLb2pMbTUvRkJvdVY2MXQ1bWZHQ2FWZEpIczVXbUlOcjBVdElnekJzVnJnT0x5MVIvbWVBYjB3RVl3MkVaSUhFR0lBNjBwQ1FHWVpObStwaEp3bjhOUDd2UFhTRHpHZWZldDZmTERKdHYvanVFS3VlcEZjNHlVVkJuNTgvZDh4bUQ2TkFSUXQ5T0JJSzg1L0c2RTJYdzlaSDRNYjJ3bzNQZ0k3UUw4WkNjQ0pFZTRza29TcStZU21jY2FsQzJGRSticG9vM25YY0tJYnlUSkhZWVNvQktUNVJtQllyWkJDbW9Rd1BwY1l6K0Y4UmoyTFZ0Vmk4Y29jYnZqRzUvQktYakVFTGZpWmd5UWVLeEZzZmhlRGR4dkIvcHY1WFJjalhiRWE2YkhiT2VaVkNJY1oxTHQ5aERvcWpic1lvdUVpMklUNWlFa215aXRLSlo3bEpHZkl3cS9oaEsvbCt4TUk5TjRBbzVzVTJPYjNETnhGcTd3SjczclRFN2oyZlNuc0doTVlHZ1crd1pESzdob2x5Z3hTTWVrbmpieW12d2JTVkZJNjVGZ0RrU2JMNyt5R3JGekllU0dEZDdyNVhCNjJXZUR6aDRoa2ZCeWRoL2Q4WkRtMjhTUC9lWmZudmo1d0NmREd0WGg5ZzIzLzRMaEI3dWxDTEtFTjdmN0VHeEM0K09Va1FMM0FIKzcyMG5xbmIxSExRQlhJNWx3VVhGVWdWU0RrQnBBcFdOVFFCSWxMbFBBYkpyeG1rQ1ZSeWpscEVnK2JiTENCRXhGQ0tqMUdDeVl6SnBkMzh5bXZ0cFlzcEw4emo5ZHNkdkU2WG1ETnFlZWkrY1ZYd0NpUXlzb1dXckNobDIxa2RvQSttNWFlZVJ6STlrTEd6dVIzOXNGTzk4T09MVWN3ZnkvY01jWXJGUnY1K0ZRRU9ma0N0Q3lTbkh6UEY4aGE1eU5ZVDc4cVZHS1pzVTMxWXNpREg0T00wbHJyTDRMVDlVVmVUeFJpWGpWUVdjRHQzM2dZdC84RStPamwzZ0xEcCtoSG4wMGJqREZET3JQaFpyTUloU3hDTHo5RGExVnJvWldWVVlUSTRveENBdEVBZVlEd1ZtMGlxaytFd0JFbnNEMnpYU0pDZ25maE9tOEJvSmJQL2RQdmdMdmE4S1ZESHZ3ZU1lVE9LTkFXSVo1NDk1VXJUci91aHBQUnRiZWYvaVdGNmpqOTVOZ291anNMMVBSUlVuOWJyNGVxeGVKTVZ1aVNGTVZDRld0VUsvZ1oyOHRqWmltd2JFWXRqRWY0WEVablR3bzVvV3VQOUhKbFhxWC9IRng5Rm1POER3S1BQbFdKdFJlZGhlYlRsa01rVjhGc2VoZmgrdzl3ZXI0UFdYRVNQN0Nmc2NRekVQV3YxdEJxOVB5Q1FsN0xRYjhTVG5vNzNLRUhTTGJxNFRhK2xQNUwrWGtHdWM0d0RZZ29FRDRKYnNVQ3VNTS8wQXZhTXJLYXJtSUhVV1E5TFk4a0o5MURIL3RpRGMzUzdrVzIveTcwVW9EUDNOV04rZlRsaTBtT3ZuQXI4THQ5QXJXTmhxNUNORjBKaTNNWkNocUlxRUp0bzZETFRXS1JLR0tNalNwSm9tSmhFNVdrMUZGS0wwSWthbTJOSVZZUlJNWUpra0NHc0hSNUhlNit0eE1mdlA0QnA4T3lBa2NqMEJualVNcGoxWW96WDRMSVNaL0dnc2J0dW9MQWlOTVhrUWdzY0ZUVldwS2tJcTJyQVBLcE1lUkpRMVUxVzRieFY1SXh6ZmpJSUViSEVraW04b1NwZ2hib2VES0RCR084Zk5iVjhWODJuME0ybmNmVER4L0Nxelk1dVA1VHdBL29TZHFTemJqNDQwc2hSam5KMVp0Z2o1S1JaS2dWOVZmeTloY01rM2JUTXJkQUJnamY5azZxNWw1cVo2Vm0yZ0ZwSUxEd1dvNHpBNHRzV3BMQThFTms0KzNJdGJ3YmN2U25rQ1B0dE1JbXhpbk5FRlJHMmZBZXVPTi9wSENxNlJmVmN0QXlZT1FYeE5nb0VmSk5XTFp3UG5yYlA0UWZmaE40ejR0cHBhOEI1dDBoOFovYmdsaXhjUUZpbFVHR1B3RkVJeEhFWWp3bzFGZ3NpSXJLTUNvaUZpb3JLRmhLT0tZRUcvRXFNSUs4SDZLd3pXeUJjWFFTNW9vR0ROMDFwa1k2ZE5TSmhTVkxsa3o3SWdGbDE2Rzk3UnNnbjRiSWo5QWl4L0dubi93S0NWcFd3SytXMHFVbXF1eEQxK1VLdlhhWjU1RmgxSjkzOG5xdE5NY2puYVltY3VCcFZRbVlVKzBScGw5eUtiRnI2eUZjZFVZZW43b09lUHd4V3VmdU9sejlvUTBNQ1RpQ0pKa3A0MUF4ZkN0RS9KMk1PMVhCa2NIYjVaeDB2aWZLeDUxMFJOVnZwV0Qzd2NrY3BOVVB3KzNjQ25QQloyQldYUW8zdWRVci93c3ZRRER6TUFsYUFLS0c0WjhSMUhWSHp1QlB2V3VSQmNKK296SXJGRWJ1Um03Z0NWUTBYMGtvNzBSZ2Z3Zk9QTDBCNDI4ZXdDMi9BbDY3RWJqbXBRemxxakw0OHAxdHFEMjVGVlhFektEbEVENnpKRHNXQld6eXZrQTRaQkFsaEs1WUNGbUdybFlNcURwamVPdkhTK2RYWVAxYWhqbmRDUnpZeFhoZFV4ZnZieWI1SExHRmtvQWQ3Rzd2M29EQkhnN0F3TDU5Qi9IdHovNGJZbkcvcjhTdnRDdldFbm1MMm9SUlZZbXUxa1g5OTlERjBKS0ZmcXkrMGZFckVWUjViSHJjeGRVa1FKLzRHSDAwZy93dmZKSGgwTmZQdzBWdjRKZTA4eE5SMHVyQmg0R3FDL2lCMy9PRGRFQXVMYXRwSG9WOU41VXBUb2FaSmV6ejFnN0Q0QmNHWWt0NDd2OG01dStIYTVHNDVYY2pPTzk2dUNSRHVld2ZxWHpkTUhQUElwRHZoRkY5QlgzekNLekU0NUR4YytHa2RzRVNhYjdISkp4ZlJpVVpRWGFJU2xDemdmSS9EWmU5b1ExZDNYMjQ2WGZqK01CVndNc1lMOWRXMlBTckIzRW9Ta1VQZWhWL2ZyR0dWM1lpSm11TERQOTVYYnhpZUt0TTUyNXF4UGtiV3pEVzE0OERqSjNEWHV2aE1VdjlpUktCN3U5bzYwV3F1eGZSNmdvNHhNeEZTeTNNbjJmclhHaXhHczcxVytwVWVhWTYxT3BHM2kvWHpPWThmNXIzMndyVStydDZYcVh0RG5XNHVJeUU0RzgrUU1FbWdJZDJOT0VqWDFxSjh5NnU1SXZxWkdFZDF1aFJXanhSNzMzMG4yK0VXODF3SS9WalRuNC9uT1Fpb09HdEVPa0hPQkhOdE1nV1pBYnVwQURlUmhhN0RvV3ViL0FjRlNnTTNRTXp2cGt4NGttMHVEM0lNZHh3Um45Sm1HNkNXVWN5bExvWFJtb2M5ampEcTBnSVZtd1pCUk5FOHRDdHFHbytHNFZNRCtHZHFKQmNnTXN2NjhaMTl3cmM5cERFRlNTSHB4R2QvK20xd0tkL0taSG1XS3VxaGRjZlkzZ05WT3BXa1o2QWZ5aEJtbjQ5c1dyeFdFUUxkUm1iRDNhTm9lUGdxQkpvV3p3ZVA2cjJmV09tQkRFQmIyOS85d2c2MnhsODJ5a0VrRU1xSmRIRjZHRmt5RHZHU1lPVDQxNEJzckpFWFRicCtLc2gwbHZGME91V2ZzTGI4dnRHK3JwZG5NdUp1TzV2dmZ6c3R4aDNQdjVzTTg1NzJ5bUVUd3B4QWNPSEZTT2toQTlDdG1iaFZENEt1eW1NZkcwbkNzR0hZTmVlRHJsb01lWGRSdXM3R1ZHK3g0dy9qblNJbjFsK09ZSU5MY2lMSFRDckM3QmJ0eUJjY1J0ZHdVM0lKcitLd0pKTEVHdHFJandTdWlzNzRiYXNnZDFRaDRLNUc2S0pjTHY2WFNSVEN5QXF4c2xrT2IyQk1RVENQUWlwT1daWTBuVE9wYmorcTFXNDR3Qnd5LzJjQTVLTk5VdTh4aU56V0NJekxnOWJ2eTNlTCsycEtTN1BLV25WVjFwazRrbDBIT2hIZjdLZ1hkMDBYZkJ6c2xBeG5aV0doTmc5UUhNNnRMY1RxOWJVd0NBSnlzdDZ0UFdUcHBNZ3FWNE9SNWNWU0grTjFOVjFyN3FqelBEcmNlRVhXZ3V2dGtpVi9nOFBPRmhNNFg3MEExNUN2YS9YVzhvU0kwL2pyaHYzSXg5dWdKMVIvc1hVWlN1VytaU3U2Y25UWWdMR3I2bmxPWjV2UGx5YjJwUlhzL1ZaanFXSDRWQ0NFOVRQaVRvRkMwNCtFNGYyM1VkTHBxWlZFSHBIVkl2RERxMmx3Y3BmSXovYWh1eFlIcFUxOUxtUm01QWMvQk1rQ1dVczFzTzQrWWRrOHJUaTBYNnZlVG03UTF1Y0tQeEdGMHRYMWtiaDV0Sll5V2hxa040dW13UTZlTHVZZXZqUkZ3R2Z2MU5CbHRBcFM4TnYrUEpnMSt0M0tSWlpLOEVtZUFsVllZWmcrVEhzM3orczI5VHB4WjhKQkFJaUVvbTQwNkNubkF2a1BtY3RUbGpXem5TaGtObS91eXR5WWFJVk5yOTkzWWFGV0x5K0JibWtRLzhsZGIxcVBwZlhkYXlxTURtWnpHcUdteXQ0ZmFJNXhvMDV4akVGUjJxeU5IaG9IQlVpaDcvL1pCek5peDEwZFdSMGI4UnJYOHR6amFzbHJ5UXlpU1JTU1ErYTlhSzA1VmY0T2Y1cWk0THo5SkJYVU8wM0RWc3hyMlRVSHU5bEtHQmhjTzllSkhvNndEQVF3U3EvbFlHVFo4YlUrLytrODYxcXBiay95MEMvMEswVDg4RW9rY1owWU9RZjBPdWs4S3NZVkZXN3NtWTFXYUZRU0N0SHVLSUs3M2laNmhrTklrM3lGalNEeUlYRHVHeHpKUjVOdE9GWFQvYWlwZG5VL2FTZWNrdGQvYWZLUDIwZkdsWGhYSWdhVXhrZzB4OGFSTnVCaE5jN1pWbFB6N0wzeExTQ3RXYmFPR0swdFhWVUhqaXdlOS9lM3ZXRmtXSEdUeEtwd1c3c2VuQWZvbUd2MFZHeHhFSStyK3R6bGZXcGJqSkxPVkhISXdlNnk0c1liUGluN2h2SzQ4emxpM0RCUjc1QnY1WkZ4UnFHRlNyQnJhdzlONHJGdXE2eVFDSXo1aFdEcXZOVDByS1ExUFd5S3JtZ2VXSWhReXRKZUtnZ2JGMGtiZEtpQTZxa01GU0xUSzRMbHR1Q2dFdEhRUVZTeGRraFRyeWVVRldMYWFraUxvNlZyeHU2aTV1dlVhSzJxZzJtcGdpK3JvcTlWUkcyR1loU1dRSWVhUWlxNUFFRlEvTVRaa0FyZGR3dk5UUXNDNUdhQ0JIaCt4eHJOK3FyNVlUUHRIeGY2dmxQcVFsU2hvUWl4dXVwQzZiUmRjakdQaW8zdjJWblgxMWR2MkVZNWJiRUtWZmlKcWVEM0xLMy9JS242YWpYajNTUElTb1pvTk1DdTN0SE9GaWY1YnFZYkJlWTZHRVJFejBzU3JZRnYwNVczWVlEQXFsMERvVmhNc0p3bkorUDZLNDFRM1h6eW9CWDRhNDBRU25MUkhkUndYTWl1c1NvdU5tQm8rTmdtNzVkZFUvcm5pT0xVOHZ2emhYR0VPSHpRVE9LZ0FnalIyaTJuUXlDaHZkWTlaYm5uSEd2V1lQdlY4K1pSckhCMWN1TGE0V3hDMzR0cGUwVmdxdEM4b0pYZFNZWmg2dTFYQk9ld2lwVVVxV2RJd21KOXIzMHQzNS9xV0wrZXI4R0gwbWtId0dvOHM0UklrWnJ0WVBHeUJpZWJuUFJPVWhkSURjc1VER2tsT1YyVEJHeldhdUY4dHZRVEx5eFFvaXRIVjJwdCt6cmZGS3Zmc1FaZHcwdzdvN0UvSVpkZDFLd1JTSWtWSGUycXI4dDFrTVc5eDF3dkthZDBZRlI5T3pkallYTFczUjJwWDNiZm56dlN6K0JtZ1hMOWJpYXFsUXdoT3BkWWVCTlN6Rm9uYXFhM3FEbHFKWUdNNlNxR0Z6ZEk2S3RPeCtncFFzOWMyWWs1MzFkamhQRG1OVUkydnhjUVVPZWsvRmlUNWdGd3F6dHIyc1FDd29NcTNMUWxxejhubTJybGdsYkY2cXB0a1BsVmhRSnNIVkN4ZmJPNzZoNDI4WDg1amplOHFaTlZDQ0RMbU1VZzMzamlJUU9iL2lkYVB6MS9hZHlIYXJNVlpXbXFJYWxnMzI2T3dGeElSNFVRcFRiV201T1crS1VnOXpEN2x1RzhkUVF6V3N2QTZaMW14UWhBSVlZcDlkVWVqNU5HRk1xMTkxaWM0NWZweVA4WGhmaGFXZVVnaGdrMVBaMWRHUGhzbHFZZkg4dnIyYjd3N3V3WXFWM3ptSXhkYkZCYU1KWCtuR3RzSHhVOEExS1RReFIyN3NnUlhwaTN1aXpDYTlNeFF6Nno4bko1MXdQUFNlS3hyUmlGanlHTHVYa3BFdDNzbkpRZWtXSUU2MFphdkZiVmZpTkRha0tqTFgwcXlZTzd1OUZYOVpHVTRVWGx1aTQweGRtc1lYRDl1TjN3L0ZhRXhWeTdlM1dMaDF1SVBDZ0duMGdFSkFvdjJmZ2RLV2UrckUxVGRYWnhIUDVxcXJ0cWVIaGtZNERxRkhzVE9VbkVhaEJ5aVdVTWNBcytCMWNqbFB3K2xGY3IydExFUW8xU1hsRmxqVGtTaStyNUtqMWpnSzYycnF3OGZ6bGpDTnoxQ29iakRKUTF6U1ZsV0ZpbDVGaUliUldJUDhvN3FUaTVFcmlzTkJrTUVhVTFiQ25GTUQwYTN0Vlc3MVRtTHhpSTNnNGlPbVdDM3V5UGJINHZjV1V0MXRTQTZ4REVWN25zZ1UxUkpZa1pNWmtIRGtFOGpuVTB1SVZleSt0QkNzcXVLcThVQzJZMUNjc2FpQ3ZvRkxzb1VBNXRkdUhHeHE2RGM5Q0RaVGZ1R3BHb1ZyVENIUGl5TWJqZVdOazVNbTJkbm1CMnU5QVdlYnBaeS9HNWd2WEl6RTh5dml6Z0Z3MjUrM1J3LzlVdzYvcUluUGNBdStUL1JaVXM2K05UTlpyTjB5TVpMQ1BWM3B3WHhjZmpETElMMmlCRmh1WlZLenFsZ2hSbFBRYUdjWWtDc0MzRnVrWGloVzNuSmxveFhjbisySGcrTnZOK0syQXBVSnhmUitIa29KdHYxbHQyZzAzaW9wV2JOVnZxQW96amt3ak5XcWpyVzFFaHlrVm5LZHcxQmVnWCtPcndoWVZqNnRqbExGckMyK2JhNERkbklwT2hqMVJJZTZ6VFZNdG1CZ2xmUzQ0RXFGYU13aHpvc1F3SnNUakhRZmxCWDBESE1RODRKNkhkK0tSMnp0MFdzdHh2VzFxQkdkYnJiZ1VORjRhdkZCYkMxTlpwZTE2bXhZcHd3M0FDd01PN090bFNERkthMUdiMytRWno0VnhzQ09ycSt0TVgvdlZaRnZtcE44cFRtWnBSVjdSTCtrSjgwdFZpaDNjaGN6a3hBY3EvTXQyU2xUZlZ4d1JtSFFaeFhhSTR1WVdFOGhRSmxwWGxxWXFDQ3RETGl3bmlRRzZrbjF0Q2FqVzBKcGFEM0pOSDZKRk1mWG4zNm9TbDVZNm9ENE8vUFl4TDNsYlk1cjNlazF4UXM0UWE4NWtvZE1LMUNpOURaam1FNzNqTHRvUEFPZHVKdXdHYzlpM0k0ZjZlbCtyeGVGczE1bkNmUFcrQWlVK3NaTFljckJ0QUNOOWc0aEVUTmpKQk5hZXNRTExUMStNVkNLdmUwZFUrNzJqbHJaMHJiVlhjSjBsR21RMEFuZ3hzRzRaZEF1YTVLZ1F4N0Q4UGsrVjJPRGpZRTc0UHNzbXNmTDZROVUyQVk3dURmV1RJZXBjeGQxVi9CNTlsUndwRkwvZjllYlFzYVgremxMclZ0ZVR6UXBVUjFSaVlCeWRIVW4wRE9SUUhmWlNmTVVTVUZGTUtvakozaHRHWmxoVTc2VkU5M1JwUFJ0TlZWYy9xSFhaTUJ4Lzd0MDVDUFd3OE1XYVRaanExcW1vZUR3eE1wSnRhMGY0NVM4ak5CQktFcXFGenMvK0ZGdlpSY2xaaXUzeE9venhZOVNBRDNtMXRKWWV0Ykt3djF2dnJSQ2hJTUlNcnVPUkFWUUZQYXRXL3RpbElHeS9WVnJ2NTZCOHRWM1FRdkw4bWFTUTgxb29YcE94MUlMUUcxbkJhK056YVdZNTFZTW92RzVzUnpYdCtra1F6eEluZHdPRDRTbWZQci9hMUFOeVlrcUxXOVRKRXIrcXlFeCszRUJOaUhGNHlzYUJqaFFHS0lwVkRSYVdMN0hRV0dlaGdVY2tIRVNncWg0dXpUV2R6YUNuaDhad0tJM1dWaW9BNDNMbGZTSkNQRkNJeGZMd3dwV2lNR2NUS21hRFhLUE1yWkdwcWtxSjBkSEg5KzJUNTZoOGJieFNJQnd6VWNlQkwyemx3RmZVSXh5djB6NXNzQytsTjU5S1pBUzZkZzFoMzdOanlDcmlCQzlUb3ViUjRPMEE3M1FlSE1DNmxWR0VneElqM2QyNDc1ZDdFSy93bVN5ZUMzdkZEVEZLL1pvd251dmZNT1U5Um5HSm82VHpjcXBmblBEYnhiMk01R1JUbEpTVC9UREZxVlB2elpEOTFGQzVhNEpKK2srSnh3OUlmTzdkWVZ6K29naENxcDFRTmZ5RWVVR3FsTDZTdHpuNmd6Qnh0akdzVWwzSWR1L0hZR2NDZGZmdlFzZlc1SjBGenpwbHlkeVhFNnFjSnJFd3dYSXhnMUFuU0ZyWU1CN3M2RGJQMmJsZDRLckxvbmpOeThNSWh3T3c2dWJEaU5XalFOSVRhbXFFRWEvUlZwQThzQXZSdHk5RmtJN2lwLy95Tkg3em8yY0pMMTVIdEdxclY1Mkc3ZnVHWUc5dWdFbXJDZ2RDWk01SlhSYzcwUU5hTXFGVENjcGNueXR0RTV6WWtFcE8vL2xTc2pUdHVYei9PVHBPaHR2QU9ES1F4aU9kemZpN3EzdlJzclFlbmUwWlhld3JUS0pPa3dtMzdRQWN4bWZoeG5tY3N4cUlJUk1pMU1MN0pocWJkdUtIajEyTTFUWC9jL2NVWmxzcVRGRW1IcDAyOVNkbUVLbyt3Z1Y3MGRldk5kOTZ6c1l3QmtjamNJZnBrNnJWTjZrOS9sU0wxVUdFR2hyMTNuNHF4V2NHUTZnKzdTemtPdHN3dm1NUHJ2N1lSbjNDeCs3WjZTKzFTZXhsSUwzbllEZUdzbU82MEthNmhuRFZRVU5xbVBUQk13bHBycy9KTW0yRWNoWmh6Zlo2Y2JaVXhVVnRUS0tDWkt4NnhXb01EUGNpMitiQVV2czNGVGVsVkRQQzROaXcxR0tHNm4yMXRCT1Z5bmZUblVnR3cvbWM0NmFycWtiOGZJS1lZcUZpbGt6UllXMkkxa3d4cURvYUF2S2tiNzZ1Njk0VksydlEwNmxxWnRJY1JBRHBzU3lxQ2JzT295NG5ZOEhwN2tOa1VZWGVxOGd3cWdtRnFpUXpwQlB1cXVGbnJDZUZvV0VMQytaYldMTEl3cDVETmc1MVpkRkxFclNBekxtS3JEQ3h6UXRkZEp0OVNVdGZrZkhLMGpaNitkd21YbGxpamFYOW5ySmtjN0hEdXZIbGMwT1JVdUdWTzRxK1ZOVk9oZm1aZVF3Ny9yZ0hXTHpoSVN5K3NCbDkrMU42SlRsSUh4eWlwS1VJMGowMVExUldFbmxDY0xJT3pIb1N1OXdBY3U0K25wUU0vMmZ0QmIvWlg1WmhzZVc2MHFiOWtRSnJocTRuclNVZnVPYWxyNURkTjJFc2JlbzFVUkgwdHBKUmEwQzJhc3JOcURvakI3SFdGdnE3ZWxqeGFxZ3dTaTA5MlpsT1JFOWVpdVNERDJCTlhUOWU4ZUVHRGRObWJTdjZodnB4ODQvMm81Y0I5ZkpGak51aXFvb3dnb005bGlaQ2FuY1NGZmJvalIvbEpHT2MyTTdVbUNRcHBSdEZHZVlVZkJLZXBYaGJ5QmtUMHZQTzVaTXJSMDZRSTI5VnhJZDY5M0JoRmpOaTZraFNCTlU4WFlzS1QwNitFTm5kdjBmOG5EcEUxMVppZERCSDE2STNoa05lanNFWjNnYkJ1VkdEVG81UTRHMThQcDNIY0pkS1l6YkIyTnZuQ0xHdzFES255d1ROMnZkaVRiT1FPaUhrNm5va0Nxa3dOU3FGY0dVVWp0b0ZTMjN1VzBIQkJNS0lMbGhCb2hORXFqdE4yRTBpTzBnSWplWWhhazNrMjN2USs3MjdZS3E5V3B5NFRuWFpNZ0NITUgzeUtnY0plQjFpaFROSXRDalEwell0eHBhWG40WHg0VEVkMCtaeUJTL0VJQWFySFZaVVBsV0ZHM3BobUpHL0NtTTAyOVM3aktsNklDOFhhSmZzUytEbFpCMHZmQ2x1WmVONklZemVJazRGT0k3YWNzNTduOTR5em5VUEoxbVlYS0MyL0I0Ymc0T2ZIL2JLTWJQWlBZaXRyY2JPSjFOb2FiSVFzNFRlNzFlMVN1cXR1Y2trN2FFUnZkN3FaRjEwRFlYUjNHUmo2WloxaUsxZVQ4VmZITDNCdnZzWEdjZmV2cTA5ZkpzWk16cHVmU1RVY1RROW83TjJudzArZFhQbWtyZldZbURRd2VoQUFYRkc2NkdxQ0hMMEF3VTNBYWYzR2JoMWpiQ2Fva2piYlhBejQ5VFdQbVFQRE1OSkN2MFZhajNUb01ZcW1JNHo3blRjRkpZdUR1bkY2N1oyYjNNb0ZZaG54bnJRcytjcFdJYTNtYTRrL2hwUzdjQmw2T1NGa1NmeFVsanNxSEFscS9jUDExM1ZKc09la0dkV2FuSGROWjBKK0hSTVJ5K3h1VUwvRDJtNi9wNUVNMi9RSk11UXBTTGtLb0dxTHU2V0tsVWtCbXp0NzhhTFh0ZUM3a2V5MUg1ZzNEV1FIU0VKVW9WaFZFVkhiNFZIdU0xTERGSGZ6N3dncEZlV0N2TWFrTjc1Tk1LOCtMTmVzMnBqWkZmN3hqZGZJcTg1ME9mMFhMb3hzM1BVQ1gvbkk5OFNkODYyWkhZa0FoWHBRaWhqRXZmcFMxRTN6MElPVmNpbWJjYVVlYzhDMUVhSkI0YVFTVHRhKzV4c2NhZkpJTW1SMUtteC92RXdGcllZT3BtdVlOcm0rK3JJL2xZc3IwQkh4N2h1eEcxb290QUxvL2pUN1UraHJ0YmZ5azJVSno1VDg3c29nZU5wNnkvazRTSE5kS1NuM0hjZHhqcjhmWmRVQ25oSm8vZmNudDBVN0IxcHJGNXVhaGpQMERKVGh0UjVicjJYa3BEZVJpQW1iNVUyRUMxU1JnQ0M4QnNJcllZUmFzRGl6UWZ4NktNSEVJcUcwTHFndW1YUnlkR1dSRHAzN2s4V3UyMDlLZU1qZi9QWm9mdm1ZcUZtZFhWMVlLWmM3dGc0ZWhzajlxb1ZLNHlsR3ZiU3JxNnMwd0VsTmM1Vm16S3F2WVAwTG1DR3Q3K2ZZeFpJNmMyUnBLcEhyVUJObGFYWmI2UXlDQ01jUmFSMU9VU2dBWHUzajJENzFnVE9PQjFZdVFMWXQ1K2FQd0MwTHZTYmVJT1RoNjVIS3U2SFlFM3VtVEN4ZDRKWjBoRHNQeFlsdFR5bDhhcVlFcmVXSG9aZndDWDhXLzM1RXNLbEZFM3Q4U2VwdUJldDhTRDN0Z2RkN095MWNQYm1JSWFIMVU3Y0ZHYUd3cU5nVmJtclVCcytjNTVVeVdwR3FnSnJJb3hhN1dsYXBTc1VvYmFKbFZXb2JtQnMydG1IVUhVVXRtQjhYdGRpTG1pdHEyK09KMSsxOFJRamZ0dDkrVC9NVm9JeXEwQUgwbWJ1dGllRHQrM2NtcjhqT2VibWttbWk3N0JJSk1ZWmEyWVJ5cVJoSmxKSTlnMkw5bjA5NXYyUDdndmVlbURRYUx2NHF2aHA0Zm9BWTB1SDJreVlyclpRVU5BcGNpUlNJOGdIWGVxRHhCMi9IOExhVmNDNlU0SHRPNENuZGtDM0VxaCtXOVdXcjQ3aTh0bEU3dGFZYkpzM2pQSXQrNlhQVzM2cmZzQXFXYTBSaDhlNHJyOXNwOXl2aXNSVXk0TXFSMUtiVXFyRzRISGVKcExlNDdaTzRLUkdyNFJ6bUw3MDdvNW1YUE9TSkJhc2lhSWlMdlRtazFraVVZRUs3dEt0RkRpWUFqWE01a0R5cm9uV1pncFh0WDdVTFlZVlpMaVhIcURDVnlJNDM4U08rOXNSdFBNSXhCbFIxTktBTXRXSUx6blZXamcvdlBudDc0aS9QOVRUYzlzais0ekJ1VUR1ZEwrUG9sKzdxeTIyKzY0MlhPL25YSW9KQjdPRW1VM2NmOXZaNmNzQ0pCKzFaRTlWellScEdkZjcwWnNxNzZyU1pmU3pUbUlZaThpU0hJNWd6MTZ2V3JDK3pvUHI3dTdEbDZvbW1LeWMzTCs5dUNWNWtlMGVGa2Y2ZzNiOEJJVWlLTlUxSnVZelpGcTB3RUx6S2krenBVWTdxRGI3U0JVd1BDNXdjTnNRdGo4MXByZWZLU3FSWVpSc3VPRXJnMUsyNWMyTVFTdWhHNERYbjBmWXpOMk5oMytiUThzeWZrOHJ3N0M0NTRpZGpHZVpLdDFvRU5VT3F0NFFCZGpLaitjekRHdFVmSnJWQmVJbTQvaG9jeE1xR2huUlZ3WXdzbXNBMWFjczBwcytXZkg1c0xxeVZXLy94S2wvaUFhM24zWGpyNjJEMHdsVVRwT0JrQ1dCYlRsaEYxOHpTeDVyeW4zbjl1QUQ2KzdKM2YvU0Z4dm5DdlhEQVVrT1VPODNMM1VXU1lVSmRzRkFUYVhBMG5rbTJoaU1EdzR4cHVNa0xadFBmOVRpbDI5TVdlRFdteWtYMXlwTGxycUtyMDlZOGtSaGNSQlhYQ0J3OXBtRStXRDV6SlpaVlpMWitvQ2YyZnFucC9IYkh6NnIvYUZwVGdyVzhIUFhGUnpyNGdiby9weDdkZ0t2ZnlOajBOTzlHTlROR2RpMWxhU00va0dvRGFFWmorbkV2OG9yaXdBU1FSVmtqOExONWxBWVQ4QXE5TktOZGZCemc3VHVKVmkxb2g1NUp3d2pPb2JLNVZRVXdySDZNUVV6YUNMR2lHSm94LzExYi8vODVtMlB0VDFhLy92dFJuNDZ5SjBwdVREZHJoelQvcExTZU43SS8vZTI0RjJQUE9yY25SaVZoZUVSbVZBdG0yTnBCTkt1WWFWanRTSlRNYy9OVmRZWE90cXloVDNQWkt6TkcrbVBDRmY3RDFsWXNEQ0lVOWVFc2ZiY2VUaDF5ektzUFdzZUZxeW93dEtUcTlDNm9nNlZVYjJUSXlJUkNicG9mczQ3YW1xOEl4UTFjZVY1Rmo3MGhnanE0cFV3YUNHaEVPTm9DdFUxZzNBd2pGQmpsQ1N0Rm1aSVpYRkNpQ3hjQW1la2dFelhQcHorNm5WRWtEeVNnd09JeGJ4aWFGWHlwSDdqaFh3UXBBUzQ4RlN2TGtndXV4QlYvWHV3OU14cVZEVXlyaVNycnF3VHFLd1ZpTVZkVkZUYXRMbzRJblZCQkNveW5LQXNJdkRRS2tlV2FGbFZjTk05eUROVU0rTU5DRWF6ZUhiclFWUkZteEFoVXpRNFpwT0QwT1ZPdVNRS0l5TUlOVE5BUzhtcU8vNlUvdTl5eTJleWpCVzZKUUd1TEVrT2x4T3dNdzIzbEtUb3pTM1ZtUlduckF5dE5tVXdHZ2dGWUZUUGc0alVJcGZKRzRHNnV1RExYbFdQeHgrL0cxbUdPS3NXUi9HMzE4ekJrbDdyV2RMUHYvUTA3dnpwczE1U3dCOUVudUhBQnkrMXNXSmwxYlNaTFRkcklUMGxzMldZZVZpUk1EaG55SXk3Rk9ZWVl0VmhMRmxvb1dVbElicXFUbHRwWDNjS2xReXJyQnFHWFB1RzBOZTdGNnZQbW5zTUdpSmFEYzJyUTJ1ZGhleDRQMlAyTVU1MExVUytEM1p2QjRJTk5nWTZCN0JnSmQwUWZVOEZyVEo3cUVCQlZ5QXoyczN3VU8zeVllR1VqWXZXMG1GTXpSUk5KT2RMZjYrclhJYmZtQUsvVTVkdmpNTmFLR3luK1N0WEQzenZ6SFdoZVlPakZYQ0dHZWJFMVpxb2wxUnc1U0VFYXV2UjNXK2pmdkFSM1A4ZEwwZGNHS1EyVDhrUmh4c2JOVlNaSlRuaWZHY2JranYyNEs4K3RoSEpVZURPbisyY0dOanF6V2RBSmg4cW05bFNPNVNwU1MzTmJBV29LRHF6TmRLUEp4NTZCbkduQjgxNzl1RVZad1lSUHE5eFJzVmErWktsYU5uUmlXVnIzRG5Gb0NxWm9hdVFCeHlkQW5XR3M4ajJQWXNRa1VLbzdkMkh1eEExd3dqUU5TVWZiU2UyQnpEZXRnOFZ5eGFSc0JtSXpxY3g4QnlISG1uRFNLTDYycGw4S01waytFdUZXdHdMMlNscG55aTlMVnF5VVdQSlZWKy91dXMzUzVmVm9MZExrc0NrNFpERnBCTlpWRWJJOW1TS1dtdWhZMXNmWWdmdnhScWRJemFQeXBMVThOZk1UK0trdHlpMnFRcVdEU3hlTDNGbys5d3lXMkdWMlJvWVErOVlFcjIvZnhDbkwzRXhtSWdnVCtZNlY4VXlSUzk2SG5NeHIxYk1Hb09xSHlleVhCdmpBK3FIQmVncnlIZ3pPY0p3ZG9UWG5kZlpxb3J1SEtJQlIyZTlDZ2tiY3RERlNOZHVLb1JLaTJ6VDMzMm9XLzdwbXAvUDIxYW01a2o3VUhPR2hpVXhUZjJuUVBtZldNU0gzL3ppMTllUGJOMWt4aXNZcTJVNE1EOG9WTzF6aEZ5MWFiNnFockxEZEVKN2Q4Q3FxdENkd0dxYmNhRiszWWlhSFlqUXp4RThqQ2dRbzFaS09ROUJ0ZDVLZHBFYkhVQXUxWUhZcXZsSVBmSXdCcllmZ0JraDFPVWRyQ2JNZHJiM1ljTmxWU2hFQXhoakhCSVdGRnl0aVFLRjdhaUM2K3d3Q21HU3REclZoRHhBMk96QStKMFBZOVdpS0FiNmhPN2ZrWHl2blNWYVZETHNDSG9iU2RvcEVvQ2FpTFptOWFUS0R4dVN5aVdHMFRWV2dYZ3dNV3NNcXZ5M1ZSVkdxQ2FFVEZxZ29VSmlqS3pYVWRTRzc5RXBSY2RHMTZqWTJ0Nk5leGhDR2JVVlRtT3VZTGdoUy9YREdlZ2FORHFUZWZQZHQrK3E2Q29YazFyVEJLbHVtZVdiVW5qRkZMOWJmSzhacjhWWUlldFppR0o0S3IydTFrRERNV3EzeFl0cFdVTGZFa0FvSVpHcU9qSkxFakZlWVoyWEkrNzc5N3RnalVnOCtneUpTTTE2YkFvL3FtRlcvVXJUMU15VytxbXQwc3lXYzJBSVdUK3psY3VlenVCU0hoVkUyOWxEaUsxZWh0Q3pmMEprbmtDRXlESkdpOHFwdkhHZVNtQXgvQkVxOXViM3FoNGRLcDRWNGkwSlVmOGhHd3ViS2FKaHpvT2JRNHpXbnh2TG9hWTFoS0V4T2ZMaFcrcmVlZEhLVEtRdTVNUlhOQmJPVW1uMWNNQnRHaHczZi9QVDdSVlBUMmRRMWd4WkIzY2ExaXZMRUttaUFtRGttVittTG4xakRmcDE3dGVtNVdRUnFnd2pyK3M2eDJIMkV6NnE2Wk15S1d4NjVYTnp4SGtWZ0pma2lBUEZISEYySE5rOWZjaFJHRTVTcjdycVF2dTdkNW83RnEweHFrNXZDczlYeWxGWEU4V1Rqem5Zc0ltdnE5NmFwSTJnNi8wMGw3UzliYzExVnNzMmRSRzNZcUVqejFPeHdsU3M3OTliL2VpV3N3UHpscmJLK2RQRm9KTGZVUmgyZEN0bEZYM2kvb014dVlqQXM1ZGNZcENLVXhzTGtVMm5zYThqMEt0ai96MFJ0UmFuU3Z4L2p2Sy9uVHB0YjR1Y29SQ3BuSVU2VTN6bnhFYmdPVHVZVWhaU3p6TlhONVBKNmFTQ0RjdkplMFZqdVFJS2gwYVFHYUE1TDR6TTJaSlVqbGdYbVNFRUsraXE5Y2o4dno4US85RlQ2Y3JmbldidHZvaks4ZGRGNVdpbWNyVHREbU00YWVrZUhQMExUNjYzWGFlaEdMSDZsU2YxZ3dKcTY0RGtkcHgxREJScmQ0LzVxOC84WSt4L3JqZzFzMzVaazdPc3FVYk9xNjRRdGFvajN4Q0dLT1NrazBpRlI4ZFNHQmhQaTROZEk5WjJocW14OTEzdS9HeFJKZjArTDY1L01JV09UdUIzVzJ1L2k5bC9DRmZPQkxrQ3MvOGFMY3FzbkQvbjlkOXZEL3greGNMOFhlZHZNUzhTWkhaWjMwTFVWcWxTL3dpUFd1OFMrcmRMSG53b2p5MWJnbk95SkZWaVg3QkpDa2RFM3hQdGtjZHUyMUZ4ZS91SXBWdlgwL2xncGh6TTF0UTcvZ0FWSVNuQW1hb2NLbUhEK1BSSUlIcXFZcEV6NVc1K3RQTC8zTHl0VXEyS3VML2FIbmtjMi9FSXZBWjI2ZDhXRzBKS2IvVVJDeVhlY001Sjh1citnVXpmYUdqTm5sOC9XZkhrZ1h6dnd5aXovL3djTEZTS3hZc1htelAxdGt5VGNDaGx1TStwUDFLM0Z5NUpyejU3amZ1YXBucTUwRlMvb0d1ZzFUSmxuWkF5V0hCa0twMUc1MkRDMk5FM0xBWmFHckNndFJFVmRGL1ZrWURiSEFySUdrdklBSlVnVFM3UzB6dGk3RzdyTi9kczZ3enMzZG9WN0VybWRZWmtZa0c0SWVyRS92NVYyYis1NG1Kam8xS09aRkxxTnI2aWNxaGJCWHV1dW05TEhTTm1jcjV5dEFXM0xsMXFMYnI4WW5QOWtYeDJZRlIwYitzSTNQL2JIYkZibmgwSWRwY0l5eWtqd0xMQ25IS1VscERMS2JWRk0vM0c5MkhQSzRFYU0zV2ZsUkhpVk1HS21RUmJrdWMxcDl3WFU1NHpwdVNKaldrVVorcksvc1M0VG0zTUxicmtkUHVpUlMyeUtXekptbWhRTmtTQ2JsVlJPWklwOUhhUEdIdmJxUnpiT3dON251NE9IdktWUTY1cnlpM2taMSs2c0ZrMmh3T3lPaHFRamVHZ1c2MCthMU1CK2RtZS9qSGoyWTRCWStjelhZR2RqeDBLdFk5bDFXNVR6eEZhNmVPNUNISTZZWllLRk5PUm9ISUNGWmo5VitETDFodk5VdjVwbGhIeTFNUytOWU1TekVXd015bmdiSC9sRmlFd1pXTExUWGFwZ09RczF1aE1FWm96aXpDbmcxazVteURMa2FLNWxEbklLY2tFVVNhTFpFeDUzOVFKTktjTWNLcWd5NlVneFpSRWh5aXpyWjFSaHNqSkdWYjVwOU44V1Naek52VjI2dUdVdVc5UDgzNW55dlBURVo5WkdlMU1MSGZXQXQ2cGJMYk0vYWxRN0V3WmFEbmhHcVV4N0F5d0xVb2dlanAzWUUrendVUTVvY29waXV5V2VWN09ZSzJ6V1YwNTYzWExuR00yWWM1V05UOXQ2ay9NcGN4K3l1dkdET0hOMURoMXJ2Qm5sTEhLVXFpMXl5UTNNQVVkTU0zK0JPVnFXdDBackVET0FMM2xCRE1YWCtsT295eHlGamN3cXlCbmlrUEZIRTRncGxsSExiWFlxYmxnWXc3K1VzeEFnTVFNamNsSDYwT251NTJycGNvWkxITW1QeW1uS1NxWWxyMCtuNDJuWnZqdG9lZFlucGpHU3FmNlUyT0c1VGwzRm1GT2Qwd25SR09PRXlKbkVlNU14MXd0MXAyQlhKV3RESm5GWno3L01zNDVFaVZqRnUxeXk1Q2FjbFhpNVhMSU13bFR6c0RNWjZ4bVBJWkNuWWtOeXlPQTJhTVc0bUVYSnVYY3psR3lpZUIwVmZhWUliU1pEajduYW8xenNjeWozWVQvK1FoVnppQ3NJeFZrV1dOb2IyOC81aFk2WFk1M1RnMm8wL2hWVWFZSlp5YmhIYTB3eFRHRzMrY3I1S09LTFkrM1FER0RNR2VMWmQwNUN1NW95TSt4c05BakpVdEhJK2k1NUdUeFFndFV6a0NXWmhLdW5LUGdaaE9pbUlNMUhxMUFNWWVKbDBjcDZEa2wyUDgzQkRwWG9XS1dGWnpwRmdMbVVtRTRGeUdLSTV5czJhd1ZjOGptek1WSEhoZGhIaXZJUFJKZldrN3dzMW5nVEw1U0hJZnh6K1piNTJyQnMxbWp4SEg0czQ3UkJNeVVhcHVMVU9WUld1THhGdWpSV2k3bStQb3hGNjUxakMxekptdWRpMUxJNTJtSjRoZ0o4R2d0OTBoZU95NldhaDBIN1JaelNQalBwaFR5ejF5Z1J5SWcrVHkvKzMvVmh3SnoyQWNBTXlmOXhSR21JNC9ISk1ubitSNTVESlRvejBhZ2N4SENiRW4vNXpPWjRoaGI1L0VVL0YrVVFPZHlZZUovOGVMbFg4ZzUvMndGZWpRVElQN01KdlYvWFdDemtvaTVKdWRQL1AxbC9QMWZBUVlBeHpNbWlUck00UmtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlnQUFBQXhDQVlBQUFBQmYrSHZBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3hOREJGTVRoQk1qTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRveE5EQkZNVGhCTXpOR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pFME1FVXhPRUV3TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakUwTUVVeE9FRXhNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtnbWFTa0FBQUNVaEpSRUZVZU5yc1hIOXNGRlVlZnpPelA3dWxXRWk1dGtETElWQk5GZFNURkVRaEp5SFJRT3A1WURoTXVFVE44Y2RkRElueHgybjg1eEp5cDJnMHhCZ1RJOEdEUk9VT01Sb001SWlZNDRRVWtZQWNCRGxhTFdocER5aUYwdjI5TytQN3pNemJ6UDZZMmRudHpIWkwzeWQ1eVRMNzV1M005MzNlNS92alBTb01iSzhqSnZEUjlodTlMYWF0V2IvR01mNHhRdHRQdEIybjdSUGFQbTNjMko0bzFGRXdJY2lqdEcybWJRNjM1WVJBTjIwdlVKTHNMa1lRU1ZiSTMwU0JQTWR0TnZGQTUvNDFPdmN2VXFLazJUWFIyQ0VsQzY5d2NreGNZTzdCZ2F4cjdFTXNLYTcxaU1xejNFd1RHK0JBNyt0bjFtWVI1SEIzS09EenlHOXc4M0NvMllsSGZuUDMwNzJCREVIYXA4ZldVWGxwNXFiaDBGMU5FK1hFNCtwbkdwQ0lYa241TFRjTGh4RTZKeVFvaUovKzR4NXVFbzRjZ3R3TmI2TVNSQktWQm00U2pweGdGWnp3aXlwTEJPTGxKdUV3UXRBNG9TcUlXSWtmUFBxL09IbDExd2o1OTM5ampvNkw4WFlkaWxqMndmY3Y3N2loUGtPcGlDV1VDUjJ2ZWtDV1N2elNsRHFSbkw0ZzA1WWdjNmQ3U2ZNVXlaRng5NTlJa2tsQjYxYzQ4WDJhWExpc2tLQy90RmZkKzAyVW5PeE5rL1VQQmgxNzNsd01qY2lrYnpBMTZuR21UL1dRK2xySDE3cFFNWUxjMnVnbHl4Y2t5QmZmcHNtT0ExSHl3cHBhUjFRSkUvL1VDaTg1ZFQ1aDJnOTlHQXIxTXpOdU9LNm9wSDdsbnhIeTU4ZHFza2dDOG54NE1GblM4MjUvSm4vZnErdTdlTW5qRk1LNnBWN3k4TDFCVndoU01YUjJCQ2xCUmpMU0hmQ05qcHNIVG1xR25kRWdrYjk4RUMzYWYvUEhzWktNdTJaSkRRbjVOU0lVSW9rVG1FbWZmZDNTOHU4L2RDYVZ0UUFjRDFhZEdBVCszUzdhVzBSeUk2cVFUVHRIaXZaOVlrVkFWWjVDZ0JKZ2RYZTBTV3FmZFVzTHkvVDMvNWZKa2JOcDlYZm56NUpNSjhrTUlFNE5kVTFiOXlleVNJTHJkbGZzNzk4WU52M3VqbFlmYmFNaGlHYjdHcjlRdlFRcGpjSDIrMGJqNW4wL1A2cTVpbVYzZURNVGFSYWdBb3ZhUEdUWm5ZR3kzZy8zWFI2V3RWaXF0aUl4ZmNtWVdpZFdMMEVLK1ZhMnlwbXNQNzNLVHhiTzh6dVd1VUE5b0FwWWdRdzlBOGs4VXZYMHk1YnhoL0YrSzhEZE9PRVd6UlRZVFRjeDVnUXhTdy9mM1JmUCtQaGNjdUQ3bmYrSmtJRWhoV3pzRE5rMlBPNzcrTEFXZThCVkdiRnRmOHpVMEhBUmhjbHQvNUNjRytRQTdwb05GNWN1Njk1aEtwRFh3c3I0SWdnbWNjdG5ZZlhCbHkrUUNzby9qQjBLQ0ZRSjBtbzg4c2VWOWdKQU5xNFZubDlkM0pYQVJVR0ZTb21wTnEyZjVNb2tRSjNXTENudlhoYmZCS3M1QnNrRmxJRzVnTFVQMUZnYWhwQUkrZXhJeWxhV2dOUVM0N1kwQ0phU2JNZHRmSFF3N2xCTVZSMHdDK2FyamlBSUNsSHJBRG5zdUE2UXBLRXVscGNsNU9MaTFYU21YdkJJaDQrOHRTZHVTU1FuWXlxekxLU1U3QzBYaUpmZ0VwMk1ZeGhXM09VdE95QjNqU0NvQ0w2N0w1S1I3VnViUlBMbHlWZ21WN2V6VXVFNnpFaUNmOE5kelpvbTZmR01PVUdjS0R3NW43M2xaMmhPS3BWeHJFaGNxVDRGNmI2WXpQTHBjQnQyQUhmQk1MZFpWTlhIakNSd1YzWUNSYk9zeXEzTW9kanZGVklndUVFV0lCZkxqdGo5VnIrREJlcENxZDA1Z21CVmQ3U2x5T3hmaUZuRko1Ym1idGxRbS9VQzdLVnpBNzlRUUl0Snp2VWw4d2ppVmhiaE5wREZGVk5lWU9WQ24yWDhoUFErMTNXd2hLQnZVQ0dyNzNQT3RiZ1NnL3hwWlNqdjVSbnNzaHN4eVgyM3AwZFYwcllUR3d4SEtrY1FxNHBya0pJZUZWNjR4ZE1YWXFTekkwVldMUXdXWEF4STd6dmEvSm52RUpkaFg0c2xCTmdFSFRkMUVPWjJBRHg4S1hCcjU3UWFnY2tHZ1JiTTlxbVREZlhzNlE4WDNFRkdqQWExd0VZbjFBU0V3YlhPRG84cHFhcWFJT2N2cHpNQmF5VmhwMTRCbGJrV3JoNmlnQXpJK3ZZY2paS0RwOUxrNmcxTlJhRVNEQWpTRWFPeCtPbVdrT0JvaGJxaUJJRnZ4SXNDclEybEt3SlMxVVczK1YwSnZKeDR0M0pXSzQ0bldFMG14bVF1dHU5S2lyejllVmpkYUdUQWJ2akFrSllwZ2h5Ym42aDFQUzV6alNCSWNTRi95RkxLWVRoOE1wcWRqTVJPMXVBVUlPMDRwRlJPVlJXMW01YUdoT205aU5sd1BzUzRoWS9kYWtZU0xCYW9ETndNU0lLQ3BOM01ycW9JQWlNYWkxcmxGSkZ5VTJDbnNnYUdjczVSc0JXTjFXc013TzNBNmtBVGxPWHJjNmtNRVRBKzNBa1VBNlE0Y25ZNFMyVVlTZUJ1am5XUGtQVy85cm5tWmh3bENLUVhQcFRWUUJBOGxmUGdQMTFPaitvNTdKelRZT2NvaXNFWUE3QnpKUnNlcWluWjllWHVNak5ic2VPUWJFR2dDbXJNVk14Y0VZdFhZR3NvVTN0TGNsUkhHbHdsQ0ZiODhaNmtHbk93amJTblZ2Z3NINWJ0cCtBZ2MrNnVMRXRCWWF4U1ZxZDJObFd4WEswTXVYM25OSGtMVHNyaE0vRXNaVEtTRHlzZDc0c3hyT29YSUFNNy9iYmtkazlta3NNeHJab0swajA0MzF2U1ltTHh5bTB6RXVxK0VqdnZpOHpHeVhxSXh3blYyUFZWUEZORk5VcWpGZUI2UGoxaXZxT0tjZXkrWk81UlFyT2poVmIzUHI4NmY1T1BCZG9nd29hSC9IbmYvMnFPVnZuVnhpaitteGdIZ2JjeDZPenN5SzhSd1VYYkxaZmptVGF0OTZuM2RKMU5xUVV6S0ZEVktBaVlqQXJnb2phWnpQK2x6N2IwWXJVNDVUZnR4QnpGZ0lQTGhkNE54REJURndTSXM2YkYxYUMxR0hEbVkvbUNRSlo5ekd3RmN1VHVKeFY3Unl5bVpYY1N4dzgxQ2FSK2NmUEFsdE45NDYzQUJGbkhHUWkzdHJuSE9vM3U3azltcWNSWW9IRmorM1IxMmFSa0llb1JsZUI0TXVKWUdhMFNnQUtNOWZ2SkNsRXpEV2ljRWs4S1Z3a0hod0h4cEFoT0tDcEJoc0xTRDl3a0hFWU1qa2puR0VIU0ozNE1mc1ZOd21IRXR4b25aQkFrK2RLdXBuMlJoTWpkREllV1JTWEVvWmQzTis2bEh4TWdTUHpTc09mSzdtT1QzK2VtNFFBb0Y3YjFYL05lQVRja0VweUpTcFgwcjFPVHJ0OC9MOXd3WTBweUxqZlJ4RVZYVDgzZUo3ZTI3S0FmTDlBMkxBNXNPUTJDWEtmdDR1L2VhWDN2bTk2YUE5eE1FeFBIZW9OZlVnNXNwUi83ZFU2a3BXY2Y5WlBYOTAzRGpsUXFKUXZpQjEzMTNiVUJlWEJlWTZMVjcxVkMzR3czUDRhajBxVy9INXF5L1EvYlp2NkRjdUE4dmZRajBmNmV1NUw1VTl5Tkc5dFJOS3VuRGYvWGZHWmRNRDMxcFZXWEZpMlpHNzY3Y1hLeU5lU1hieEVGSW5GempuL0lDa21INCtLMWdldmU4NGZPaFk3L2RjKzBMa3FTUVowWUlNZ1FCQU45cy81V3UwNFNYR2lrclVrbkRDcXNxR2VESEFJMzcwMEI3QVRDYTZDZUg5VUpBYmN5QUVGaDVGQUpRdW9YNTk2TXpDYWdFMlVxYlpOcEMra2tFYmx0Ync0UjBja1IxbU9OUVowWU1mMjdERHdtTjBmMHpyZ1pXNjQrblJ3Q1Y1R2JRajBVZlo1eEdDYXV0NExuTG40V1lBQ2VKempTQ2Q4bDJRQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWZRQUFBQnNDQVlBQUFDY2xFQVFBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJOMEl5TUVZNE5ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk4wSXlNRVk0TlROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZM1FqSXdSamd5TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkzUWpJd1JqZ3pNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCthcUgwYUFBQUtGeEpSRUZVZU5yc25jMlBOTWxkNXpNaXM2cjdlWjU1WnZ3eXF4Vmk0QWluUFlGdkhEQUhWa2pJZTBBQ1dlc1RJTm1BUVdKUENJRVAySHZibSswRENPMEpzSkU0SVhGWXRGcXY5cmpBSHdCWEJuRmd4alB6dlBSTFZXWUc4ZjFGUkZaa1ZtUm1aSFoxUDkwOTMrOU1UVlZYWjFWbFZkdjFpZTh2ZmkvcXN6L3p1NFZTcWlqc3YvaVAzTVlQQ3JlMXZkYis5K0cyWEd0NzN4ZnMxUmZ0RHo5dDcvd0plLzJqOW9IUDdPMnp3cGlpYVEydVZrbmJsOWlVWlhIWDJqZE4wYmJySG91UHFDcjlaMlZsUnQ3ODZFZVNPdDdlMVpqMW55TkZVUlIxSDlWOXFWL2J5MnY3SmY4djlyNS9zdHo0ZTN2N0IwWFIvcDI5YnUyLzltNTNFYWFFbi9GNCsvTVAvOS8vNkQxclpmeVRxMEozTUE4Z0Y0RHIzdlY3OW5lL1phLy9xOUxsanlrUC9pSXNBanpZNUhZTHFLK2tJeDV2Z2E0T1A5M054OXZhOTFtdW8yZGxQeDl0Z1I2OWd5VFVwOTVMNzNqQTNINkdoVEozOHY0cGlxS291K2E2T2JQL1BiTzI3WFAyTy84L3FjTDhrb08yK1djTDh6OVhwdjJ1L2ZsOWdGM0ovZllJZTNGUVArWnJGWEF1Y0E0dzE0QjdHVjkvM2w3L2tiMytkZnY3cllYNXdjMkhSVUJ4Y1BrUTJOWmF4N3ZHWGNwRDdPdHF2UjVsd1NrUFlZbjdVNkJ0RVZIUTY5MjV4Z0prOEpvcUJlcnBaVXgzZkF0blh0eTlOWS9mQWlNREZFVlJ0KzBrdldtVEwxem52QzBCZmt3Wjgzc1czUC9OdE0yZldwaC9vekROaDZaMXJCMzdhcTRrdE80UGNEQXZEOWR5MGI5czRmcGRlL3RkT0hVTm1JdDdEeEEvaG5rQVoyVmRmOTIwSzkrbmp3b3NnSFlPTE1kY2NtMmFRcTFjUHlEVVhsWjZGSVNxV0JpQ3Q0dUx0bTFYbjg5TlFSN2ZSNmhURkVYZDFoZHZSQUxqTFp3QjRGdjM1V3ZhclFYaGIxcDMvTXZXbVgvZDN2K1hCcXhxdTJWQW4wV0hzTG0yVDJIQmRJQjVaUy9mVnJyNkduNE9JRmNlNW5LN2cyby9PSzY4czhaek5jVTZsKzZpQTNvVnZGZC9zQ3NpQWhvTGwwM1pYekNvWTFDclJMU2c1OHFqU0VHTmNJcStteHlDMlkrVlFLY29pcnBkbTI0Y0RKUUh1d1ZBNGZiUExRY3R3QzI4MzFWR2ZkOFV6YzhxVS95MlBhSlc3WWhEanhQZUFQVktWMDh0elAvU1huN1J3Ync2QU5ZbnlYVUxnZGlWRHh3MWZyMHBWYkZmNGRLeFQyQ3dMNzBDNU9FaCtGeHlRc2hHRXM5VWJ3R1I3YzRyUkMzMEtNQlRyK21jcnpsMjhhMEx0YTg1ajdVd1YvNU1EY2xOVVJUMVpvQWUvMWM1d0R2RzJtOW1oTmwxSS92bjlvNnZXVmE5WjIvOWlqM2s0aGpvaFhmYnNsZnVuSGxUNk85dExNeXRPeStVN0EzNzN3a2RENW5jWGJoOTZLQlZCQXo3Mk1ZVUFxb2xhZ09RSjF6ekhPdUh2eDg3dm01OGVzSEN4UU1XRzV1cVREcnQxT0tpZjM5L0x4K2ZUeTBoRjNYcldZQXh5SE9PWmRpZG9panExcjZSby8rYWc3M3lYNzVnb0V1RWE5d3hiZkdMMXJoL3o5NytKZUJyNE5CajU0MndldmtkZS8ybEJrNWRBZkJWTDlTdTR0STJmeFlwUnhreHZ5aEw2L3pyRlM2OUdFUUFiZ2wwYnJHeC9NbXJxang2M0JUWXg2QXVNRzljbE9DMk5SYnhjSGtVaGxDbktJcDZJMHozSEpKbzhhSCtUUDcxK0RSYUJhaC95U2p6SFh2cmE3M3Y5MTU1bXRhL1loMzZWeVdMSGM2NkNJNzhzSC91NE8xZHBGS1RNTy9BVjY0TG5XTS8rZUQwbDM0KytROHc3WEpheWQ2NVZxTjcrMnBCUkFHSmc3Y05UTW5FbDc5WGNhZkpkaFJGVVZRdTFROXNEZEZ3bEpSTFR0VlJ3bnI1MVhmLzg3ZStQT0JTMkVNdlVacjJuVUtGTFBaU25yQXhqZ0E2em1idjZ0WFZFVFNPd3R6K1VsWEw5NFZSeHo2V0hhNW0vc2s1Umx3cHNndFcxTXR2cXNQV2czem9DVXFxQk5qanp3anZiVi9mUHN4MStQdXA2Y1hGMUNLSWl3Q0tvcWczQVBhT3ZmckFabjhOWnIvNzg5LzhEejJIN2tQdTM3TGtmOWMxa0NtN2VuVEF4am5sZmplNUZNeW5YQ3JjYkxrd2kveTQvS3NQN0ZQSXJPakVodmRSbGFuSXhEallVNENFTTI5dmtlYXkzV0hQZFVrOVA2Rk9VUlIxWDhBK2dIcVhuRjc2cUhyNU9YdmptejJnMjh1UFcvdithNzBESlpUdTlzMmJ6c1dxckM5Nk5YSmtDb0p6cWx0emNvajNvd0RMZ1lwRU9LWEd0d0p5M0RxYytaclhYdUxLUzkyUEl1UUNXckUzSFVWUjFMMkR1bU55Nk56cWpMZGw5NjlhbC83ai9udGZEdmdOZTltRWhqR0hYdTZISjBUbEdRQTA1OHpUYnRRNVYybkFzdENsTnhNbGJ6RlUxMTZXTnI3QmU2aktqT2pFaEZ1dkxjelhOdHpKZGVXcHoxblJZbE1VUlQxTXFCZWV5UkdqdlNIZkNNT2RRMWVBK2xjNld4L2k5SEVjM3o4aElCUUROaGZtUTNlN1JNT1E5SlF6WHFPbEllOHQ5czRMTmJxNG1Idi9xTW5mM3hMTWd5c1BDWWc1SDlGU2w4NDFBVVZSMUJ1QWVzZGlOV2p5SnR6K3lycy8vMGNTaFArQy9lazl5YVFyRGhuc1NxV1JBQmcxaWJha0tzT2h1b2xrYW5Ib1BiemVxV0d5MUNWdkpNS2dGd012ZkE3WVB0alh0d1B6NE1yblBxSWxvZmVsaXdDS29panFkc0YrcUJyM21mQnVhL3c5c0J5ZDRuNnVpRWgvT1BxNFAzc0g5Ym9WTUlTd3Jsb0lEYmhjbDhFK2YvbzRCb3VJcVVYQVdzRHNGNVNMNFRXMm16THBZb2YxMjZsbU10aXUyTzJiVzNMbGcyWTBwci9RTXBudkw1V0V5QTV5RkVWUjk4V2xtOUF4YnJCL0xBei9Jc3JXZmlvQS9JRG5zYlMyR09xTlpMOHZoYmxBU0M5ejZjY05XVTRUZWw4U2JRKzE5R1BsWG1OaGVBaGgvVjE5ZXBpTEt5K1hkNWJqWGpwRlVkUURCbnVDMmZaNy9hZUI5WjhjMGxIMUhqamhuRkZEdlJEbUFZQ2JCYzFtWkxTcE9mSGVlWHRvWEpQamdyYytzMzBxSXBDQ09zcmlybmIxU1d2TlhZOThMUjM0a3NsM0szSWJKZ0k4SjQyS1VCUkZVVGVCZWZTZDNvK3MveVNJOENNOWdPY1o5SVB6M0RkKzlPbzh6R01uaTczb3Nzd0VPaHF3ak8xM3IweHZSeGxlYmtJY3puT1lOVDZhQkJkOWNIajY2MzF6VXBpSC92SDY2SHlXUTUyUXBpaUtlckFHdlE5NHkzTEV2Wi8zdi9JemFlN1Z0S0hibVptRitWQ3g2ODJCZWhMaUs1VmJBNDZYT051TW4yZTZPNTY3QXpBL1ZhMTVjT1hTb1c0RTBrdEQ2UXk5VXhSRlBXU3E5MGp3SEVEZit2RmJxNFZzOFRoN093Zm1vVjQ2ZHkrOVd6Q2NDRUltMHpiRERYZkpmeE5yaU42WVZ2dlA5YTQ1V2EyNURqWDhTeHZ6bk1pbE0reE9VUlIxbjlrdVg4WmJyZlZwdnBVUkVrZmlWeTdNZzg0M1ZSWVlwQVord3UycUJaZTJNVm13eFhtZGI4b3NWeDYvcjExOXVscHpnQnpaOVYyNW5GTExJRDA3WW5iOVhqb25zRkVVUmQwZmFZQ2lrdVNxRTBDOWJnVm1ZeEJJZ1JDY09yTlFuM2ZVMGZTMXhHV0oyc3orN2VmYnlzMWpIeUY0Nm01WjJKeWdQQzJVeWJraE1Fc2VwMjdDOTh6b0JtRk9VUlIxMzZ5NkRoRFlsT1hpdHF3cEFXYVk3WjJDK1ppanpjMTRYemUxUEFXa2VScTV6SGFkWjgwam1DT2ovUlN1SEl1SnNiL0huRXRYYWtXc2ZlWnZoVzBFZ3B5aUtPb2VPL1FlU0twUzRIcFR0MzY5cjNzalNhZGczcm4wN1h4TDJKQlJQK1ZPNXk2bWNNbHE4KzY4SEhlN0E3Q0hudkEzaGJra3Z0bEZ4TlludnFrSnlDNE92UzlaQUF4QTNxNllTRWRSRkVXOUlhQ0hML1ZTTXFsdjV0Yng1USs0cFZyRUpnR3ZYRjM2WElJYzl0Qk50STgraEhYdXljMWxudU04Tm43dmZES2tIMXE2TnFhNHZHR3RPVDV2dVBMTmlUcmlMWFhwOGZIaXhBbHlpcUtvaHdmMDRaYy9FdVZrLzNiRnVOTSsxUHRsVzhtSWRXaG1vNVc0MHh3WHV3amdpZk9hMHpZcURZdDVxRVlXR1pmWE40TTUzamRncmxQOTd4ZEEreVl1UGN5Rngvc2h5Q21Lb2g2d1EwODZWUXNhMUdEcmxmQnNmWmUwMFFZdWcrZDEyZHpUcjNXNXkwODRTN1dJdlpvSnQ4T2RueUVaYnVROTkxcW1lNWkzSyttSHp4VWdQeHYyaUovNHZFK1pJQmRBamtoS0FEbEZVUlQxUUlFKzVmSndHNERGL25hMTBxMERGSERxUjZ3WW1SVU93RTFwbitpSlB0WVFMblhjZnFhbitubTBsejgxMHh4dkNEQmYyemdHMFk4bloxVTNXMzJLdlV0Y2VvNHROLzd2RWtCT2psTVVSVDB5aHo3ZW85eDFTOXR1eWxVSmM1SXd0cTlIWHlnT1p5UDhQTGQ0dU1sd2xxa0JvNVhQSDhpQkppSUZhMnJOcGJiZExscENpSDBOcUpmQWY3ZzNEb0RqNzhHd09rVlIxQ01HK3FoVDkxQVFWemxSVGpYdHJGdHg2a1hHdnUrVENaY3VlL1BYNjdMSjBiMXRLcXo4OUt5YTZBUjNjT3Q0SDJ0cXpiRmdlSGErR2MxTm1NcGtYK3ZTRVZKdlBjUUR5Q21Lb3FoSERQU1lDWFB3UUtoNGpWdEh1VmdNd3JFcFlCaUdzdDJVazR1RHNVWEkxR1VLd3JKL1grcGVCQ0FsUE1mUzhyVFFEeDRMQm4yMG9GbVhuekQzMldOL3Y2NWRTMTZHMVNtS29oNi9xcVVQQ0NCQkpqaWMrbTdoQUpKTDc2N1BOdU9oYlZ5ajVTcjJ1K2RBdEFpSEl3Y0RzaysyWmNJaEg2SUN6dUhYeGNYQzZFQW9SNHVqR25qZXFUekIwZDhWeFdRZFBuNEhOOTR5d1kyaUtPclQ2ZERWQlBQVW9JRktieldnWGJsVlRyblpFT3JENWk3RHNIRTVVWmN1Q1YxTnV3am0wZ3UrU1VNT0VZRnFwdjU3RGN5ZEs5OUk0dHZZWWlIbDBudS9tMHBhVk9IemFQMkFuSVpoZFlxaXFFOHowTWRCTnBHWTVkRWlwVmViU3NMd1MwTHdnSG9Za0RJMlMvM3ArU2FaT0NaejJPdDI4cnlIRnh5ZkFoMmVIL3ZhQVphcGV2UDl2bDBFYzV3eW52TWNJZlp5ZkVHVStqeHovdzU0S3dpcG95c2Z3K29VUlZGVWRzaDlFa1orVm5kcElYYTlJUHY3NHFvdTNucXlFWWVjZWkwWnIycmRmMnJ2VzJVc09vcUp5RVAzQWZpdGc5VHhVdDVsMzh2cnEzMzJCNHBveFpNdzFDWGpNMTBDNFJCU0Q1bnFGRVZSRkhVd3FCblF5M1dUY0x0UHoxMmpsQnpPd2pGZlNKYzEwd0Z1K0RnQVB5VXNHbkpaaU5jWlcyUTh0ODgvdGlqQWFiMit5bXNjRThyUjRNeVBSdEtxUEpjK3RvQUs1NCtGemZXK0ljd3BpcUtvWXdidm0zUXBsOHFFVU9wM2FNNENzT1UwbzZrbkhIQUlmNGVRZUEvb2RTc2g1eHlGYk8raDNvcGdubW9pOCtweWx3VlB2TS9uVDdhOXBqUnJJaC9EaFJLY09BQXVVWSs2WGQzRWhxSW9pbnI4cWpBVURjbFVqZEZGdFVFaTJrelpXcEhYOEtTVW1tdmxHckRNWktzRFZoY1c2czlHM0RqQzJIRC91Y2xlVXdsb2NUUmhxb25NcTh2OWFIbGMvTHg0RGxlL3JucGpXWTh5MHFQNCtsU29YZmJHRzdjQVlYSWJSVkVVbFEzMGNFUEN1bnZzZjZNa3JTcktTczAya0prTkgvdWFkZXl2dStscjQ0QUtXZThCNnZGVDR6endQRU1uRC9ERjllckpPZDRtWGJjZTJxNm1tQW1ZejlXYTQ1d2tnejNLOEI5Q2ZZbHFuNm1PQ3psT1VSUkZyUVo2enpIRElWcjRWbVVwKzhHVnZlZ2xjQitRMWJWejNjaCsrWlRyRFZBZjdwc3I1U2F4QWFMeG9nRFBoMHp5cVlWSDJLZnZ2V2xwOGFwN3B4b2dtZ1B6YldnU280OFhCREhVNTF3Nm9pTzd1bUdTRzBWUkZIVTdRSThkY0dFWld5c0g5TzFJUnZnazZDUFFZUzg4N0ptUHVkQWgxRU1JSEJBR1NDOFgxb0tuemhidlkxZzdqNWQ1ZVRFTmN4enoxdm0yMkd4MGl0SFprcjF4UDFxV1lYV0tvaWpxMW9FZXU5eTJjZE81c1BjY3hweUcvZlFwZDM3c3RNdmk3YWRLblBCWUNCNVFsNUQySUJrT3JualltUTVsWEdPTERKd2Z6amxXNm5uRjdWL1ZrekRINDU0LzNYYXZaZExHTzdtZ3dLK01MemNMNDJRZkc4ZmpQenZYS0JSRlVmY1U2UEVYZGVQSGh1SUxmRnM1c0MvdEZLZTFMdDUrZGlad0czUGNHSUN5c1F1SGVKQko2Q09QeFVEUWk5ZTc0dlB2bkhjQUh3cS83eThLWExNYUV5RVoyd0JUemg4TENieHVQdHdPWVhlM0wyNmtBY3hEQnQyeU9leUVPa1ZSMUwwRytoRHVJVHkrYVJDSzE4WFpSaCs1MHhoeXd5LzlKMzcvRy9BZTdpSER4YjYyNEg3bjJUWXFMWE9QR1I2Zk8rQWt6Q0FQandsUXh3SWhGZnF1L0hTNU0xK09OcFhGSGtNTXgxMzdTTUthcVd6M0FkcGo3V2hUb0RhRklkUXBpcUllS3RCandlRmFKTnBydDljT1I1dHI2UkMrQnpnQndLRkxCclRoc045NTY2ejNkTS9PcStLVGdmUE8wZE5oc3AzOTU2T1hWOG1FdENmZWxldGVQZjUwRnJ2eENYanRBMGh5a3lZK3hhSEgvSGh6blhWVUpzd3BpcUllSU5DREdyOVAvS0xadWE1eENHL3IrZmFzcFY4RTRLaXJ3Y3h5Wk54Lzh1cTZCM1VzQXRDVkxleEhmL3o2dXZqTXM3T2o1OFg5NGJsdy9GbFVkdzVYK2JGOTNtRUhPWndMT3QyRjhya3BNQ24vbmdGd2dCejc5ZmNKWkIyc1BiaWxlVTRjT2ttNjdkTzlOcUZPVVJUMVFJRWV1elBzdGIrODNMa3d1WXdQMVYzTjloamZneXQrY2JIcmxiY0oxQzJjMzNsMmdEckMrNGdJdUtFa1poUm1IYVMzZlpqRDRROUw2SkFMRUw5R0dsVE9wWWZHTHhlWnJXSHZ5bTNIME81dUQwRGRmVjdxeEJTbktJcWlIaGZRaDNDLzhFbDBHNTlFRnllWXBjYTF2djEwSytIM3k5MGhrUXdBQmRRL0E2ZGV3RVZYMG9XdWFadlpOclVJNlo5dnl1NThBUE40YjFzbXU1MXRwQS85bk5NTVUrSjJHYlBhYjBQYWx4QU9vZTFhMS9iUDFkQWlVeFJGZlhxQURzQWFTUkM3ZmJBSGlLSzNPcUEwMXVwVktWZGFkbWFkL1FzTDhWQ21CcWgvL1BLNitPeHpsOVdPV3ZXUGZVOTNoTi9qaGNLbE5MRnBCSUJ4bzVxUFhsMzFuRG5lUDhMNW1PMGVPL2locE13T0RYZnVjRys4OUExOUFzVEhGa0YzaVcyRzBpbUtvdTRwME9GZVZWbmFDenFmbFlWUlpRRis0bUtNNmdCM3lpL3h2VzlZQTVlTFVEekFYdXJqWEhXMFpvVWpSMkpjYU1LQ3h5S1VqMkVvbFEvajd4SVR5TUo4OEkzMHAzZXdmaG1GOGdGSmpHMUZpRDA1YzExZXp6M210dmJHUTZoY3pzZkRlNm9ySDkwM1JWRVVOUXIwNFBoQzJOYUJUbnVvcUE1dUlmbXJBNTR4TjU3K0ZRYVJJT2t0bElqQktNZERVM0FlbjNsK1p1RnZRVzdCanRkRmw3WHpiU3RsYUNocis3ZVBMNDhnR0NDTjMwTTdjZkZOOTd1MzdmMUlmaHR5OFJxaGRKL2tkc3BNOVhJQWFyeGZMRWhDWUtBUDYvRkl3V2tXRW9vTEFvcWlxTWNJOUhrWW9jNzg0Q29EZE9CY1k2YmZKQ1JkZStjTklTTWQ3Vm5qUkRiOERBakRZYU4xTEp3ellJMXpRNmdka0QvekpYQjRMb1Rnbi9xeU15dzhjRHdXQXdpL1k4R3dqUkwwcEtiZWdueVhLSjFiSXl3MEVEbFEwYUpFSWhCcXNMVXhBOVc0VnY1TmlmQ25LSXA2UkVCUGY5RVgvUTV4UWtZdEEwZU03TW83R0FHMGRkUitOWWNOZ1BIMUh2dmdXcUlGYm02NTYwd1h1dE1oRS82amw5ZlNKUTdnL3ZENnlyNk9rZkd2QURnV0Z0Z2J4K3Y5OE1XVndCd0xBQ3dXNG5ONTRVUHFTNmFjeFJGNmwzRG5JZ3Q0ZkpkcDdnOTY2REFrekNtS29oNDUwTWRJcDh1NHk1Z3FxaWY5MXExdzhjaGVqOFAzeGhSSHBWOHk5dFE3ZnJSTlJWWTdzdENWZC9ES1FoMmQ1RDc0NUxMNC9OdFBYRE1iL3h6NHI1dFJYaFQvOXNtRnVQaTNuN2dRZXloelEwajlhamZkampVa293V29sYjdUWEtVUFR2dG9vdHBnMFhKZkhHN3FQRzl5M0gyTEpGQVVSUkhvdHcyU1FjSVpRdEhQcTIwSEQ4aUZ5SnZlWXhEK0RwREhGZUNMQzl3NXByWWhPdkM1NStjU3BvY0R4MzBJQk1oZWYyTUU0aDkrY2lYNzhnalZvNTg2SGo4MkZDWU1uWWwxdmkyN0tJU1pvUFlVQkIrYXd6V0p2OS9jZXlETUtZcWlQZ1ZBQnd4RzI0cDZHRllTVnRlOTQvWVdwZ0J6REEwMGNaRk9kQmV1RXgxZ2l4RDh4ajYyOVVOanNHQzR1TjVMWGZuenB4dmg3c2V2ZHIwRmd2YWpYSHZOWnpBanZkVFprSHBvZTh2bUJuOC9pcUlvaWtDZmJQczYxUkFXY0ZXRHM1T3M5T2puMmlmSUljbE5FdEhzQlFDU1VqeUY0VEd0MUtKakR4Nzkzd09FUTIxM3dteC82a0czSnVST1VSUkYwYUZQUWozVWtoOFdCLzNmUzhMYzA2MExsMXRuL3RTK25SKyt2SkpRUEk2dDBKNjFMVjFudGNoUlN4bGVoQzJ0VkxJV25icnBZbzVOYUNpS29oNEUwRU5XOTV3UTZqYStNY3dVb0E4dVVibUV1TG9aclhVUFdlK2h0bHRaT3krZ2J0em9VaG5MNmt2UVdobjFPcDRBQjBlUDhIMEl1VTlCS0dUd0k2c2RjOTFkYzVoVExvRGU3UDhnekNONkx4UkZVUVI2QW1MR09MZHQvQmYxNGJZWmdGYjEzSG5oTTlpSE1GOHJoTTlEOHhzQUdDRjN2TTZWOUl0MzlkNXVuT3Vodi9uejgwMVJOMVUzVUFXSmNiR1FsSWZMNVlMejBQNjVnL3RYRTFBOE5PMDVuRk40L0pzQTM2bTNDNWpsVGxFVWRRK0Fqakt5cGtEeGVHUEpCbEloUks2OWZWWkhZTDlMQUlYV3FFaHVLNzE3RGozWDRiaC82R3ZJVWJZR3NLT2NETWNCNmdBMCtzRi8rT0pTTXVpeGh4NTZ2Wi81YkhiVXJhUDczSnJXdHExZnJDenRsaGVQTkoxODN5TlQwOEtDS1JYZHlLK2pQMjFDSDJGT1VSUjFENEFPcUNtRnhpOElINHYxdm9OUkxlTWdDOEJHbDdqUUJDYUdGMEx4cjlDVDNWN0Q1UUxteUdESEJjY2JoTnU5YzBjby9kMTNua2o1R2lhc0lVdisrYk50RjFySDFmWWROK2psNnJxUnNqWUgrdHViYTU3VjF0V2tmSDcrUWlIK3ZIcVQ2R2JCbkgvK0ZFVlIxRDBEK3BzK0FmQUdUV09jYzlhOVB1NHhxT0NFQVcwWFluZjczdWo4QnFpampBMk5aSkFZOThvZUoyMWpyUXZIL2YveDdHbnh1YmZQaTQ5Zlhjc2k0S09YVjhWYjU5dGl1OUZTcXg2OGI1akZEdENpNzN1WUREZlhmT2ErcUxkUU1Nc3duWnNQR0VjVjVsdzV3VTlSRlBVcEFEb0E0Z2F4dUQzdktxci9Ub0VCZmRnUlFnL2hiVFNBZVVzbXRHbUJ0clJmQll6TjRUSDRlU2N6MUYzUGQxeXdkNDZFT1RTanFYWXVOSTlwYTBOSWJhVytYWGV2aFhwNC9CTVdFNDlOdWUrSm9YV0tvcWhQTWREalVMQzBUUzFsVTFoZ21vYUw2Zlo0MFo0VlRqbUFITS8xOXRPdHVIamNCcGpob0pHaFhubTRJMXlPYXh5SFkvQjdTWXg3c3BXT2NZQThacXk3UkxoQ3l0eWs1RzNRYUNaSXd2TSthSURYeFhraGt4NXdENUNqRzZVb2lxSWVKZEFCeGpMc2hXOWMrOVNwQmpQRGV2UVFXbzhUemdUbTFrMEg1NHdTdGRyUE5nOE9QOHd0YjlyRC9jaHNCN3lSeElidy9KbUZNbHo1SnhicVlYeHJMZjNpWFFPYXVQM3JFTlNsOUhWMzE5dk5tWnozZnQvZXlkNDdSVkVVUmQwSjBBSExNREswR293UHpWWG82WDY5YjQ0V0NIRGNNY3hmK01TNDRMN2RjYXAzamZzQjI3MkUzcThGNUs0SlRTblBoK2NJQU1iaUFlRjVKTlloSVcrVDJBWklaWVp2c08rL2NhK1BCUVlpQURndWxNaFJGRVZSMUwwSGVoaG80aHk1RDZQSGRlaVI4eDUyakl1YjB1RDJLK3ZJNnhFSWhqQjdlTXhPV3JvNkZ5Nlo3Uk43dS9nOWVyenZmYUpieUp6SGVjUHhmL0xxdW5jOEZnQTREbEdGWjc3bVBRWHoxS3dXbWNZV29nVit6eC92QnlOa0NYZUtvaWpxWGdBOXdOY05SWEV6eVVOemxGNDBQYmQ5bkhmYUVscHZUQko0OFo1NVVOTWU5cThEc0tlRTdQZEwzekVPU1hFQWRlZ3VCOGVQbWVrdmZQaTlPeS9qdXMwaFl0RE5ZMS93b1hiOTRxUFhjWlBnbklNUFd3SmtQRVZSRkhVblFEOTBORk5kNGxrSzhya01EeTRkd054YllGNU9sSVRoZGRGUUpvWTVIZzlISGVEdkZoVWpyMVdFUkRxWFJSLzIwVkcrOWxuZjZ6M0FGazc5bFRTcDZaOE1mbTdhcHZpb2JtUjZHMXc5WG05cS92bnhlUlRkbkhoZEhzYXhTamM3SDVGSXpZT25LSXFpcUJzQlhYc0FGbEpPVnZheTBVTWY4d3h5ZDRRZkpyeGRJNlR0RTlYR0pPSHU4NDFQUWp1RTZyRy9Ia05YMnNENjg1UHdkaHNOWDJtTlBCNFBSZWc4aE5aeFB4ejcwL1BEV3c5Ty9iVXZhMHU5SFVRRkVJckgvdnBVNGx5dVpJSFVKZk1aeVFjSUdmU0VPMFZSRkxVSzZJQzBqQnkxQUFmRTRTU1ZiLzJhNzc2bmp3T29KRUZ0QXVSUWFQQ2lCczVlZXEzNzBIbFllQlJLZFVERlBuVllKRWpXdXYwNVFGdjU0d01vdzl6ME9QRU52M2UxN1VySzVWS1NnVEdYYmJIeHoxM09KTTZaWXR6S3g4eDJrUWEzU0dncjArMjlOMUh0UFVWUkZFVk5BbDJTMmdUaWJtOVpGZE1qVDVkQVBCejArcXJPS3VuQ2Z2ZTU3N2NlTzNzd0RmdmZzWFBkRElCOGxMUTJPQmJ2TTVTWHlZQ1dpMTN4R2V2S2U2MVI3VzFYajY1NisvUXBzTCs4MkF1STRmN1ZTT0pjcm9ZVDZLUldINHNwUDkrOWFjT0ZaWEVVUlZIVUNOQ1BSN0RNd0djaTdCNERIdDNWZG5XVERHR1BPZk1BODlqaDR1bmk1aklCZW1Fdk9oZVVnUDkxTko4YnozY2RaYjNIQzRIemJkazF0aG1UVEpCcjNKNjhsTHB0K3JYMnVlNThTc3BQWndIZ2tVcGdqTzdnam0wRk5yV2hLSXFpT3FEbk9zZ3hKejc4SFg0T3ZkQno5NExoek0rMlZmSjFybjJUbWQ1SmE5MU5UTXNWOXI2dmRyb1g4b2ZyeCtMa3pBTjh1TUNZYytwQnJ0Uk5kZnZyeXpMaTgzNW5va1JBeVMwb1hLNUFsMVRYY3UrZG9panFVdzMwWHExNE1WNDNudVBTUTdKYlBiTlBIanZRSjFzSDh6RmRwbHl5NmtOT1paYkpTUUxkSUdCd2NiMlhRUzFqaTRCd3pCd3JBZE5RN3g1Qy9FdmRlVnhQUDVzNTc5K1BNajdjci8xOCt2YXdCMDlSRkVYUm9TOXk2UUFJWE9xU0JDNHQrOVhWMFdDV21FTVhnL2F2WVJId2x1OE1GN3RYTXdLOVdOanZ4alpBL0JwNGZqajFaNE5hY3hOQkhZNTR1SWMvcHJDZ1FZUUNwVzVhcjNQblN5V0xHaXpDZlAxN2dMdHNEUmlHNWltS29oNjdkREVCd3Fra0x5QVVTVm9BK2VzRWVDZFhFYjVaUzRCNTZuVUF4TlQrTzNyRUQydlA4ZEs3d2JGaDMxMWc3eStxT1BTWWozWHQ1Nm1IOXo4OEcyVEVveVorYWlwY2FwR0Q0VEhZaHcrZlRUK0VQdTdPajhHL2pzYUFPekx4Y2Q3SUlZaWJBVkVVUlZHUEVPaTV1QWhjYVgxQzJXVkdHZHBRcnNhODZ1ckhVOUF5dmxOYlNuaXNHWUEzVmQ0bHlXT0pjM3Qybmc1S29NYmRUTHh2cmZYUjhKWWNJUVNQQmMvbGd2YXZxYjN6OUlKckNkMWRpTDVFZ3AwbTNDbUtvaDZicWhnT09YdnBBTzNhNWllQU9STGdwSDY4T002dUQ2K0Y4UGJZUHZ4d3YzenBXWXp0dCtQMVhyN2VGYytmYlVlQktXVnRQaE4vbDVtOUg1NEh4Nk5YUGR6K1dWV091dk9jdmZPa3cxLzQ5M0IxL0lWa1F4Z2ZrbWZXUEVWUjFDTUEralNRWEtMVmNQOTVMY3lMeE1JaGFMZHZSbUdPeDJ1OXpGSU9UeGVQUnhlNlZQYjYzdTk5YjZwcEY3NEc2aExac0I5ZUFEdWN2cXMzUDczV0xISkNpVndNOThWUkFJcWlLT3FOU2M5QklkUnI0N0wyeXgzd0NoQXNFaUhrY0UvcjI3S21vZVAydndVMjV0Z0JMMUZvQ1p2U3hWVnR6Nk1kWGRqRVVGOGFmby9CanR5RFlTdmJxZGViVzNDZGt2YWhoMys0SEEzZ29TaUtvdTYzUTQ4ejJVUHprbnJoSHZrUURKZzlmbFF6bmtpWkQ0MWN4a0w1U093cVM3VUk0bVBIaEVTeE1JSjFDRnQwdHBzYW5ScUVXblVjYzcydlZ5MTJRa1o4NWMrbjF6ZC9abHhyTnI4bkV4c3ovNDRoanFLV044ZWhLSXFpN2dqb0lmczdCbHFMRVo4U2VsMXZ5OEJDZEZEYmRKbnMwMk5XOXpNRFcrRE9SL2UvUnh3MTd0OFVPZ2tnUE4rK2FNZEI2K3ZKNTBDSXNqWndlR3B5WEE3WVVUR0FaRFhzc2VzWk81eWJOTGVVNEhOT1A0QmQraEFvZ3AyaUtPbytTY2RmNXNnS3h6NTUzZHlzWnppQTlDU0MrUnlaMEVMMWNsZFB3RHpkelMyY2Q4cHBoMFZDS2tRUG5XLzdrK1NHUWpPWk5oRU9UMzBzTGo5Z013dml1WThDZS9qU2RhN3VaOXpuWnJhYmhZQmVHK0VZTHR3WWpxY29pcm9uUUc4eFJheTVPY2dEZkJHS0R2dmRRMENZeEREeE9YY3IrN2dScE1JbFFHek0yZGQrSkdrYVJHb1N3SGpZc0plN21hQWVFdHhrQXB1K0dkMEU3TFdiRmxlM1p0SlUzd1RZcTBQNEJTMDVSVkhVL1pNcHRJU1hUelRGQ3pCRG1EMEdaZXA1NC91dWRzMWtxRDJFN3RjQ3pVekFFTTg3NVM1cmNjeE5zdGxNYW5VaWtZbXphbEVEbWpHRmpQZzQ2LzlHN3R4TWZ5YkgwK3I0ZncrS29xZ0g1ZER0Ri9uTzF5bmRTSUJZQU9UUXhZMUJYWnhvUnVtWEx0V05UaTkyOWJHN0x6UEt4aEFDcjRjaC9XVG9QNEw2OWpSUWg1Q2N1RThNdXpsbFpudDJOdjNJRXhIK0ZFVlJiOHlZaHkvaEhhanpzdit0YjRxbGRNZGVPVExaZTFQWE1xQytxK2N6NkdOM2JsSm5kME9hbkcvblMvR2wzank4emdUTTQ2aENWZzdCUXJBSHQ5N09KTUlaRXBhaUtPcXhVM3hJZ0pmWTZQNVhFeDlrbGpFZDBBcjEySFA5eWVNbzlkVyt5U3FKcTdTZWZEdHpQZVNSY0RkMy9uUGErOUI3WWNiZlQrbytMQmJXMXFxUENaL1p2dlo5NmxlNDdady9LOWNERkVWUjk1emw1dkNOTGpTd0xMYzBNLy9ZVVNoS05NdjUrajhhRTFya0RSMEowOGhtRndzbzRkTFRoS2xuZ0EwWW04Rm5FRitrVmo0RHV0ZXlBSm11dzA3ZHQ2Mld6MjdQQVc0TTlwc1FuT0YyaXFLb2gwVHo2R3U5WTdmODhJL1lRLytIZ0RkempQOVJBWUp3dHlZakJEMkVnYmpkRFBYMm9VZnF6NW9abHovM2V4Qzl5c3hNUnhlN09WZWVldCtiVzRCNkRIYnM4YWRLN0FwekduZk96SGFLb3FqN1o5RmpabHNXL3oySS9JUEN0RVhmcGZ1TE9jWUFIQzNnVkUxME5adUNPcExNY2dhN0lHTStHVzZQejlQM21KOEVlc1pZMTJHWHRqSGh2SWV0YWNjQU9JUmduRFI0YXVHOEF0aVhzSmQ3N1JSRlVROEk1Q1lDZW8rRnd2QWZXR0syLzkvZWVOOUkxN1MyZTVBWmdUbGF1V0xBU1U0aTF2Q3V2UytSeTVIMi9kYkgzTzlpSzV0WURJU0w5SW5QVEdERCtlK2JkdGFWcDE1ZUd1UnNxaHMxb0prRE84NE4wL0RNaWR6NUtZK25LSXFpYmdaMTA5cy94NWF5d1B4OWUvdnY0TkF0QjlvL0M0UXlRdnIyeUtVRFFnSG1ZNUNZZ3JxYm9WNW5keDhiSnF2ZEdPeG1Qamt1aDdONG11dVIyZVpUTU84V0tzcTFpNzFwQTVvNXNLT1ZiRWljVzVNOE4vV2VDSE9Lb3FnMzZjNWJ6K3FPMjMvMndkOStvOVVlNE4rMWwxMFhlaS9DUWU0SkFKOU5wYVM3MnB6emkrdTg0eS8vWFozZnZBYUxoM0lzdTMxZ3NHL0M4dmg1OEI1em5YTm8raEpETHdmbTNZS2xjRGtJdHdsMXZIWUErM0IvUFNlYVFsRVVSZDBUbVBmY2VSeHlGMzd2aE9GZ3A3L2pmZE0yZityZzN0Z2ZnMHR2eFZGaXY5dzFYMDNQeUo1alFaZ3FscXNxR3VneUJScm5RT2ZLdEl5QUxSVnRQM0xwVlg3aTJyN3hvZmRNQnp0YzZBU29WeWVzVmM4Qis1SjljeWJEVVJSRjNRT1lkOUJ5YkhhTWJzU2xXM2IvencvKzlnL2Y3NER1WGZvM2lyYjVNRDZ3OGpBM1hTaSt5SVo2QUJoZ2t0TU5yZ09kMzZkUE9la2swR2ZMc3VaTDI0SlFZclprZXh0YkNNZnVOdzN6c1RVWE11QnZHK294MkZ0amJqeFBubTZlb2lqcWJtRXVCcXNOdlBiRzJ6TGIzdmlEOEFodE90dHVZVzZhcitOQS9Gd3E3SnZqeTcveDRYZi9oSkhsejNIcSszclpQUFd4UmpJeExNT2x6U1JMem5IaE9hZGVQL1dZWFRUUkxWMmJQait4RFVEZjNBSFVVMkFmM1k2Z082Y29pbnBESUk5WTI3RzNEYXp1cmkyZmY4ZTY4dzg3b0llREhPM2I3MXY3L3NmYTJucFZJRVRiK00xM2Y5MDY1eDYvV0dvZWQ3aG52ekRVSGh5cmlmNlpCSFdiQ2ZUV2pDVzRIMEZ0YkFiNm1Hb2ZlaTlHSWhSek1POHk0TzhRNmpIWWszdi9FNTg3M1RsRlVkUWRnTHhvdlpFV0p5NFg0Uyt1M2VWUFB2aGZmL0FYUFhQb2dPMzN5QzI0UzZWK3g4TDhSNHEyL2xKSWl0ZXFMSXd1NUJoNUhkZStUZUxqeWpoNHFUaFdyVnc0dkc2YVJXK245S1ZxL1Y1MThiNnpTbjhBdVI5VWh2RFd3TldtelNmWHZxN3RZdzdsYURrZ1Q4RlJoc1hZNXpqRkdOc2xZTWRuTEhQTkQwTnFDWE9Lb3FpN1pIbkVxcTVzM01RWjdjMEI1cWI1YS92emJ3K2ZwZ29wOE02dUt4eThNMHA5MmY3NFYvYnlDeFl6UlN0ZjlnQTRxTzdpK1BMMWo1bm5SUVF4NVlHTVNXcjdabkhqRWpkRGZjSWRGcGt0MmhJa211OXhibm9MaTJaQlpFRkM3N3Q2dElXc3lRQmpPRDk4Zk1oYnVFdW9EOEUrL3o4NmlxSW82bVEwTjBXL1U2dGN1V2g0eUdzN1JNbWJ2N0dHKzh0ZzlUSFF2YlhYVXBMV09sNDN4WVZGOTMreDkzemJQdDFYNVU0TGRybFdEdHlBdTdIUTBlTFdWWHhlNG02YmRsbW9IVStwQyswMi9hUDdwdFMyZVlzR0NibTMrZGx1T2hUc0x3QlkzZUI4VGJHSjl1RE5FaVlPTXVBbFN0Q1k3RHlCVTRJOTlkblRuVk1VUmQwZTBBKzNnMHNQZGViTklhdTliZjRZenR4ZTd5VU1uM0xvTWN6eEhERGk5dGk5QmR2WDdDLytiNkhOdCszMXUwWWpDMXg3cDk1S2lMYkY0NVR1S0NEZHl2Yk40cmVFUFdRMWdHaHFMR2tQMGsyVFJScHNLZUJRblZuM2pjTksrN25VQ3hjbCsxMVRxRTA1K2pwTGsrYTBySzd1SHVyRGhZZFNkT2NVUlZHM0MzVWZKKzdLMDZKd2U5dDhnQVE0Qzc3dkdSUHRwdytCTHV5UmNIbmhvQzVPMzRWZTRaV1ZOdCszdi9qZmhXNi9XWmp5ViswZDJ5SzRjdVV1Q0xzRDZqaWR1akdyZW9UamRUSHFWRTNZOHZoWkd3RmRYdWM1dkcwQS9YZ1BmbUx4VVBoa3dJWGE3OXZaQ1hSVE1COStKcTdTNE0xQW5lNmNvaWpxdHAxVFZKN1dnYjBEK2c1MTV2YjZENjJEL1NEMGlBbUo2a2RBZDF2ZkI4dHZpdmJRUXFiMTlsK2JEd3FqZjhOQy9iOWJvSC9kR1AwVkMvQWZkU0EvUUYzS29kcDFNRmZHYnhPTU9QSWpTQWVIbnZtWnRRcFFYQkIyeCtmUzFvdU5LVDdpR3NtRm9Ubk9DcEFQajlYK2o5MlNyQlJGVVk4STZORTRWSE5vNjJwdi80dHJ5ZDUrUnhxL2RTVnJiUkhmUGdKNmVKNGgxTjNRRWd2TkVJZlgxblVhL2I0Rit1L1pYL3krVWZvTEZ1WS9aNC82S1h2OUUvYUk5NXJHdkdVZnZqbGdPaE9lYUY3VGpCZExwY0RlSW1tc3lRZGNxOXBGUUhkUXh6Q1o1UkRkeTA2QVRyYVNIWU81bWJIR2J0Rmppb1c3QUJSRlVkVDl0T2FDQzN0NTVZYXJtSCtTY2ViRy9COE1XdkZ6VmlLUVI3WG9SVG9oL044RkdBRC9mRTMwQ3dxV1ZBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQS9DQVlBQUFBeEJleUlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFOVVJGTmpGRlJqTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMU5VUkZOakZHTUROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pFME1FVXhPRUUwTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalUxUkVVMk1VVkZNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtDaWJydUFBQUNwaEpSRUZVZU5yc25YOXNFL2NWd04rZHo3OGR4MG1nWXhEYVVFWXFUWlFXMW1panFLaFRTYXMxbzZXcXlxcVZRZFdvQlRaYXRYKzBVTFdqUXRYYVAxcXRHaTJNZG9LMWhXbEFrUkJhUWFpdE5xa0krSU1mQVJwRUNMOUZnSkNRMkU1c3h6bi91TDEzOS9WaEo3WnpOc241WE80cFQyZkhkK2V2MytmNzN2ZDkzMzE5NXE0LytTUVVLVHhxQStxdlVSOUFyVWVkaE9wR3RZTXBXbVFRTll4NkJiVWQ5VERxLzFBUG9TYTFuR0RLQlUvR2M2R0lSdFNpL2duMU9kVEpKcE5iRWp2VGF0UjdVWjltLzcrTStpL1VkYWdkaFhxWlZxbGhiM0FPZFpVSmMweGxNclB4T1diem10RUd1aEMxRGZXUHFEYlQzcnFKamRtY2JQKzcwUUFxWUNEZmdOdHRxT05NKzVaTXlQWmJHWXU4dzZRZzVYN05oYTl0NXdDYUpOT2doaEJrc1JTaDFuSkt4SXdVNHFGQ0FyMlNZSnBtTkJ6VXBvUVNNUVhOUVBHQTlSYUEzNXJtTTZZUUcyS2tDZWlnQkwvSEExNDB6V1o0cUM4aXEwWERQTGp6aVNmVUo5MEpibnlOUldyamxYbVJLUVlYekczOFYrTDh6K2QydUR1emVxaVhsOTQzWVpiVmVGbzEzcEw4UzBiSWxSVFNjREhHVDdWeXNDVDEzTlR5VUdTMitMK1R3bE16UEhUcXhRb09RKzBLcnJoU29DbWw5VktCMkNrUEdkQmZPaEoySnljOWE1cW5QSVhZRVVNVjZPcnE2QndMQnhOTTA1UnB4b3ZzaUtFTUZNTXQ3K09sUmtNMmRNb1U4SzFaQTNkczNRb1ZLMWFNNlh0VnJsd3BxL1crKy9MdVI2OVRlMnJXclFQWE04OFl4bGJJY0I3eEpBKzEybm1ZWmNRQlAzN2hBbkF1Ri9CT0o3Z2JHMEZBWTQ3RisvRFljWndQUGlpclVGK2ZkMSt1b2tKdWo3VzJGcEtoa0dGc2hReC9RU3dKcU0yR2VaRlJ3MGx3L2MyQ1NPVkxMNDNOR1BUd3cvSTJPVEFBMGUrK3krK2gwNmFwajhXMk5zUFlpVEcwQ1RKUVRqTHNsWlFFZW1ua3dBRndvZmVRVjFDWWkzejExYWkraDJ2dVhIa2JiV2tCeDd4NVlKOCtQVGZRTysrOE9XOS8vdm44YmUvdWhyNVBQdEVIcU1KUUJtcmxPWEFaZWREdi8rd3pjTXljQ2JITGwwSENNRGVxTUxHRFdLcVZXa3BrNzE1d1B2UVFPTzYvWDlPeEkrMFg2K2pRelVhTW9WV1FreVJKRXZTNlJGYno0WWRncjY4ditEZ0toM1FjcVcvWk1rM0hSSThkZzk3VnEvUHU0M244Y1hrNzJONE9JdTV2bVRnUjh0bkMwOWlvN2grN2RDbC9tOE5oa0NSOUxNdHFDQlloTlNIVnJTZTVpZ3NHbElpTXRuaGVlRUgxenRDdVhmSjJZTThlR01peHY0REpVd29vN1QrNGI1L2g2Z3k2QXcxOS9UVllKdVNlOHZKdXQybzBlZjl2djVWN2VqRVNPM01tOS90VVZZSG5zY2ZVMEtnRmpxVzI5dWE1VzFzTldUalN2ZFJISGpCU1NFNkgyZmZ4eHptOWhmTjZJWGI4ZUZIdDhDNWRxbnI5d09IRHcxOS8rZVhoQ2RGZGQ2bmgzN05vVWQ3ejUycjNXSXNNMUNoTFRDb3dCS2JHVi9LYVlBNmp1QmN1Qk8vVHlvckhYc3dpQ3cxOWRreDhLR3RPRnluSFdKa3IvT2Q3WFo1dWxSS29FWVNNN0Yyd1FQV0EzZzgreUIxS1Q1OVdEVHZ1OWRlaEZ5ZjdJM2wrZXFqMU5UZHJibGNZcDB5SnJpNU4rMXJyNnNDcE1VUCtVUU9sOEZtZFZ0cnJlZTg5dVVxVVMwUU1zOTJyVmtITk8rK0FnRWxOTldhOUFZOEh3dHUzai9oZTFXKzlKUitqVlFaUG5ORGNXU2pDbEJvb2J3U1lCQ1kxbnQxQXp4UTFqSXNFdkdmTkdvajM5c3JQZlRpbVVTak9KNVU0THFaQytnQk9VWDZNVXRJeFZQWk1ESmtwai9GdjJRTFJQT01oaFV2MXNjOG50N3NmdmFlS0pTZ0VsZjZYeTFNNXQxdnBETmdKL0I5OUJNNHZ2bERIejF3MjhDMVpJa2NBclhQbFhHT3l2aUZYMHYvdFhUaWg5NkpIQ1RYS0t2OTRUdzg0cGsrWGxlYXFxZmtxaDU2YjJrZUxFTnpFMWF0Wk8wWnd3d1p3WXpMVWl6Q1R6TFBWenovYU5wQ2tFZ0l0Z1Robno4NEFSWThMQVpkUHhyM3hCblQxOTh1Vm53d1A4dnZoNnVMRjhsYXJCRDcvSENJRmpLR1ZUejExZXlaRkF3Y1BxZ2tFaFNvYVExTzFUeXVid0pQWERodzVvaFlXRXAyZFVERi92bkxwQ28vcFdya1Nrb0dBQ3N1Qm1UTEJsSk9mVjErRnppekY4MEpnbW1Ob0FSTEdYcDhnTDJwdHpUQXlqWk9UdnZ4U3lURGIyaUF3WkQ1SG5rMUE1UTR3SkJNZXdEQWJuRFlObkEwTjRQLzAwNEkrVjY1OTdUTm01SzFzcFlzTmN3SmpqS0Vsa216am5DM3QwbFZjNC93dm8wS3phWk9zb3lYdU9YUEt6ME9OSkxiMEM4aDVhckc2UlpMOSt6VjNMUEpRczdDUUoyeUpCaWlBUjArYzBKd1VlYzNDd3ZCNXB2MmVleFNZbUNEZFNnSkRDZEx0S01ZcXp1TWNNbFV4aWh3NmxMVmRrb1pFaG1ROFpydlJCUXNnc0huenNPbEx0blBtT2xjVlpzbzF5NWViaFlXQ1F5MkdLdStqajZxR0NlM2NPWEs3Y3J6T3M4cVRvNzRlYktoaVM0ditoWURicmJDUTBZaTc3NFp4cjcxMmN6Sy9ZMGRtSmFmUTBPM3ozY3lVcjEyN3BiYjFVbUZoOTI1dFkyaHpNL2lNVUZoSTR1Zm1Td1RYMWRRRTFSalcxRkNMNFRHMGJkdXRmYWkwbFFWeEhSZHFsVktJb1FvMEprSFV4b0ZIendhNEVhVG5rVWZrc0pnU2d0bjk5dHY1RzU2MkhNWDN5aXRabDZlNEdoclUwQjA3ZjE1ellhRUt6emZzWExObmcyMnF0bVhMdHJxNmpMYWwyaHZjdUhITTdVa01VMENscU1UNWJaeWtDOUNhTjk4RTE2eFpHWXUreVBCOWUvZHErdUEwamZDd3lYNXF6TTBsb1FKWE1tUTduNnZJYVVqcVhKU3Q2d0dVR0JKTEdXZ3d5VjN4OHBJdU41SktCMElnSTBlUFFoQkRiRnlqSjRWeFBCTW1USkM5MEpZV1d0T0Zhc0RSdGpid3IxMWJVTnNpWTNDTnRKaHFWekZDREZOQUU1MEp2bjJ5a1B5VkxwVVhCb1MrRnhLbUZYMUZKRC9VNDBlajEvZDk4NDNpUmF3aU5WSzRON0pjUlliRWtvREdEZzhLaHgrd3h4ZnI5ZVlCSFVLUXBneTJRQTgyc2h3ZEZPaUdqekdxRkluLzZMTWZpU2d4MkpReUZHS0hESThTU3hrb0RxaUJrNkpsdjJtYThoUmlSd3lKcFJ4eWFUaloyR2ZmT1d0YzdEY1crUlk0cHBTTEpQQ1AyQkZET2VTZXJQWFRqWGI3OTBXdHAxdEZZWjlwb25MelRtRS9zU09HTkhIZ1djV1Jxc3BkNy9wZFc5QjF3K2J0WXNwRGlkVWF2MnN6c1dNTTFjdG5GSFo3VHNVc1ozYUViZjgyKzMxNUNMTGExaGF6MEhTbGh6RlVnTGJXK2drNGZaTzI0LzJBYTg4eFVUaGdtc3ZZY2h3WklTdTZhdERCMkVucEhrcFFSWnBibzE1YWZzT3o4VnpNY3RJMG16R0YyQ3hEUnNTS01STlRydzFkc1VBMzFiM2NuK1RPTnQvd3JMOFl0N1NaNWpPV25JOVpUaEViWWdUS2p3MWszQWc1QXloNmFZSUtPZFFKYmlUNDB3dXZWL3l0UlJRT21tWTBoaENMWjdzcTFoSWJVSDVnd0svTVhOS0FEczJjZnFqMXg1Z2J0MGNrN3V3ZnVpbzJiZXAzbU5sdmliUFpmeUlEWW9GTXFQQk1pVkEzWTVVaFdTOXE0NDdpdlIxVjE5bjV4TDhHbmVLdWlPM1VuMzJSK1RQdDhRYmVMRDdvSWtuMHZwWkI0ZEM3QWRkL2NOeWs1T2NpODB5Q0tXWTdoanZIN2dLU1RSQ3FGVGUwbm9NdXJkSDMwZStZWVl0UFhPNk56a1d3TTkyY1ZHbWFmZlFsTEhGQkJObnk5ejdIOXlkRTRTcWJaMTVpWTJZZzNUT1JrWGFnN0FEeVJ2b3EySGhRZmxYcHB3Ulo0TURWNUJLbnpIWEVmbFluSkdwcmVHbThoNWNxclp4a016MVl1d2ZHSkU0TUpibGdUNUxyeGlTMDQvdW85ZXp1aU8xQ1hKS1RIY3BucnJHcENRMkRrUitVUEFlS0JwcDJJUDBvREsxcW9LK0kvWVJ0dmFnT1VINHdSbURLZ2M1M1ZpbGpVVzlyeUpUQ0tDMGw2V1BGZ3V0c0c4b1ZZb2NCZGMxNHJwQUdFQ2dLdzdSK3BJSUI5VExRVGdiV0FnWmJ3RzFzSjVXelZKR1Y3a0lNSm1rLysxOE1DbGptS3hUUm8wU20vU3dNMkpoYUdVelRRd3YzMEFRRGw3SnRERFQrT3VGUStiOEFBd0J3a2JDeDlpSVl0UUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGltZyBjbGFzcz1cXFwicmVjaGFyZ2UtcmVjb3JkXFxcIiB2LWJpbmQ6c3JjPVxcXCJyZWNvcmRJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwicmVjb3JkSW1nU3R5bGVcXFwiLz48ZGl2IGNsYXNzPVxcXCJyZWNoYXJnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWltZ1xcXCI+PGRpdiB2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCI+PGltZyB2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiLz48ZGl2IGNsYXNzPVxcXCJiYXJjb250ZW50XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiPjxpbWcgY2xhc3M9XFxcIm1vbmV5LWltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIgdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIvPjxkaXYgY2xhc3M9XFxcImJvbnVzLW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVxcXCIgdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJib251cy1tb25leSBib251cy1zdWJcXFwiIHYtaWY9XFxcIml0ZW0uc3ViXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJvbnVzU3ViXFxcIiB2LWh0bWw9XFxcIml0ZW0uc3ViXFxcIj48L2Rpdj48aW1nIGNsYXNzPVxcXCJyZWNoYXJnZVxcXCIgdi1iaW5kOnNyYz1cXFwiZG9yZWNoYXJnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJyZWNoYXJnZUJ0blxcXCIvPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm15LW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvb3RlclxcXCI+5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX08L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ydWxlSW50cm9kdWNlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxydWxlSW50cm9kdWNlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi00MWFmMWFlZC9ydWxlSW50cm9kdWNlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ydWxlSW50cm9kdWNlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcclxcbmRpdi5pbnRyb2R1Y2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT80ODJjYmRiYlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7Q0FDQVwiLFwiZmlsZVwiOlwicnVsZUludHJvZHVjZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LmludHJvZHVjZSh2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiLHYtaHRtbD1cXFwicnVsZVxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5ydWxlKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHJ1bGU6IHJlcXVpcmUoJy4vLi4vLi4vZGF0YS9ydWxlSW50cm8uaHRtbCcpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAgICAgY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmludHJvZHVjZSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi5pbnRyb2R1Y2Uodi1iaW5kOnN0eWxlPVwiY29udGVudFwiLHYtaHRtbD1cInJ1bGVcIilcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucnVsZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJ1bGU6IHJlcXVpcmUoJy4vLi4vLi4vZGF0YS9ydWxlSW50cm8uaHRtbCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmludHJvZHVjZSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogcnVsZUludHJvZHVjZS52dWU/NDgyY2JkYmJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9kYXRhL3J1bGVJbnRyby5odG1sXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW50cm9kdWNlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiIHYtaHRtbD1cXFwicnVsZVxcXCI+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1vZGVsXFxcIiB2LXNob3c9XFxcImRpYWxvZ1Nob3dcXFwiIHRyYW5zaXRpb249XFxcIm1lc3NhZ2VcXFwiPjxkaXYgY2xhc3M9XFxcImRpYWxvZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJkaWFsb2dcXFwiPjxkaXYgY2xhc3M9XFxcImNsb3NlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNsb3NlXFxcIiBAdG91Y2hlbmQ9XFxcImRpYWxvZ1Nob3cgPSBmYWxzZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29udGVudFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48L2Rpdj48ZGl2IHYtYmluZDppcz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVxcXCIgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiPjwvZGl2PjxpbWcgdi1iaW5kOnNyYz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0uYmFja2dyb3VuZFxcXCIvPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgLy/mlbDmja7mqKHmnb9cbiAgICBub3RpY2U6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiAnPz8/Pz8nLFxuICAgICAgICAnY3JlYXRlZEF0JzogMTQ2OTU0Mzk4MDAwMCxcbiAgICAgICAgJ2lkJzogNixcbiAgICAgICAgJ3RpdGxlJzogJ3RpdGxlJ1xuICAgIH0sXG4gICAgb3B0aW9uczogWyfmipXms6jorrDlvZUnLCAn5byA5aWW6K6w5b2VJywgJ+a4uOaIj+inhOWImScsICflhZHmjaLnpLzlk4EnLCAn6LWg6YCB5aW95Y+LJ11cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL25vdGljZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgLy8g55So5oi35L+h5oGv5pWw5o2u5qih5p2/XHJcbiAgICAnY3JlYXRlZEF0JzogMTQ2OTU0ODY3NTAwMCxcclxuICAgICdtb25leSc6IDEwMDAwLFxyXG4gICAgJ2NvZGUnOiAwLFxyXG4gICAgJ25pY2tuYW1lJzogJ+a1i+ivleeUqOaItzIyMicsXHJcbiAgICAnb3BlbmlkJzogJ3h4eHh4eHh4eHh4eCdcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL3NpbmdsZXVzZXIuanNcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcdGlwLW1vZGFsLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdGlwLW1vZGFsLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTY5MWMwMzFiL3RpcC1tb2RhbC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vdGlwLW1vZGFsLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG4udGlwLWNvbnRlbnQge1xcclxcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcclxcbiAgICBtYXJnaW46IDAlIDAgMCAzMCU7XFxyXFxuICAgIHdpZHRoOiA0MCU7XFxyXFxuICAgIHBhZGRpbmc6IDVweDtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuMzUpO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtdHJhbnNpdGlvbiB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgLyog5ZCm5YiZIHNjYWxlIOWKqOeUu+S4jei1t+S9nOeUqCAqL1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLWVudGVyIHtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGJvdW5jZS1pbiAuNXM7XFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLWxlYXZlIHtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBib3VuY2UtaW4ge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2UtaW4ge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZS1vdXQge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlPzc5MTg3Y2JlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTtJQUNBLG9CQUFBO0lBQ0EsbUJBQUE7SUFDQSxXQUFBO0lBQ0EsYUFBQTtJQUNBLCtCQUFBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsbUJBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0Esc0JBQUE7SUFDQSxxQkFBQTtDQUNBOztBQUVBO0lBQ0EsaUNBQUE7WUFBQSx5QkFBQTtDQUNBOztBQUVBO0lBQ0Esa0NBQUE7WUFBQSwwQkFBQTtDQUNBOztBQUVBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0E7O0FBUEE7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7Q0FDQTs7QUFFQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBOztBQVBBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0FcIixcImZpbGVcIjpcInRpcC1tb2RhbC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LnRpcC1jb250ZW50KHRyYW5zaXRpb249XFxcImJvdW5jZVxcXCIsdi1zaG93PVxcXCJpc1Nob3dcXFwiLHYtaHRtbD1cXFwiY29udGVudFxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFtdLFxcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICBpc1Nob3c6IGZhbHNlLFxcclxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAgIHNob3dUaXAoY29udGVudCkge1xcclxcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnRcXHJcXG4gICAgICAgICAgICB0aGlzLmlzU2hvdyA9IHRydWVcXHJcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaXNTaG93ID0gZmFsc2UsIDMwMDApXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGV2ZW50czoge1xcclxcbiAgICAgICAgc2hvd1RpcChldmVudCkge1xcclxcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpcChldmVudClcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuLnRpcC1jb250ZW50IHtcXHJcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXHJcXG4gICAgbWFyZ2luOiAwJSAwIDAgMzAlO1xcclxcbiAgICB3aWR0aDogNDAlO1xcclxcbiAgICBwYWRkaW5nOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjM1KTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLXRyYW5zaXRpb24ge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIC8qIOWQpuWImSBzY2FsZSDliqjnlLvkuI3otbfkvZznlKggKi9cXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1lbnRlciB7XFxyXFxuICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1sZWF2ZSB7XFxyXFxuICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcblx0ZGl2LnRpcC1jb250ZW50KHRyYW5zaXRpb249XCJib3VuY2VcIix2LXNob3c9XCJpc1Nob3dcIix2LWh0bWw9XCJjb250ZW50XCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbXSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNTaG93OiBmYWxzZSxcclxuICAgICAgICAgICAgY29udGVudDogJydcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNob3dUaXAoY29udGVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XHJcbiAgICAgICAgICAgIHRoaXMuaXNTaG93ID0gdHJ1ZVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaXNTaG93ID0gZmFsc2UsIDMwMDApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgIHNob3dUaXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VGlwKGV2ZW50KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4udGlwLWNvbnRlbnQge1xyXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcclxuICAgIG1hcmdpbjogMCUgMCAwIDMwJTtcclxuICAgIHdpZHRoOiA0MCU7XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC4zNSk7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XHJcbn1cclxuXHJcbi5ib3VuY2UtdHJhbnNpdGlvbiB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAvKiDlkKbliJkgc2NhbGUg5Yqo55S75LiN6LW35L2c55SoICovXHJcbn1cclxuXHJcbi5ib3VuY2UtZW50ZXIge1xyXG4gICAgYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xyXG59XHJcblxyXG4uYm91bmNlLWxlYXZlIHtcclxuICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XHJcbn1cclxuXHJcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcclxuICAgIDAlIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcclxuICAgIH1cclxufVxyXG5cclxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcclxuICAgIDAlIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB0aXAtbW9kYWwudnVlPzc5MTg3Y2JlXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInRpcC1jb250ZW50XFxcIiB0cmFuc2l0aW9uPVxcXCJib3VuY2VcXFwiIHYtc2hvdz1cXFwiaXNTaG93XFxcIiB2LWh0bWw9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8YmFja2dyb3VuZD48L2JhY2tncm91bmQ+PG1lbnUtYmFyIHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIiB2LWJpbmQ6bm90aWNlPVxcXCJub3RpY2VcXFwiIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIj48L21lbnUtYmFyPjxiZXQtYW5kLWJvbnVzIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIiB2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDpsb2NrbW9uZXk9XFxcImxvY2ttb25leVxcXCIgdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIiB2LWJpbmQ6bG90dGVyeW51bS5zeW5jPVxcXCJsb3R0ZXJ5bnVtXFxcIiB2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVxcXCJjb3VudERvd25cXFwiIHYtYmluZDpjb3VudC1udW0uc3luYz1cXFwiY291bnROdW1cXFwiPjwvYmV0LWFuZC1ib251cz48cGxheS1wYW5lbCB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIgdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIgdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIiB2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIj48L3BsYXktcGFuZWw+PHN0YXRlIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIiB2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCI+PC9zdGF0ZT48bWVzc2FnZSB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIgdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIj48L21lc3NhZ2U+PG1vZGFsIGNsYXNzPVxcXCJtb2RhbFxcXCIgdi1pZj1cXFwiZXJyb3JcXFwiPjwvbW9kYWw+PHRpcC1tb2RhbD48L3RpcC1tb2RhbD5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiIWZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiKGEpXG59KHdpbmRvdywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjKGIsIGMsIGQpIHtcbiAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSA/IFdlaXhpbkpTQnJpZGdlLmludm9rZShiLCBlKGMpLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZyhiLCBhLCBkKVxuICAgICAgICB9KSA6IGooYiwgZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkKGIsIGMsIGQpIHtcbiAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSA/IFdlaXhpbkpTQnJpZGdlLm9uKGIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkICYmIGQudHJpZ2dlciAmJiBkLnRyaWdnZXIoYSksIGcoYiwgYSwgYylcbiAgICAgICAgfSkgOiBkID8gaihiLCBkKSA6IGooYiwgYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPSBhIHx8IHt9LCBhLmFwcElkID0gei5hcHBJZCwgYS52ZXJpZnlBcHBJZCA9IHouYXBwSWQsIGEudmVyaWZ5U2lnblR5cGUgPSBcInNoYTFcIiwgYS52ZXJpZnlUaW1lc3RhbXAgPSB6LnRpbWVzdGFtcCArIFwiXCIsIGEudmVyaWZ5Tm9uY2VTdHIgPSB6Lm5vbmNlU3RyLCBhLnZlcmlmeVNpZ25hdHVyZSA9IHouc2lnbmF0dXJlLCBhXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZihhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lU3RhbXA6IGEudGltZXN0YW1wICsgXCJcIixcbiAgICAgICAgICAgIG5vbmNlU3RyOiBhLm5vbmNlU3RyLFxuICAgICAgICAgICAgXCJwYWNrYWdlXCI6IGEucGFja2FnZSxcbiAgICAgICAgICAgIHBheVNpZ246IGEucGF5U2lnbixcbiAgICAgICAgICAgIHNpZ25UeXBlOiBhLnNpZ25UeXBlIHx8IFwiU0hBMVwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGQsIGUsIGY7XG4gICAgICAgIHN3aXRjaCAoZGVsZXRlIGIuZXJyX2NvZGUsIGRlbGV0ZSBiLmVycl9kZXNjLCBkZWxldGUgYi5lcnJfZGV0YWlsLCBkID0gYi5lcnJNc2csIGQgfHwgKGQgPSBiLmVycl9tc2csIGRlbGV0ZSBiLmVycl9tc2csIGQgPSBoKGEsIGQsIGMpLCBiLmVyck1zZyA9IGQpLCBjID0gYyB8fCB7fSwgYy5fY29tcGxldGUgJiYgKGMuX2NvbXBsZXRlKGIpLCBkZWxldGUgYy5fY29tcGxldGUpLCBkID0gYi5lcnJNc2cgfHwgXCJcIiwgei5kZWJ1ZyAmJiAhYy5pc0lubmVySW52b2tlICYmIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGIpKSwgZSA9IGQuaW5kZXhPZihcIjpcIiksIGYgPSBkLnN1YnN0cmluZyhlICsgMSkpIHtcbiAgICAgICAgICAgIGNhc2VcIm9rXCI6XG4gICAgICAgICAgICAgICAgYy5zdWNjZXNzICYmIGMuc3VjY2VzcyhiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2VcImNhbmNlbFwiOlxuICAgICAgICAgICAgICAgIGMuY2FuY2VsICYmIGMuY2FuY2VsKGIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjLmZhaWwgJiYgYy5mYWlsKGIpXG4gICAgICAgIH1cbiAgICAgICAgYy5jb21wbGV0ZSAmJiBjLmNvbXBsZXRlKGIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaChhLCBiKSB7XG4gICAgICAgIHZhciBkLCBlLCBmLCBnO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgc3dpdGNoIChkID0gYi5pbmRleE9mKFwiOlwiKSwgYSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugby5jb25maWc6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBcImNvbmZpZ1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG8ub3BlblByb2R1Y3RTcGVjaWZpY1ZpZXc6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBcIm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBiLnN1YnN0cmluZygwLCBkKSwgZSA9IGUucmVwbGFjZSgvXy9nLCBcIiBcIiksIGUgPSBlLnJlcGxhY2UoL1xcYlxcdytcXGIvZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpICsgYS5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgICAgICAgfSksIGUgPSBlLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsgZS5zdWJzdHJpbmcoMSksIGUgPSBlLnJlcGxhY2UoLyAvZywgXCJcIiksIC0xICE9IGUuaW5kZXhPZihcIldjcGF5XCIpICYmIChlID0gZS5yZXBsYWNlKFwiV2NwYXlcIiwgXCJXQ1BheVwiKSksIGYgPSBwW2VdLCBmICYmIChlID0gZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGcgPSBiLnN1YnN0cmluZyhkICsgMSksIFwiY29uZmlybVwiID09IGcgJiYgKGcgPSBcIm9rXCIpLCBcImZhaWxlZFwiID09IGcgJiYgKGcgPSBcImZhaWxcIiksIC0xICE9IGcuaW5kZXhPZihcImZhaWxlZF9cIikgJiYgKGcgPSBnLnN1YnN0cmluZyg3KSksIC0xICE9IGcuaW5kZXhPZihcImZhaWxfXCIpICYmIChnID0gZy5zdWJzdHJpbmcoNSkpLCBnID0gZy5yZXBsYWNlKC9fL2csIFwiIFwiKSwgZyA9IGcudG9Mb3dlckNhc2UoKSwgKFwiYWNjZXNzIGRlbmllZFwiID09IGcgfHwgXCJubyBwZXJtaXNzaW9uIHRvIGV4ZWN1dGVcIiA9PSBnKSAmJiAoZyA9IFwicGVybWlzc2lvbiBkZW5pZWRcIiksIFwiY29uZmlnXCIgPT0gZSAmJiBcImZ1bmN0aW9uIG5vdCBleGlzdFwiID09IGcgJiYgKGcgPSBcIm9rXCIpLCBiID0gZSArIFwiOlwiICsgZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaShhKSB7XG4gICAgICAgIHZhciBiLCBjLCBkLCBlO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgZm9yIChiID0gMCwgYyA9IGEubGVuZ3RoOyBjID4gYjsgKytiKWQgPSBhW2JdLCBlID0gb1tkXSwgZSAmJiAoYVtiXSA9IGUpO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGooYSwgYikge1xuICAgICAgICBpZiAoISghei5kZWJ1ZyB8fCBiICYmIGIuaXNJbm5lckludm9rZSkpIHtcbiAgICAgICAgICAgIHZhciBjID0gcFthXTtcbiAgICAgICAgICAgIGMgJiYgKGEgPSBjKSwgYiAmJiBiLl9jb21wbGV0ZSAmJiBkZWxldGUgYi5fY29tcGxldGUsIGNvbnNvbGUubG9nKCdcIicgKyBhICsgJ1wiLCcsIGIgfHwgXCJcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGsoKSB7XG4gICAgICAgIGlmICghKFwiNi4wLjJcIiA+IHcgfHwgeS5zeXN0ZW1UeXBlIDwgMCkpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEltYWdlO1xuICAgICAgICAgICAgeS5hcHBJZCA9IHouYXBwSWQsIHkuaW5pdFRpbWUgPSB4LmluaXRFbmRUaW1lIC0geC5pbml0U3RhcnRUaW1lLCB5LnByZVZlcmlmeVRpbWUgPSB4LnByZVZlcmlmeUVuZFRpbWUgLSB4LnByZVZlcmlmeVN0YXJ0VGltZSwgQy5nZXROZXR3b3JrVHlwZSh7XG4gICAgICAgICAgICAgICAgaXNJbm5lckludm9rZTogITAsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeS5uZXR3b3JrVHlwZSA9IGEubmV0d29ya1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gXCJodHRwczovL29wZW4ud2VpeGluLnFxLmNvbS9zZGsvcmVwb3J0P3Y9XCIgKyB5LnZlcnNpb24gKyBcIiZvPVwiICsgeS5pc1ByZVZlcmlmeU9rICsgXCImcz1cIiArIHkuc3lzdGVtVHlwZSArIFwiJmM9XCIgKyB5LmNsaWVudFZlcnNpb24gKyBcIiZhPVwiICsgeS5hcHBJZCArIFwiJm49XCIgKyB5Lm5ldHdvcmtUeXBlICsgXCImaT1cIiArIHkuaW5pdFRpbWUgKyBcIiZwPVwiICsgeS5wcmVWZXJpZnlUaW1lICsgXCImdT1cIiArIHkudXJsO1xuICAgICAgICAgICAgICAgICAgICBiLnNyYyA9IGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbShiKSB7XG4gICAgICAgIHQgJiYgKGEuV2VpeGluSlNCcmlkZ2UgPyBiKCkgOiBxLmFkZEV2ZW50TGlzdGVuZXIgJiYgcS5hZGRFdmVudExpc3RlbmVyKFwiV2VpeGluSlNCcmlkZ2VSZWFkeVwiLCBiLCAhMSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgQy5pbnZva2UgfHwgKEMuaW52b2tlID0gZnVuY3Rpb24gKGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgJiYgV2VpeGluSlNCcmlkZ2UuaW52b2tlKGIsIGUoYyksIGQpXG4gICAgICAgIH0sIEMub24gPSBmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSAmJiBXZWl4aW5KU0JyaWRnZS5vbihiLCBjKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHZhciBvLCBwLCBxLCByLCBzLCB0LCB1LCB2LCB3LCB4LCB5LCB6LCBBLCBCLCBDO1xuICAgIGlmICghYS5qV2VpeGluKXJldHVybiBvID0ge1xuICAgICAgICBjb25maWc6IFwicHJlVmVyaWZ5SlNBUElcIixcbiAgICAgICAgb25NZW51U2hhcmVUaW1lbGluZTogXCJtZW51OnNoYXJlOnRpbWVsaW5lXCIsXG4gICAgICAgIG9uTWVudVNoYXJlQXBwTWVzc2FnZTogXCJtZW51OnNoYXJlOmFwcG1lc3NhZ2VcIixcbiAgICAgICAgb25NZW51U2hhcmVRUTogXCJtZW51OnNoYXJlOnFxXCIsXG4gICAgICAgIG9uTWVudVNoYXJlV2VpYm86IFwibWVudTpzaGFyZTp3ZWlib0FwcFwiLFxuICAgICAgICBvbk1lbnVTaGFyZVFab25lOiBcIm1lbnU6c2hhcmU6UVpvbmVcIixcbiAgICAgICAgcHJldmlld0ltYWdlOiBcImltYWdlUHJldmlld1wiLFxuICAgICAgICBnZXRMb2NhdGlvbjogXCJnZW9Mb2NhdGlvblwiLFxuICAgICAgICBvcGVuUHJvZHVjdFNwZWNpZmljVmlldzogXCJvcGVuUHJvZHVjdFZpZXdXaXRoUGlkXCIsXG4gICAgICAgIGFkZENhcmQ6IFwiYmF0Y2hBZGRDYXJkXCIsXG4gICAgICAgIG9wZW5DYXJkOiBcImJhdGNoVmlld0NhcmRcIixcbiAgICAgICAgY2hvb3NlV1hQYXk6IFwiZ2V0QnJhbmRXQ1BheVJlcXVlc3RcIlxuICAgIH0sIHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiLCBhID0ge307XG4gICAgICAgIGZvciAoYiBpbiBvKWFbb1tiXV0gPSBiO1xuICAgICAgICByZXR1cm4gYVxuICAgIH0oKSwgcSA9IGEuZG9jdW1lbnQsXG4gICAgICAgIHIgPSBxLnRpdGxlLFxuICAgICAgICBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLCB0ID0gLTEgIT0gcy5pbmRleE9mKFwibWljcm9tZXNzZW5nZXJcIiksIHUgPSAtMSAhPSBzLmluZGV4T2YoXCJhbmRyb2lkXCIpLCB2ID0gLTEgIT0gcy5pbmRleE9mKFwiaXBob25lXCIpIHx8IC0xICE9IHMuaW5kZXhPZihcImlwYWRcIiksIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gcy5tYXRjaCgvbWljcm9tZXNzZW5nZXJcXC8oXFxkK1xcLlxcZCtcXC5cXGQrKS8pIHx8IHMubWF0Y2goL21pY3JvbWVzc2VuZ2VyXFwvKFxcZCtcXC5cXGQrKS8pO1xuICAgICAgICByZXR1cm4gYSA/IGFbMV0gOiBcIlwiXG4gICAgfSgpLCB4ID0ge2luaXRTdGFydFRpbWU6IGwoKSwgaW5pdEVuZFRpbWU6IDAsIHByZVZlcmlmeVN0YXJ0VGltZTogMCwgcHJlVmVyaWZ5RW5kVGltZTogMH0sIHkgPSB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIGFwcElkOiBcIlwiLFxuICAgICAgICBpbml0VGltZTogMCxcbiAgICAgICAgcHJlVmVyaWZ5VGltZTogMCxcbiAgICAgICAgbmV0d29ya1R5cGU6IFwiXCIsXG4gICAgICAgIGlzUHJlVmVyaWZ5T2s6IDEsXG4gICAgICAgIHN5c3RlbVR5cGU6IHYgPyAxIDogdSA/IDIgOiAtMSxcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdyxcbiAgICAgICAgdXJsOiBlbmNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaHJlZilcbiAgICB9LCB6ID0ge30sIEEgPSB7X2NvbXBsZXRlczogW119LCBCID0ge3N0YXRlOiAwLCByZXM6IHt9fSwgbShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHguaW5pdEVuZFRpbWUgPSBsKClcbiAgICB9KSwgQyA9IHtcbiAgICAgICAgY29uZmlnOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgeiA9IGEsIGooXCJjb25maWdcIiwgYSk7XG4gICAgICAgICAgICB2YXIgYiA9IHouY2hlY2sgPT09ICExID8gITEgOiAhMDtcbiAgICAgICAgICAgIG0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBkLCBlO1xuICAgICAgICAgICAgICAgIGlmIChiKWMoby5jb25maWcsIHt2ZXJpZnlKc0FwaUxpc3Q6IGkoei5qc0FwaUxpc3QpfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LnByZVZlcmlmeUVuZFRpbWUgPSBsKCksIEIuc3RhdGUgPSAxLCBCLnJlcyA9IGFcbiAgICAgICAgICAgICAgICAgICAgfSwgQS5zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeS5pc1ByZVZlcmlmeU9rID0gMFxuICAgICAgICAgICAgICAgICAgICB9LCBBLmZhaWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQS5fZmFpbCA/IEEuX2ZhaWwoYSkgOiBCLnN0YXRlID0gLTFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBBLl9jb21wbGV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgei5kZWJ1ZyB8fCBrKClcbiAgICAgICAgICAgICAgICAgICAgfSksIEEuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBkID4gYzsgKytjKWFbY10oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEEuX2NvbXBsZXRlcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIEFcbiAgICAgICAgICAgICAgICB9KCkpLCB4LnByZVZlcmlmeVN0YXJ0VGltZSA9IGwoKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoQi5zdGF0ZSA9IDEsIGEgPSBBLl9jb21wbGV0ZXMsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGUgPiBkOyArK2QpYVtkXSgpO1xuICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZXMgPSBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB6LmJldGEgJiYgbigpXG4gICAgICAgIH0sIHJlYWR5OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgMCAhPSBCLnN0YXRlID8gYSgpIDogKEEuX2NvbXBsZXRlcy5wdXNoKGEpLCAhdCAmJiB6LmRlYnVnICYmIGEoKSlcbiAgICAgICAgfSwgZXJyb3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBcIjYuMC4yXCIgPiB3IHx8ICgtMSA9PSBCLnN0YXRlID8gYShCLnJlcykgOiBBLl9mYWlsID0gYSlcbiAgICAgICAgfSwgY2hlY2tKc0FwaTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgZCwgYiA9IGEuY2hlY2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgZm9yIChjIGluIGIpZCA9IHBbY10sIGQgJiYgKGJbZF0gPSBiW2NdLCBkZWxldGUgYltjXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjKFwiY2hlY2tKc0FwaVwiLCB7anNBcGlMaXN0OiBpKGEuanNBcGlMaXN0KX0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBhLmNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYyAmJiAoYS5jaGVja1Jlc3VsdCA9IEpTT04ucGFyc2UoYykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9IGIoYSlcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlVGltZWxpbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVUaW1lbGluZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVRpbWVsaW5lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZUFwcE1lc3NhZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVBcHBNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYyhcInNlbmRBcHBNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IGEubGluayB8fCBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nX3VybDogYS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGEudHlwZSB8fCBcImxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdXJsOiBhLmRhdGFVcmwgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlUVE6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVRUSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVFRXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlV2VpYm86IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVXZWlibywge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVdlaWJvQXBwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlUVpvbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVRWm9uZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVFab25lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIHN0YXJ0UmVjb3JkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInN0YXJ0UmVjb3JkXCIsIHt9LCBhKVxuICAgICAgICB9LCBzdG9wUmVjb3JkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInN0b3BSZWNvcmRcIiwge30sIGEpXG4gICAgICAgIH0sIG9uVm9pY2VSZWNvcmRFbmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKFwib25Wb2ljZVJlY29yZEVuZFwiLCBhKVxuICAgICAgICB9LCBwbGF5Vm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwicGxheVZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBwYXVzZVZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInBhdXNlVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZH0sIGEpXG4gICAgICAgIH0sIHN0b3BWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdG9wVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZH0sIGEpXG4gICAgICAgIH0sIG9uVm9pY2VQbGF5RW5kOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChcIm9uVm9pY2VQbGF5RW5kXCIsIGEpXG4gICAgICAgIH0sIHVwbG9hZFZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInVwbG9hZFZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZG93bmxvYWRWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJkb3dubG9hZFZvaWNlXCIsIHtzZXJ2ZXJJZDogYS5zZXJ2ZXJJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCB0cmFuc2xhdGVWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ0cmFuc2xhdGVWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGNob29zZUltYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImNob29zZUltYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBzY2VuZTogXCIxfDJcIixcbiAgICAgICAgICAgICAgICBjb3VudDogYS5jb3VudCB8fCA5LFxuICAgICAgICAgICAgICAgIHNpemVUeXBlOiBhLnNpemVUeXBlIHx8IFtcIm9yaWdpbmFsXCIsIFwiY29tcHJlc3NlZFwiXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiBhLnNvdXJjZVR5cGUgfHwgW1wiYWxidW1cIiwgXCJjYW1lcmFcIl1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBhLmxvY2FsSWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiAmJiAoYS5sb2NhbElkcyA9IEpTT04ucGFyc2UoYikpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIHByZXZpZXdJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoby5wcmV2aWV3SW1hZ2UsIHtjdXJyZW50OiBhLmN1cnJlbnQsIHVybHM6IGEudXJsc30sIGEpXG4gICAgICAgIH0sIHVwbG9hZEltYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInVwbG9hZEltYWdlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZG93bmxvYWRJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJkb3dubG9hZEltYWdlXCIsIHtzZXJ2ZXJJZDogYS5zZXJ2ZXJJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCBnZXROZXR3b3JrVHlwZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgZCwgZSwgYiA9IGEuZXJyTXNnO1xuICAgICAgICAgICAgICAgIGlmIChhLmVyck1zZyA9IFwiZ2V0TmV0d29ya1R5cGU6b2tcIiwgYyA9IGEuc3VidHlwZSwgZGVsZXRlIGEuc3VidHlwZSwgYylhLm5ldHdvcmtUeXBlID0gYzsgZWxzZSBzd2l0Y2ggKGQgPSBiLmluZGV4T2YoXCI6XCIpLCBlID0gYi5zdWJzdHJpbmcoZCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VcIndpZmlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZVwiZWRnZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlXCJ3d2FuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhLm5ldHdvcmtUeXBlID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5lcnJNc2cgPSBcImdldE5ldHdvcmtUeXBlOmZhaWxcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGMoXCJnZXROZXR3b3JrVHlwZVwiLCB7fSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiKGEpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvcGVuTG9jYXRpb246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwib3BlbkxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogYS5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGEubG9uZ2l0dWRlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGEubmFtZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBhLnNjYWxlIHx8IDI4LFxuICAgICAgICAgICAgICAgIGluZm9Vcmw6IGEuaW5mb1VybCB8fCBcIlwiXG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBnZXRMb2NhdGlvbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IHt9LCBjKG8uZ2V0TG9jYXRpb24sIHt0eXBlOiBhLnR5cGUgfHwgXCJ3Z3M4NFwifSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhLnR5cGVcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIGhpZGVPcHRpb25NZW51OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImhpZGVPcHRpb25NZW51XCIsIHt9LCBhKVxuICAgICAgICB9LCBzaG93T3B0aW9uTWVudTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93T3B0aW9uTWVudVwiLCB7fSwgYSlcbiAgICAgICAgfSwgY2xvc2VXaW5kb3c6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhcImNsb3NlV2luZG93XCIsIHtpbW1lZGlhdGVfY2xvc2U6IGEuaW1tZWRpYXRlQ2xvc2UgfHwgMH0sIGEpXG4gICAgICAgIH0sIGhpZGVNZW51SXRlbXM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiaGlkZU1lbnVJdGVtc1wiLCB7bWVudUxpc3Q6IGEubWVudUxpc3R9LCBhKVxuICAgICAgICB9LCBzaG93TWVudUl0ZW1zOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInNob3dNZW51SXRlbXNcIiwge21lbnVMaXN0OiBhLm1lbnVMaXN0fSwgYSlcbiAgICAgICAgfSwgaGlkZUFsbE5vbkJhc2VNZW51SXRlbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJoaWRlQWxsTm9uQmFzZU1lbnVJdGVtXCIsIHt9LCBhKVxuICAgICAgICB9LCBzaG93QWxsTm9uQmFzZU1lbnVJdGVtOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInNob3dBbGxOb25CYXNlTWVudUl0ZW1cIiwge30sIGEpXG4gICAgICAgIH0sIHNjYW5RUkNvZGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhcInNjYW5RUkNvZGVcIiwge1xuICAgICAgICAgICAgICAgIG5lZWRSZXN1bHQ6IGEubmVlZFJlc3VsdCB8fCAwLFxuICAgICAgICAgICAgICAgIHNjYW5UeXBlOiBhLnNjYW5UeXBlIHx8IFtcInFyQ29kZVwiLCBcImJhckNvZGVcIl1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYztcbiAgICAgICAgICAgICAgICAgICAgdiAmJiAoYiA9IGEucmVzdWx0U3RyLCBiICYmIChjID0gSlNPTi5wYXJzZShiKSwgYS5yZXN1bHRTdHIgPSBjICYmIGMuc2Nhbl9jb2RlICYmIGMuc2Nhbl9jb2RlLnNjYW5fcmVzdWx0KSlcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhvLm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3LCB7cGlkOiBhLnByb2R1Y3RJZCwgdmlld190eXBlOiBhLnZpZXdUeXBlIHx8IDB9LCBhKVxuICAgICAgICB9LCBhZGRDYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIGIgPSBhLmNhcmRMaXN0LCBkID0gW107XG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBmID0gYi5sZW5ndGg7IGYgPiBlOyArK2UpZyA9IGJbZV0sIGggPSB7Y2FyZF9pZDogZy5jYXJkSWQsIGNhcmRfZXh0OiBnLmNhcmRFeHR9LCBkLnB1c2goaCk7XG4gICAgICAgICAgICBjKG8uYWRkQ2FyZCwge2NhcmRfbGlzdDogZH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYywgZCwgZSwgYiA9IGEuY2FyZF9saXN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChiID0gSlNPTi5wYXJzZShiKSwgYyA9IDAsIGQgPSBiLmxlbmd0aDsgZCA+IGM7ICsrYyllID0gYltjXSwgZS5jYXJkSWQgPSBlLmNhcmRfaWQsIGUuY2FyZEV4dCA9IGUuY2FyZF9leHQsIGUuaXNTdWNjZXNzID0gZS5pc19zdWNjID8gITAgOiAhMSwgZGVsZXRlIGUuY2FyZF9pZCwgZGVsZXRlIGUuY2FyZF9leHQsIGRlbGV0ZSBlLmlzX3N1Y2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmNhcmRMaXN0ID0gYiwgZGVsZXRlIGEuY2FyZF9saXN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIGNob29zZUNhcmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiY2hvb3NlQ2FyZFwiLCB7XG4gICAgICAgICAgICAgICAgYXBwX2lkOiB6LmFwcElkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uX2lkOiBhLnNob3BJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHNpZ25fdHlwZTogYS5zaWduVHlwZSB8fCBcIlNIQTFcIixcbiAgICAgICAgICAgICAgICBjYXJkX2lkOiBhLmNhcmRJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNhcmRfdHlwZTogYS5jYXJkVHlwZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNhcmRfc2lnbjogYS5jYXJkU2lnbixcbiAgICAgICAgICAgICAgICB0aW1lX3N0YW1wOiBhLnRpbWVzdGFtcCArIFwiXCIsXG4gICAgICAgICAgICAgICAgbm9uY2Vfc3RyOiBhLm5vbmNlU3RyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5jYXJkTGlzdCA9IGEuY2hvb3NlX2NhcmRfaW5mbywgZGVsZXRlIGEuY2hvb3NlX2NhcmRfaW5mb1xuICAgICAgICAgICAgICAgIH0sIGFcbiAgICAgICAgICAgIH0oKSlcbiAgICAgICAgfSwgb3BlbkNhcmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgZSwgZiwgZywgaCwgYiA9IGEuY2FyZExpc3QsIGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGYgPSBiLmxlbmd0aDsgZiA+IGU7ICsrZSlnID0gYltlXSwgaCA9IHtjYXJkX2lkOiBnLmNhcmRJZCwgY29kZTogZy5jb2RlfSwgZC5wdXNoKGgpO1xuICAgICAgICAgICAgYyhvLm9wZW5DYXJkLCB7Y2FyZF9saXN0OiBkfSwgYSlcbiAgICAgICAgfSwgY2hvb3NlV1hQYXk6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKG8uY2hvb3NlV1hQYXksIGYoYSksIGEpXG4gICAgICAgIH1cbiAgICB9LCBiICYmIChhLnd4ID0gYS5qV2VpeGluID0gQyksIENcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==