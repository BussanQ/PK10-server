/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _App = __webpack_require__(4);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _weixinJsSdk = __webpack_require__(170);
	
	var _weixinJsSdk2 = _interopRequireDefault(_weixinJsSdk);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	_vue2.default.filter('time', function (value) {
	    var hour = Math.floor(value / 3600);
	    var min = Math.floor(value % 3600 / 60);
	    if (hour < 10) {
	        hour = '0' + hour;
	    }
	    if (min < 10) {
	        min = '0' + min;
	    }
	    var sec = value % 60;
	    if (sec < 10) {
	        sec = '0' + sec;
	    }
	    return (hour > 0 ? hour + ':' : '') + min + ':' + sec;
	});
	_vue2.default.filter('datetime', function (value) {
	    return new Date(value).toLocaleString();
	});
	var config = {};
	_requestList2.default.getMainConfig().then(function (res) {
	    config = res.data;
	    console.log(config);
	}, function (res) {
	    console.error(res);
	});
	
	var main = new _vue2.default({
	    el: 'body',
	    components: { app: _App2.default }
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, jQuery) {/*!
	 * Vue.js v1.0.26
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && UA.indexOf('trident') > 0;
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var iosVersionMatch = isIos && UA.match(/os ([\d_]+)/);
	var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');
	
	// detecting iOS UIWebView by indexedDB
	var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    if (this.size === this.limit) {
	      removed = this.shift();
	    }
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        // Firefox returns unknown for some "Interactive elements."
	        !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;
	      parent = mergeOptions(parent, mixinOptions, vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE: isIE,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		iosVersionMatch: iosVersionMatch,
		iosVersion: iosVersion,
		hasMutationObserverBug: hasMutationObserverBug,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;
	
	function noop() {}
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here because the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');
	      } else {
	        warn('Invalid expression. ' + 'Generated function body: ' + body);
	      }
	    }
	    return noop;
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat literal values as paths
	  !literalValueRE$1.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if ((isA || isO) && Object.isExtensible(val)) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	var commentRE = /<!--/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	  var commentMatch = commentRE.test(templateString);
	
	  if (!tagMatch && !entityMatch && !commentMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * watcher's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    // #3029 only update when the value changes. This prevent
	    // browsers from overwriting values like selectionStart
	    value = _toString(value);
	    if (value !== this.el.value) this.el.value = value;
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var _this = this;
	
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', function () {
	      nextTick(_this.forceUpdate);
	    });
	    if (!inDoc(el)) {
	      nextTick(this.forceUpdate);
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value, vm);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value, vm) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  if (typeof coerce === 'function') {
	    return coerce(value);
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid coerce for prop "' + prop.name + '": expected function, got ' + typeof coerce + '.', vm);
	    return value;
	  }
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    oldId = oldId || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    removeClass(el, oldId + '-transition');
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = _toString(value);
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop$1() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop$1;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    var length = args.length;
	    if (length > 1) {
	      var index = value % 10 - 1;
	      return index in args ? args[index] : args[length - 1];
	    } else {
	      return args[0] + (value === 1 ? '' : 's');
	    }
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          if (!definition.name) {
	            definition.name = id;
	          }
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.26';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2), __webpack_require__(3)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable no-unused-vars*/
	/*!
	 * jQuery JavaScript Library v3.1.0
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-07-07T21:44Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.0",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.0
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-01-04
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true;
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
		// Known :disabled false positives:
		// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
		// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Check form elements and option elements for explicit disabling
			return "label" in elem && elem.disabled === disabled ||
				"form" in elem && elem.disabled === disabled ||
	
				// Check non-disabled form elements for fieldset[disabled] ancestors
				"form" in elem && elem.disabled === false && (
					// Support: IE6-11+
					// Ancestry is covered for us
					elem.isDisabled === disabled ||
	
					// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						("label" in elem || !disabledAncestor( elem )) !== disabled
				);
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnotwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? JSON.parse( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) ),
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support: IE <=9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox <=42
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			opt.duration = typeof opt.duration === "number" ?
				opt.duration : opt.duration in jQuery.fx.speeds ?
					jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in uncached url if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rts, "" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	return jQuery;
	} );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(5)
	__vue_script__ = __webpack_require__(9)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\App.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(169)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0692510b/App.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue", function() {
				var newContent = require("!!./../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n", "", {"version":3,"sources":["/./src/App.vue?471db99e"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgJA;IACA,UAAA;CACA;;AAEA;;IAEA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oCAAA;IACA,SAAA;IACA,QAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;CACA","file":"App.vue","sourcesContent":["<template lang=\"pug\">\n        background\n        menu-bar(v-bind:game-data=\"gameData\",v-bind:notice=\"notice\",v-bind:zoom-rate=\"zoomRate\")\n        bet-and-bonus(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        play-panel(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:lockmoney=\"lockmoney\",v-bind:error.sync=\"error\",v-bind:lotterynum.sync=\"lotterynum\",v-bind:count-down.sync=\"countDown\",v-bind:count-num.sync=\"countNum\")\n        state(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:user-bet=\"userBet\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        //- bet-multiple\n        message(v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\",v-bind:bets.sync=\"bets\",v-bind:error.sync=\"error\")\n        modal.modal(v-if=\"error\")\n        tip-modal\n</template>\n<script>\nimport Background from './components/Background.vue'\nimport MenuBar from './components/MenuBar.vue'\nimport BetAndBonus from './components/BetAndBonus.vue'\nimport PlayPanel from './components/PlayPanel.vue'\nimport State from './components/State.vue'\nimport BetMultiple from './components/BetMultiple.vue'\nimport Message from './components/Message.vue'\nimport gameData from './data/data' //  加载模板数据\nimport RequestList from './js/request-list'\nexport default {\n    props: [],\n    ready() {\n        let that = this\n        window.onresize = function() {\n            that.screenSize.width = window.innerWidth\n            that.screenSize.height = window.innerHeight\n        }\n        this.init()\n    },\n    data() {\n        return {\n            userBet: {\n                betmoney: 1000 //默认下注金额为1000\n            },\n            gameData: gameData,\n            lotterynum: { //开奖结果\n                id: '',\n                createdAt: 0,\n                lotterynums: ''\n            },\n            countDown: 300, // 倒计时秒数\n            countNum: 300, //开奖时间间隔 默认3分钟\n            error: false,\n            bets: [], // 下注集合，可以单次下多注\n            notice: require('./data/notice'),\n            userinfo: require('./data/singleuser'),\n            stageSize: { // 整体画布大小,所有变化组件再次基础上乘以放大倍率\n                width: 640,\n                height: 1008\n            },\n            screenSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            }\n        }\n    },\n    methods: {\n        init() {\n            // 初始化读取数据\n\n            // 读取开奖数据\n            RequestList.getBonusNum().then(res => this.lotterynum = res.data)\n            this.getUserInfoByNet()\n                // 获取公告数据\n            this.$emit('getLastNotice')\n        },\n        show() {},\n        getUserInfoByNet() { //从网络获取user信息\n            var that = this\n            RequestList.getuserCodeFromNet(RequestList.getCode()).then(res => {\n                // 获取用户数据\n                that.userinfo = Object.assign({}, that.userinfo, res.data)\n                that.$emit('getUserInfo')\n            }, res => console.error(res.data))\n        }\n    },\n    computed: {\n        zoomRate() { // 初始化放大倍率\n            let x = this.screenSize.width / this.stageSize.width\n            let y = this.screenSize.height / this.stageSize.height\n            return {\n                x: x,\n                y: y\n            }\n        },\n        lockmoney() { //锁定金额\n            let result = 0\n            for (let i = 0; i < this.bets.length; i++) {\n                result += this.bets[i].betmoney\n            }\n            return result\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.$broadcast('showMessage', event)\n        },\n        getUserInfo(event) {\n            var that = this\n            RequestList.getuserinfo(JSON.parse(JSON.stringify(this.userinfo))).then((res) => {\n                if (Object.prototype.toString.call(res.data) === '[object Object]') {\n                    that.userinfo = Object.assign({}, that.userinfo, res.data)\n                    that.userBet.userinfoOpenid = res.data.openid\n                } else {}\n                return\n            }, (res) => {\n                console.error(res)\n            })\n        },\n        getLastNotice(event) {\n            RequestList.getLastNotice().then(res => this.notice = res.data, res => console.error(res))\n        },\n        cancelbet(event) {\n            this.$broadcast('cancelBet')\n        },\n        reloadinfo(event) {\n            this.init()\n        },\n        // 触发错误，并打开遮罩层\n        error() {\n            this.error = true\n        },\n        showTip(event) {\n            this.$broadcast('showTip', event)\n        }\n    },\n    components: {\n        'modal': {\n            template: '<div class=\"modal\"></div>'\n        },\n        'tip-modal': require('./components/tip-modal.vue'),\n        'background': Background,\n        'menu-bar': MenuBar,\n        'bet-and-bonus': BetAndBonus,\n        'play-panel': PlayPanel,\n        'state': State,\n        'bet-multiple': BetMultiple,\n        'message': Message\n    }\n}\n</script>\n<style>\nbody {\n    margin: 0;\n}\n\nhtml,\nbody {\n    height: 100%;\n}\n\n.table {\n    display: table;\n}\n\ndiv.modal {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, .6);\n    top: 0px;\n    left: 0;\n    z-index: 999;\n}\n\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 7 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if (media) {
			styleElement.setAttribute("media", media);
		}
	
		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _Background = __webpack_require__(49);
	
	var _Background2 = _interopRequireDefault(_Background);
	
	var _MenuBar = __webpack_require__(55);
	
	var _MenuBar2 = _interopRequireDefault(_MenuBar);
	
	var _BetAndBonus = __webpack_require__(67);
	
	var _BetAndBonus2 = _interopRequireDefault(_BetAndBonus);
	
	var _PlayPanel = __webpack_require__(77);
	
	var _PlayPanel2 = _interopRequireDefault(_PlayPanel);
	
	var _State = __webpack_require__(85);
	
	var _State2 = _interopRequireDefault(_State);
	
	var _BetMultiple = __webpack_require__(94);
	
	var _BetMultiple2 = _interopRequireDefault(_BetMultiple);
	
	var _Message = __webpack_require__(99);
	
	var _Message2 = _interopRequireDefault(_Message);
	
	var _data = __webpack_require__(161);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: [],
	    ready: function ready() {
	        var that = this;
	        window.onresize = function () {
	            that.screenSize.width = window.innerWidth;
	            that.screenSize.height = window.innerHeight;
	        };
	        this.init();
	    },
	    data: function data() {
	        return {
	            userBet: {
	                betmoney: 1000 },
	            gameData: _data2.default,
	            lotterynum: {
	                id: '',
	                createdAt: 0,
	                lotterynums: ''
	            },
	            countDown: 300,
	            countNum: 300,
	            error: false,
	            bets: [],
	            notice: __webpack_require__(162),
	            userinfo: __webpack_require__(163),
	            stageSize: {
	                width: 640,
	                height: 1008
	            },
	            screenSize: {
	                width: window.innerWidth,
	                height: window.innerHeight
	            }
	        };
	    },
	
	    methods: {
	        init: function init() {
	            var _this = this;
	
	            _requestList2.default.getBonusNum().then(function (res) {
	                return _this.lotterynum = res.data;
	            });
	            this.getUserInfoByNet();
	
	            this.$emit('getLastNotice');
	        },
	        show: function show() {},
	        getUserInfoByNet: function getUserInfoByNet() {
	            var that = this;
	            _requestList2.default.getuserCodeFromNet(_requestList2.default.getCode()).then(function (res) {
	                that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                that.$emit('getUserInfo');
	            }, function (res) {
	                return console.error(res.data);
	            });
	        }
	    },
	    computed: {
	        zoomRate: function zoomRate() {
	            var x = this.screenSize.width / this.stageSize.width;
	            var y = this.screenSize.height / this.stageSize.height;
	            return {
	                x: x,
	                y: y
	            };
	        },
	        lockmoney: function lockmoney() {
	            var result = 0;
	            for (var i = 0; i < this.bets.length; i++) {
	                result += this.bets[i].betmoney;
	            }
	            return result;
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.$broadcast('showMessage', event);
	        },
	        getUserInfo: function getUserInfo(event) {
	            var that = this;
	            _requestList2.default.getuserinfo(JSON.parse((0, _stringify2.default)(this.userinfo))).then(function (res) {
	                if (Object.prototype.toString.call(res.data) === '[object Object]') {
	                    that.userinfo = (0, _assign2.default)({}, that.userinfo, res.data);
	                    that.userBet.userinfoOpenid = res.data.openid;
	                } else {}
	                return;
	            }, function (res) {
	                console.error(res);
	            });
	        },
	        getLastNotice: function getLastNotice(event) {
	            var _this2 = this;
	
	            _requestList2.default.getLastNotice().then(function (res) {
	                return _this2.notice = res.data;
	            }, function (res) {
	                return console.error(res);
	            });
	        },
	        cancelbet: function cancelbet(event) {
	            this.$broadcast('cancelBet');
	        },
	        reloadinfo: function reloadinfo(event) {
	            this.init();
	        },
	        error: function error() {
	            this.error = true;
	        },
	        showTip: function showTip(event) {
	            this.$broadcast('showTip', event);
	        }
	    },
	    components: {
	        'modal': {
	            template: '<div class="modal"></div>'
	        },
	        'tip-modal': __webpack_require__(164),
	        'background': _Background2.default,
	        'menu-bar': _MenuBar2.default,
	        'bet-and-bonus': _BetAndBonus2.default,
	        'play-panel': _PlayPanel2.default,
	        'state': _State2.default,
	        'bet-multiple': _BetMultiple2.default,
	        'message': _Message2.default
	    }
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(11), __esModule: true };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(12)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(14), __esModule: true };

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(15);
	module.exports = __webpack_require__(12).Object.assign;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(16);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(30)});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(17)
	  , core      = __webpack_require__(12)
	  , ctx       = __webpack_require__(18)
	  , hide      = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 17 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(19);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(21)
	  , createDesc = __webpack_require__(29);
	module.exports = __webpack_require__(25) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(22)
	  , IE8_DOM_DEFINE = __webpack_require__(24)
	  , toPrimitive    = __webpack_require__(28)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(25) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(25) && !__webpack_require__(26)(function(){
	  return Object.defineProperty(__webpack_require__(27)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(26)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(23)
	  , document = __webpack_require__(17).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(23);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(31)
	  , gOPS     = __webpack_require__(46)
	  , pIE      = __webpack_require__(47)
	  , toObject = __webpack_require__(48)
	  , IObject  = __webpack_require__(35)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(26)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(45);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(33)
	  , toIObject    = __webpack_require__(34)
	  , arrayIndexOf = __webpack_require__(38)(false)
	  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(35)
	  , defined = __webpack_require__(37);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(36);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(34)
	  , toLength  = __webpack_require__(39)
	  , toIndex   = __webpack_require__(41);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(40)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(43)('keys')
	  , uid    = __webpack_require__(44);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(17)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 46 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 47 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(37);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(50)
	__vue_template__ = __webpack_require__(54)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7658d6de/Background.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(51);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Background.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(" + __webpack_require__(52) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(" + __webpack_require__(53) + ");\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/Background.vue?b29085ae"],"names":[],"mappings":";;;;;;AAMA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,YAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,iDAAA;IACA,0CAAA;IACA,uBAAA;IACA,6BAAA;CACA;;AAEA;IACA,uBAAA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,sBAAA;IACA,uBAAA;IACA,6BAAA;CACA","file":"Background.vue","sourcesContent":["<template lang=\"pug\">\n    div.background\n    \tdiv.up-background\n    \tdiv.buttom-background\n</template>\n<style>\n.background {\n    position: absolute;\n    z-index: -1;\n    height: 100%;\n    width: 100%;\n    background: url(../assets/切图/主界面/BG.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.up-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 89%;\n    width: 100%;\n    border-bottom: 2px rgba(255, 255, 255, .3) solid;\n    background: url(../assets/切图/主界面/dock.png);\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n\ndiv.buttom-background {\n    /*position: absolute;*/\n    z-index: -1;\n    height: 11%;\n    width: 100%;\n    /*background: white;*/\n    background-size: cover;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4b4a6609b989655a4d67f245bd57e41d.png";

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABlCAIAAAADEh6SAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5RjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDlBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlGQzJEOTlEM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yDa1IwAAABxJREFUeNpisArsZGJgYGB+//EbiB7FA48BAgwAr7gEtOjH9QQAAAAASUVORK5CYII="

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "<div class=\"background\"><div class=\"up-background\"></div><div class=\"buttom-background\"></div></div>";

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(56)
	__vue_script__ = __webpack_require__(59)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\MenuBar.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(66)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-a5fa5098/MenuBar.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./MenuBar.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(" + __webpack_require__(58) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/MenuBar.vue?542b96fa"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;IACA,mBAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,qBAAA;IACA,oBAAA;IACA,eAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;IACA,aAAA;IACA,sBAAA;IACA,aAAA;IACA;2BACA;IACA,wBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"MenuBar.vue","sourcesContent":["<template lang=\"pug\">\n    //-菜单部分\n    div.menu\n        div.notice\n            table\n                tr\n                    td\n                        span(v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\",v-html='notice.title')\n        div.option(@touchend=\"triggerOption\")\n        options-dialog(v-bind:game-data=\"gameData\",v-bind:zoom-rate=\"zoomRate\")\n</template>\n<script>\nimport OptionsDialog from './OptionsDialog.vue'\nexport default {\n    props: ['gameData', 'zoomRate', 'notice'],\n    ready() {\n        console.log(this.gameData.notice)\n    },\n    data() {\n        return {\n            name: 'liu',\n            isShowOption: false\n        }\n    },\n    methods: {\n        triggerOption() {\n            this.$broadcast('triggerOption')\n        }\n    },\n    components: {\n        'options-dialog': OptionsDialog\n    }\n}\n</script>\n<style>\n.menu {\n    position: relative;\n    height: 5%;\n    padding: 1% 3% 1% 1%;\n    background: #e14f50;\n    z-index: 1;\n}\n\ndiv.notice {\n    height: 100%;\n    width: 60%;\n    border-radius: 1.5em;\n    background: #eebebe;\n    color: #783a3f;\n    float: left;\n    text-align: center;\n}\n\ndiv.option {\n    width: 12%;\n    height: 100%;\n    /*background: black;*/\n    float: right;\n    /* border:.15em solid #fcd19e;\n    border-radius: 0.5em;*/\n    /*background: #ff9e40;*/\n    background: url(../assets/切图/主界面/菜单.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA0CAYAAAA5bTAhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUI5QzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUI5RDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcwMzg1MUZGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjcwMzg1MjAwM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+mrp5MgAABkJJREFU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"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _OptionsDialog = __webpack_require__(60);
	
	var _OptionsDialog2 = _interopRequireDefault(_OptionsDialog);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['gameData', 'zoomRate', 'notice'],
	    ready: function ready() {
	        console.log(this.gameData.notice);
	    },
	    data: function data() {
	        return {
	            name: 'liu',
	            isShowOption: false
	        };
	    },
	
	    methods: {
	        triggerOption: function triggerOption() {
	            this.$broadcast('triggerOption');
	        }
	    },
	    components: {
	        'options-dialog': _OptionsDialog2.default
	    }
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(61)
	__vue_script__ = __webpack_require__(63)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\OptionsDialog.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(65)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-3d271406/OptionsDialog.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./OptionsDialog.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/* 必需 */\n\n.expand-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter 定义进入的开始状态 */\n\n\n/* .expand-leave 定义离开的结束状态 */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n", "", {"version":3,"sources":["/./src/components/OptionsDialog.vue?53ddea8e"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,iBAAA;IACA,iBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;;AAGA,QAAA;;AAEA;IACA,iCAAA;IAAA,yBAAA;IACA,iBAAA;IACA,kBAAA;IACA,2BAAA;IACA,iBAAA;CACA;;;AAGA,6BAAA;;;AAGA,6BAAA;;AAEA;;IAEA,UAAA;IACA,oBAAA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,WAAA;IACA,oBAAA;IACA,6BAAA;IACA,mBAAA;IACA,mBAAA;IACA,yEAAA;CACA;;AAEA;IACA,eAAA;IACA,gBAAA;IACA,oBAAA;IACA,mBAAA;IACA,oBAAA;IACA,4BAAA;CACA;;AAEA;IACA,cAAA;IACA,mCAAA;CACA","file":"OptionsDialog.vue","sourcesContent":["<template lang=\"pug\">\n    //- 右上侧选项列表\n    div.option-list(v-show=\"isOptionShow\",transition=\"expand\",v-bind:style=\"optionStyle\")\n        //- img(v-bind:src=\"menuImg\")\n        div.pointer\n        div.inner-pointer\n        div.option-item(v-html=\"n\",v-for=\"n in gameData.options\",@touchend=\"showMessage($index)\",v-bind:style=\"itemStyle\")\n</template>\n<script>\nexport default {\n    ready() {\n            console.log(this.gameData)\n        },\n        props: ['gameData', 'zoomRate'],\n        data() {\n            return {\n                isOptionShow: false,\n                menuImg: require('../assets/切图/主界面/菜单展开.png')\n            }\n        },\n        computed: {\n            optionStyle() {\n                return {\n                    borderRadius: 12 * this.zoomRate.x + 'px'\n                }\n            },\n            itemStyle() {\n                return {\n                    fontSize: 26 * this.zoomRate.x + 'px'\n                }\n            }\n        },\n        methods: {\n            showMessage(event) {\n                this.isOptionShow = false\n                this.$dispatch('showMessage', event)\n            }\n        },\n        events: {\n            triggerOption() {\n                this.isOptionShow = !this.isOptionShow\n            }\n        }\n}\n</script>\n<style>\ndiv.pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: 20%;\n    margin-top: -1em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #fed095 rgba(0, 0, 0, 0);\n}\n\n\n/* 必需 */\n\n.expand-transition {\n    transition: all .3s ease;\n    /*height: 30px;*/\n    /*padding: 10px;*/\n    /*background-color: #eee;*/\n    overflow: hidden;\n}\n\n\n/* .expand-enter 定义进入的开始状态 */\n\n\n/* .expand-leave 定义离开的结束状态 */\n\n.expand-enter,\n.expand-leave {\n    height: 0;\n    /*padding: 0 10px;*/\n    opacity: 0;\n}\n\ndiv.inner-pointer {\n    height: 0px;\n    width: 0px;\n    border: 0.5em solid;\n    margin-left: calc(20% + 0em);\n    margin-top: -0.9em;\n    position: absolute;\n    border-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0) #ffa956 rgba(0, 0, 0, 0);\n}\n\ndiv.option-list {\n    /*width: 30%;*/\n    /*height: 70%;*/\n    margin: 13% 0 0 70%;\n    text-align: center;\n    background: #ffa956;\n    border: 0.1em solid #fed095;\n}\n\ndiv.option-item {\n    padding: .5em;\n    border-bottom: 0.1em solid #e89342;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.gameData);
	    },
	
	    props: ['gameData', 'zoomRate'],
	    data: function data() {
	        return {
	            isOptionShow: false,
	            menuImg: __webpack_require__(64)
	        };
	    },
	
	    computed: {
	        optionStyle: function optionStyle() {
	            return {
	                borderRadius: 12 * this.zoomRate.x + 'px'
	            };
	        },
	        itemStyle: function itemStyle() {
	            return {
	                fontSize: 26 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        showMessage: function showMessage(event) {
	            this.isOptionShow = false;
	            this.$dispatch('showMessage', event);
	        }
	    },
	    events: {
	        triggerOption: function triggerOption() {
	            this.isOptionShow = !this.isOptionShow;
	        }
	    }
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAFcCAYAAABhrZRpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MjdCRUJBMDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MjdCRUJBMTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQjlFM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkyN0JFQjlGM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ePgOugAAKRNJREFU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"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<div class=\"option-list\" v-show=\"isOptionShow\" transition=\"expand\" v-bind:style=\"optionStyle\"><div class=\"pointer\"></div><div class=\"inner-pointer\"></div><div class=\"option-item\" v-html=\"n\" v-for=\"n in gameData.options\" @touchend=\"showMessage($index)\" v-bind:style=\"itemStyle\"></div></div>";

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "<div class=\"menu\"><div class=\"notice\"><table><tr><td><span v-bind:style=\"{fontSize:26*zoomRate.x+'px'}\" v-html=\"notice.title\"></span></td></tr></table></div><div class=\"option\" @touchend=\"triggerOption\"></div><options-dialog v-bind:game-data=\"gameData\" v-bind:zoom-rate=\"zoomRate\"></options-dialog></div>";

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(68)
	__vue_script__ = __webpack_require__(73)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetAndBonus.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(76)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-7138c18e/BetAndBonus.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetAndBonus.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(70) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(71) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(" + __webpack_require__(72) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n", "", {"version":3,"sources":["/./src/components/BetAndBonus.vue?17f568bf"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2GA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,aAAA;IACA,WAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,gBAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,kBAAA;IACA,aAAA;CACA;;AAEA;;IAEA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,uBAAA;IACA,gBAAA;CACA;;AAEA;IACA,oBAAA;IACA,uBAAA;IACA,mBAAA;IACA,eAAA;CACA;;AAEA;IACA,aAAA;IACA,oBAAA;IACA,uBAAA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;CACA","file":"BetAndBonus.vue","sourcesContent":["<template lang=\"pug\">\n    //- 展示用户的下注金额 以及 奖金金额 当然还有倒计时\n    div.bonus-bar\n        div.bonus-item.bet\n            div.item-back.forzen\n                div.item-show\n                    div.bet-num(v-bind:style=\"betNum\",v-html=\"lockmoney\")\n        div.bonus-item.count-down\n            div.count-down-back\n                div.count-down-show\n                    div.count-down-num(v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\",v-html=\"countDown | time\")\n        div.bonus-item.bonus\n            div.item-back.balance\n                div.item-show(@touchend=\"showMessage\")\n                    div.bet-num(v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\")\n</template>\n<script>\nimport RequestList from '../js/request-list'\nexport default {\n    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],\n    ready() {\n        this.getCount(this.count(this.countDown))\n    },\n    data() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight\n        }\n    },\n    computed: {\n        betNum() {\n            return {\n                fontSize: 34 * this.zoomRate.x + 'px',\n                lineHeight: 3 * 34 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        //每次开奖都重新获取 倒计时\n        getCount(fn) {\n            var that = this\n            RequestList.getCount().then((res) => {\n                that.countDown = res.data.countDown\n                that.countNum = res.data.countNum\n                that.userBet.idnum = res.data.idnum + 1 //开奖期数\n                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {\n                    that.$dispatch('error')\n                    return\n                }\n                fn ? fn() : null\n            }, (res) => {\n                that.countDown = 0\n            })\n        },\n        // 买定离手\n        createUserBets() {\n            var that = this\n            RequestList.createUserBets(JSON.stringify(this.bets)).then((res) => {\n                if (typeof res.data.errmsg !== 'undefined') {\n                    that.$dispatch('showTip', res.data.errmsg)\n                }\n                console.log(res.data)\n            }, (res) => {\n                console.log(res.data)\n            })\n        },\n        getBonusNum() { // 获取开奖结果\n            var that = this\n            RequestList.getBonusNum().then((res) => {\n                that.lotterynum = res.data\n                that.getCount(that.count)\n                that.$dispatch('cancelbet')\n                that.$dispatch('reloadinfo')\n            }, (res) => {\n                console.error(res)\n            })\n            this.countDown = this.countNum\n        },\n        showMessage() {\n            this.$dispatch('showMessage', 5)\n        },\n        count() {\n            // 距离开奖时间30秒时 买定离手\n            if (this.countDown === 30 && this.bets && this.bets.length > 0) {\n                this.createUserBets()\n            }\n            // 倒计时不是数字时不进行倒计时\n            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {\n                this.$dispatch('showTip', '倒计时读取错误,请刷新页面')\n                return\n            }\n            // console.log(this.countDown)\n            this.countDown--\n                let that = this\n            setTimeout(function() {\n                if (that.countDown > 0) {\n                    that.count()\n                } else {\n                    // 倒计时小于0 时 获取获奖结果\n                    that.getBonusNum()\n                }\n            }, 1000)\n        }\n    }\n}\n</script>\n<style>\nimg {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.forzen {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/冻结.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.balance {\n    height: 100%;\n    width: 80%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/余额.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\n.bonus-bar {\n    height: 20%;\n}\n\ndiv.item-back {\n    display: table-cell;\n    vertical-align: middle;\n}\n\ndiv.item-show {\n    text-align: center;\n}\n\ndiv.item-show div {\n    /*height: 30%;*/\n}\n\ndiv.bonus-item {\n    display: table;\n    float: left;\n    height: 100%;\n}\n\ndiv.bet-num {\n    margin: 30% 0 0 0;\n    color: white;\n}\n\ndiv.bet,\ndiv.bonus {\n    width: calc(35% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down {\n    width: calc(30% - 1em);\n    padding: 0 .5em;\n}\n\ndiv.count-down-num {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: 2em;\n}\n\ndiv.count-down-back {\n    height: 100%;\n    display: table-cell;\n    vertical-align: middle;\n    background: url(./../assets/切图/主界面/count-down.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n\ndiv.count-down-show {\n    display: table;\n    height: 92%;\n    width: 92%;\n    margin: 4%;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ2RTNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ2RjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0ZCM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0ZDM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jqTgIAAAGLJJREFU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"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAABzCAYAAADt2VwJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNkJDRDdGOTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGQTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2QkNEN0Y3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2QkNEN0Y4M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8Nwv7wAAFD1JREFU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"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAACVCAYAAACzfqM2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRDA4NDQ3MjNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRDA4NDQ3MzNGMzQxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBEMDg0NDcwM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBEMDg0NDcxM0YzNDExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gONmGwAAMvxJREFU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"

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(10);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'userBet', 'countDown', 'countNum', 'bets', 'lockmoney', 'lotterynum'],
	    ready: function ready() {
	        this.getCount(this.count(this.countDown));
	    },
	    data: function data() {
	        return {
	            width: window.innerWidth,
	            height: window.innerHeight
	        };
	    },
	
	    computed: {
	        betNum: function betNum() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                lineHeight: 3 * 34 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        getCount: function getCount(fn) {
	            var that = this;
	            _requestList2.default.getCount().then(function (res) {
	                that.countDown = res.data.countDown;
	                that.countNum = res.data.countNum;
	                that.userBet.idnum = res.data.idnum + 1;
	                if (Object.prototype.toString.call(that.countDown) !== '[object Number]') {
	                    that.$dispatch('error');
	                    return;
	                }
	                fn ? fn() : null;
	            }, function (res) {
	                that.countDown = 0;
	            });
	        },
	        createUserBets: function createUserBets() {
	            var that = this;
	            _requestList2.default.createUserBets((0, _stringify2.default)(this.bets)).then(function (res) {
	                if (typeof res.data.errmsg !== 'undefined') {
	                    that.$dispatch('showTip', res.data.errmsg);
	                }
	                console.log(res.data);
	            }, function (res) {
	                console.log(res.data);
	            });
	        },
	        getBonusNum: function getBonusNum() {
	            var that = this;
	            _requestList2.default.getBonusNum().then(function (res) {
	                that.lotterynum = res.data;
	                that.getCount(that.count);
	                that.$dispatch('cancelbet');
	                that.$dispatch('reloadinfo');
	            }, function (res) {
	                console.error(res);
	            });
	            this.countDown = this.countNum;
	        },
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        count: function count() {
	            if (this.countDown === 30 && this.bets && this.bets.length > 0) {
	                this.createUserBets();
	            }
	
	            if (Object.prototype.toString.call(this.countDown) !== '[object Number]') {
	                this.$dispatch('showTip', '倒计时读取错误,请刷新页面');
	                return;
	            }
	
	            this.countDown--;
	            var that = this;
	            setTimeout(function () {
	                if (that.countDown > 0) {
	                    that.count();
	                } else {
	                    that.getBonusNum();
	                }
	            }, 1000);
	        }
	    }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _vue = __webpack_require__(1);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vueResource = __webpack_require__(75);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_vue2.default.use(_vueResource2.default);
	
	module.exports.getBonusRecord = function () {
	    return _vue2.default.http.get('getBonusRecord');
	};
	
	module.exports.getMainConfig = function () {
	    return _vue2.default.http.get('getMainConfig', { params: { url: window.location.href.split('#')[0] } });
	};
	
	module.exports.getCount = function () {
	    return _vue2.default.http.get('getCount');
	};
	
	module.exports.getBonusNum = function (params) {
	    return _vue2.default.http.get('getBonusNum', params);
	};
	
	module.exports.createUserBets = function (params) {
	    return _vue2.default.http.post('createUserBets', params);
	};
	
	module.exports.getuserCodeFromNet = function (code) {
	    return _vue2.default.http.get('getUserCode', { params: { code: code } });
	};
	
	module.exports.getuserinfo = function (userinfo) {
	    return _vue2.default.http.post('getuserinfo', userinfo);
	};
	
	module.exports.getLastNotice = function () {
	    return _vue2.default.http.get('getLastNotice');
	};
	
	module.exports.getCode = function () {
	    var reg = new RegExp("(^|&)" + 'code' + "=([^&]*)(&|$)", "i");
	    var r = window.location.search.substr(1).match(reg);
	    if (r != null) return unescape(r[2]);
	    return null;
	};
	
	module.exports.updateuserinfo = function (params) {
	    return _vue2.default.http.post('updateuserinfo', params);
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	/*!
	 * vue-resource v0.9.3
	 * https://github.com/vuejs/vue-resource
	 * Released under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */
	
	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING = 2;
	
	function Promise$2(executor) {
	
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	
	    var promise = this;
	
	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}
	
	Promise$2.reject = function (r) {
	    return new Promise$2(function (resolve, reject) {
	        reject(r);
	    });
	};
	
	Promise$2.resolve = function (x) {
	    return new Promise$2(function (resolve, reject) {
	        resolve(x);
	    });
	};
	
	Promise$2.all = function all(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        var count = 0,
	            result = [];
	
	        if (iterable.length === 0) {
	            resolve(result);
	        }
	
	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;
	
	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }
	
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};
	
	Promise$2.race = function race(iterable) {
	    return new Promise$2(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$2.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};
	
	var p$1 = Promise$2.prototype;
	
	p$1.resolve = function resolve(x) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        var called = false;
	
	        try {
	            var then = x && x['then'];
	
	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;
	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }
	
	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};
	
	p$1.reject = function reject(reason) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};
	
	p$1.notify = function notify() {
	    var promise = this;
	
	    nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];
	
	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};
	
	p$1.then = function then(onResolved, onRejected) {
	    var promise = this;
	
	    return new Promise$2(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};
	
	p$1.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};
	
	var PromiseObj = window.Promise || Promise$2;
	
	function Promise$1(executor, context) {
	
	    if (executor instanceof PromiseObj) {
	        this.promise = executor;
	    } else {
	        this.promise = new PromiseObj(executor.bind(context));
	    }
	
	    this.context = context;
	}
	
	Promise$1.all = function (iterable, context) {
	    return new Promise$1(PromiseObj.all(iterable), context);
	};
	
	Promise$1.resolve = function (value, context) {
	    return new Promise$1(PromiseObj.resolve(value), context);
	};
	
	Promise$1.reject = function (reason, context) {
	    return new Promise$1(PromiseObj.reject(reason), context);
	};
	
	Promise$1.race = function (iterable, context) {
	    return new Promise$1(PromiseObj.race(iterable), context);
	};
	
	var p = Promise$1.prototype;
	
	p.bind = function (context) {
	    this.context = context;
	    return this;
	};
	
	p.then = function (fulfilled, rejected) {
	
	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);
	};
	
	p.catch = function (rejected) {
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    return new Promise$1(this.promise.catch(rejected), this.context);
	};
	
	p.finally = function (callback) {
	
	    return this.then(function (value) {
	        callback.call(this);
	        return value;
	    }, function (reason) {
	        callback.call(this);
	        return PromiseObj.reject(reason);
	    });
	};
	
	var debug = false;
	var util = {};
	var array = [];
	function Util (Vue) {
	    util = Vue.util;
	    debug = Vue.config.debug || !Vue.config.silent;
	}
	
	function warn(msg) {
	    if (typeof console !== 'undefined' && debug) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	}
	
	function error(msg) {
	    if (typeof console !== 'undefined') {
	        console.error(msg);
	    }
	}
	
	function nextTick(cb, ctx) {
	    return util.nextTick(cb, ctx);
	}
	
	function trim(str) {
	    return str.replace(/^\s*|\s*$/g, '');
	}
	
	var isArray = Array.isArray;
	
	function isString(val) {
	    return typeof val === 'string';
	}
	
	function isBoolean(val) {
	    return val === true || val === false;
	}
	
	function isFunction(val) {
	    return typeof val === 'function';
	}
	
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	
	function isPlainObject(obj) {
	    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	}
	
	function isFormData(obj) {
	    return typeof FormData !== 'undefined' && obj instanceof FormData;
	}
	
	function when(value, fulfilled, rejected) {
	
	    var promise = Promise$1.resolve(value);
	
	    if (arguments.length < 2) {
	        return promise;
	    }
	
	    return promise.then(fulfilled, rejected);
	}
	
	function options(fn, obj, opts) {
	
	    opts = opts || {};
	
	    if (isFunction(opts)) {
	        opts = opts.call(obj);
	    }
	
	    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
	}
	
	function each(obj, iterator) {
	
	    var i, key;
	
	    if (typeof obj.length == 'number') {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (isObject(obj)) {
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }
	
	    return obj;
	}
	
	var assign = Object.assign || _assign;
	
	function merge(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source, true);
	    });
	
	    return target;
	}
	
	function defaults(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	
	        for (var key in source) {
	            if (target[key] === undefined) {
	                target[key] = source[key];
	            }
	        }
	    });
	
	    return target;
	}
	
	function _assign(target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (source) {
	        _merge(target, source);
	    });
	
	    return target;
	}
	
	function _merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
	            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
	                target[key] = {};
	            }
	            if (isArray(source[key]) && !isArray(target[key])) {
	                target[key] = [];
	            }
	            _merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}
	
	function root (options, next) {
	
	    var url = next(options);
	
	    if (isString(options.root) && !url.match(/^(https?:)?\//)) {
	        url = options.root + '/' + url;
	    }
	
	    return url;
	}
	
	function query (options, next) {
	
	    var urlParams = Object.keys(Url.options.params),
	        query = {},
	        url = next(options);
	
	    each(options.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });
	
	    query = Url.params(query);
	
	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }
	
	    return url;
	}
	
	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */
	
	function expand(url, params, variables) {
	
	    var tmpl = parse(url),
	        expanded = tmpl.expand(params);
	
	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }
	
	    return expanded;
	}
	
	function parse(template) {
	
	    var operators = ['+', '#', '.', '/', ';', '?', '&'],
	        variables = [];
	
	    return {
	        vars: variables,
	        expand: function (context) {
	            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
	                if (expression) {
	
	                    var operator = null,
	                        values = [];
	
	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }
	
	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });
	
	                    if (operator && operator !== '+') {
	
	                        var separator = ',';
	
	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }
	
	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }
	                } else {
	                    return encodeReserved(literal);
	                }
	            });
	        }
	    };
	}
	
	function getValues(context, operator, key, modifier) {
	
	    var value = context[key],
	        result = [];
	
	    if (isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();
	
	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }
	
	            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            result.push(encodeValue(operator, value[k], k));
	                        }
	                    });
	                }
	            } else {
	                var tmp = [];
	
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        tmp.push(encodeValue(operator, value));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(encodeValue(operator, value[k].toString()));
	                        }
	                    });
	                }
	
	                if (isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }
	
	    return result;
	}
	
	function isDefined(value) {
	    return value !== undefined && value !== null;
	}
	
	function isKeyOperator(operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	}
	
	function encodeValue(operator, value, key) {
	
	    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);
	
	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	}
	
	function encodeReserved(str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	}
	
	function template (options) {
	
	    var variables = [],
	        url = expand(options.url, options.params, variables);
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	}
	
	/**
	 * Service for URL templating.
	 */
	
	var ie = document.documentMode;
	var el = document.createElement('a');
	
	function Url(url, params) {
	
	    var self = this || {},
	        options = url,
	        transform;
	
	    if (isString(url)) {
	        options = { url: url, params: params };
	    }
	
	    options = merge({}, Url.options, self.$options, options);
	
	    Url.transforms.forEach(function (handler) {
	        transform = factory(handler, transform, self.$vm);
	    });
	
	    return transform(options);
	}
	
	/**
	 * Url options.
	 */
	
	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};
	
	/**
	 * Url transforms.
	 */
	
	Url.transforms = [template, query, root];
	
	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */
	
	Url.params = function (obj) {
	
	    var params = [],
	        escape = encodeURIComponent;
	
	    params.add = function (key, value) {
	
	        if (isFunction(value)) {
	            value = value();
	        }
	
	        if (value === null) {
	            value = '';
	        }
	
	        this.push(escape(key) + '=' + escape(value));
	    };
	
	    serialize(params, obj);
	
	    return params.join('&').replace(/%20/g, '+');
	};
	
	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */
	
	Url.parse = function (url) {
	
	    if (ie) {
	        el.href = url;
	        url = el.href;
	    }
	
	    el.href = url;
	
	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};
	
	function factory(handler, next, vm) {
	    return function (options) {
	        return handler.call(vm, options, next);
	    };
	}
	
	function serialize(params, obj, scope) {
	
	    var array = isArray(obj),
	        plain = isPlainObject(obj),
	        hash;
	
	    each(obj, function (value, key) {
	
	        hash = isObject(value) || isArray(value);
	
	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }
	
	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}
	
	function xdrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xdr = new XDomainRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith(xdr.responseText, {
	                status: xdr.status,
	                statusText: xdr.statusText
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xdr.abort();
	        };
	
	        xdr.open(request.method, request.getUrl(), true);
	        xdr.timeout = 0;
	        xdr.onload = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = function () {};
	        xdr.onprogress = function () {};
	        xdr.send(request.getBody());
	    });
	}
	
	var ORIGIN_URL = Url.parse(location.href);
	var SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();
	
	function cors (request, next) {
	
	    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {
	        request.crossOrigin = true;
	    }
	
	    if (request.crossOrigin) {
	
	        if (!SUPPORTS_CORS) {
	            request.client = xdrClient;
	        }
	
	        delete request.emulateHTTP;
	    }
	
	    next();
	}
	
	function crossOrigin(request) {
	
	    var requestUrl = Url.parse(Url(request));
	
	    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;
	}
	
	function body (request, next) {
	
	    if (request.emulateJSON && isPlainObject(request.body)) {
	        request.body = Url.params(request.body);
	        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	    }
	
	    if (isFormData(request.body)) {
	        delete request.headers['Content-Type'];
	    }
	
	    if (isPlainObject(request.body)) {
	        request.body = JSON.stringify(request.body);
	    }
	
	    next(function (response) {
	
	        var contentType = response.headers['Content-Type'];
	
	        if (isString(contentType) && contentType.indexOf('application/json') === 0) {
	
	            try {
	                response.data = response.json();
	            } catch (e) {
	                response.data = null;
	            }
	        } else {
	            response.data = response.text();
	        }
	    });
	}
	
	function jsonpClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var name = request.jsonp || 'callback',
	            callback = '_jsonp' + Math.random().toString(36).substr(2),
	            body = null,
	            handler,
	            script;
	
	        handler = function (event) {
	
	            var status = 0;
	
	            if (event.type === 'load' && body !== null) {
	                status = 200;
	            } else if (event.type === 'error') {
	                status = 404;
	            }
	
	            resolve(request.respondWith(body, { status: status }));
	
	            delete window[callback];
	            document.body.removeChild(script);
	        };
	
	        request.params[name] = callback;
	
	        window[callback] = function (result) {
	            body = JSON.stringify(result);
	        };
	
	        script = document.createElement('script');
	        script.src = request.getUrl();
	        script.type = 'text/javascript';
	        script.async = true;
	        script.onload = handler;
	        script.onerror = handler;
	
	        document.body.appendChild(script);
	    });
	}
	
	function jsonp (request, next) {
	
	    if (request.method == 'JSONP') {
	        request.client = jsonpClient;
	    }
	
	    next(function (response) {
	
	        if (request.method == 'JSONP') {
	            response.data = response.json();
	        }
	    });
	}
	
	function before (request, next) {
	
	    if (isFunction(request.before)) {
	        request.before.call(this, request);
	    }
	
	    next();
	}
	
	/**
	 * HTTP method override Interceptor.
	 */
	
	function method (request, next) {
	
	    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	        request.headers['X-HTTP-Method-Override'] = request.method;
	        request.method = 'POST';
	    }
	
	    next();
	}
	
	function header (request, next) {
	
	    request.method = request.method.toUpperCase();
	    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);
	
	    next();
	}
	
	/**
	 * Timeout Interceptor.
	 */
	
	function timeout (request, next) {
	
	    var timeout;
	
	    if (request.timeout) {
	        timeout = setTimeout(function () {
	            request.abort();
	        }, request.timeout);
	    }
	
	    next(function (response) {
	
	        clearTimeout(timeout);
	    });
	}
	
	function xhrClient (request) {
	    return new Promise$1(function (resolve) {
	
	        var xhr = new XMLHttpRequest(),
	            handler = function (event) {
	
	            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {
	                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
	                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),
	                headers: parseHeaders(xhr.getAllResponseHeaders())
	            });
	
	            resolve(response);
	        };
	
	        request.abort = function () {
	            return xhr.abort();
	        };
	
	        xhr.open(request.method, request.getUrl(), true);
	        xhr.timeout = 0;
	        xhr.onload = handler;
	        xhr.onerror = handler;
	
	        if (request.progress) {
	            if (request.method === 'GET') {
	                xhr.addEventListener('progress', request.progress);
	            } else if (/^(POST|PUT)$/i.test(request.method)) {
	                xhr.upload.addEventListener('progress', request.progress);
	            }
	        }
	
	        if (request.credentials === true) {
	            xhr.withCredentials = true;
	        }
	
	        each(request.headers || {}, function (value, header) {
	            xhr.setRequestHeader(header, value);
	        });
	
	        xhr.send(request.getBody());
	    });
	}
	
	function parseHeaders(str) {
	
	    var headers = {},
	        value,
	        name,
	        i;
	
	    each(trim(str).split('\n'), function (row) {
	
	        i = row.indexOf(':');
	        name = trim(row.slice(0, i));
	        value = trim(row.slice(i + 1));
	
	        if (headers[name]) {
	
	            if (isArray(headers[name])) {
	                headers[name].push(value);
	            } else {
	                headers[name] = [headers[name], value];
	            }
	        } else {
	
	            headers[name] = value;
	        }
	    });
	
	    return headers;
	}
	
	function Client (context) {
	
	    var reqHandlers = [sendRequest],
	        resHandlers = [],
	        handler;
	
	    if (!isObject(context)) {
	        context = null;
	    }
	
	    function Client(request) {
	        return new Promise$1(function (resolve) {
	
	            function exec() {
	
	                handler = reqHandlers.pop();
	
	                if (isFunction(handler)) {
	                    handler.call(context, request, next);
	                } else {
	                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');
	                    next();
	                }
	            }
	
	            function next(response) {
	
	                if (isFunction(response)) {
	
	                    resHandlers.unshift(response);
	                } else if (isObject(response)) {
	
	                    resHandlers.forEach(function (handler) {
	                        response = when(response, function (response) {
	                            return handler.call(context, response) || response;
	                        });
	                    });
	
	                    when(response, resolve);
	
	                    return;
	                }
	
	                exec();
	            }
	
	            exec();
	        }, context);
	    }
	
	    Client.use = function (handler) {
	        reqHandlers.push(handler);
	    };
	
	    return Client;
	}
	
	function sendRequest(request, resolve) {
	
	    var client = request.client || xhrClient;
	
	    resolve(client(request));
	}
	
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	
	/**
	 * HTTP Response.
	 */
	
	var Response = function () {
	    function Response(body, _ref) {
	        var url = _ref.url;
	        var headers = _ref.headers;
	        var status = _ref.status;
	        var statusText = _ref.statusText;
	        classCallCheck(this, Response);
	
	
	        this.url = url;
	        this.body = body;
	        this.headers = headers || {};
	        this.status = status || 0;
	        this.statusText = statusText || '';
	        this.ok = status >= 200 && status < 300;
	    }
	
	    Response.prototype.text = function text() {
	        return this.body;
	    };
	
	    Response.prototype.blob = function blob() {
	        return new Blob([this.body]);
	    };
	
	    Response.prototype.json = function json() {
	        return JSON.parse(this.body);
	    };
	
	    return Response;
	}();
	
	var Request = function () {
	    function Request(options) {
	        classCallCheck(this, Request);
	
	
	        this.method = 'GET';
	        this.body = null;
	        this.params = {};
	        this.headers = {};
	
	        assign(this, options);
	    }
	
	    Request.prototype.getUrl = function getUrl() {
	        return Url(this);
	    };
	
	    Request.prototype.getBody = function getBody() {
	        return this.body;
	    };
	
	    Request.prototype.respondWith = function respondWith(body, options) {
	        return new Response(body, assign(options || {}, { url: this.getUrl() }));
	    };
	
	    return Request;
	}();
	
	/**
	 * Service for sending network requests.
	 */
	
	var CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };
	var COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };
	var JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };
	
	function Http(options) {
	
	    var self = this || {},
	        client = Client(self.$vm);
	
	    defaults(options || {}, self.$options, Http.options);
	
	    Http.interceptors.forEach(function (handler) {
	        client.use(handler);
	    });
	
	    return client(new Request(options)).then(function (response) {
	
	        return response.ok ? response : Promise$1.reject(response);
	    }, function (response) {
	
	        if (response instanceof Error) {
	            error(response);
	        }
	
	        return Promise$1.reject(response);
	    });
	}
	
	Http.options = {};
	
	Http.headers = {
	    put: JSON_CONTENT_TYPE,
	    post: JSON_CONTENT_TYPE,
	    patch: JSON_CONTENT_TYPE,
	    delete: JSON_CONTENT_TYPE,
	    custom: CUSTOM_HEADERS,
	    common: COMMON_HEADERS
	};
	
	Http.interceptors = [before, timeout, method, body, jsonp, header, cors];
	
	['get', 'delete', 'head', 'jsonp'].forEach(function (method) {
	
	    Http[method] = function (url, options) {
	        return this(assign(options || {}, { url: url, method: method }));
	    };
	});
	
	['post', 'put', 'patch'].forEach(function (method) {
	
	    Http[method] = function (url, body, options) {
	        return this(assign(options || {}, { url: url, method: method, body: body }));
	    };
	});
	
	function Resource(url, params, actions, options) {
	
	    var self = this || {},
	        resource = {};
	
	    actions = assign({}, Resource.actions, actions);
	
	    each(actions, function (action, name) {
	
	        action = merge({ url: url, params: params || {} }, options, action);
	
	        resource[name] = function () {
	            return (self.$http || Http)(opts(action, arguments));
	        };
	    });
	
	    return resource;
	}
	
	function opts(action, args) {
	
	    var options = assign({}, action),
	        params = {},
	        body;
	
	    switch (args.length) {
	
	        case 2:
	
	            params = args[0];
	            body = args[1];
	
	            break;
	
	        case 1:
	
	            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
	                body = args[0];
	            } else {
	                params = args[0];
	            }
	
	            break;
	
	        case 0:
	
	            break;
	
	        default:
	
	            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';
	    }
	
	    options.body = body;
	    options.params = assign({}, options.params, params);
	
	    return options;
	}
	
	Resource.actions = {
	
	    get: { method: 'GET' },
	    save: { method: 'POST' },
	    query: { method: 'GET' },
	    update: { method: 'PUT' },
	    remove: { method: 'DELETE' },
	    delete: { method: 'DELETE' }
	
	};
	
	function plugin(Vue) {
	
	    if (plugin.installed) {
	        return;
	    }
	
	    Util(Vue);
	
	    Vue.url = Url;
	    Vue.http = Http;
	    Vue.resource = Resource;
	    Vue.Promise = Promise$1;
	
	    Object.defineProperties(Vue.prototype, {
	
	        $url: {
	            get: function () {
	                return options(Vue.url, this, this.$options.url);
	            }
	        },
	
	        $http: {
	            get: function () {
	                return options(Vue.http, this, this.$options.http);
	            }
	        },
	
	        $resource: {
	            get: function () {
	                return Vue.resource.bind(this);
	            }
	        },
	
	        $promise: {
	            get: function () {
	                var _this = this;
	
	                return function (executor) {
	                    return new Vue.Promise(executor, _this);
	                };
	            }
	        }
	
	    });
	}
	
	if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(plugin);
	}
	
	module.exports = plugin;

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bonus-bar\"><div class=\"bonus-item bet\"><div class=\"item-back forzen\"><div class=\"item-show\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"lockmoney\"></div></div></div></div><div class=\"bonus-item count-down\"><div class=\"count-down-back\"><div class=\"count-down-show\"><div class=\"count-down-num\" v-bind:style=\"{fontSize:40*zoomRate.x+'px'}\" v-html=\"countDown | time\"></div></div></div></div><div class=\"bonus-item bonus\"><div class=\"item-back balance\"><div class=\"item-show\" @touchend=\"showMessage\"><div class=\"bet-num\" v-bind:style=\"betNum\" v-html=\"userinfo.money-lockmoney\"></div></div></div></div></div>";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(78)
	__vue_script__ = __webpack_require__(81)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\PlayPanel.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(84)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-5febd0b0/PlayPanel.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(79);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./PlayPanel.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.playpanel {\n    /*background: url(../assets/切图/主界面/主操作.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(" + __webpack_require__(80) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n", "", {"version":3,"sources":["/./src/components/PlayPanel.vue?dfc2404a"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+NA;IACA,sDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;CACA;;AAEA;IACA,WAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;IACA,kBAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,gCAAA;CACA;;AAEA;IACA,kCAAA;IACA,qBAAA;IACA,+BAAA;CACA;;AAEA;IACA,6BAAA;CACA;;AAEA;IACA,4BAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;CACA","file":"PlayPanel.vue","sourcesContent":["<template lang=\"pug\">\n    //- 主游戏区\n    div.playpanel\n        div.table-panel(v-el:panel,v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n            div.num.single(v-bind:style=\"single\",@touchend=\"dobet('single')\")\n                img.chip(v-for=\"item in bets|filterBy 'single' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.double(v-bind:style=\"double\",@touchend=\"dobet('double')\")\n                img.chip(v-for=\"item in bets|filterBy 'double' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.zero(v-bind:style=\"zero\",@touchend=\"dobet(0)\")\n                img.chip(v-for=\"item in bets|filterBy 0 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.one(v-bind:style=\"one\",@touchend=\"dobet(1)\")\n                img.chip(v-for=\"item in bets|filterBy 1 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.two(v-bind:style=\"two\",@touchend=\"dobet(2)\")\n                img.chip(v-for=\"item in bets|filterBy 2 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.three(v-bind:style=\"three\",@touchend=\"dobet(3)\")\n                img.chip(v-for=\"item in bets|filterBy 3 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.four(v-bind:style=\"four\",@touchend=\"dobet(4)\")\n                img.chip(v-for=\"item in bets|filterBy 4 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.five(v-bind:style=\"five\",@touchend=\"dobet(5)\")\n                img.chip(v-for=\"item in bets|filterBy 5 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.six(v-bind:style=\"six\",@touchend=\"dobet(6)\")\n                img.chip(v-for=\"item in bets|filterBy 6 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.seven(v-bind:style=\"seven\",@touchend=\"dobet(7)\")\n                img.chip(v-for=\"item in bets|filterBy 7 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.eight(v-bind:style=\"eight\",@touchend=\"dobet(8)\")\n                img.chip(v-for=\"item in bets|filterBy 8 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.nine(v-bind:style=\"nine\",@touchend=\"dobet(9)\")\n                img.chip(v-for=\"item in bets|filterBy 9 in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.big(v-bind:style=\"big\",@touchend=\"dobet('big')\")\n                img.chip(v-for=\"item in bets|filterBy 'big' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.small(v-bind:style=\"small\",@touchend=\"dobet('small')\")\n                img.chip(v-for=\"item in bets|filterBy 'small' in 'betnum'\",v-bind:src=\"chipImg\",v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\")\n            div.num.formula(v-bind:style=\"formula\",v-html=\"bonusNum\") \n            div.num.bonudnum(v-bind:style=\"bonudnum\")\n                table\n                    tr\n                        td(v-html=\"userBet.betnum\")\n        img(v-bind:src=\"tablePanelImg\",v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],\n    data() {\n        return {\n            tablePanelImg: require('../assets/切图/主界面/主操作.png'),\n            chipImg: require('../assets/切图/主界面/5X筹码-拷贝.png'),\n            imgSize: {\n                width: 640,\n                height: 528\n            }\n        }\n    },\n    computed: {\n        // TODO 重新设定中奖规则\n        bonusNum() {\n            var nums = this.lotterynum.lotterynums.split(',')\n            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1])\n            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')'\n        },\n        single() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'\n            }\n        },\n        double() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        zero() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        one() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        two() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        three() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        four() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        five() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'\n            }\n        },\n        six() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'\n            }\n        },\n        seven() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'\n            }\n        },\n        eight() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'\n            }\n        },\n        nine() {\n            return {\n                width: 120 * this.zoomRate.x + 'px',\n                height: 120 * this.zoomRate.y + 'px',\n                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'\n            }\n        },\n        big() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'\n            }\n        },\n        small() {\n            return {\n                width: 83 * this.zoomRate.x + 'px',\n                height: 83 * this.zoomRate.y + 'px',\n                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'\n            }\n        },\n        formula() {\n            return {\n                width: 210 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                // height: 83 * this.zoomRate.y + 'px',\n                fontSize: 42 * this.zoomRate.x + 'px',\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'\n            }\n        },\n        // TODO 遍历上期下注记录，计算筛选是否有中奖号码\n        bonudnum() {\n            return {\n                width: 68 * this.zoomRate.x + 'px',\n                textAlign: 'center',\n                fontSize: 40 * this.zoomRate.x + 'px',\n                height: 68 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'\n            }\n        }\n    },\n    methods: {\n        bet(event) {\n            console.log('Height' + event.target.offsetHeight)\n            console.log('Width' + event.target.offsetWidth)\n            console.log(event)\n        },\n        // 用户下注\n        dobet(num) {\n            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return\n            if (this.countDown < 10) return // 倒计时小于10秒时禁止下注\n            if (Object.prototype.toString.call(num) === '[object Number]') {\n                this.userBet.type = 'NUMBER'\n                this.userBet.betnum = num\n            } else if (Object.prototype.toString.call(num) === '[object String]') {\n                switch (num) {\n                    case 'single':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'double':\n                        this.userBet.type = 'SINGLE_OR_DOUBLE'\n                        this.userBet.betnum = num\n                        break\n                    case 'big':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    case 'small':\n                        this.userBet.type = 'BIG_OR_SMALL'\n                        this.userBet.betnum = num\n                        break\n                    default:\n                        break\n                }\n            }\n            this.bets.push(Object.assign({}, this.userBet))\n        }\n    },\n    events: {\n        cancelBet(event) {\n            this.bets = []\n        }\n    }\n}\n</script>\n<style>\n.playpanel {\n    /*background: url(../assets/切图/主界面/主操作.png) 50% 50%;*/\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 50%;\n}\n\nimg.chip {\n    width: 50%;\n    height: 50%;\n    position: absolute;\n}\n\ndiv.table-panel {\n    width: 100%;\n    height: 50%;\n    position: absolute;\n    /*display: none;*/\n    background: rgba(255, 0, 0, .3);\n}\n\ndiv.single {\n    background: rgba(0, 255, 255, .6);\n    border-bottom-right-radius: 1em;\n}\n\ndiv.double {\n    background: rgba(0, 255, 255, .6);\n    margin: 3% 0% 0% 86%;\n    border-bottom-left-radius: 1em;\n}\n\ndiv.big {\n    border-top-right-radius: 1em;\n}\n\ndiv.small {\n    border-top-left-radius: 1em;\n}\n\ndiv.num {\n    position: absolute;\n    background: rgba(0, 255, 255, .6);\n}\n\ndiv.bonudnum {\n    background: url(../assets/切图/主界面/显示-红.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABJCAYAAACesWDiAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4NzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4ODNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTg1M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTg2M0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Uv2HIAAABDxJREFUeNrsnLGOFDEMhuPM6BDFFbRX8wR0xyvwKDwPj8JrUCNETUd1BTppJyGZtXP/eDPL5ITAIEfKJuzMLcmX3453FQ99+JxDKeuLl215f/+WYnm5cRS75SaWl1vnsFtuK6AXzmG3vJh77/549zpMRGudS43cj9Cncl/klri1VKpTzTmvbeJ2KW3iKv0T92t9+fHrxed0AQmYKcY+JIHDfYFkClCFUsaUuF9h1DELnMhwysVAKe1+zi6gCmdmKFgRFKonGgMkqmmgRDW8oAvft466zDXvQOoCQjBzT0UMZmIo0aKJMZQy0LNieJyiHuIaCpg1xinX8lFAUUwM/BCqBxWEcKyYWVUNQkLTaqoBkNIuIyYWFZyeiUVlXmRIPWJmAofApBZ1b+Y5LyMKmjo7l/gmkWsEcyNLgLjWsYnPEX+5sK+ReyYGlHbUvwsodkxK4CC4CKZlAVKG700Z4ZxtrznkSZw57MpDu1hU7UW/Y2JWdrLEviZpQAxJNpfM/QTvHQJEoCJCtfSqChQtKEjMhhiSVpdUwpgu5zETk0lj1NyDYzGaxvgn8FavASVQj4hgTEHgW5opyfvS11u9AUirMiA4jAxJnHZmVUlMtMKBXe4YINiVNhDA5Mjo9zGSbR63eFZ7hsUVeMRwaFRBBE44dPwLQiFDwWIWNTAkUv6FOr6WrvigeGhVQFEXgaGxSJp2xhbVHI6OdX6OhLutkWhadidRkphVfubYYvDigByQA3JADsgBOSAH5MUBOSAH5IAckANyQA7IiwNyQA7IATkgB+SAHJADcgQOyAE5IAfkgP7ZMnw+KHfa9fwNn+aykNvZUhF2xvzbFSR5V3hCtP2HfA0HZgYOjC2pORwd67ynEsmxynBULXfuwaO2ZAUSLipA6s1hnaO659eAeOLtA+RIbXg6RiunSTdHbY0cAw4q07AtNtekr19Z2F0FSaZewJSi8HQIMvFA8KgtXVmJv6WgxEl0Mqek3QRcPwyo0ZYENEgp2uQ9dI7amlAQugmBpKrksKLCxhQkeZ7c3xyhVfeKp49GdrGWzIIq6kFSwA4DEtVgexYMO+SwzcnCncJUOpRSkOSsLqov7ZCJJfWHa6ZeTUaLsTnBHDo5WVZ8UM/EeA4JUsFRUUOAFlaDJHpIuuKajMam1BJDxCUZAtQzsUW1GtSYidU/DGGTw7DmYik/JQ68maCxSBohLQrSSf17SEEnmbQCFOBrxQR+qqU8GlKRLNwiDjmE7hMXTqMKak8kWGmlc9DIQBKkZ2L8Y/rBAqAgVNKiIE0jJkbskLNyfJtcK0hGM/loCgh4EzjsCxWVuS6jgMQhB6We9nATMK1r+VZWoukjDzc5bGL4FJTMO9jyn/7eM8HG4z+Y+S+KDuiPFwqv7u9K+6bUO8exKd9K/VSd9GOp353HRalMHiugh1K/BH/Ymy5VOA8/BRgA3V2MtlWnR+sAAAAASUVORK5CYII="

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _assign = __webpack_require__(13);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate', 'userinfo', 'bets', 'userBet', 'countDown', 'countNum', 'lockmoney', 'lotterynum'],
	    data: function data() {
	        return {
	            tablePanelImg: __webpack_require__(82),
	            chipImg: __webpack_require__(83),
	            imgSize: {
	                width: 640,
	                height: 528
	            }
	        };
	    },
	
	    computed: {
	        bonusNum: function bonusNum() {
	            var nums = this.lotterynum.lotterynums.split(',');
	            var sum = parseInt(nums[0]) + parseInt(nums[nums.length - 1]);
	            return parseInt(nums[0]) + '+' + parseInt(nums[nums.length - 1]) + '=' + (Math.floor(sum / 10) ? Math.floor(sum / 10) : '') + '(' + sum % 10 + ')';
	        },
	        single: function single() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 7 * this.zoomRate.x + 'px'
	            };
	        },
	        double: function double() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 20 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        zero: function zero() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        one: function one() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        two: function two() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        three: function three() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        four: function four() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: 174 * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        five: function five() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 0) * this.zoomRate.x + 'px'
	            };
	        },
	        six: function six() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 1) * this.zoomRate.x + 'px'
	            };
	        },
	        seven: function seven() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 2) * this.zoomRate.x + 'px'
	            };
	        },
	        eight: function eight() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 3) * this.zoomRate.x + 'px'
	            };
	        },
	        nine: function nine() {
	            return {
	                width: 120 * this.zoomRate.x + 'px',
	                height: 120 * this.zoomRate.y + 'px',
	                margin: (174 + 120) * this.zoomRate.y + 'px 0 0 ' + (18 + 120 * 4) * this.zoomRate.x + 'px'
	            };
	        },
	        big: function big() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 8 * this.zoomRate.x + 'px'
	            };
	        },
	        small: function small() {
	            return {
	                width: 83 * this.zoomRate.x + 'px',
	                height: 83 * this.zoomRate.y + 'px',
	                margin: 425 * this.zoomRate.y + 'px 0 0 ' + 548 * this.zoomRate.x + 'px'
	            };
	        },
	        formula: function formula() {
	            return {
	                width: 210 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	
	                fontSize: 42 * this.zoomRate.x + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 220 * this.zoomRate.x + 'px'
	            };
	        },
	        bonudnum: function bonudnum() {
	            return {
	                width: 68 * this.zoomRate.x + 'px',
	                textAlign: 'center',
	                fontSize: 40 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 290 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {
	        bet: function bet(event) {
	            console.log('Height' + event.target.offsetHeight);
	            console.log('Width' + event.target.offsetWidth);
	            console.log(event);
	        },
	        dobet: function dobet(num) {
	            if (this.userinfo.money - this.userBet.betmoney - this.lockmoney < 0) return;
	            if (this.countDown < 10) return;
	            if (Object.prototype.toString.call(num) === '[object Number]') {
	                this.userBet.type = 'NUMBER';
	                this.userBet.betnum = num;
	            } else if (Object.prototype.toString.call(num) === '[object String]') {
	                switch (num) {
	                    case 'single':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'double':
	                        this.userBet.type = 'SINGLE_OR_DOUBLE';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'big':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    case 'small':
	                        this.userBet.type = 'BIG_OR_SMALL';
	                        this.userBet.betnum = num;
	                        break;
	                    default:
	                        break;
	                }
	            }
	            this.bets.push((0, _assign2.default)({}, this.userBet));
	        }
	    },
	    events: {
	        cancelBet: function cancelBet(event) {
	            this.bets = [];
	        }
	    }
	};

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAIQCAYAAAARq99gAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRUE5RTk4MzNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRUE5RTk4NDNGNUQxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFQTlFOTgxM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFQTlFOTgyM0Y1RDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+vclhJQAAXSNJREFU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"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAlCAYAAAAqXEs9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5RkMyRDk5NzNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5RkMyRDk5ODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkyN0JFQkE2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlGQzJEOTk2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EVwcGQAADetJREFU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"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "<div class=\"playpanel\"><div class=\"table-panel\" v-el:panel=\"v-el:panel\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"><div class=\"num single\" v-bind:style=\"single\" @touchend=\"dobet('single')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'single' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num double\" v-bind:style=\"double\" @touchend=\"dobet('double')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'double' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num zero\" v-bind:style=\"zero\" @touchend=\"dobet(0)\"><img class=\"chip\" v-for=\"item in bets|filterBy 0 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num one\" v-bind:style=\"one\" @touchend=\"dobet(1)\"><img class=\"chip\" v-for=\"item in bets|filterBy 1 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num two\" v-bind:style=\"two\" @touchend=\"dobet(2)\"><img class=\"chip\" v-for=\"item in bets|filterBy 2 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num three\" v-bind:style=\"three\" @touchend=\"dobet(3)\"><img class=\"chip\" v-for=\"item in bets|filterBy 3 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num four\" v-bind:style=\"four\" @touchend=\"dobet(4)\"><img class=\"chip\" v-for=\"item in bets|filterBy 4 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num five\" v-bind:style=\"five\" @touchend=\"dobet(5)\"><img class=\"chip\" v-for=\"item in bets|filterBy 5 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num six\" v-bind:style=\"six\" @touchend=\"dobet(6)\"><img class=\"chip\" v-for=\"item in bets|filterBy 6 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num seven\" v-bind:style=\"seven\" @touchend=\"dobet(7)\"><img class=\"chip\" v-for=\"item in bets|filterBy 7 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num eight\" v-bind:style=\"eight\" @touchend=\"dobet(8)\"><img class=\"chip\" v-for=\"item in bets|filterBy 8 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num nine\" v-bind:style=\"nine\" @touchend=\"dobet(9)\"><img class=\"chip\" v-for=\"item in bets|filterBy 9 in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num big\" v-bind:style=\"big\" @touchend=\"dobet('big')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'big' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num small\" v-bind:style=\"small\" @touchend=\"dobet('small')\"><img class=\"chip\" v-for=\"item in bets|filterBy 'small' in 'betnum'\" v-bind:src=\"chipImg\" v-bind:style=\"{margin: (Math.random() * 50) + '% 0 0 ' + (Math.random() * 50) + '%'}\"/></div><div class=\"num formula\" v-bind:style=\"formula\" v-html=\"bonusNum\"> </div><div class=\"num bonudnum\" v-bind:style=\"bonudnum\"><table><tr><td v-html=\"userBet.betnum\"></td></tr></table></div></div><img v-bind:src=\"tablePanelImg\" v-bind:style=\"{width:imgSize.width*zoomRate.x+'px',height:imgSize.height*zoomRate.y+'px'}\"/></div>";

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(86)
	__vue_script__ = __webpack_require__(91)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\State.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(93)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-0ce74191/State.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(87);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./State.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(" + __webpack_require__(88) + ") 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets/切图/主界面/头像1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(" + __webpack_require__(89) + ") 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(" + __webpack_require__(90) + ") 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets/切图/商城/金币.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n", "", {"version":3,"sources":["/./src/components/State.vue?46a91f68"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA;IACA,YAAA;IACA,YAAA;IACA,YAAA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;IACA,gBAAA;IACA,aAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,4DAAA;IACA,yBAAA;CACA;;AAEA;IACA,2EAAA;IACA,YAAA;IACA,aAAA;IACA;+BACA;IACA,aAAA;CACA;;AAEA;IACA,kDAAA;IACA,6BAAA;IACA,yBAAA;CACA;;AAEA;IACA,kDAAA;IACA,yBAAA;IACA,6BAAA;IACA,YAAA;IACA,YAAA;CACA;;AAEA;IACA,sBAAA;CACA;;;AAGA;;GAEA;;AAEA;IACA,oDAAA;IACA,6BAAA;IACA,iCAAA;CACA;;AAEA;IACA,YAAA;IACA,iBAAA;CACA;;AAEA;IACA,aAAA;IACA,+CAAA;IACA,iBAAA;CACA","file":"State.vue","sourcesContent":["<template lang=\"pug\">\n    //- 状态区 ，展示用户的一些状态\n    div.state\n        div.state-item.money.table\n            div.money-state.table-cell\n                div.button\n                    table\n                        tr\n                            td\n                                span.money-num(contenteditable=\"true\",@keyup=\"checkData\",@blur=\"changeData\",v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\",v-html=\"userBet.betmoney\")\n        div.state-item.portrait\n            div.polygon(@touchend=\"showMessage\",v-bind:style=\"headstyle\")\n                svg(xmlns=\"http://www.w3.org/2000/svg\",version=\"1.1\",v-bind:width=\"headsize.width+'px'\",v-bind:height=\"headsize.height+'px'\")\n                    defs\n                        pattern(id=\"image\",x=\"0\",y=\"0\",patternUnits=\"userSpaceOnUse\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                            image(v-el:image,x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\")\n                    polygon(v-bind:points=\"headborder\",fill=\"url(#image)\")\n                    image(x=\"0\",y=\"0\",v-bind:width=\"headsize.width\",v-bind:height=\"headsize.height\",v-bind:xlink:href=\"headborderimg\")\n        div.state-item.stars.table\n            div.money-state.table-cell\n                div.button.undo(@click=\"cancelbet\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userBet', 'userinfo'],\n    ready() {\n        console.log(this.zoomRate)\n        console.log(this.$els.image)\n    },\n    data() {\n        return {\n            headzoom: 1.2,\n            headborderimg: require('../assets/切图/主界面/头像1.png')\n        }\n    },\n    watch: {\n        'userinfo.headimgurl': function(newval) {\n            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval)\n        }\n    },\n    computed: {\n        headsize() {\n            return {\n                width: 142 * this.headzoom * this.zoomRate.x,\n                height: 165 * this.headzoom * this.zoomRate.y\n            }\n        },\n        headborder() {\n            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y\n        },\n        headstyle() {\n            return {\n                // width: 640 / 3 * this.zoomRate.x + 'px',\n                // height: 640 / 3 * this.zoomRate.y + 'px',\n                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' //\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ')'\n                    // transform: 'scale(' + this.headsize.width / (640 / 3 * this.zoomRate.x) + ',' + this.headsize.height / (1008 * 0.17) + ')'\n            }\n        }\n    },\n    methods: {\n        showMessage() {\n            this.$dispatch('showMessage', 5) // 5代表背景数组的最后一个，即显示充值的背景\n        },\n        cancelbet() {\n            this.$dispatch('cancelbet')\n        },\n        checkData(event) {\n            // console.log(/\\d+/.test(event.target.innerHTML))\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 //最小值为 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        },\n        changeData(event) {\n            event.target.innerHTML = event.target.innerHTML.replace(/\\D+/g, '')\n            if (!event.target.innerHTML) {\n                event.target.innerHTML = 1 //最小值为 1\n            }\n            this.userBet.betmoney = parseInt(event.target.innerHTML)\n        }\n    }\n}\n</script>\n<style>\n.state {\n    height: 17%;\n    width: 100%;\n    bottom: 1em;\n    position: absolute;\n}\n\ntable {\n    width: 100%;\n    height: 100%;\n}\n\ndiv.state-item {\n    float: left;\n    width: 33.3333%;\n    height: 100%;\n}\n\ndiv.money-state {\n    padding: 0 1em;\n}\n\ndiv.portrait {\n    padding: 0;\n}\n\ndiv.portrait-img {\n    width: 100%;\n    height: 100%;\n    background: url(../assets/th.jpg) 50% 50% no-repeat;\n    background-size: contain;\n}\n\ndiv.polygon {\n    /*clip-path: polygon(50% 0, 100% 27%, 100% 73%, 50% 100%, 0% 73%, 0 27%);*/\n    width: 100%;\n    height: 100%;\n    /*    background: url(../assets/切图/主界面/头像1.png) 50% 50% no-repeat;\n    background-size: contain;*/\n    margin: auto;\n}\n\ndiv.button.undo {\n    background: url(./../assets/切图/主界面/撤销.png) 50% 50%;\n    background-repeat: no-repeat;\n    background-size: contain;\n}\n\ndiv.button {\n    background: url(./../assets/切图/主界面/投注金额.png) 50% 50%;\n    background-size: contain;\n    background-repeat: no-repeat;\n    height: 40%;\n    padding: 5%;\n}\n\ndiv.button span {\n    /*font-size: 1.5rem;*/\n}\n\n\n/*div.stars-button{\n    padding: .8em;\n}*/\n\n.money-icon {\n    /*background: url(../assets/切图/商城/金币.png) 50% 50%;*/\n    /*background-size: contain;*/\n    /*background-repeat: no-repeat;*/\n}\n\nspan.money-icon {\n    float: left;\n    font-size: 1.5em;\n}\n\n.money-num {\n    color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    font-size: 1.5em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCODNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNkJDRDdGMjNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkI2M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkI3M0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0Y1lLQAAHf9JREFU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"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAABTCAYAAAA2jC0IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNkNBNkJCNDNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNkNBNkJCNTNGMzMxMUU2OUVENERCMTBDMjA1QTQ2RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2Q0E2QkIyM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI2Q0E2QkIzM0YzMzExRTY5RUQ0REIxMEMyMDVBNDZFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++LpzqQAAEvFJREFU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"

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userBet', 'userinfo'],
	    ready: function ready() {
	        console.log(this.zoomRate);
	        console.log(this.$els.image);
	    },
	    data: function data() {
	        return {
	            headzoom: 1.2,
	            headborderimg: __webpack_require__(92)
	        };
	    },
	
	    watch: {
	        'userinfo.headimgurl': function userinfoHeadimgurl(newval) {
	            this.$els.image.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', newval);
	        }
	    },
	    computed: {
	        headsize: function headsize() {
	            return {
	                width: 142 * this.headzoom * this.zoomRate.x,
	                height: 165 * this.headzoom * this.zoomRate.y
	            };
	        },
	        headborder: function headborder() {
	            return 70 * this.headzoom * this.zoomRate.x + ',' + 15 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y + ' ' + 128 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 71 * this.headzoom * this.zoomRate.x + ',' + 146 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 113 * this.headzoom * this.zoomRate.y + ' ' + 13 * this.headzoom * this.zoomRate.x + ',' + 48 * this.headzoom * this.zoomRate.y;
	        },
	        headstyle: function headstyle() {
	            return {
	                padding: '0px ' + (640 / 3 * this.zoomRate.x - this.headsize.width) / 2 + 'px' };
	        }
	    },
	    methods: {
	        showMessage: function showMessage() {
	            this.$dispatch('showMessage', 5);
	        },
	        cancelbet: function cancelbet() {
	            this.$dispatch('cancelbet');
	        },
	        checkData: function checkData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        },
	        changeData: function changeData(event) {
	            event.target.innerHTML = event.target.innerHTML.replace(/\D+/g, '');
	            if (!event.target.innerHTML) {
	                event.target.innerHTML = 1;
	            }
	            this.userBet.betmoney = parseInt(event.target.innerHTML);
	        }
	    }
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI4AAAClCAYAAACKlsX9AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AcMDwUMXfst2QAAIABJREFUeNrtnXl4HNWZ7n9V3S2pd+1qLRbekC1ZlrHBLMaYQCABkwlJyDg3DNyEO4HBIUMymRmInwlz7wVmIDN3cicbDgTGSSDJXBImJKwhrAaMWeJFlrzINpYlW7vUe7d6qTr3D7X27q6SDVhq1fc8/kNydVfVqVffed/3+84p6b7dAiMmRRPwN8B64A3g/wLNuXqz3zrn1D5nPt0TP9vSmxMDuLGxwgw8ANw84ddLgS8DPwG++WxLbyj3gFNxZoCTI6D5JvAVoF4I6PBGODYQYVGpjdoiG5LEzcAVGxsrHnm2pfefcuneJVeDAZxTAMwngb8FrgQYDMdp7QoSiiUBaO0KcnwwSn2lkzJH3iLg3o2NFVcCDz7b0vur+Tx25nkKmBrgO8D1ANGEwoHuID2B2LRjQ7Ek77Z7KXPkUV/pxJFvvhS4dGNjxfXAvc+29L5tAOcUQjC3yPU1jZ57gNuAIkUVHOkPc2wwjKJmv4++UIz+IzFqi2zUVTjIM8mfAj61sbHip8Adz7T09BvAycG4ptHzReB24EKALv8wB3uCRBOK/j8SAceHInT5h1laZmdhiQ1Zkr4MXHVNo+fhZ1p67jKAozM6dr8xq29w842fbwLuBf4MIBBNsL87yGA4fsrfmUiqHOgO0jEYYXmlE4+rwAN8+5pGzxXAQ1sf/c02AzhzNDbf+PlJ8jqeVGnrC9ExFEFozK6hgW4C/SdxlFTiLKtCkqS0x4XjCn867qPEnkdDpROX1XIhcOHmGz+/Cbh/66O/ec0AztwCzTeAW8bk9VCEQ71BEoqa9XPDIT++k8eIR8MA+LqOERrsprBqITZ3ScbPDYZjvHEkRk2RjWUeJ/lm+Srgqs03fv6XwLe2PvqbTgM4sxswnwD+bqK8bunyExxOZv2cEo/h624n4h2Y9n/J2DADxw6S73BTWL2IPKs9g0gY8X+6/FGWlDlYXGrHJEvXA9dvvvHzP9766G82G8CZ5CBJZx4wN1xXDfzLRHm9vytAt384O9lVVYL9Jwn0n0SoatZ7iYUD9LbtxV5cjruiFpMlL+1xSUVwqGec/1QXWgFu3Xzj5y8AHt762BMPGMCZDVnmhuvuAb4KFI/I6xDv92vL64hvAF/3cZREbEbnCw/1EfEN4iqvxllahSTLaY+LJhR2d/hoHwjTUOWmyGZZDfxo8w3XfQb47tbHnnjeAM6ZAcwXgb8GLgLo8kU50B3QlNfxaBhfdzuxUODUvStVwd/TQWiwl8LKWmyFpRmP9UbivHmkn+pCK8srXVgtpiuBKzffcN2vgW9vfeyJtrk4/tLpVse3bar7SC/4psfbmoB7gE+PyuuW7gCDoeyZQ00mCfR2EhrqRVNWzTDybE7clWeRb3dmPc4kSywudbC03IFZHpsWHwS+tm1TXfJMAKCtx5zbwLnp8bZp8vpQb5Djg+HsOBCC0FAvgd4TqIqOZyMEps4/YT66XVJq196SXHTRg8j6BtfqKsZdWYs5ryDrcQUWE8s8ThYU20jB5wDw8LZNdd81gPPBgubrwF+Nyuvjg2EO9mjL61jIj6+rnUQsqus8srcDc8tTkjTUgYCRh2orItlwtVCqm0Z/o6EVJBwlHpzl1cim7A/FbbWwospFiSN/9FcvAz/YtqnuSQM4pweYK4G/H5XXA6EYLSf9BIYTWT+XjA8T6OkgGvDqG4ThIObWZyT5xB6EqqKoKkKoSJKELJuQJQlRfBbJlZ8SalGtPhCazLgqarAXlWsqz0q3lYZKF/b8sYf4JPA/t22qazaAMzPAVAH/Oiav4wqtXX66fFFN0hoc6CY00IMQqvaJlATmo69L5sOvoCaGUZUR0KiqihBiBDiShGwyYZJlJFlGrTmHZMPVQlgL9amPfCtuTy0FDnd2oEkSi8rs1FU4sZjGlNojwJZtm+r6DeBog+YeYDNQoqiCI31BjvSFNOV11D9IoKcDJZnQlxG6WzC3PisRGkBVVRRVQVVUVCEQE0iTJEmpzCNjkmVkk4xszkdZcgnJsy8TmPN0nS/f4cbtqcWcb81OtM0yyz0uziqxjyaqnhT/ucsATnrAfBH4GrBuVF63dvmIxrPL60Q0jL+7g3hUX1enFOzF3PykJPUfRRUCVVEmZZls3GUk+8iYZBOyLIPVhVJ3hVAWng+SrOPkEvaiMl38x5Fvpr7KTaV7DGg7gYe2barbZgBnXF7fDVwL4I8maDnhY0BTXicI9p8k4hvQd6PxMKYDL0hy+07EGFgUVFVFVfWPwbTsI8ng8pBs/JRQK5bp5D8m7CWV2IvLkTQAV+rIp7GmELfVMvqr54H7t22qe21eAiedvD7YHaB9MJRVXgshiHj7CA10oSo6emmEiqn9bUwHXpBELDQCFmWUAIusWUaLk8gp8JhkE5IsISqWk2z8lBBOfQ3gJksezvIarK7i7A8JWFBip77SRYHFNPrrXwLf2raprnPeAOemx9tuB24dldftgyEOdvuJJ7XkdYBAbwfJuL4ygTxwFPPeJyUCPSkeo6IqyjQec8ru6VT+I8tIJhPqwgtR6j8hRJ5d1/dYrHbcFQuwWLMfb5Ylzq5wsaTciWncQPzxtk11m3MaODc93nYFcMeYvA7GaD7hJRDNTmiVeIxAbyexsL4ygRQexNzytCR170OoAkVVUBRtHnO6ABqZvkb4j5xnI7ns4/criy6+E5O+h1PgKsJZVp2xgDpmNOaZWFFdSE2RbfRXu1ME+oGcAs5Nj7dVAv9norxuOenjpDeSnccoCuHBHiLePn0PPBnDfPgVyXRkO2oiNp5lVBWhqh96d/RU+S7L8oiBuGKjUGvO0WkgytiLy7GXeDIWUEej2J5HY00RxfYxoP0R+O62TXXPz3ngpOT1rUCpogoO9wY43BvQIa+HCA50o+qS1wK5cw/mlqckov6xKel0ecxpAWiMQKcMxJKFKCs/LdTis/RNs2YLztJKrO5izWNrimysqC7EmjcGgl8D3962qa5tzgEnJa9vAy4GOOmN0HLCRySevV6UGA4T7DtJYjii7wa8HZibfydJg+2oQp1m4p2pkABJlpAleZKBKGpWk1xxjRA2/Qais6yaPJsjO9GWJZZWOKnzuGdUQJ01wEnJ6/8NfGZEXsdp7vQyEBzWIa+7GA769F34cADT/uclueMdhDKB+KojJt5siYwG4tJLSdZdJjDn6zMQ7S4cZZW6CqgNVYXUljp0FVDPOHDSyev9XT6ODQR1yOt+IkN9I114WqEqmI6+/mvzwRc2qYnotAwjxOxc55XeQHSjLL9SKAsv1G0gWt3F2EsqNA3EQlseK2uKKHOOAS1tAfWMAuemx9v+mpEyQb0QcKw/yP4un7a8DvsJDXSjJPQtVZG7WzHv+71EsP9DkdcfPf9JGYhuD8mVnxZqxXJ93yGbsBeXY3WXZlyBMRpVRTYaa4pwZCigningfBy4c1Re9weHae4cwh/JDoRkPEZooJt4RGeZINCLed/vJKn3AKqqv0wwmyO9gVhPcuW1Qrj0G4iOUg/5dpfmuZaUO1leVTixgPoT4JtbNjSEPkrgeIB/G5XXkXiSfSe8nBgKa5i4CuHBPqKBIX1deIko5oMvSPKR7YgUf1FOoUwwm7NPWgNx0TqUhqtmZCA6Sisx52fnP/lmE/VVhSwuc4xmqmPAI1s2NPzTRwGcexhpqipTVEFbj59D3X4NeS2IBrxEvL06ywQC07GdmPY/K4nh0AhQzqC8/qgANM1ArL/yPWXJ+nP1diAWOIuwF2vzH5fVQtOCYirGC6ivAQ9u2dDwqw8DOF9kZDXB+hF5Haa5Y0hbXkfDhIZ6ScaG9aXw/iOYm5+U8J5AFeqY4zuXp6XTMhDtxSMF1AWr9RmIsoytsBSru0ST/1S4rTQtKME1XkB9Grh3y4aGtz8I4EyW15E4ezoG6Q9oy+vwUK/+MkHEO9K22bnrIykTzB0CPcFAXPVZ/QaiyYytqJwCZ6HmuRaXOWmoKSTfPFZA/Slwx5YNDf2nApwp8lqh9YSX9/uDWR+kEIKob5Cof1DfA1cSmA+9KJnaXkZNxibL64+gTDBrwZPJQFywhmTjnwlhK9JnIOYVYC8px1Jgy86TTDL11UUsrXAhj2SqHuDhLRsa7poJcL6WmpbqhRC83x9k/wkvsaSiIa8DhL39MygT7Ma87ymJ8NAI8c1hHvOBG4h1HyO57ArdBmKezYm9qEyzgOoosLByQTHVRWPEfCfw0JYNDduyAedy4Ftj8joQZc/xQXw65HXE26e/TOA7gXnvbyWp7/CsKhPMDf4zxUBsuEooiy7SbyA6i0b4j0YBtcxl5ZzaYgrtY8B8Hrh/y4aG1yYCpwL47kR53dwxSOdgSFNeR3yD+ssEsTCmlqckuf2tWV0mmHsGYiXJps8I1VOv20C0FZZQ4HRnJdwSsLDMSeOCkokNZD/dsqHhJum+3aIReAkoV1TBoS4fB7q8mvJ6OOgnGhjUXyY48hrm/X+Q1Hg4NS3N/jLBnDMQPQ0kV31WCJdHt4FoKyzT5D9mk0x9VSF1lYWjDWTrzcBWoPzEUIg9xweIxLSq1xEivgH9ZYKeA5j3/lbC340yR8sEszFUIRCpTK3KYiQDdbVi6T0oqYvXo6zYKES+XUOXxAn2n8RSYMNWWJplBw6FfZ2DSBIsryoCuMQ86svsaOvJfpJkgqhvcGzTIS1PQQr1Y97zhCR1t+RMmWC2xWi2FkKgquoIeIRAPrKdvI73pGTDVUJZeinIJo1kEMXf00m+3YnVXYJsMmmrtYkXkf7iVIaDPoZD/pEygZYHlYhi3v+8JB9+FZFMjmeZeS6vPyoAyao6It/VEKY9/yWZDr9Ksulaodau0fxjj0WCxKNhCpyF5Dvc0wzEiRAxAwpgkiRpGnjikRDRwNCEMoGU7eoxte/EtO9piajvjHfhzVcAKUKkpq8UgQ4NYn5rmyQOv4ZyzueEWrJI8zuiAS9CCKyuoqwZJwy4TJJEYgohDnv1rTyVB49h3vW4xFDHvCsTzFYAqYqCEOp4Buo/ivmlf5NE7Xkkm67VNhBF9jq0edKRUycSjWlJivow73lSkjreG1usb8jrWQIeQKgCIamTM9Dxd8g7uVdSll1Osv4TmQ1EaToe1HEFnadRdpUy0XFMh176tfnASBeeMke68OY7/xGqiixkTKpAbn2evGM7peTaG4Ra2aDr2SfHZySreeoJpnoF6UBgee4eidBAiviOFCMNwMwl/pOS7+Eh5L7DkqhsEOk46/TnKdJNVWnZCzDd4BPB/rG6ksFj5iCAFCWVfUyYEsMZZhZJpxwnDcIyfDapJFEUJSe68OZrqEKAqiCrStrnnA4PU+W4BseZ/q0qMqqaNEZ/zmef0cln5hlHniaqRHqBNTlP5RmjPm+kWXo8mIE4jGxTJ9LKcckYwFwOSUq7R6EQapp3kYlJGScCYJZlYxCN0B3myROemNE8Z0TOpJ3MJGhCKOPbA0/wcdLRGgM38xs3U35WxoGUnz3jSDLo2fbViBxEjjQdD+nkeMaMY2Sd3I7EcHofRyILNdYqcmZEjoGm3NLcEvomq0wlB71GsMlijPd8wFOWlJN1qpIyaHy9myEaMUcYTrpnLGl4wEAMwCRJH/h7nIyYyxkneyeXGRgeAw4GO56fiup0q+PpkpNkUOP5qMbT4SExvkWNTYMcGxln3iInDckR4200Fu2eY4P25DiXUTWkldZUlbZUlUFVGVkodyIRy/gGvyzGMUZJ3IhTiqxTlZSJ41gKjJHLKU0lpfl9Op6SzjnO1PWXTlVJxlSVMxQnExtBaDrHUQCTSU4vx41a1bxUVYLpHaFiSgdgAhjd9033eQzoGBwns6wypqR5knD09eMkx/eAdJi1KI4R85j/TPl5wjI6kwY5lowpKddDSWZQVdkzyWntVmFELgAnkUX/nPLacWkGc6IRuaSqTm/teKZ+DIvVGOv5wG+mrR3Xm3GkGf+HEbmScHTI8RCAJc1Ok1mpsdExmEO4kU4JOMo4FzKAYEQWqqJ7m5NMJNiYqXJrmpL0LQFOjBuArqyto5KBknlOkDPWqiRtOW40cuV2JOMZnrHQaQBmWMhpQCTHQ1XI2FWhZ0HeTKpVkrGXzryZrDL9rE2O06Uxs9EBmDuqSZxSJWBSxpm2zzHCKHPOE2GVLtcIDec4AGAxmzNpNWNk5yV0tDOOyPpRQ1QZuJnOeCSNPQAN5MzryWqqAZgY29vaqblfidFBMQ9gc4pFTg05biAnpyMezTKrfNA7chmRG2o820Of2Y5c02tVaTdrMrbkzyn0ZFzkkGVdlY492dI0Mht7AM4DcqzdOioyqirJIMfzlhzLaG7lFgDIsxgGoJFxZpZxPujvNCIXcJMm2UwoOZiyGoDZt8AwIndwo28J8AQD0JG1P8J41+Z8UFWn9ozNWfNTtn5UI3IjEtEMnstpGICSMOhMziecbJRVnwE4vVldZMo4xlZuua/HJenUDcCMe27LJmOwc1xU6eE4CqS2H033akXJ2Fp9XmYcWc66IE8GggBms+lDxqgRuRRZVdVIr7oBktxPOPpedKaKsZWcecY6FyN0R3L8LcC2rAvyhCoM5zjXI8NWbnr2Oc6MnExGjoGbnAmRjJ2SkaNjKzcDJfNTkM+kOj6tyCnSq/F8uzAQlRshu8ozV5WybO13Sm9lNdc0IlndiIjPGPm5mmMs+VjX/YWwXvDnM8hCEwAHJAFkaSLPGec7kiRN+2dZcgHFmx8V1gs23S+Z842nMMempfwVH6f41p8L+/obkS0FaZ+xLMtp8DD5XQ5hSO0BmP6Y9KcvcOC4YvOdxZt/LvJXfNyYueZAmD1nU/il7wvXZ74tZFe5DuacETcaBiDaBqDJXYH7s3eJxPnXEXrhh1Li5H7jCc02HmMrxHH5LaJg1dW62mRURSEa8E7Dg6KOGYD5Wd/lEA36EEJQ4HQjSdm9Qkt1A0U3/UgMt75M+OWHJMXfazyxMz0pmSxY137ucfv6G/9cKnDoyDCC4XCAaMCHSPOuzgkGYH7W1lEhBNGAl1g4gNVVQr7dqTl/Fqy4gvxll4jIzseJ7PiFJOJR4wmegchbcj7OT/y1MJXU6jo+Hg0T9Q+iJBP6pj09B6mKQtjbRyzsx1ZYgiXfqsnYHZfciG31RhHa/jMpuvtpGE9zRnyIYSquwXXV10XekvN1Ha8k4oR9gySGI1mPc9gKuHBl3eiPb0j37RbrgdcTSYXdh47R3NY+MSWlR7PVjq2wFJNZ38K8ZH87wT/+SIoffdt4sh/WtFTgwHHJl4R17ed0LZgUqko0MEQ05M++fsoks6puIauXL8ZskhGqGpBk+WLpvt2CZDz2K3Ne/n8DCEWG2bmvjSOd3RpXKmF1FmJzFeveEzB25G2Cf/yRlOxvN570B4YYGeuqq3F+/BYh24t0fWQ4FCDiG0DVmAUWVVdw8arlOGwjHZ/9He+/2br9xb/9w0P//rZ0327Blg0Nrk3/cP9fLlx17leKPNUNAL2DPnbsPUTvYHaTT5ZNWN3FWJ2F+hrbVYXIrt8TevURSY34jQd/GmFZ0Ijr6m8Ki+dsXccnYlHCQ30k47GsxxW5HFyypp6qsmIABk92tL339BMvv/qLnzwHvAP0jALHDiwFGq+7897PLrvwkgudJWXVAEc6unm39TD+UPY50GTJw15URp7NoesmxHCI0Paf/SnyzhPnCSVhoGAmPMZdgfOKW0VBoz7/TE0mCHsHiIUDWY/Lt1g4f+XZ1C9egCxJhH1DfYff2/HW/7v7jmeAPuB94BgQGgWOGSgBFgG1QMlf/fCxGxY2rVkHoKoq+450sGv/UWKJ7A/ZUmDDUVyOOU+fo6z4ewm++GMp2vISxj4rGrOSOR/7RV8QjvU3IOVpv/ppRBUPEfENpZXX46xDomHxAtauWEpB/shOJMf37Xr7kW9+5ZFEbNgPnAROAIOMvDVake7bPfKwtmxosAAOoAyoASrPWrnmF9fcdse7CxqazgMYjsV5t/UwB452omos5CpwFmIvKkM26SuHJU604v/D96XEiVYDIenGs/5SXJ+8XZjcFfr4ZCRIaLAXVUNeV5UXs25VPaVFLgD62o8eeOmnD9zb/PJzJqArBZg+RlqMx5ZyjgEnBR4JsABuwANUA57zrrlu5SVf+PLV5QuX1AN4AyF27DlIZ0+/Bm+TsRWWYHOX6GxBFUT3vUTgxa2GgTiawT1n47rqdpG/cLU+BRuPERrsIR7VktdWLmxaxtLaSgD8fT0dza8899qzP/rXV4HeFGC6AT8QnzodTALOBADJQD5QlAJQDVC28ba/v7Rxw5UXF1XWLAbo7Olnx54DeAOh7HOy2YK9uIICh1sf/0nGCO34T0JvPDpvDUTZ5sZ52VeE/dxrQcdypFGvLRr0ashrE011i1jTsARz6h1l7c27djz4tRt+DgykAHMSGAKGgbRzXFrgTACQCbACxUBVCkAlf3HPv1+79NyLLihwOItVIThwtIN3Ww8zHItr8B8rjpJKLAX6Xs2oBAcJvvqIFNk1jwxE2YR97WcWOy+/5aiss0wQDXgJe/tQFS157WHd6nqctpHxP3modffTP7hvTXvzrusn8Jh+RgrfWb8sK3AmAMgM2IHSFHiqXGUVr1//v/7tN2etXHMBQCyRYFfrEfYdPo6qZjcQ8+0unKUVmCz6toRL9rfjf/4H0vCRnTmNmfwl51N49deFuWyhruPj0TDB/m5d8nr9uSuoLi8Zl9fP/Ncrrz720M7UdHQC6EnxmLguoq4HOBMAlAc4gfJRAt10+dXJy79065aKRWc3AvhDYXbuPcixEz0a/qGE1V2Co7hc98rQ4SM78T//AynZfyynAGMursH1iduEtf5SfZk4mSDY36VLXq9duYyGpbUj8trv7Tv87psT5fWJFAH2ArGZyNoZAWcCgc5PEejKFIDKr/zK7etWffyaS0uqFywF6OobZMee/Qx4AxqZ2YyjpBybq1i3gRh673cEXn5YUud4B6KUZ8W14b8Lx8XX6y4ThL39hL0D2vJ6SS1rG+smyev/+LtbfhGPRnrTyesZX/tMgTOFQFtTBLo69a/0C//4LxvPPm/dRfbC4nIhBIfaT/DOvoNEotnTqTmvAGdZFfk2p67zq8Mhgq9tI7Tz19KcMxAlCduqq3FfuVmYnKX6sm3QR3CgGyWZfSapKith3eoGSovcY/L65Z9t3br3pWd9U+V1nSeZbOsxn9otnCpwphBoe8pArAGqLfkFzr/87sM3nbVyzUUAiWSS3fuP0nzofZIaBC7f7sRZXoU5T9+OGElvF4EXfyxF9r04J15Gm7egkcKrvy7yFjTq87diUYK9J4lHw9ryetVylp5VPSav9736h9ee+eF3Xkvxl0nyus6TFABnDDjbNo2U2tt6zJYJ/KcaqFp24YZHP3nzN/ZWnr28CSAUibJz70GOHD+p/RfpLsFZWqHbQIx3tuB97ntSvLNlVgLG5CzFfeWtwn7ORp1deEmC/d1E/EPZM7XJRNOyxaxZsVSXvK7zJCfNcWccOKmLkIC8CQZiDVDxsRtuueC8az53WUl1bR1A76CXHbta6R30Zuc/sglHiQdbUalmB+KoNI3s+yO+Fx6QFH/P7JiVTBacF18vXJd+WVeZACEIe/sJDfZoV69rPKxbvQKn3aYpr+s8ybRfNiuAM+FiZKAgxX+qUhmo7Lo77/3kpALq8ZPs3HuAUCS7yWey5OEsq8Lq0tc2IBIxgm/+isD2n51RA9Ha8DEKP/k1YS6p0XV8LBwg0HeSZGxYQ147WX9uI9UVpZryus6TnRTNKuBMuCgTYEvxn1ECPamAmlQUmg8eZff+IySSyez8wGrHVVFDntWu00AcwP/iQ1Jo9zMfqYFoKV9E0cZviIKlF+jjafEYgd4TDIeyt5nk51lYu3I5DWcvHJXX/YfffXNHJnk9ymPmHHAmXFzaAuqf3b5lV/WyFasBItFh3mk+yKFjnZq7nVpdxbjKq3UbiIm+Y3if+540fPitD9f0LXDivuIW4Tz/Ol1lAqGqBAe6CA/1Zb1nSZKoX3IW5zctnySvt91x6y9j4VDvBB4zAEQzTUtzDjgT+M+0Auq66/7i3As/e/2VZbWLlgEMeP3s2NVKV9+ABn+WcZRU4Cj16O5AHG57C+9z35MSfR+wgSibcKz97BWFV9z8R9lWqOsjEd8gwb6Tms3hleUlXLymcZK8fuXnD/5+z4tPt06R16E6T3LGvsSsB84U/jNaQB01EMuu/Zu7Lq+/+LKL3eWeWoBjJ7rZuacVfzC7DDWZLbjKa7AV6vNDUBWC7/4W34sPfSAGYsGicyna+A2RV7VMn/qLhvD3dBKPhrTl9TkNLD2rZqK83v7MD7/zajZ5nbPAmcJ/rFP5z5e+s/Vzi89Ze2Ge1eZUVZV9h95nV2sbsbh2A5nbU6tjCc+ogRjE/8p/EHzr8VMyEM2FHoo2fkPYVlyuj28lEwR6TxDxDWjL6+VLWLOibmx7vZnI65wHzoQLN0/gP9VAlWdx3S8/d+c97yyoX7kWUg1kzQc5cKRdVwOZ21ODOV9fBT452InvxYekcPMLugxEKc+K+9IvC9f665Es2l2OQghCAz0E+7sQGsXfRQsqWbe6Eafj1OX1vAHOFP7jAipS05fnvGuua5rUQOYPsmNXC53dvZoGoqOoDFdFjW4DMdbZwtDT35VimQxEScLe9AmKPnmbMBd6dH1nNODF39NJMq4hr91O1p/bRLWnLJ287gE69crreQWcKQDKBwon+D/l0xrIunvZsasFrz+owVlNOMuqcZR49HUgCkG4+QW8f/ihlPSNG4h5Vcso+fQdIr+2SZ+Ki0Xxd3cwHPJpyuvzVi5nRd1iZEkiEvD1t73zxmnJ63kJnCkEerSBrJpMDWRH2nm3+YBmA5k5rwB3Ze2MDMTAG78g+N7vpcLL/odwnPsp0OFcq4pCsO8kwcGerNOEjuvvAAADxklEQVTemLxe1TBJXv/0zs2/HA4FT0tez2vgTOE/2RvI4gl2tRxi36Gj2g1kDheFlWdh0WkgziTCQ334ezpQNUzMyvISLj6vidKiwjF5/epjDz29+4Wn9n0Q8toAzuSb024gC4bZubuFY51dmt9nLy7HXbFAt4GYlRuFA/i62vVVr1c3snThuLxuee2F15/+wf2vMNIc3vlByOs5A5xn9n00xcQ3brtcXwNZ7wBv/mkfA97s/EKSTbjLq3GWVuo2ECepsUQMX3eHLnm9qn4pq1fUYTGbNeX1+h+9rPIRxhu3XX6GgNPy0Vah3/jq5foayN4/ztt79xOJZlc0Jksebk8tjuJyXecXqkqwvwt/3wkd8rqKdWtW4nKMTI1dbft3P/X9f04rr9c/8PIZ6cZ/46vzBDgTblhfA1lrG3sPHNZsIMuz2imsWph1CU/EP4ivq127OdztYv15TdR4yjXl9foHXo5zBuOMAefZljO7cO71r16m3UAWjrBzdyuH2zs1v8/mLqGoaiHm/PEOxHg0jPfkMV3V6/Oa6mlctiQlr/0Dbe+8/mYmeX3JA6+c8ZbF17962fwETurm9TWQDQzx1q4WujULqBLOsiqcJR4C/V365PXShVxwzopJ8vrnW277XiTgV6fK60seeGXWLBKb18CZMAi6GsiOdXbx1q59+IOh0z5nZXkp689bRWnxuLx+7ZcPP73r+d9Nk9eXPPDKrOuqN4AzeTDSNpB9+V8evG7RqnPPHy+gHuVP+w5oFlAzyus1Kzl74YIxed26/cXXn/r+P6eV17NhWppVwNn62BPM1uh46K5pDWSexXW/mFxAjfHu3gPsP/y+ZgF1XF6fzerGZZnk9ahaGgKGa2+5R2UWR8dDdxnAyTAwExvIRguoFdMLqAF2/KmZjq5eDXndhMuZkteHD+x56nv/tHqKvB4AQrW33DMnFrufOeA8+hvmxAD95B9HG8gKUwZi2gJqR1cPO95rxusPTJbXa1dRU1mhKa9rb747zhyKjp/8owGcGQBIs4C6v+19mg8cpnHZEhqXLx2V14Nt77z+RiZ5XXvz3XNuSzEDODMfMM0C6sQ4vm/X24/+w+13h31Dzqnyuvbmu+fsHiwGcE594NIWUNdv+tLflNSctWjwxPFjO5/8z1d3Pf9k81R5XXvz3XN+18szBpxciEw7cKQ8oeEUUCbJ6/u27xc5cu+n9DkzRpACwfCWDQ1xIJSagioZaWUNpjLNEDB83/b9qjFiBnCmAkgFwls2NAwDvlQWigPR+7bvTxojNB7/H1tAwgq7HPA5AAAAAElFTkSuQmCC"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "<div class=\"state\"><div class=\"state-item money table\"><div class=\"money-state table-cell\"><div class=\"button\"><table><tr><td><span class=\"money-num\" contenteditable=\"true\" @keyup=\"checkData\" @blur=\"changeData\" v-bind:style=\"{fontSize:34*zoomRate.x+'px'}\" v-html=\"userBet.betmoney\"></span></td></tr></table></div></div></div><div class=\"state-item portrait\"><div class=\"polygon\" @touchend=\"showMessage\" v-bind:style=\"headstyle\"><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" v-bind:width=\"headsize.width+'px'\" v-bind:height=\"headsize.height+'px'\"><defs><pattern id=\"image\" x=\"0\" y=\"0\" patternUnits=\"userSpaceOnUse\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"><image v-el:image=\"v-el:image\" x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\"></image></pattern></defs><polygon v-bind:points=\"headborder\" fill=\"url(#image)\"></polygon><image x=\"0\" y=\"0\" v-bind:width=\"headsize.width\" v-bind:height=\"headsize.height\" v-bind:xlink:href=\"headborderimg\"></image></svg></div></div><div class=\"state-item stars table\"><div class=\"money-state table-cell\"><div class=\"button undo\" @click=\"cancelbet\"></div></div></div></div>";

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(95)
	__vue_script__ = __webpack_require__(97)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\BetMultiple.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(98)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-8ff4067e/BetMultiple.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(96);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./BetMultiple.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n", "", {"version":3,"sources":["/./src/components/BetMultiple.vue?3803979b"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqBA;IACA,iCAAA;IACA,YAAA;CACA;;AAEA;IACA,eAAA;IACA,YAAA;IACA,WAAA;IACA,aAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,gBAAA;IACA,gBAAA;IACA,eAAA;IACA,qBAAA;IACA,oEAAA;IACA,kBAAA;IACA,mBAAA;CACA","file":"BetMultiple.vue","sourcesContent":["<template lang=\"pug\">\n    //- 选择下注部分\n    div.multiple\n        div.bet-button-area.one\n            div.table-cell\n                a.button 1X\n        div.bet-button-area.five\n            div.table-cell\n                a.button 5X\n        div.bet-button-area.ten\n            div.table-cell\n                a.button 10X\n</template>\n<script>\nexport default {\n    data() {\n        return {}\n    }\n}\n</script>\n<style>\n.multiple {\n    background: rgba(255, 0, 0, 0.6);\n    height: 12%;\n}\n\ndiv.bet-button-area {\n    display: table;\n    float: left;\n    width: 33%;\n    height: 100%;\n}\n\ndiv.ten {\n    width: 34%;\n}\n\na.button {\n    /*width: 100%;*/\n    /*height: 50%;*/\n    font-size: 2em;\n    /*background: #CCC;*/\n    background-image: -webkit-linear-gradient(315deg, #feae3d, #ef8b11);\n    padding: .1em 1em;\n    border-radius: 1em;\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 97 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    data: function data() {
	        return {};
	    }
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multiple\"><div class=\"bet-button-area one\"><div class=\"table-cell\"><a class=\"button\">1X</a></div></div><div class=\"bet-button-area five\"><div class=\"table-cell\"><a class=\"button\">5X</a></div></div><div class=\"bet-button-area ten\"><div class=\"table-cell\"><a class=\"button\">10X</a></div></div></div>";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(100)
	__vue_script__ = __webpack_require__(103)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\Message.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(160)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-33fdb807/Message.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(101);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Message.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(" + __webpack_require__(102) + ");\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    -webkit-transition: all .3s ease;\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n", "", {"version":3,"sources":["/./src/components/Message.vue?5d23d056"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,aAAA;IACA,mCAAA;IACA,0CAAA;IACA,OAAA;IACA,sBAAA;CACA;;AAEA;IACA,iCAAA;IAAA,yBAAA;CACA;;AAEA;;IAEA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,sBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;IACA,kCAAA;CACA","file":"Message.vue","sourcesContent":["<template lang=\"pug\">\n    div.model(v-show='dialogShow',transition=\"message\")\n        div.dialog(v-bind:style=\"dialog\")\n            div.close(v-bind:style=\"close\",@touchend=\"dialogShow = false\")\n            div.content(v-bind:style=\"content\")\n            div(v-bind:is=\"dialogImg[currentIndex].type\",v-bind:zoom-rate=\"zoomRate\",v-bind:userinfo=\"userinfo\")\n            img(v-bind:src=\"dialogImg[currentIndex].background\")\n</template>\n<script>\nexport default {\n    props: ['zoomRate', 'userinfo'],\n    data() {\n        return {\n            dialogShow: false,\n            currentIndex: 0,\n            dialogImg: [{\n                type: 'betInfo',\n                background: require('../assets/切图/投注记录/投注记录.png'),\n                close: require('../assets/切图/投注记录/关闭.png')\n            }, {\n                type: 'bonusRecord',\n                background: require('../assets/切图/开奖记录/开奖记录.png'),\n                close: require('../assets/切图/开奖记录/关闭.png')\n            }, {\n                type: 'ruleIntroduce',\n                background: require('../assets/切图/游戏规则/游戏规则.png'),\n                close: require('../assets/切图/游戏规则/关闭.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets/切图/商城/兑换商城.png'),\n                close: require('../assets/切图/商城/关闭.png')\n            }, {\n                type: 'exchange',\n                background: require('../assets/切图/赠送/赠送好友金币.png'),\n                close: require('../assets/切图/赠送/关闭.png')\n            }, {\n                type: 'recharge',\n                background: require('../assets/切图/充值/底.png'),\n                close: require('../assets/切图/充值/关闭.png')\n            }]\n        }\n    },\n    computed: {\n        dialog() {\n            return {\n                width: 550 * this.zoomRate.x + 'px',\n                height: 760 * this.zoomRate.y + 'px',\n                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'\n            }\n        },\n        content() {\n            return {\n                width: 478 * this.zoomRate.x + 'px',\n                height: 618 * this.zoomRate.y + 'px',\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\n            }\n        },\n        close() {\n            return {\n                width: 42 * this.zoomRate.x + 'px',\n                height: 42 * this.zoomRate.y + 'px',\n                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',\n                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'\n            }\n        }\n    },\n    events: {\n        showMessage(event) {\n            this.dialogShow = true\n            this.currentIndex = event\n        }\n    },\n    components: {\n        betInfo: require('./messageComponent/betInfo.vue'),\n        bonusRecord: require('./messageComponent/bonusRecord.vue'),\n        exchange: require('./messageComponent/Exchange.vue'),\n        Recharge: require('./messageComponent/Recharge.vue'),\n        ruleIntroduce: require('./messageComponent/ruleIntroduce.vue')\n    }\n}\n</script>\n<style>\ndiv.model {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 999;\n    /*background: rgba(12,26,55,.35);*/\n    background: url(../assets/切图/暗色挡板.png);\n    top: 0;\n    /*padding: 10% 7.5%;*/\n}\n\n.message-transition {\n    transition: all .3s ease;\n}\n\n.message-enter,\n.message-leave {\n    opacity: 0;\n}\n\ndiv.title {\n    height: 20%;\n    /*background: black;*/\n}\n\ndiv.close {\n    position: absolute;\n}\n\ndiv.content {\n    position: absolute;\n    /*background: rgba(0, 0, 0, .6);*/\n}\n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZEQzMwRDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZEQzMwRTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkRDMzBCM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkRDMzBDM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+X2ymawAAAA9JREFUeNpiYGBgmAkQYAAAngCaoMXLCwAAAABJRU5ErkJggg=="

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    data: function data() {
	        return {
	            dialogShow: false,
	            currentIndex: 0,
	            dialogImg: [{
	                type: 'betInfo',
	                background: __webpack_require__(104),
	                close: __webpack_require__(105)
	            }, {
	                type: 'bonusRecord',
	                background: __webpack_require__(106),
	                close: __webpack_require__(107)
	            }, {
	                type: 'ruleIntroduce',
	                background: __webpack_require__(108),
	                close: __webpack_require__(109)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(110),
	                close: __webpack_require__(111)
	            }, {
	                type: 'exchange',
	                background: __webpack_require__(112),
	                close: __webpack_require__(113)
	            }, {
	                type: 'recharge',
	                background: __webpack_require__(114),
	                close: __webpack_require__(115)
	            }]
	        };
	    },
	
	    computed: {
	        dialog: function dialog() {
	            return {
	                width: 550 * this.zoomRate.x + 'px',
	                height: 760 * this.zoomRate.y + 'px',
	                margin: 140 * this.zoomRate.y + 'px 0 0 ' + 45 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        close: function close() {
	            return {
	                width: 42 * this.zoomRate.x + 'px',
	                height: 42 * this.zoomRate.y + 'px',
	                margin: 23 * this.zoomRate.y + 'px 0 0 ' + 484 * this.zoomRate.x + 'px',
	                background: 'url(' + this.dialogImg[this.currentIndex].close + ') 50% 50% / contain no-repeat'
	            };
	        }
	    },
	    events: {
	        showMessage: function showMessage(event) {
	            this.dialogShow = true;
	            this.currentIndex = event;
	        }
	    },
	    components: {
	        betInfo: __webpack_require__(116),
	        bonusRecord: __webpack_require__(122),
	        exchange: __webpack_require__(128),
	        Recharge: __webpack_require__(140),
	        ruleIntroduce: __webpack_require__(154)
	    }
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMDVDNDY0MjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMDVDNDY0MzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjAwNUM0NjQxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Ii2N+QAAGLNJREFU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AAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhYhcAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCpAv09fT4jgDAKuumo29XhclArzABgNU22Ns9OdBVYTLS1+enAwBW2Yb+7jn+dlWYbBoc8NMBAKvsp7ro+NtVYbJ53UBXnU4CgDe7OO5uFiblYobJCSNDfkoAYJXEcbebpnh23emJqLafWb/OTwoAdFgcbzd32TSKrrxuctzwUDpqaNBPDAB0SBxn43jbbfq7cWfFGaW3jqxPhw30p2fGJ9LETNVPEACsgKG+3lqQbO7SG076u3nnxU6LO3X2Tk6lfZWptH96JlWq1TTr5woA2v5lPya4xi3BcUyNG026edWw/kNhh27JdmIMAODNzb25AIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAoD5MKgu29PXZKwBA59U3RyXCZDS/pWfdoB0FAHRcSXOMRpg8n9/Su2HEngIAOq6kOZ6PMHksv6VvyyZ7CgDouJLmeCzC5KH8lv6tR9lTAEDH9W89urjpwQiTe/JbBre9zZ4CADpucNvJxU33RJh8NxvPzW/pPeKwNLTjdHsLAOiYaI1ojpxokQciTKrZ+NKCgjntVHsMAOiYktb4Utq+szq/wNoNKbeeScwzGTr7THsNAFhx0RiFOa2VuRY5uPJrnD75q/wzhi84N/W95Uh7DwBYMX0/vaXWGAV/k7bvfC4fJuHqbOzNP2vkwvNSz9CQvQgALFs0xcjO84uboz1+f/4PvYUHPpl/Zv/xx6QNF7839QwO2JsAwNKjZN1grSmiLQo+nbbv3FsWJuEr2bgpv2HgxBPSxkt/2WUdAGBJoiE2fugDtaYo+IssSv5+QcDM7rqz+KRYuP7WbFxUfGD87m+nifsesocBgLYMnX1GGr7gnWUP3Z6ND2ZhUmkVJmE4G/+YjZ3FB6b3vJAqu3aniQe+Z28DAOVBsuP02i3BDVaU/9dsXJJFyXjxgUZhEmJiyReycUXZg9VXf5Iqj/4wC5Xn08zL+1J1dH+ancyip1r13QCAtaK3tzZ/pHfjhtp738Qy84PbTkq9Rxze6CNiysinsiiZKnuwv8mnig+4MhvfmguULQu+juwTxukZAIA2vJxiomtKtzTtnDZeKCbEbsvGjSm3CBsAQBsqcw2xrVWUtBsm85VzVTZOzMafZGOP/QwANLFnrhlOnGuIl9v5oGZzTFoFzY5sxCopcT0n3pI4bkzekF6fmwIArA0x9WN/en0V+cezEbfvfjMbD6TX34+v3PadpZv/T4ABAMFnY+3Ft1qIAAAAAElFTkSuQmCC"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMxRDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMxRTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjAwNUM0NjQ0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzFDM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MfthnAAABlJJREFU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"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyNjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzIzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzI0M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+M8ZK3gAAF+xJREFUeNrs3W1sXfddwPG/7dhxYieO4zw3bZp2TR+20apNixgwmmoIlY5qEtBFrAKJaXQddC/6AngBTBW8YLzom2qwdsCEVNRQihDVqgiBSDegE31Y263rU7Y2aZM4aZwHx3lw7CTm/G5y0+vjc+1r+17npvl8pP8Ln3vtOCdXOt+c8z//0/LEO2NpBlqzcWs2NmVjYzY2ZOOybHRlY34CAC4VJ7NxLBu7s/F2Nl7MxrZsvJCNM9W+afP64u0t0wyTtdn4/Wx8IRuX+7cAAKp4Pxv/mI1vZGNXrWHSWuMP7zv3g3+ajT8WJQDAFC4/1ww/PdcQfbV8Uy1hck823szGV7LRYT8DANPQca4hoiU+P9Wb503x2iPZ+HLRi0eGR9P2fUdS/+DxdPDYSDp6cjSdOn0mnToz5p8AAC4R81pb0ry21tQ9vz0t7epIq3sWpmtWLk6LO9vzb12WjS3ZuD0bD2TjVNHPqzbHZGE2/ikbn82/sHfwRHq9/3B65f2D/jUAgEI3Xb403bB6SVrVs6Do5e9k4/Ob16fjtYRJnCn5l2zcnX/he2/vSy/uHLC3AYCabFy3LH16w8qil57Oxq9ncXJqqjD5Zjbuq9yw+9DxtO2t/vTB0LA9DABMy/JFnemOa1eny3oX5l96NAuTL08WJjEpZUvlhh0HjqZnfrgrnTx12p4FAGZk/ry2dNfPrE1X9nXnX/qtLE6eKAqTuI0nZswuK2/Ydeh4evrV99LwqCgBAGans70t3X3jFWnt+DMnMWn1uixO9scXlbcL/0VllIS4fCNKAIB6iKbY9mZ/fvPSbPx5+YtymFyRjS9Wvismuu43pwQAqKP9R4fTd9/em9/8u1veLbXI+TC5PxvnbzjuHzzh7hsAoCFe2nmg1BoV2s+1SClMYtxb+errew7bawBAwxS0xr1b3k2t5acEry1vPXJiNL26y+JpAEDjRGtEc1SIFrk1wuSOyq3bPzhibwEADVfQHJsiTG6p3BLPvgEAaLSC5tgYYXJt5ZZ4IB8AQKMVNMe1ESarK7ccOzlqTwEADVfQHKsjTBZVbhk5fcaeAgAarqA5FkWYdFRuOX1mzJ4CABquoDk6Wu0WAKBZCBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAANNo8uwDq68GNy+f0z3tj/4m0defRcdvuXNc97uvK1/O/39afDKY3Do+M+97rly84//WeIyNpy9uDNf0un1q5IN33sysnfc+j/7cvPbfvRPrSJ5emX1i/eNZ///LPK6vXz63FOwPD6aHn9vrQgzCB5rX55hVz+udt+cEHE8Jk843L0vWrus5/vePJ7efjI//7RdhUhkn+e+Pn50Mnr/zn93S2jfveIvGesGj+1O+tRfnnldXr5wLCBKiTfUMj4w7ON65YMC4+qrl+SceEg3otobX1sR/b6YAwAYrtHRod9/Wd1/WmNYs70sMv7i98/9c+tSpdtawzLe/uuOj/7nEGKM7yNMJnNvSmZd3tPmAgTIDpHpwrxVmQGNXCJKKkHpc/dgyOTBkF8Z6ZBkQtYRCXlfKXturlxjVdwgSECVxcbjt3WeMf7r5ywsH+a/++c0YHzZjj8dCvrBsfH3uPpd95esekB/9ZB072Z1SKMyr5A/N7B4c/fP/hkfRGlfipR0DUEgb5ybv19FE4owTCBJhzEQjPvHYgbdqwJC3saJvy/XF3Sd6re46NO8OyorMtPbn5mgnv+7sX9jXV3z2iZK4nIAPCBJhC3MZa662sT75+MF3ZM/5swODw6XFf33/z8gmR8+z2Qw27bAIIE+ASdefHegrPMpQvPcXlkbs+0TfuteMjp9O3Xx4Yty3OqtyysvgySlxequXOoNkqrcuSm2NTL1+8dWW6YmmnDwwIE2Am8guexeWZ6fi163pLYfLAz6+Z8NrTrx2YEBoRJfm5MGUx0bXW+SfVHDt5esr3lOa5NCiAYo0XQJgAM/S5G3rHTcDd+uahwvcNZQf88kTXyvdvXLc4/dWmNRMmnA4cHU2Pv3ZwVr/bZGdXqumaP/V8mViLJX9Zql66cpey4uuIv8qVZwFhAlQ58N+27sOl2ePSSywt/+Dtaye891s/Olga4anfuHrc5Yrbr+md8P5//dFA+mD49Kx+v8nOrsxGtctSjRD7Kc5IPVfl7ihAmMAFF89qiWXRi24t3XTV4hndyrpq0cRbZOPnx3Nv8s/Kif/B33vTstLZhcrJqs/vPFL15xfd2lxNnFkpR0xeTJiN1+NMwlzNxajXrdGAMIGPpHiAXLWDfNHZh5mKyytxZiD/rJx4dszGdRMfYveD3cfq8udueXWg6mtxSSPOHhStu9IIcUlpLibUAsIEqKPyZZzZirVRGnl7cPyeOw8O1/TemAj7+CsTIynWXnl4GpNsn/+9j4/7erKF6wBhAkxT+XJKpcqzHPnX4v1FC6zl/c+7R6pewqmXiJLZRkHMrfnrz1454VLSw8/umnWcxWW6OCM21/sFhAlw0SpfTqmm8sAfd7DEZNGhkdPnbyXOz1m52MSk3D/9z/fT33zuqnFzbGLSb+XE36keD1AUIflLdLEc/79tH/ShA2ECzat84L+Qz8qpVdxWm7+DJT9n5WIU806+vm3XrOa5xATmqSYEP/zfe2Z9dxIgTOAjbbYTTyNUpnO7bYTMw7NcOK0RIq7Wfr8/feGWFTU9L2i64u9t/RIQJgA1K6/PUrTo2ktTRMVkS9vHvBxRAsIEYEYiSvLrx8T6J9O9DBMx49INCBOAGYu7dP5o09pxl3Nifs5Ul58iZvKXxJr1shUIE6BpxdyKrY/9eNL3xB0nX/q51ZO+J+44+cp3dlz0Zwjuv3n5hDkmf/m9PTXtx81ZwFROgL37E32lZwQ5awKN02oXwKUlHso3VZSEWAck1gOJMw4Xq1ie/64sJiqVnnJc42qx+VVuI3AidABhAhedWJm0mURgxC3MRcviP7v9UOmAfaHjZN/Q7JeXjxiJO5M2b+hJD/7imnGvxRL2+UsxsdpsNXHWJPZNpQid+PlAY7iUA3VWfojflX0LLsifX140Le8zG3pLz9cpipI/3Hb20sZQFlP5synlOHnqhwNpsCC2YhJpLWcg4jLIjWvOXhaptv5KRNOz6xZP6/be/Now8bTfauuPPPK/Z/+eERblybBT/VnffnlgQszF3JMHssiJ/XnbFJfNAGECF9RkD/GbC0WLplUTz7556Lm9578uL61eFCeVq6ZWKl0aqWFCaARALfulEWuOlAOsHDARJdX2Uf5MV0RXfG8+TooiD5g9l3JgDsXZhWbxre/3j4uSyjiJ12ZjsIbJoXO5L+ISTpz5qMXLeyY+hTm+d7JLPkD9OGMCcyT+113rpMuiA33+4Xu1PHgvr/z03q1vHpr0gXYRJ3FZ57c3rpzRmYFYfKzoLEP+TEScsdm0YUldz5LUskx/LJxWNKem2nOC4ne9Z8v2dMvKBT7I0GAtT7wzNla54eH/cL0UZiMmX/bkJovWOg+jGcXE18kOyBfz3w248B785Y+P+9oZE6izj9pS5bFmx8X+UD/g4mGOCQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQBAncxr9l9wbGwsHTt8IBsH0/CxoXRqdKS0DQCYWmtrW5rX0ZHmL+hKXUv6srE0tbS0CJOZiBgZ2L0jjZ4c9skCgBk4c+Z0Ghk+URpDhwZS+/zO1HfZutSdRUpThlRT/lZjY+nA7p2p/503RQkA1FEcV/e+81bpOJua8ApEU4bJgT3vpUP7dvv0AECDxHE2jrfCZApHDx8QJQAwR3ESx11hUkVMah14/12fFACYI3HcbaabSpoqTI4eGijddQMAzI047sbxV5gUiLtwAIBL9/jbVGEyfPyoTwcAXMLH36YKk9Ojoz4dADDnx9/mmUbRZJNfz/h0AMCcH39NfgUAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECZ2AQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGFiFwAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmdgEAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMLnwv0xbm38RAJhjLS0twqRI27wOnw4AmOvjb3vzHH+bKkzmL1jo0wEAc6xzYbcwKdK1ZKlPBwBcwsffpgqT7t5laV67yzkAMFfiuNvd2ydMisTkm2Vr1/uUAMAcieNuS0vz5EDT3S4c1da78jKfFABosDjeNtPZkqYMk9C35orUs3y1TwwANEjP8lWl422zmdeUe6ulJS2/fH1asGhxOrB7Zxo9OewTBAB10D6/M/Vdti51L+lryt9vXjPvvNhpXT1L09FDA+nY4YPp5PGj6dToSBobG/PJAoCa/q/fUprgOn9hd+num7jRpJkWVLuowqS8QxctXV4aAMBHm2flAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAgIlhMlK5oa21xV4BABquoDlGIkyGKrd0tDmJAgA0XkFzDMWW/sotXfPb7SkAoOEKmqM/wuStyi1LuzrsKQCg4Qqa460Ik5cqt6zqWWBPAQANt7pnYX7TixEm2yq3bFjRY08BAA13zYrF+U3bIkyez8au8pbFC9rTTZcvtbcAgIaJ1ojmqBAt8kKEyZlsPF75yg2rl9hjAEDDFLTG45vXpzPl+3S+kSrWM4l5JhvXLbPXAIC6i8bIzWkdOdci51d+jdMnf1v5jk9vWJmWL+q09wCAulnW3VlqjJy/37z+7LSSypVN/iwbByrftena1amzvc1eBABmLZrijutW5TdHe/xJ+YvW3At/UPnOtb0L069+cm1qtxosADALHfNaS02xtrcr/9JXN6//8MRIyxPvjOXf8M1s3Fe5Ydeh42nbW/1p/9CwPQsATMvy7s606brVpRMeOY9lUTKuOYrCJJZh++ds3J1/4btv700v7TxgDwMANbllXV/6pQ2ril56Ohu/mYXJyFRhEiJpnsrGnfkX9g6eSK/3H06vvH/Q3gYACsU6JXFLcJUV5Z/Jxj1ZlBzPv1AtTEKsevJIyl3WKRs8MZJ+8sFQ6h88ng4eG0lHT46mkVNn0pmxMf8aAHCJaG1pKc0f6Z7fXnr2TSwz/7EVi1LPgqrP3ns0Gw9kUTJa9OJkYVK2+VygWNgEAJipgWx8NRtPlOJifZXQqeEHbcnG9enspNgR+xUAmIaRcw1xfTlKJlPrfcBROfdn4+psfD0bu+1nAGASu881w9XnGmKglm+q5VJOtaC5NRt3ZOOWbGzIxtpsdKezc1MAgEtDzBU5ms6uIv92Nl7Kxn9l44V09nl8hapdyvl/AQYAVOAKyrWfc2EAAAAASUVORK5CYII="

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyQ0I2ODYzNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyQ0I2ODYzNTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJDQjY4NjMyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJDQjY4NjMzM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IMkNPQAABoZJREFU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"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiYAAAL4CAYAAABP+jwZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNkE4MjEwNjNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozQzNFNkNCQTNGNUYxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM2QTgyMTA0M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM2QTgyMTA1M0Y1RjExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jGVjpAAAGdJJREFU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TAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTGwCAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwsQmAACECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAQJgAAAgTAECYAAAIEwBAmAAACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIACBMAAGECAAgTAABhAgAIEwAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAABhAgAgTAAAYQIAIEwAAGECACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJACBMAACECQAgTAAAhAkAIEwAAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABAIQJAIAwAQCECQCAMAEAhAkAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgCAMAEAECYAgDABABAmAIAwAQAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABg1YZJ1/Sk3wgArLTpaWFSaeqINwcArLCuDtr/dlSYdB/9qXcHAKz4/veQMKnSM/6idwcArOL9b0eFSe/4gdQ1NeEdAgArJPa7sf8VJlWmp1PfyG7vEgBYITP7XYNfG+sZfyGtGXvWOwUA2iz2t7Hf7SQdOY/JmtHh1PvT57xjAKBNYj8b+9uO+746c3PFKZ2nUs/ESJpYtyVN9/R7BwHAMuiaHE99o3s67khJh4fJrNhoL5t4MR3tH0yT/aelqd6BLFL6YrN6ZwFAi3/sd01OpO6jYzNX38wMdO2gMSUnVJjMbs/p1Ht4/8wCAJzc3CsHABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAECYAAMIEABAmAADCBAAQJgAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAAwgQAQJgAAMIEAECYAADCBABAmAAA1IfJRHFNj60CAKxAhdQ1x0SEyUjxSf02FACwAmFS1xwjESbPFFb1rbOhAID2q2+OZyJMHiusWrvRhgIA2q++OR6LMHmgsGrduTYUANB+6zaX1+yMMPlmYdXgpTYUANB+g5eU13wzwuS+bNkzv6p/Q0pnb7exAID2idaI5jgmWuT+CJOpbPls4clnDNlgAED71LfGZ9PQjqnaBGufSPn5TGKcyaarbTQAYPlFYxTHtE7Mtcj8zK9x+ORThU/a+rqUBs628QCA5TNw1mxjFH0mDe3Ykw+T8MFs2V942vlvSKl3rY0IABy/aIqfe2N5bbTHX9Q+6C498MeFp67fmtJFv5VST5+NCQAsXU//bFOcurX8yK1paMf+qjAJn8+WTxbWbLggpW1vcVoHAFiaOH2z7cbZpii6LYuSz+VXVN1d+NZs+XJhTRw5GXpnSpuusnEBgNZFOwz9wWxLFEVr3FJe2TX98B2VbZMtX8yWHXWPjD6d0r5dKe3daWMDANVinpK4JLh6RvmvZMuNaWjHWKthEtZky8ey5V2Vj46/mNKBx7JQGU7p8P6UJkZSmhxPaXrKLwMAVouu7tnxI33rZ+99E9PMD25Lqf+0Rp8RQ0ZuyaLkSNWDvU2+VHzCu7Pl7rlAOaPwaHxBp3YAgNbsS7PDRf6l2ZO6W3ihGBAbN9D5+5SfhA0AYGETcw1x6UJR0mqY1CrnPdlyYbb8VbYM284AQBPDc81w4VxD7Gvlk5qNMVkoaK7MltdmyxXZcnG2bMmWdWl2bAoAsDrE0I/RNDuL/A+y5YFs+Ua23J9m78dXbWhH5er/F2AAstWqWoT5nd4AAAAASUVORK5CYII="

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNEJGOTMyMTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowNEJGOTMyMjNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0QkY5MzFGM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA0QkY5MzIwM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8++YKmbwAABkhJREFU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"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5ODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5OTNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjk2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjk3M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MTGWBAAAFjdJREFU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CQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAIAgAQAECQCAIAEABAkAgCABAAQJAEAEyWh+w6K2drMCALRMSWuMRpAMTLpRe7eZAgBaFyS1rTEQQXIov6Wte7mZAgBapqQ1DkWQPJPfsrj3EjMFALRMSWs8E0Hy0/yWjos2mykAoGVKWmNPBMkj+S1dl15tpgCAlilpjUciSP4zGweqWxb39KUlm28yWwBA00VjRGvkRIPsjiAZz8Z9+T3dG95kxgCApitpjPvSmu3j1QujfSHlrkfScdHrUs/W7WYNAGiaaItojJzRiQZ57Uqtcbjky/lb9L7+3al9xXqzBwDMWfvySyttUfDVtGb7gXyQhD/PxtH8rZZddXta1NFjFgGAWYuWWHbVjuLmaI4/q37TVtjxR/lbdvRtTSuu+1Ba1N5lNgGAmcdIe3elJTr6Lyvu+mRas/1oWZCEB7LxpfyGzouvTCt/6+PevgEAZqR9+bqsIe6qtETBvVmMfH1SuJw+9FDxRp3Z+EY23lHcMfjkt9PQc7vMMAAwpVjAWrJmJDyYjduyIBmdLkgq95ONb2bjbcUdJ1/+RRre/5N0Yt+jZhsAmCSuMxKn9hbOpqn6XjZuz8ZQFiSpkSAJHdn4XDY+Urbz1NDRNPLC41mg7EunBl9M48PH0/jYcErjp/w2AOB817Y4tbV3p7buFZXPponLwccVWAsXPcuLJSGfyMbJynczCJKq90yESb/ZBwBm6EiKBawp3T9payFI2hq4o1joekU2vphyF08DAJjC6EQ7XFETIyXaGrzTqJuPZWNLNv4mGwfNMwBQ4uBEK2yZaIcjjfyhRt6yqRcy12fjlmxcm41t2YjzgnvTmbUnAMD5LdaCDKYzV3t/Nhs/zcb3s7E7nfmcvKkV3rL5fwEGAEDIMmUyEQC5AAAAAElFTkSuQmCC"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RTU2MkY5QzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RTU2MkY5RDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlBM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVFNTYyRjlCM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+uB+DYwAABmJJREFU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"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwNzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwODNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTA1M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTA2M0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+E7Z1owAAIPNJREFU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qHeP1TF2xxi+OYKk2cyvxtoqrlr3MSsxAgDrKEpm13TmY3Y2dscYXryeyYYNkrhr7/S1qfal4GdnRoQIAKy/MJmZKWmP2zGGx1i+4YPk6vjZ2eNT9Zp1IwCwnmOkYszOx/IVtuIXRpu8+F5rkUz7vjSte9PUdAgArMMuaXbuI5c6QVLPx/KVtuIzJNcvX25fAK7zxCqKDABY+xqZ+XP3uJ2P5Rs9SKavTZZCpFZ6CwCskyrpftsOk3ws3+hB0pxuzD65TpiYGQGAddokxbG6VhrLN3KQdO4oqEEAYIPFSStM8rF8owdJ9bMDANZ3iayuup0OAKy1VQwSMyMAsLGs3ththgQAWHOCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAAQJAAAggQAECQAAIIEABAkAACCBAB4PwVJ094GgA1l9cZuMyQAwJpbgyAxUwIA69vqj9UrHiS1WvYjmk0dAgAbsUuyMTwfyzd8kAzUZ59VJ0ya6gQA1meEFMfqZmks38BBMjA0UpohaZbeAgDrpEa637bDJB/LN3qQDG7bNlta5UM3ZkoAYJ20SLO7Swrjdj6Wb/QgGRndmT2fRrY1U+d/4glqEQBYh01SGK/zsTsbw2Ms3/BBsmX32GxlNZqF4mrOLTIAYI1KJHWP0YUxOx/LN3qQjNy0Kw0MDWdPqNHaGmIEANZ1lORjdWvcjjE8xvINHySpVkvbbz2QPadGtnWmf1pPtClMAGBdhEhxbM63GLOzsTvG8BjLN36QZEYPHkr5U2k0CltnLYkoAYC1j5H2zEhhrK61x/DVsCpBMrhla9q+77astKbbWyNfJGM9CQCsbYwUx+L8JJT8iEZrvN5+6235GL5pgiTs/sCRVKsPzFRXs73NHLoRJQCw6jEyc6imMy53ZkeyMXv34SOr9iutWpDUh4bT2D33p+b0dL6l2EpR0izXGgCwvCFSOExTjJE8RNpjdGxj99yXj92bLkjC9n0H0o44dDN9vRAm2Y6YbnTNnCRhAgArEiL5rEhhJiQfg/OxuBMj1/OxOpZarKbB1d4nNx95IE1PTqYr42c7eynbBvK3+c176rXsT+0b8tVqrYW9+U6s+Q8KABZfIzNNMhslrZNLOmtGZmZGrk+nrbv35GP1alv1IKnV6+mWBz+U3nn+B+nq+XP5fqpFuNWz/1PP/5BFSCtGYmvOnGrUXJXTjgBg87RIs/vPzcIZroU1I52ZkbgAWozRMVZv+iDJo2RgIO394GPp3Ms/TpdOn2jFRjNmRQZmZkZipiSfIYmZkbxDaoVJEmECAPOUSOFNs/2/s6f2zgbJ9EyQxGGam+99oHW0Yg0MrtWuiic8dvShtGXXWDr36oupcf16a4ak3jpskxrtt6k2OzNihgQAFtElhXUjafYKrM3GbJDU6wP5eLzaa0bWTZB0xELXLWN70vnXX0kTb59o1VpESRRa+7BNa0upe5ak/T4A0CmQ0h+bM3funbnERnvdSIygO269Le06fKR1i5c1Nrgedl/siLGjD6addx5OF4+/kS69fSo1rk21Q6Te6g6zJACwiDYpnrGaZi5IGqfyju4/mEYP3rlqFz3bMEEy88tkO2b33fel3YePpskL59PV8bNp8uJ76fqVy/mZOfmim+Q0YABYSL4Kc2AgDYxsSYNbt6WR0Z35otX8Rnnr8MX94Prci7U0snN3vgEAm1/dLgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBAkAAAgsQuAAAECQAgSOwCAECQAACCxC4AAAQJACBI7AIAQJAAAILELgAABAkAIEjsAgBgPQTJVPGBoXrTXgEAVkxFa0xFkFwsPrJ9QJAAACunojUuRpCcKj4yNtKwpwCAFVPRGqciSF4uPnLHtuv2FACwYipa4+UIkh8UH3lg5zV7CgBYMQ/ObY2/iCD5VvGRT++9ak8BACvmU3Nb41sRJM9k2/HOI/u3Tqcnb79sbwEAyy4aI1qjIBrk+xEksbLkd4of+dz+K/YYALDsKhrjd9K+xxudC6P9dipcj+T+m66lLx6asNcAgGUTbRGNUTDVbpCZK7XGdMl/KX7Gl+65mO4edcYNAHDjDu+4nrdFyX9N+x4/XgyS8K+y7Wzxs379yIU0OuS6JADA0kVL/Pq9F8oPR3P8i8479dIHvlT8zEd2T6V//eB7aaurtwIAS7B9sJm3xId2T5U/9E/TvsfPVgVJ+Fq2/afiAx8bm0z/7pFxh28AgEW5e8f19G8/OJ63RMl/zmLkd4sP1Jqnvln+pOFs+x/Z9kT5A195dTR99dh2exgAmNevHJpIX567ZiR8Pdv+RhYkUwsFSdiWbf8z2z5X/sCLF4bSH53amp56a5u9DQB0ieuMxKm9pbNpOv4w276QbZezIEn9BEkYyravZNs/rPrgySsD6dvvbEkvvDeU3rw8mN6drKfL1+vpuuUmALDpDdZS2jbYSLeMNPJ708Tl4D+592o60H3Rs6JYEvLlbGuVyiKCpONvtcNkj90PACzSmRQLWFP6atejpSCp9/GNYqHrfdn2H1Ph4mkAAPOYarfDfXNipEK9z28adfNr2XY4234z207YzwBAhRPtVjjcbocz/XxRP4dseoXMR7LtM9n2aLYdybaD2bYjtdaeAACbW6wFuZRaV3t/Jdt+kG1/km3fT6375M2vdMjm/wswAOFHcKYGBK+BAAAAAElFTkSuQmCC"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0NDk4QTUwMzNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0NDk4QTUwNDNGNjAxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0OThBNTAxM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQ0OThBNTAyM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/IKTpgAABoJJREFU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"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiQAAAL4CAYAAABLD+wkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFGNzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGODNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU1REU2MUY1M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUY2M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xBVG6wAADz5JREFUeNrs3U9sVVUewPHD62tLrXVaCppaamRqJCXOwiBuR91NYnRhojHjyiHB/2tjjBvduFYTHYkrZ3SSWU0y28GZpUjGhYKYICbQaYZ/VaCUvrYPz6+84u3lSl+lLyb4+SS/Bee+9iXnbb65vZy34f2Dl9LPUMuzK8+Dee7Lc3ee0Tz9eXoTAHCjm8szk2cyz9d5PsuzL8/+PM3Vfnj3xMp/19f45lvzPJ/nj3nGfBYA8KvV25pNeX6X57HW+rE8f8nzTp7j7f6yWpuvG2794iN5XhYjAMBPGGu1wpFWOwyvV5A8nuerPM/l6bHPAEAbelrtEA3xxGovrq9y7a08z1RdnJ1rpP+dmk7T52bSzOxcujg3nxaazdRsNn0EAHCDq9VqqZ5nY2936u/rTUMD/en2zUOpr/eqexeb83yc54E8L+ZZWEuQ3JTnb3keLl/4LgfIsRNn0rdTJ30aAPArFTcgGjELC+nszGyaOvVdOnh0Mt05siWN3bopDQ70l38kbnDEs6hxt+RCO0ESax9VxUi80ZHJ//sUAIBKccMiZnz0trRj22j58sOtxogHYFfcKal6huTtPI8UF86cPZ/+8/lXYgQAaEs0w7//e2ipIUoeabVGulaQxG2UPcWFk9Nn06cHj6Tvz1+wuwBA2+JPOdEQ0RIle/YeSk/+VJAMl4vl9Pfn04HDR9P8wqJdBQDWLBoiWiKaouTtHCVbqoLkjXT5SdgrvvjmmBgBAK47SqIpSuJAtdfLQXJHnj8VXxUPsMatFgCA6xVN8eXRqw5ufXrvoaUGuRIkz+bpXr4aZ4t4gBUAWE/fTJ5YaoyC7laDLAVJzFPFq8dPnLFrAMC6q2iMp/YeSrXlb+3durx64WLDoWcAQEdEY0RrFESD7Iogeai4OnV62m4BAB1T0RoPRpDsLK6U/rYDALCuKlrjvgiS7cWV+KI8AIBOqWiN7REkI8WVi415OwUAdExFa4xEkAwUVxYWHYQGAHRORWsMRJD0FFeazUt2CgDomIrW6KnZFgDglyZIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAIEgAAEECACBIAABBAgAgSAAAQQIAEEHSWLFQ22BXAIDOxcfVrdGIIDlXXKl3ddkpAKBjKlrjXATJVHFlY0+3nQIAOqaiNaYiSA4XV/r7eu0UANAxFa1xOILkQHFlaKDfTgEAHVPRGp9FkOwrrowMD9kpAKBjKlpjXwTJp3mOL6/ctLEn3TmyxW4BAOsuGiNaoyAaZH8ESTPPh8UrY7dusmMAwLqraIwPd0+k5vLBaO+kwnkkgwP9aXz0NrsGAKybaIvBlc+PNFoNcuWk1rhdsrf4ih3bRtMt/X12DwC4btEU0RYlH+yeuPzYSPHo+NfynC6+6p7fjqXuuoPSAICfL1oimqIkmuPV5X/UShdeKL5y+Dc3p53bt6V6l6+8AQDWLk5ljZaIpih5affEjzdCyqXxcZ73igtbhm5J9++4y59vAIA1iXa4f8f4UkuU/DnHyF+LC1W3Pl7K84/iQlTN7++d8KArANCWaIZoh4o7I9EYL5YX6xW/I554fTLP3/P8oXghHka5ffNgOnbiTPp26qTdBgBWiHNG4r/2Dlaf/P7PVmM02gmScCHPo3neyrOneCHeYPm/BU+dnk7T52bSzOxcmp2bT4uLi6l56ZJPAwBucLUNG1JXV1fq6+1e+m6aOA4+TmAtHXpWFI+ExJ2R+aqL9Wu8V/zAM3k+aYXJ5uLFeEN/wgEAVnEqXX4c5KNrBk4bvygedJ3I826quMUCAFCh0WqHidVipN0gWa6bZ/OM53kzz6R9BgAqTLZaYbzVDqfa+aH6Gt8kTlN7Oc8reXbleSjPzjx359maJx6l7fZZAMANLx7tON9qg6/zHMjzrzz70+XvyVuTHwQYANsFYMWa99MrAAAAAElFTkSuQmCC"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAtCAYAAADV2ImkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4MDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4MTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjdFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjdGM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+o5CrmQAABp1JREFU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"

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(117)
	__vue_script__ = __webpack_require__(119)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\betInfo.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(121)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-e2a4ac6e/betInfo.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(118);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./betInfo.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/betInfo.vue?7661e2a1"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;CACA","file":"betInfo.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.bet-info(v-bind:style=\"content\")\r\n\t\tdiv.record(v-for=\"item in betRecord\")\r\n\t\t\tp.created-time(v-html=\"item.createdAt\")\r\n\t\t\tp.detail\r\n\t\t\t\tspan 玩法：\r\n\t\t\t\tspan(v-html=\"item.playlaw\")\r\n\t\t\t\tspan 下注金额：\r\n\t\t\t\tspan(v-html=\"item.betmoney\")\r\n\t\t\t\tspan 倍数：\r\n\t\t\t\tspan(v-html=\"item.multiple\")\r\n\t\t\tp.bonus-num\r\n\t\t\t\tspan 数字：\r\n\t\t\t\tspan(v-html=\"item.num\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {},\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                betRecord: require('../../data/betRecord')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            betRecord: __webpack_require__(120)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }, {
	        createdAt: new Date().toLocaleString(),
	        playlaw: '单双',
	        betmoney: 1000,
	        multiple: 5,
	        num: 3
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in betRecord\"><p class=\"created-time\" v-html=\"item.createdAt\"></p><p class=\"detail\"><span>玩法：</span><span v-html=\"item.playlaw\"></span><span>下注金额：</span><span v-html=\"item.betmoney\"></span><span>倍数：</span><span v-html=\"item.multiple\"></span></p><p class=\"bonus-num\"><span>数字：</span><span v-html=\"item.num\"></span></p></div></div>";

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(123)
	__vue_script__ = __webpack_require__(125)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\bonusRecord.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(127)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-692cd0ba/bonusRecord.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(124);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./bonusRecord.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/bonusRecord.vue?c765f018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,oBAAA;IACA,iBAAA;CACA","file":"bonusRecord.vue","sourcesContent":["<template lang=\"pug\">\r\n    div.bet-info(v-bind:style=\"content\")\r\n        div.record(v-for=\"item in bonusRecord\")\r\n            p.created-time(v-html=\"item.createdAt | datetime\")\r\n            p.bonus-num\r\n                span 开奖号码：\r\n                span(v-html=\"lotterynum(item.lotterynums)\")\r\n</template>\r\n<script>\r\nimport RequestList from '../../js/request-list'\r\nexport default {\r\n    props: ['zoomRate'],\r\n    ready() {\r\n        RequestList.getBonusRecord().then(res => this.bonusRecord = res.data)\r\n    },\r\n    data() {\r\n        return {\r\n            bonusRecord: require('../../data/bounsRecord')\r\n        }\r\n    },\r\n    methods: {\r\n        lotterynum(nums) {\r\n            if (Object.prototype.toString.call(nums) !== '[object String]') {\r\n                throw new Error('获取中奖结果出错')\r\n            }\r\n            // 中奖数字总共十位数，取第一位和最后一位相加结果的个位数作为开奖结果\r\n            nums = nums.split(',')\r\n            return (nums[0] + nums[nums.length - 1]) % 10\r\n        }\r\n    },\r\n    computed: {\r\n        content() {\r\n            return {\r\n                width: 458 * this.zoomRate.x + 'px',\r\n                height: 580 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.bet-info {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n\r\ndiv.record {\r\n    color: white;\r\n    margin-bottom: 2em;\r\n}\r\n\r\ndiv.record p {\r\n    margin-bottom: .5em;\r\n    margin-top: .5em;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _requestList = __webpack_require__(74);
	
	var _requestList2 = _interopRequireDefault(_requestList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	    props: ['zoomRate'],
	    ready: function ready() {
	        var _this = this;
	
	        _requestList2.default.getBonusRecord().then(function (res) {
	            return _this.bonusRecord = res.data;
	        });
	    },
	    data: function data() {
	        return {
	            bonusRecord: __webpack_require__(126)
	        };
	    },
	
	    methods: {
	        lotterynum: function lotterynum(nums) {
	            if (Object.prototype.toString.call(nums) !== '[object String]') {
	                throw new Error('获取中奖结果出错');
	            }
	
	            nums = nums.split(',');
	            return (nums[0] + nums[nums.length - 1]) % 10;
	        }
	    },
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }, {
	        createdAt: new Date().toLocaleString(),
	        lotterynums: '01,03'
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "<div class=\"bet-info\" v-bind:style=\"content\"><div class=\"record\" v-for=\"item in bonusRecord\"><p class=\"created-time\" v-html=\"item.createdAt | datetime\"></p><p class=\"bonus-num\"><span>开奖号码：</span><span v-html=\"lotterynum(item.lotterynums)\"></span></p></div></div>";

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(129)
	__vue_script__ = __webpack_require__(131)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Exchange.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(139)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-f367a86e/Exchange.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(130);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Exchange.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Exchange.vue?4d705018"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Exchange.vue","sourcesContent":["<template lang=\"pug\">\r\n    //- 兑换 商城 模板\r\n    div.exchange(v-bind:style=\"content\")\r\n        //- img.background-img(v-bind:src=\"backgroundImg\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"bonusMoney\",v-html=\"item.goodname\")\r\n                    img.exchange(v-bind:src=\"doexchange\",v-bind:style=\"exchangeBtn\")\r\n            div.change-button(v-bind:style=\"buttonBar\")\r\n                div.bonus-button\r\n                    img.bonus-button(v-bind:src=\"bonusButton\")\r\n                div.prize-button\r\n                    img.prize-button(v-bind:src=\"prizeButton\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                moneyData: require('../../data/money-data.js'),\r\n                backgroundImg: require('../../assets/切图/商城/内底.png'),\r\n                moneyBack: require('../../assets/切图/商城/块.png'),\r\n                bonusButton: require('../../assets/切图/商城/奖金.png'),\r\n                prizeButton: require('../../assets/切图/商城/奖品.png'),\r\n                doexchange: require('../../assets/切图/商城/兑换.png'),\r\n                moneyImg: require('../../assets/切图/商城/金币.png')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 618 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyblock() {\r\n                return {\r\n                    width: 478 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n                }\r\n            },\r\n            buttonBar() {\r\n                return {\r\n                    width: 260 * this.zoomRate.x + 'px',\r\n                    height: 68 * this.zoomRate.y + 'px',\r\n                    margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            barcontent() {\r\n                return {\r\n                    margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n                }\r\n            },\r\n            bonusMoney() {\r\n                return {\r\n                    width: 150 * this.zoomRate.x + 'px',\r\n                    height: 20 * this.zoomRate.y + 'px',\r\n                    margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n                }\r\n            },\r\n            moneyImg() {\r\n                return {\r\n                    width: 116 * this.zoomRate.x + 'px',\r\n                    height: 108 * this.zoomRate.y + 'px',\r\n                    margin: 0 * this.zoomRate.y + 'px 0 0 0px'\r\n                }\r\n            },\r\n            exchangeBtn() {\r\n                return {\r\n                    width: 90 * this.zoomRate.x + 'px',\r\n                    height: 50 * this.zoomRate.y + 'px',\r\n                    margin: 30 * this.zoomRate.y + 'px 0 0 ' + (364) * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.exchange {\r\n    position: absolute;\r\n}\r\n\r\nimg.exchange {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {},
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(132),
	            backgroundImg: __webpack_require__(134),
	            moneyBack: __webpack_require__(135),
	            bonusButton: __webpack_require__(136),
	            prizeButton: __webpack_require__(137),
	            doexchange: __webpack_require__(138),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: 478 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 35 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: 0 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        exchangeBtn: function exchangeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '10000金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50000金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '10W金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }, {
	        goodname: '50W金币',
	        price: '100',
	        goodsimg: __webpack_require__(133),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEMzREOUUxMjQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEMzREOUUxMzQwM0IxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQzNEQ5RTEwNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQzNEQ5RTExNDAzQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+MrPF1wAAIN9JREFU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"

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAIICAYAAACYbhx1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg4MTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg4MjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjYzODRGODdGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODgwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6e7g8wAAD2RJREFU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AwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6AAg6ACDoAICgAwCCDgCCDgAIOgAg6ACAoAOAoAMAgg4ACDoAIOgAIOgAgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4Agg4ACDoAIOgAgKADgKADAIIOAAg6ACDoACDoAICgAwCCDgAIOgAIOgAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwCCDgAIOgAg6AAg6ACAoAMAgg4ACDoACDoAIOgAgKADAIIOAIIOAAg6ACDoAICgA4CgAwD/f4Je/Y8BAI+Uug26kAPAIx/2chL4etyuSg8A16zb9TiY19MhvUwpndd6usf95AcAgOswhD8wcLet1vDW8hJbv1yeqO2JkykdALiGYV8iPrd7eVx/Waaafj4/UXvM+7heVR0ArlfML2n11AbyaHkEvf5wOjyxlP6yY+oAwNVO5euqLYduLw3/YZvQ/2dc6t6f7CN8dWIcAFyfqPc239fs3vDvl3Gq355iqz0x9trPE/uac1M6AFz5dD5P5ak3um663RoeLS/x4Lv7qd4dlyfmF9YRfjulizoAXEHMT6bzvqu9N7stc8Nr/V4ZxzrFg3/ZL0+mfT2d1i+71g0A+P3E/DCdb/rcWn3odjT8L++8PpX9NKX9OL0ay3nbjsDPyzKpx4dMfUoXdQC4gpjXucXzrvapHjrd+33eGt7eWi7ixVjuXoz1a7Gki3Fqj+fqr7vfpyrqAHAVMZ82u9n3S7OXVs/Nrv/8F3devzsHfR7X44XzcXo5RvQ3zvsb9+2Nrf51M62LOgD8fmPeD4fPTe6Dd2v13Oxx+vL6I+0Yeq/8/MJL8YYW93Sv17/98CHqUz/7fb2gXdgB4HcS8sPZ7POdW3tze8z3vdX3lgE89VZ/4dk7r7+xfsbwZ08+lnJOseS2/kFJ+YmU01PxaPnmlry8sT2uef2xfPJ8ysf/qOz/FwB469P4ZiI/3Jt9PvktzWext8l8Hrz3S8j/d1n/00f+7cdf3X7Ebj7lPd5Y8hRL+/q1/IWo8hOx+UyL83J/95LqMKVdFL3Em4b5F4D5vbFeRvWcj/+BWdYB4CEx33zBSj2up3552rg5Zr7vk/nFHPMx3dtP/xnL5+//zF37DSDHD+R4c14m7PP447nY/Ea89OfrLvaziPrUYh41n6LeZV7qMtlvhvblkR3xAPBmUd/eNGa9A9zh8rTxeALcfCh8Py//Fctz9/bj+QNBn0+BT2uM57q3538Tmx+J5ZX4zBfWg/LTUNIQU/ouL5P6Iepp2WW/lL2azwHgoTE/bqzfmHZyNvsa9OMJcG35xzaZR8wv2sT+YNDr4X5y/Y8yX3weT13Eny/GbwnfGaf6yrgrj7e/YDeVtGuT+rzrPS+73ueY1+WYe5/WAYCHF3392vL1Dq3zZH64Ycxy7DxC/ot2Alwsr/Wwz89fEvT+a0E5Rr0us/p6uvyd+PBvxvKV/ZA/uRvqjW3QSw/64cS67acLOwBcMpofd7NvvgL1NOjjdN6uM4+Q/21M6hH19frz5fK1B4K+XOeWT6K+/CVTH/1L+/BfxPKZizH/QwT9pQj687G8s2yivsY8Zx0HgDfrer3v2PnmRLifzrdkH6fb+/nGb/0s934d+r7fw/2BoM/77/Mm6nn7F+QUPU/7WLcD82cl392N9YvDkL8UIf9ATOkfipi/Pyb098b6VtT87fH2M9M5ADx8So/5+SJi+6vI690YoH80f535VL/Vvmhl+Z6V451b11u9zl/I0s9ru9//CTAAwcI8aGUDpYoAAAAASUVORK5CYII="

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OTRCNTVEQzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OTRCNTVERDNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY5NEI1NURBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY5NEI1NURCM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FIWMwgAAJ/FJREFU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"

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI2RTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI2RjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjczMzVBODg5M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjczMzVBODhBM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Nzdc8AAAB/ZJREFU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"

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAABGCAYAAAANZDwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODcxNjI3MjNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODcxNjI3MzNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4NzE2MjcwM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NzE2MjcxM0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+QQjJUwAACBpJREFU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"

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDg5RkQxOTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDg5RkQxQTNGNjExMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVFNTYyRjlFM0Y2MDExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY0ODlGRDE4M0Y2MTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CgsFFAAAC2RJREFU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"

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = "<div class=\"exchange\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"bonusMoney\" v-html=\"item.goodname\"></div><img class=\"exchange\" v-bind:src=\"doexchange\" v-bind:style=\"exchangeBtn\"/></div></div><div class=\"change-button\" v-bind:style=\"buttonBar\"><div class=\"bonus-button\"><img class=\"bonus-button\" v-bind:src=\"bonusButton\"/></div><div class=\"prize-button\"><img class=\"prize-button\" v-bind:src=\"prizeButton\"/></div></div></div></div>";

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(141)
	__vue_script__ = __webpack_require__(143)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\Recharge.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(153)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-9e1d8b66/Recharge.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./Recharge.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/Recharge.vue?4d573667"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;IACA,mBAAA;CACA;;AAEA;IACA,WAAA;CACA;;AAEA;IACA,aAAA;IACA,mBAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;IACA,oBAAA;CACA;;AAEA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;CACA;;AAEA;IACA,YAAA;CACA;;AAEA;IACA,YAAA;IACA,aAAA;IACA,WAAA;CACA","file":"Recharge.vue","sourcesContent":["<template lang=\"pug\">\r\n    //- 兑换 商城 模板\r\n    img.recharge-record(v-bind:src=\"recordImg\",v-bind:style=\"recordImgStyle\")\r\n    div.recharge(v-bind:style=\"content\")\r\n        div.background-img\r\n            div(v-for=\"item in moneyData\",v-bind:style=\"moneyblock\")\r\n                img(v-bind:src=\"moneyBack\")\r\n                div.barcontent(v-bind:style=\"barcontent\")\r\n                    img.money-img(v-bind:style=\"moneyImg\",v-bind:src=\"item.goodsimg\")\r\n                    div.bonus-money(v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\",v-html=\"item.goodname\")\r\n                        //- 副标题\r\n                    div.bonus-money.bonus-sub(v-if=\"item.sub\",v-bind:style=\"bonusSub\",v-html=\"item.sub\")\r\n                    img.recharge(v-bind:src=\"dorecharge\",v-bind:style=\"rechargeBtn\")\r\n    div.my-money(v-bind:style=\"footer\") 我的金币: {{userinfo.money}}\r\n</template>\r\n<script>\r\nexport default {\r\n    props: ['zoomRate', 'userinfo'],\r\n    ready() {\r\n\r\n    },\r\n    data() {\r\n        return {\r\n            moneyData: require('../../data/exchange-data'),\r\n            recordImg: require('../../assets/切图/充值/充值记录按钮.png'),\r\n            moneyBack: require('../../assets/切图/充值/块.png'),\r\n            dorecharge: require('../../assets/切图/充值/充值.png'),\r\n            moneyImg: require('../../assets/切图/商城/金币.png')\r\n        }\r\n    },\r\n    computed: {\r\n        recordImgStyle() {\r\n            return {\r\n                width: 136 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        content() {\r\n            return {\r\n                width: 495 * this.zoomRate.x + 'px',\r\n                height: 618 * this.zoomRate.y + 'px',\r\n                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyblock() {\r\n            return {\r\n                width: '100%',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'\r\n            }\r\n        },\r\n        buttonBar() {\r\n            return {\r\n                width: 260 * this.zoomRate.x + 'px',\r\n                height: 68 * this.zoomRate.y + 'px',\r\n                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        barcontent() {\r\n            return {\r\n                margin: -110 * this.zoomRate.y + 'px 0 0 0'\r\n            }\r\n        },\r\n        bonusMoney() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusMoneyHasSub() {\r\n            return {\r\n                width: 150 * this.zoomRate.x + 'px',\r\n                height: 20 * this.zoomRate.y + 'px',\r\n                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        bonusSub() {\r\n            return {\r\n                fontSize: 14 * this.zoomRate.x + 'px',\r\n                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',\r\n                borderRadius: 10 * this.zoomRate.x + 'px',\r\n                // width: 150 * this.zoomRate.x + 'px',\r\n                // height: 20 * this.zoomRate.y + 'px',\r\n                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        moneyImg() {\r\n            return {\r\n                width: 116 * this.zoomRate.x + 'px',\r\n                height: 108 * this.zoomRate.y + 'px',\r\n                margin: -2 * this.zoomRate.y + 'px 0 0 0px'\r\n            }\r\n        },\r\n        rechargeBtn() {\r\n            return {\r\n                width: 90 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'\r\n            }\r\n        },\r\n        footer() {\r\n            return {\r\n                // width: 136 * this.zoomRate.x + 'px',\r\n                fontSize: 34 * this.zoomRate.x + 'px',\r\n                height: 50 * this.zoomRate.y + 'px',\r\n                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n\r\n    }\r\n}\r\n</script>\r\n<style>\r\ndiv.recharge {\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge {\r\n    z-index: 3;\r\n}\r\n\r\ndiv.my-money {\r\n    color: white;\r\n    position: absolute;\r\n}\r\n\r\nimg.recharge-record {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nimg.money-img {\r\n    position: absolute;\r\n}\r\n\r\ndiv.barcontent div {\r\n    float: left;\r\n}\r\n\r\ndiv.bonus-money {\r\n    position: absolute;\r\n    color: white;\r\n}\r\n\r\ndiv.bonus-sub {\r\n    background: #f26a30;\r\n}\r\n\r\n.background-img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\ndiv.background-img {\r\n    padding: 1%;\r\n}\r\n\r\ndiv.change-button div {\r\n    float: left;\r\n    height: 100%;\r\n    width: 50%;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: ['zoomRate', 'userinfo'],
	    ready: function ready() {},
	    data: function data() {
	        return {
	            moneyData: __webpack_require__(144),
	            recordImg: __webpack_require__(150),
	            moneyBack: __webpack_require__(151),
	            dorecharge: __webpack_require__(152),
	            moneyImg: __webpack_require__(133)
	        };
	    },
	
	    computed: {
	        recordImgStyle: function recordImgStyle() {
	            return {
	                width: 136 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 28 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        content: function content() {
	            return {
	                width: 495 * this.zoomRate.x + 'px',
	                height: 618 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyblock: function moneyblock() {
	            return {
	                width: '100%',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: '0 0 ' + 16 * this.zoomRate.y + 'px 0'
	            };
	        },
	        buttonBar: function buttonBar() {
	            return {
	                width: 260 * this.zoomRate.x + 'px',
	                height: 68 * this.zoomRate.y + 'px',
	                margin: 52 * this.zoomRate.y + 'px 0 0 ' + 105 * this.zoomRate.x + 'px'
	            };
	        },
	        barcontent: function barcontent() {
	            return {
	                margin: -110 * this.zoomRate.y + 'px 0 0 0'
	            };
	        },
	        bonusMoney: function bonusMoney() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 37 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusMoneyHasSub: function bonusMoneyHasSub() {
	            return {
	                width: 150 * this.zoomRate.x + 'px',
	                height: 20 * this.zoomRate.y + 'px',
	                margin: 32 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        bonusSub: function bonusSub() {
	            return {
	                fontSize: 14 * this.zoomRate.x + 'px',
	                padding: 1.5 * this.zoomRate.y + 'px ' + 6 * this.zoomRate.x + 'px',
	                borderRadius: 10 * this.zoomRate.x + 'px',
	
	                margin: 70 * this.zoomRate.y + 'px 0 0 ' + 151 * this.zoomRate.x + 'px'
	            };
	        },
	        moneyImg: function moneyImg() {
	            return {
	                width: 116 * this.zoomRate.x + 'px',
	                height: 108 * this.zoomRate.y + 'px',
	                margin: -2 * this.zoomRate.y + 'px 0 0 0px'
	            };
	        },
	        rechargeBtn: function rechargeBtn() {
	            return {
	                width: 90 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 30 * this.zoomRate.y + 'px 0 0 ' + 364 * this.zoomRate.x + 'px'
	            };
	        },
	        footer: function footer() {
	            return {
	                fontSize: 34 * this.zoomRate.x + 'px',
	                height: 50 * this.zoomRate.y + 'px',
	                margin: 710 * this.zoomRate.y + 'px 0 0 ' + 25 * this.zoomRate.x + 'px'
	            };
	        }
	    },
	    methods: {}
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return [{
	        goodname: '500金币',
	        price: 500,
	        sub: '',
	        goodsimg: __webpack_require__(145),
	        goodsnum: 200
	    }, {
	        goodname: '1000金币',
	        price: 1000,
	        sub: '',
	        goodsimg: __webpack_require__(146),
	        goodsnum: 200
	    }, {
	        goodname: '2000金币',
	        price: 2000,
	        sub: '+188金币',
	        goodsimg: __webpack_require__(147),
	        goodsnum: 200
	    }, {
	        goodname: '5000金币',
	        price: 5000,
	        sub: '+888金币',
	        goodsimg: __webpack_require__(148),
	        goodsnum: 200
	    }, {
	        goodname: '10000金币',
	        price: 10000,
	        sub: '+2888金币',
	        goodsimg: __webpack_require__(149),
	        goodsnum: 200
	    }];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Mzg0Rjg3OTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Mzg0Rjg3QTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjQwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjYzODRGODc4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+3Q/9KQAAEj9JREFU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"

/***/ },
/* 146 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzRjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjNDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjNENDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Z4g2cwAAGIhJREFU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"

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzQTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzQjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDQTNGNjM4NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDQTNGNjM5NDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YbZkgAAJTdJREFU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"

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQjUwMkFGRDQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQjUwMkFGRTQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZCNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQUZDNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+L33IaQAAMdZJREFUeNrsfQecXWWd9vOec26fO71PyqSHAEkIJUDoRVQQEBELsiqf4roqlhWwrKyrgqu7spbV/VzURXFXUcQOKyBFEZBOIAkZkkkyvdc7t53yfs/7nntnboZpaUD45uR3cu4999T3+Zfn/3//7ztCSon55bWzGPNNMA/o/DIP6PwyD+j8Mg/o/DIP6Dyg88s8oPPLPKDzyzyg88s8oPOAzi/zgM4v84DOL/OAzi/zgL5GF+u1/HKBQOBgXk7sw7EHrWrAtu15QF8mAMUMAIpDBfA8oAcOpDgA8OWk3+U8oK8MkOIAzK6cQYsPObDzgM4MpphmO5PJldNsxTSf5wE9RGBOB6SYBdiZgJQzaOghAfU1BehxYlI7Wy99vUWOU1sMLGe81ugBVZZAFVu10jSxgGuExDjONWYYKGKTB6XUoV2QTS/kNCbXcWE7DhzpcZVIcpvyPAzxp15u92Q9dPAiPfy+cwTY0WJZPYcK1P9vNLTecd60JIb3NSzB6ekESkaTQHklEAoDJlvBdQFPIWepcIctbUIjaHDryQl9m6x26gvBVKDqrcetywupcucIUXS5r38UyKaAkogO/AeXpZ1Hm0ZwBy/9PwQ3dTBBFa+lQuvJGvosNbTBcU6KAzeefhzOKImykYuAsTSBCwFhrtQgDZpqBQWEAsTLAaf2U2vHF3WsICJS3Ucdw7ZTzae+GqbQ6qbO9/WOqs1jDX42DV9ghgb4nQDH+D3Aaz3ShJYnenBDr2XdPB2o+xqHvuyAvsQsTuPU1GtQdONUlgVs00Vsjwq2QQV/q2J7NBjKTBKXgIkyNlyYjVZCAMK8vHqhkMor8EOQ30MBK3dPoqFur/HQr21okNQNLSInLAOBsIlAyKTmWogVBait3BfgRSIBCkMAkqg7WZuX4o1oW6Xn+MASMc/NQt9eusimk5CO5wuB8LU+TGuQpDAN0RhX8vu6amBLN/DjJ/C/JcC7miyr/zUFqHJWfF+TfuaK6gAuaKzHmU4a5b1sgAqax7AyWUb+RX0XGQr5jZV3l9NdfvJrqu/ZbM5cOr4GqSWrrqsA4OcMfx+guUwmaLIrlbYKDLsm3CABKTe15vk2mIBSNVVbKo1UGi402P591CMpTVfPKHy5Qnu//7I3vhXY2g585rdopW8/a4dl7TjsAc3vIVN4X2UQf3/yBqxW5lE18iDBDBLIeNw/Rvk77bdc3z+pY9Qr5P2cZU34upcAmduffwStrYYvJPnrKDOrvlNZtfl0FPAZgkuf63FbFqMQ8Zjn9gCjfK41SwUi4ZzZzZlYy5IabKNgn7qlBjtn1hXAPXy3gTbghkuA3/4V+MIfMERNPXq7ZbUdtqm/nHldRDC/f+YanHP6CTRJwwJZacGi+Vt5jEWiIrSJM9g6aqs0xeI+KxDSDal9nueDpU1oXi2k/1HmfFueVrqOrU+Q8H2h62T1wYIXszNpOGxEmT9X+o2vNLe7j1sCS1nD5acDrb3ADx+k5SgJojhq8XxfJS2ljaZPjx0+kNJWj/sdd+KBbMd/nhf44slh4NZPRtA1ki39ziPu3esc58hnlVQcDqSoUEPVC7N9Tqf1+cVHL11dcdoGFw83uahduQaLGgiqbSKdMZBOOTR7WWQyDuysi0yaPkx7K5o/Ze7oq9Q+j41nZ9XnLEFxSXIIOlVFfXfttBYG9c9zbd2wHn2dR3vr2lley28HO53W3x13Qrvzpj0S8cHd0wUMk+C8eR394HLgX37L32pK8aZTq2GSGhvKUhjC99FUfcl72HxG9UyeFHpfOs04h/tcKbSpvnBTBAsrBa77Vg/u2pb+SbtlvfOw0lDhk56zaXX+94YPn2oduboS//DlR1BZFUFtx3Y8OJJiQ7o0U65ugGzG5qriAocAuSQtSgM8bTKDgQlTizzpyZERmQs/lJkUOQZbaIql8CmUZqg5OpUjsXmyOr4os5ziQ9eW0vTS4d2xhaalDrj5KuCDNw/hv+8cxscvJoGyfD8cJqEK89kCvGCU2yC11jQDBJ2CxocK0NI4nonhhId0YhQZYTEQVpYD5x02YYvS0JyZ3dgKPPzlD59jXHHlqfjY+7+KiroxRAmQsoiKEWpfltMOK1Dg83Jm1s2ZrbzJ9eTeAOSJj8QE6cmzXHXtvLHIEy0dYli58GRSPkgU+uScOR+heXn8ceBTrycVLwc+8F2gk8+0bonQWhriM0dIoIgjYiFJKs4t3yucA1zdL87fj1oILQRfvh24sxnP1gKXPGNZzYcNKeJ7lO0Ctn34ko01//j19+Lycz+JzEgCRx4JJFJ+o6n3kCgI+qXfrC5VzlFMRSqfamkTajF2UX2fJs2rSz+lj3elNmWOMwGo+s1h2OFxtW2PYPu+TaUU1PUNw/d/piH1fnV8jsSOm+A8Acvm2rmTlLyGoNx6TRBjBPiqb2cx5CmrIcaJmKGFjs/uBBENOTTHUsetrfSdHz3TwfvPAa69hRr/Ih4oF+J1O03Tycelh4PJNcktfnbRGZtqPv+L72Fw13asO/VclNPUOo5SPT+WswJBNqyHKG1VmPFKhKIeUvFgkD6I6miSgISU9KtTnBSEl+bxPo2UWl09HQ+qa8ncZ7V1yEaUCVf+TPs0fnaJluv65yl/LCgoyufZRE357QzP0f7blvq4NE1+kj5bCYWyGINJD00jEZx9TBDXXT6Kz/+4X5talbxQz6dWx7H0I1k0Bwafs3sQOHmhjXeeCnzxNuB2gjlsWWcPHmDW6GUHlPJ2SdA0z/ng+8rgdf4nkm39+MQnSjWhEfSPbjqhKalitG56GG42oSVcaYZLiimzY77geyqY9xmjZ9gkQCqonPCdIpfF0fm8vF2Gn9JTFxQBZfL8DIMoYLRwlVk3+TwFvyF3Pn2cImKKtYpcioiip4HqYcDa0SKwodFAQ5FA84iH6ogYt9WesiSWp8OhMYY/xdTUz17q4bY/A/+1GVulaZ53MHpiXnaTe6wQC7PC+OERjd6Z13yAIUARYzEyxuK4nyJTpkz5Rjvn+5TFGRvLhR3ckcr4oCllzMeieb+Ybwb1u/oNsiDR4BX40El9IupjMJfm0+EP12jIj0XVPX1C42ta0Jhg6Crvq8KPJN1ERdxPUNx4B/1qJ31KiUAw7L+TpHDYWVoYkjxBle7o9fC5N9uI8fyrforhmBBHtphm98RTTqSMX/Uml+/XGpLeWX/ehXsDP8DZX/wcUM3A7pZbgd5+nwRlMwLprEQma9HUKT/ojseTeaCQS9+NE5gC9iIxoamTOyvFVJ1fuXyrKOjcUs9hiAmwIQM691scdnSIo9KJI0mBdQs9XMGYNEGh++IvgT8TlvpyA2bAd56KA9gZU19HEbv2XokLNthYVAV86HskQ0JcRDD7CrrpDqjP9GUHNP+E9cC59zbhsfrv4rgvXO9naH6/2cQSUkGhYjkSB9cLsOEcRELu+Hn5ui8xmXkW4mNOsFiZY8Dj956h+kfm9ELkVCWfh00yFk5Rw8SYgzYCa/D5Mo6B7pSLC9Z7WnP/6efAQ4xPawmmoVhsOKhdCP+DVGydzzQ4JrCwzMFFG4GbqMkdjvjsoGk+Oel1Ds/uM2WJagjqbQ/h+aNuR8Mnrwa2vuChrctCdaUysUL3figTpcIWWSC3ogBRkdPGQlB1L0kgp61OQfcXJsDd61qFOE8CXGlpKqs6SF2CoogT2TXVeXeXhw+d4uDNJ1LTGK7c1678ooGs9MOseEUlEn0d48KVptnNZDy8+/USf3wauL8Dfxm1zP87RQf6AfWTvmJ1ubkYfohu5s033Uz6T1P1gfdIZFXmxhO5HKvuxJrIk+a7o0zffCltJRn2fZU5abX8rQY3Z/ryeVq95q6hgB8/1th7VfuE4bezSuWpB1H37CIVXb/QwQffyNjxZ8C9bSYWNRhYe2oEFVV+b0ooVq+T+zrGFYo0SVx8vKvf5XsPC4ds9++mqIg4vDu4FVyl5BAdEp+88Sv41//4BnDGiS7+9KiBhWwg2/EdZ2Gf5Lgk5kASBSKpLFye+OST+IqlOgW9HrrvU7k3ywdT5Eyr50zS3tw9bMfQQmUYjr7uaFogQlb9ucskfvsocDMN5rlvqkJxcR/CtUuxck0DervGUBQNYqRdYGxUCSlw/HIbJ6wE/o2mlrzuy4OG0T+FdooDZbmveOW8akMK9dfu34G/3k5ScdV7yCrDrs7wKL+T73qavOpqAsPXMotaGopMaJpa85qrmGdixNfs0VEfbBUfqo5u9bsVwnjPyOR7qGtL6T+EypWrXPDgsIOPXeDp0OOLvwGO21gGKxqGayyC28sDQ3EsXgosOqoeF175LsQrF6B/1ER51MODz1N6B9EyGjZvzbW9MQnI/SkhfXUBmjcTbN93ffMHfhXBZRd56OpzNSjC9HtaNFjW3ibRcya0MRD2Qc33OY7QLLa2UhvIPj98/Xr8y12X4G2XlaB1FzA8DE1U9PX9/ui9Ta2VM8fmRJgT5LHtfRJvWO/ilCOB637E0GRZMUqrFINdAika4YkU3L4H4GYsOMMpRqxP4Owz23DZJTaaeE/B5/3YKSirct1rYkUwp9DMw9vkFpreG+/Djg+fhW9+49u4+rqPk2Q85LLhTURj0Ok9lY5DzvcpAIZpsLJpEpFyCkOFX96hTKZinDa155TXlSFaW42jjo5h44UmwVmG//Ol44nMt9Han0Tz5gEkkgTV8GNeBa4CUZnicCyObDKpswxaWHjdvhEDdcU2PnQ+8A1akl0yiI3LGcJYyxgL99KsJiAYvBqpfmpsFubIkwiksihfvhGLTkkiFn0O7duA849FfEE53v+Nu9xj2j3xoYRh7MBLKw4PX5NbuJD1fvaXTyDbxFd87zskhkY93e8ZDEtfayxfC1XyYdmacpzxliM1i2zj8WdcuBJnXbpMB/kXvesofOzmi/Du64/AseevgtNMZrqd9tZag3d+YRmu+cYafPwzC+Hw2E6yU0YYSFE4jIB//Yalyyk4rq+lKo4ksx0ddfCpSzw8zXvd8gyw7pgS2FY1su4Q4+ZO2HYvnGwKjtXAbY9OR8rgQmprGZzOSqw/eSMu/ru1uHMLUEchvekKHLe+1Lun2HXPfc1paH753H1IfOIs3PT17+JT3/0asOm4EJ7e4qKiwicyqg+ybzcb84QS/MOPr0RxRTG2//5P2LOtFW+49iKGF304+dQKrD6iHmZqCHJPv454RflbYdgPwun9FtyRdhix47H+smvx0eHrKQxbcMpb1+DZB3fhv78/gt4+gaM2rUPzc09rMw7PYCjl4sozXCytA95Ct7DiiDqYUdPPOzMmMgL8bnl+ZYJVwn193NZTzTw41FQjXglRtQmhohbUrdqMu/8KXHEC8JXLUfyvv5Y/vb/FuXbIsr59ULolXy01RZ++z9/eeBZKqDSdX7kKkTUrQ7jplsUospqQpIKtPWUlShY34tiTIjj6NJq73SGI5ZchYN0F88UWuKVvQSr+EMzhbkT6TSSCK+jXdsLKhBGtPBpjA/cThAZEAiaM4qVw3J+QxbZBhN8EUXEpdj3WjEzS4/Vs3PTxLzHsoJVIBLCkxMXn3+XhC6Qyv2uxcNyZK4lzJZxMq+4UsAIRhMIlCLrNiMYbESXDjYWyiEddhIISpTEPIXMQZWWLEG8YweaHuvHE7UP4uzf4lYHfvgv4+RZ8c9CyrsnnNApSf/KwNblqeVLK4TjwnW/+J/D0MxksXtyAp9qrULpgMa773qX42+sX4dhNp8HoXqTqoOF270a6PYisUQxzrAnh/nLYHf1w4m+mTysBxl6kGaJ5ZIDk0c9FSjZBhGLI9D9FwrQKnv1WyE4bRqIcK1f8Ees2hrHmzIvw6e/8CwJFx6J/OILSiIc7H4M2l6vW1vKcUZpSarqXoSaW0aerToR+uFYdXJdbZ4jH9OrO82C0hia5FyEGsJ6kc08tw4mb4pD1Arc96PeXfpTx7HvW4+oax/mvg5CweVUt4vwjRSRt4pjTTwYWrypH48oMbvzWF3Eh3xiiDXh+D4nHSgRrr2Lw7iDY81MSk/OQLFqD5PCdfKFVCIcZ1HvdMDIJEqVGmrtz4aSbEDHJRDGAsZFtbOQUTeGVbPC1PH4Ega4bYXSQAju8T+891MqbcdUVT+JjHxrDC8MC/UPAtxhSOe1DSCb76ALoJ42spr8GkmTidMgxBmBWmvfsgIwvgherIcAd3JeFY9rc34pMit+j9fjgJ5djM0/50T1+PfBH3kCavxbvrHKcH75mTO5Nl6Jqzwh+8zdn4sR38AXLjj4VtWdeTP9HKivraN4of5kMZLoXIsBAP/UEkO6CjJ1AreiGk+yBE1uOYPYBeMOMV4qO5/ejEWTjC1CzSHKynf9M1roAwUr6VUFAUoxtShvpb6+FjFJbK8+F2/4VhitRiPpSIG7jzm89ijt/AlxzEW9P8nT9z4FtSYMxZkhnNrx0GqGQRdPLc6itqi80Ho8iRBZn2COIBiSCwu+1IedCBQ1HMYnR889JREjwzlnndwCUc99Xfw/c04yvtfrmd59N7qumjFOGUNeRxf2Xn4ZV110NPPZ0HGvPPQm1xyyHSKyCWXMVY7s/wu28BbJoNb3MTjKk5yEqL9Wm1ej8BUFeSwp5Idzkc/D6H2K8UQmv+nX0XyHYvWQz7gAViEQmvBpe0UJ4Az/UHdoysgbe2BYY0fXUvDSMZCd97JnaNEunC+mee9BFAJ+/pwML6MsbSY7++Q7g9zsEyqsNXYVokhxZbMtQ0EBEFWobti43iUWiiDE2ijOkiYVNxEmpo0QvEgqioSGGWFEQKTeIQCCEpcsrcN8Dbbj6hofcFssK7A+gr4oyTupJTW8WD7z9FKy84Xrgh/QkzYlanPeppRBDbOTSjXCGyEhSDEAr38ztLyAHtlMzN0EGqtnoW3mhFymdcYiRXyAgDQQWfQyel4LlDEKSwOiStJFdyNR9AHLoNsjBXdRCBkqhWgjbhaz6ILzRPxGcUvpFand8GTD4C9rYKC3kFVi2aAG6dn0Ut5KLfvBMaunbyJ/vkvjR5iBWHL8QsXiQ4U8A0UgEsRhXghqLBVEUD6MoYiFeRGCJcEwBG/ErMIL8HCLYZtpmHJ2AuaIK/fcMqyftPyzDlhyYVT3An95BMK+/DnjicWrn9gpc9tFjIRyatASZKeNQMXAHRPH7GXeqgiOD2+VsdB4T5fc2OqLS9xDYHXBTe+CKAXhtz8Bc+E8wS94IL/GMX/4XXohg6lGYbgCijOGfEdR1R27fbfpppLQZflQrtYI9eB8yvU+iqPbNNOVtCOxswQkbqjD6N724/VfA248HrnwdUF2Swk13N6P8iAaU0GYGLZfmM02yYxFgk58FwiGDVkLoWqKQZehqxYCqM1ZhDR9/6YIirF/LMKdjBLtf2KUKLwbybbRkyZLDA1AFJh+8uhf4C8Fc/tlrgS7GK//8FeDD3zwN515eDOziEdGFNK2PAiVn02TeSzDpgDxqVk09wb6PWlhMhplmCMKtE4ZBhhGILYFr/y8Z7k54ViVkdjuC9TfAIxnKpP9E9tkBM7MNgWwbjNKL6ZsHYY08AVl8KtyxF2CJJI8xac7Pp5AMIt1PISg7lvgfg/Mvb0Z7Rzdu/v0oPnIJ8Ppj6fuKHPrVPWiNCgSCfsWfyuupVYFoiYnaIiO3XxevGH4v06kbq3H68XUY7u7B7p39CPtDDw8fDc11IEe7gIcvPAbLPvERIDkCPLKlBp/82kqcdh4Dl1aaV1vVcpb4T2mR8nc9SP/5LnilDDfG/oeN3wM3sZg6/h6I5ENsiFpqZB1SvXcTgPeSxa6D3f4tXqMIdv/9MItPZIy4mhrXhAzDDXfolzTTNTArSIbGHoAxNgpntBtWJAQrtozABJFovQMltSfDTnXSvNMqJBbiovM7cN0DAr99ROLiTcAxtM5ffTvw+V9KJPmsJaXCHx+j8sWmv1WkJ5BbFZBmrp5YDfFYTA31UoPoax9Gy54hBWhzcXHxfg3ff8XCFoL5xzNXYdl1f+/nZ/+DcecT22px2nuPpPkkiAsZPqwYJCV8GLIhDTf+GJyaMLLlbbCDj8Ap3wC5uJF4N1P7jkCUx5jFTyAZ4jnLL0Kwqg5ZsQVmqQ2nYRPCRb9F1rkZ6cTXEVjyBsRqamgeabrjbfDqjoJTVQHb3A5RQ3O75iqSqYUQRaNksmzewDAC4U6EVBszLKk55Y244esluGs3cPufATXW9Kgl/sAjc0AiNSr36r/Nfy4cU5PvnlNoVcYtMvEEWnb3oCdhq37iFybJ/5xTg69ETRFoZn+6Oo4Tr/mIn1Dv7vK7ssTgs7jnyzuRDVfBSSn/oob4qc7lp3VNT5YaEzB+TSnP0E8ugOcM0wmr1voCG6mTceEIG6iHDXUkFh5xAlp3PEhNJsUooukdVEMctuhe9WD818gONSM9nEW8jD43cjMSfX+BJKGMxToRLLsVqWFq8VCP7nFx0lu0xgn7N7pYOl4ehZdJYiWjqT56O1Wo2MJtI+XwmjOAL92tOmGF7qZTlYXa9GqT6493yRdZK2BH+AolYYZg2WHs3DkAiiPoxZ8PBAIiEol403SnyVcNoBTmj1XErLd95nPFqG100d6iBjDbePvbJTKjqssrgdRIAmNsJNvNdUpbuQo/N9fbwte0k/1+QbXnS4kV84c1OKNdDAUs9L34IkY6W8AwEMES/94MEWHG1PF/UaU+uqe5J81A3+7QiflglFzYdGFkH9L9pMhVMaiqdqXNqrFCoZAWjnBRCd73ejVmNIgkyVvQDCITDuP8E+N4bKQZv3qqC3W1ph5PqrrqPD3kUOjyTycn2KpiMESJiQcy9NN9aN494o+dsqxnp+gPlXMB9mUHlO37wXWNDTj7k9+iX0uj6CiGFQ5jP7awmxlCo66rtElkhtWwIp2Vt4m0tBO6XlYlFzRPtFPUkhFV805lcHSRtEmNDkjVJVOOVKYdlleHgBdARmR0cXaIDa8bVNViWkGdWLf4u6FHcfM3Iuqo2mBKiuDvqthbFWGbgSiFJeD3EARV8oDAUP2EGaBASRTnSg0Ny0KkLEKLcAuftQOVpXLcZ1o5X+r7T6kJUsomoeb7VASTaG91sIPCzbts7a6o6DEMY6opcaYqcZOvKKB8r11jycxKe4CMMFzMBokwqLZgqNG8MuBXuCuaKAw2Yn4MhO07EV1ilJ/swIXjJLiO6dHTesyRxaalmmbsYUS4P2hGERBhZGiaHTeFoOF/p+gg447q66jj1T5Tqageb+/nxbXAOH5NrFTV9qoQnPtd2686k66jhyGaUIVjLhKjKV3aOTgisetF+tvc+FJVC67na8hZEqWtrvBregdpMRpKXVRHhvFss4e2Pt3R/4hNwZBSTjVjiphNW192QIPA7qHeIXS+uB2Lltfp7MquzTvxg6/9BKoVLM/3tKpSwRBq7IqqcQ3S9Jm6mt6g5qghDWZI+F1W+jhClA1Q04VuOTOS8ceBZtgwjFmNoMPzbG3y3JQfe8K0aWadXL8GbYEt4GSgNVn5PcdRQyYcXaimhh1mVcUXz3dcR/+mr09BSmU9LKgtxruv2EgBMugyhtDXPYpIaO8Bv+MDf3P+U7kONSxVlaaoAUt7GL4o/1ksxMNCiKmmlpvTlDivBKDNA4k0uls6sGhZOUw2aBff5rlHX8CKlb6fzBdT5wcIjftK+Ils4uwXU+cUSjUMrbb/Qor0xPxXTo/4ZSpmMLdPTuzzfOs5XjSmrq+HjeZHcosJf52vHJR+EeL40AzV+a0q/Ib7B+Gm19KvmtizswvdaQc1RX5YouPOHJgaDd7YyY2UM1x/aKLN7y92aJcOLxB4WD09SZHE1HMGTlfqqb+/7ICyvZtJatHe3I7jT1/OODJDqXLAKAMVNZMcRK5QerwC3rfE4ytyQ9zdTAGLDk0EY7Sy2uwpATBztb1qWL1rTzSBEdzbiOkhF87E8MT8ffMpb6+gBliHIgR72cIyWpYEZMpkHNkP8jmUU+MVey+sBDNyyQVVeZGx/ZHgi6vI8ikUTQSURP+5gaqqDsPXUANTT1w1I6gvO6B8gu1qu2dHOxnSEIN8WwOqNE/VAqmUtFcAYv6JvVyVHwoHIBl+4wsxMeXM+FB8b2I8DNzcdDO5oYCFoHg5H+drz4S2SregJeXUgpYfql9VEmYcmcTYkIPm5kEdphTFCVA0B2CuxleFLQFVo6Q0m3S/jtvaMjYIm6KNYU9UiAcd01QdJgYmxrlgX0CdM6D7mlOcbqkAdvBpB3bv6Cq3CajL2IQRJuO5MPa0pHV1nZmTftXYljnhd/KNWViRl/dLusFCfklnfgS3nZpo+EBR7rXdAtHPCY4ITAx2yg+HyE9uMW4ZpgjrlaapCsJ4yIPlJtBL1r6jeQRqaGhZuW9yzZyJFvnUX26rBlnVsTEqi4HfPe4nb8tM8wGtyELIGWLNmTT0FUn9pXjTLXuae08d7O5DJGLCSYxg7XErsHxDI8ZGsnrsiBp+76quLV1r7Rdcp8nzU2MpPXhJhQt6yKBna5KjQhzDyo3zVGNE+T2YETmf5ZBY+eNDsxmphcjJ9Up56lrIFWbDJ0hqULCdv7/nt6HrSH3PQu1WPj6dFiiNqMTAKNpaEujszaA07Kf48iWgIp9UyAulqSMzLK6khvMaTe1azobGSksf1rJsKO+K6bR0KmIkXgmWq1+nv7ER0d27t3R2jJy6e2cH1NwKEQIRZnBdHOlFSdDVs5MoRusRCCc3VFq5Fd0z4tgaJN+fSYKc1aBI4QOvgFCzmPhjXggz1SyjxiAKfzS2qwbtqskq8mNLvYnZwGD4I6319dVEUvqACd9ZCKYeZc7v2VEDZaEsnDEHu1vG0EsoVlVZWL7EQnWFhSqukXAQgZJKeFTXZDqFzs4MKluTaGigAPRnobxPRIiH7FgsCz9cyYM5G6jYb5O7vwBOtVCAN/eyQdv29GLdyijCQYnBjg48+MsmFBflmCxeavbyE2IU+jVhvNS/YdIxRr6LI98M8qV+cdxv5+cykhODoqScGA+Tbzp1bIrsp4x+siyYoP+UeGK3xBc/EMZFZ0QQIkk11UQRYb6QKqWPc5uhPwjTzlaHVaoL6Y6d6GsbQcWfX0DLM4m7bV8789o3HahymsTCIWO5s04eTG17Mqvizx39cE6sgkmtCgdCGCNTVHWx42NACxp0MkGZ677xzwWTL0JOf34hWZr2Wjn/OTRKhlvFODKQxF/bavHpy7pQt7QSbbtSuthXmLQ6NSa85t1wGZ+Fq+sRDpdB9JsQoTp+NlFdsxW3Pn4e1pT94b5JzLYQTDFFPHrIU39iDvv0dycYfMHIZAaa9nSU96eHdaFNaRnNVQsVqSo3myVmBmmu++QUwwjlLGDN9nv+TVTFfXlMoohkrHTFGvQOdCHd7MISRq53xVc0weDYsDx+V2NfLe1EpfLddCeSwXA243rJkpLBXD5BTNJQMUumqFBTD1rYMhOYevuWtYmKo1d76+pqsKEiXnTMZ78qgq3taTV7FhbWAyVkhSOb/dBFD7MvGNKXZ7yycBi9LHizgs+yUBMx8VnKl7ZGIUBiCksw1Zr3pWmCGeY59Qw7/tQENB77CBrPqUX3zjGdPgnSB4eItBRBhGO1EPE4LU8IbtqFWUlil+lFxtvBi5Lh/2yXnRvsL6dgsVONSpv2jxRYh1grxYaSxBuvfsvYx1euiBwnvFA8HA7ALG/AmSf24Kc/3okuBtTLFzNui6rJJCLY02lpIqRmJ7FtV7PXPGkRBSGEBtmb+D7ueMxJ9kn4muJPIWeMo+dfK0euXDlOjvxekZyp9/YGMz+Xg1oThKCUl6tT4ckR5yC9/V4Un1KB6No4hvoy9MF6Yjhk5TDcgc0QbqV+6MQgAW/m/mQWA+0qjVkD48VuV4hFhZo5XSZo1nEv1iHyn6IonW385rv77j1+Xbixd6gY2T4HkRI1GWIAbiaLI1a5qudFjxCzjwOKCegxGxux6YKTMDowrKecyWRsP8SgDTYgdT5VhRu6Y5iRvwpjNNvUs4ypeiA/F+gUTDTh52RdP3zJT2Xj+SGMniJOBTiumnLOP05PGed5e5MsTHRQW7kxNgYffkHYL8dMp5sQW1uKrU+Noa7GQsxSeWaGP6TBtppCJ52G0z+o+1vdtIf2/jBqaxws3bQOsTXr+XtjZOWDj1Y39ZqdU3Rq79OYUesgauc4mItC3pqvvL1z84oVZehokwywk/AYZSeH0wxNTPrIMSxtDOnO6+Zd/uRQKhBPDXeis+lpWIbtV93Q/hpS6slw1fxCRjaLkLLFrgpX0nr+cD2q2mTYE/LVylVAme64+XRNV3exeUL/D2l6uTmJZnizAjM92fzquYYsfxR3XYkqEgOe6enAGe+oQ8df0xjho496BtKDJEGqMIyiqOTGc2husxL9pAwnnB3SPUt2fRWSW59FuKxc/Pt3lv7ydW/dc/IMYcq0XWYHA1Axk7/8yAcuuFQ2/weGkiQBThJCRdkqvlNz27lcKaUVZH8rlhehpWVUD8StqqHU20P4y51Po6I8N5WbmJr4TM7vosAcT+sE5N4hzXSkZ6p77cU6hE/aVAp4SbW/r2k7gb0riTXLTW3GU9TMMUYfaiJJPZeSkP5EICa3ShpoLcaMAATNbyC0BkaoCiuO27Pwune2/e1X/sf9zhxAPaQ1RS/5iwmVNWLYLg4RuCQCRRE4OjNuIBJTWhlGrH4ZgkUrcPTSErSqPCbXWgJaV+f3H5bS3RRR8mNxfx4jtUZifm5UhTVqVSUrgVBuG/RTfoHcnID5da9BwubEE4pJcWvh/H965LY5sVXtbxoT4ZOyJoM0t6qXaAFDSjXcvmmXg//+dRYpT6CnXyIxTPeQUKktDwHHg6W6VzLcl6Q5F373jutmYUXKYZXWMXjkC6WX4Yr3LLo2Zqra1QMr8TnYjFb0PXlL8vgLyhFZVYThGF8mQEks95AJqD+XMIKxrq1I2h1Yf3IMA2wQBarK4arZQ7r7/RojNRmVypMq7VUzYKoh+vk5ifKTOuZnsg4EJlZ1HbUWflbXVdtwbvbr/NB9YUzQSmURVFKK7k4PBFb3HRgCevtAkPhMvUBnD00t120kp9UUsAXUUDXb9oBZi7cel0EkLlCz0EQoasALGHp2zTSlIh20kCEZdGIhv2whN+GSSgoJNT/hWLdOiMZWLAlccJp54SwFYYeUFE35h2mSdjhlkJ6XWxIltXwZWUyfR7qu8q4qXZYahTsygMWGC5dP0PSiL/mVFX6dTUfH3l1V40xWTszfnp+SPM9294ojc8/h5hIUiqCUlplYsMDC4oUWaldVIlxcoZ+4r2sMqTEbA6MCezb347mnh/X0M/k+WMMomHAj122nBncvr2UMSguiBgCvP41mM3MfHv1dBnXLeJ8GhmHFviN2UxKZtJ9uNGh+9qQcv1dY+fFsip5IxadpXSBuIoDzTy+99Lb7h39SEMLIfSnltA6iyR3X0Me3G3+of9j9/aaTzfMF/Ugq4SKgJt93pM6lqjDBsQ2UUaKX1ptoZjDeRy2oZyMtW0Dpr8uVb0zq4Farne+rLOjqyv+e344/ENXy4rMFTj4hightswqZrIoFMGKVsBlIhmqqYZaU6WdK7H4B0Y8sRbCuArd99Vn87tZt2h8qTc4Dq+eG5FrEZ22s8s3t/VuBd76LMegGPwb1MgZeeIbaR5svAhZdS9RP/Ku8sghgJKiC7CF46Qzs0RFYdhdNcQvP60NR8RKcuKH2lOV1g+EdnUZiCs2UBxvQmf6k1Pj6u6bY0O+acNnbHhlds24V/qamAo38oZoNov7YTRX5AeNuMZrJoKU8Ypotze7qdjVxU7FAeZWJBmrSIq4liyrZIBXa/w32jTEYt5FICfTt6kdXy7CeEXqqjvBkxsS56w2cfkIYfUMRGKMOzFLFNMgs9eRBexCurtYNbKr5G4IhlB5zErJtzUhsacLbPn289kVP/HHrXj0rCtj+hM9sF1T6f+HhpDeeA28PY9DTJ2LQ4jo/lPSHViQgSvwY1M4S8N6M/qMEQfXXegZ7ECitgUwOIkvHnI25CMayOHXpyLk7Okt/VdDzO9VfaZpSew9VYkHvv21L/IXbtuAfMNFx/5I13pk+NxgJ/iCdEFjVGMXfXzkHTXq7r0k//9qzuPu2bX5SIHfTLMOBq9/oYMXKEnS2qdFgSchcyFQaY8iEBLXDQrKjG5HFRRQSFdeWUmgUSQkjw8ZOjXpI9A0jVhrGkkUW6lbSRJdUaC3t7hhDnGGVVcaQa0c//f2LWHPS3GPQEK1Vf30FGiroX0fpkKPDbIhyiGw3nK4WBKscFIfNDXyVO6YAbTotHf/dOlhmFtNPojTVqsEM2c6if7tafunkY31NsvscRPdBk9567fFIkJTc/bOt42HFmhOPg0w8gmEdMo1BBP1JklV1s5qhTDWqUewi1lBHs16JAAVFFQhkqC1PPvI8it1O1DbtwJtOCCJ8WvWMgrXyrKWo29KGZUd5c4pBVTJDVyH3ulhIC+QOpJHu3oaQQUApWMmBdkTNMOqryLL2rs2YCtQDLhIT+xHGTAemqLTkqu+8o/3eFSvL9luT1OMftSCB1e8m0xxRBcsGGtdLtD4X5vFjCMejcNX87urPVhVRKAJhRBeuYGgUxFhHEuGqBNK9w+gaTqDr3oexYYmHvpEIsgxL5ipYpuhC5+Me6svFrDGoy98sz8For/rDAozFPBOpTAoiPcj3zupsVVEHiVWJV1EQi3ozgPiSv4p4sMe2zAlMtX74vedcIBmr+ZqU0VpkqP8tY1yTRICatIABqtKkaCVVOqg1KTmyB7E1y5B4+M+QvW2waKKrGRKtXRlHb9NWbLywHNHVcYwUURuDCYQqXWRDfsiU7HoeKYfn1KSR9JqxvWkzeu+4C6trDQqWCUNNsszGV4JlIsNWSuiEuhIsGAMUlBF4bHiZ9gWroiaCXlE/pxjUMUKwKuMoW1qE1g4y75DQacsxNeGSK/W05pmxLM2zF5xGQ6fzp4e0BGVGv5oHtqScFiq1b5okYjaMChPZXZ3o/v49sAYlHns+CFm2HhvDj2nhkLRxJgGoCkhU1DNkQgkyDBUCMuuTG/UnP3b3I510tdBk0nRX44K1bybaSbdqwQpt+wsi9QIRWpbhPl5T5Y2z9KMWwx/GOapc2FFjdCIWLIJoMXzraXWwqJYCNCAx5mUQo/ZnhjMoawjR2sj0HMCUh6K3ZX/9Knqf/Xn6givLGbi7GOq1UWynECqhuSOldahJLjXJq6hGoCaKpNNM8zuKdFM3MgTDTShdNnWh/f3bzGcXH2mUbagJL1LCUVEWxVOPuzh2o6kknabZQVAn4tXfd/GnNdcF2Y6pbUJR3MFgyYEJVpiCdcsDpY9tOjlQv7RBLpguBpW8hz3g6hnQSlwDO/fE5OIKiBd7HPRRcMpjIYQjSexoCXTNEcyD0sEt9tGnTnmNpB1K7Ysmuelc4TVotoKemro086OHi7//1Fj818cFt7+RZvajeeGopXA0bw9jIGEhGvYnYNTJB/ovQzFiCo3+gwKpLBKJ53DShQcuWNs7zV/90z/G/nDx0an1y2rcZTVlsr60SJSrEfmGMISdke7IWHhoeAy9o0mxp33Qeo5hauxDF7k/Wxyn3+fL9TA0a2kDfv9M+ff2AcxXvOpPL3c+E3hgdWP2vvPONM+aiyap5KntIN0zJDqf2R155DfPx367YyCg5yJI2cH0VMJRVunm3lgREhvuZOFQCZuQiQMVrJ8+Fv/3n26O361E5lfPRZ7Ac/ir7gzNJfly5tOdtNVrLDRy+Smr5WU9vanuodBRTb9+quip3dmuRzHF/PNz0FA551lQlixZMtufNDYKQ5IpVnOKrXn64uSqs4/x3tJQLReSpFaGLa82GJTlFpvbceXYWBIdBHHb7h7zhc3tge1PtIZaRzO5/rXctWtibtFn3pK69sLXmScq4UgkpB7GlxcOtVVmz1OfHaljxFSGEcOg6H6yOfjM0qXW4ovOM9fvy7m9Q6Jjc0vgz7/bErt9W2+wowAsdwoApwRz0jpdmOJh5r/xvdf+gwloIZhiGjDHgZwB5MnnFAqLOYVvHmfO62oyjW841jlvUY2sCwdkaTQgq8NBr9QSMmA7MpkYQ1fnkNG0u9vcTuFoeqY92JrIGloVee6iN2xwzltcK2tCAVlWeK4SLJ7b2TNsbGvpNbY+3x7Y+nhraNdwWs029RLQCr/PBUhvBkaLSZo6U4L+kAE6Fy2dDtiZVjHFFpOABWafTHhyeYecJmcqp2nsQoDkLNroTgLNnQXM6cysnA3IQ+VDCxtrqtWb9Ls3C8EqPLew1sabBCAmXUvMkHfGLP5ocgNO1eiTV3eKz840x7uT9stZUnxzBnNfAZVzZLZzBdWbBcDC63hTmFx3Gu2cS/GanEVb5TSaKafQLncWM+pOs38uYM5WNX/Qus/mUiOKWUCdrsO98JjC6nFRAOx0ABpzSFXKOWjpbKZ3KmDm4iu9aYRlTnnaQ9F9NhetnTzmQs5RG6cC0ZucMpwi87Sv2rmvJncmTZUzaOZMflLO0A0m9xXEAwF0qqHh0910KnAKr2NM0WhTgTndOh2Ixj68C2YBdSYLMxeN9WYgVzP1c+4zkAeTFM0E7FTjNCZrr5iC7OwvmPvaI3QwQJ2JDct9MLP7DeKhMrlTAVtoMr0pTOZk9ipeBjAPpqbKGcCaDci5xJbYtWvXIQd0tskcJhOj6YCdPAhHzCWpv49gijn6o7mCeqAg71ds+UqZ3Ln8ETZvjsCJabrdZiI/B0ND95Us7Q/Qc8nJvuwmd6pximIO4Mo5AjcbiHNlsvsDKObQ8HI/gZ5Tgv2V8qFzAXU2fyumSSVOZ1L3VSvFPjbWbNqKOWRzZvt8yMA81Kk/zAKsnKMGzuQrxSF4/tl861w1eC6Ji4O+WAepAcQMiYW5gCr3UxMPNaD7q7mY4+8HHVzrIGvmTNo6F6GQB6iJ4iABuL+auy+/HRJNtQ6BdM80x6s8gPzwqwnQfQFIHuC9X1EfCsxhHoAZwJWz5F1nA04e5HfY32PkQRCi/Vr+nwADAGCkIKhq9nPVAAAAAElFTkSuQmCC"

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABsCAYAAAC7H5bRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Q0EzRjYzNjQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Q0EzRjYzNzQwMEIxMUU2OEI2QzgzQjMwOEM2MzIzOSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBCNTAyQUZGNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBCNTAyQjAwNDAwQjExRTY4QjZDODNCMzA4QzYzMjM5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+56FGOgAAQAZJREFU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"

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAAxCAYAAAABf+HvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNDBFMThBMjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNDBFMThBMzNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEEwM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE0MEUxOEExM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+gmaSkAAACUhJREFU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"

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABsCAYAAACclEAQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2N0IyMEY4NDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2N0IyMEY4NTNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3QjIwRjgyM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3QjIwRjgzM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+aqH0aAAAKFxJREFU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"

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAA/CAYAAAAxBeyIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NURFNjFFRjNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NURFNjFGMDNGNUUxMUU2QUMxQjk4N0ZGM0ExOUY0RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0MEUxOEE0M0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1REU2MUVFM0Y1RTExRTZBQzFCOTg3RkYzQTE5RjRGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+CibruAAACphJREFU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"

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<img class=\"recharge-record\" v-bind:src=\"recordImg\" v-bind:style=\"recordImgStyle\"/><div class=\"recharge\" v-bind:style=\"content\"><div class=\"background-img\"><div v-for=\"item in moneyData\" v-bind:style=\"moneyblock\"><img v-bind:src=\"moneyBack\"/><div class=\"barcontent\" v-bind:style=\"barcontent\"><img class=\"money-img\" v-bind:style=\"moneyImg\" v-bind:src=\"item.goodsimg\"/><div class=\"bonus-money\" v-bind:style=\"item.sub?bonusMoneyHasSub:bonusMoney\" v-html=\"item.goodname\"></div><div class=\"bonus-money bonus-sub\" v-if=\"item.sub\" v-bind:style=\"bonusSub\" v-html=\"item.sub\"></div><img class=\"recharge\" v-bind:src=\"dorecharge\" v-bind:style=\"rechargeBtn\"/></div></div></div></div><div class=\"my-money\" v-bind:style=\"footer\">我的金币: {{userinfo.money}}</div>";

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(155)
	__vue_script__ = __webpack_require__(157)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\messageComponent\\ruleIntroduce.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(159)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-41af1aed/ruleIntroduce.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(156);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue", function() {
				var newContent = require("!!./../../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./ruleIntroduce.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n", "", {"version":3,"sources":["/./src/components/messageComponent/ruleIntroduce.vue?482cbdbb"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;IACA,mBAAA;IACA,eAAA;IACA,cAAA;CACA","file":"ruleIntroduce.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.introduce(v-bind:style=\"content\",v-html=\"rule\")\r\n</template>\r\n<script>\r\nexport default {\r\n    ready() {\r\n            console.log(this.rule)\r\n        },\r\n        props: ['zoomRate'],\r\n        data() {\r\n            return {\r\n                rule: require('./../../data/ruleIntro.html')\r\n            }\r\n        },\r\n        computed: {\r\n            content() {\r\n                return {\r\n                    width: 458 * this.zoomRate.x + 'px',\r\n                    height: 580 * this.zoomRate.y + 'px',\r\n                    margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'\r\n                }\r\n            }\r\n        }\r\n}\r\n</script>\r\n<style>\r\ndiv.introduce {\r\n    position: absolute;\r\n    overflow: auto;\r\n    padding: 10px;\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    ready: function ready() {
	        console.log(this.rule);
	    },
	
	    props: ['zoomRate'],
	    data: function data() {
	        return {
	            rule: __webpack_require__(158)
	        };
	    },
	
	    computed: {
	        content: function content() {
	            return {
	                width: 458 * this.zoomRate.x + 'px',
	                height: 580 * this.zoomRate.y + 'px',
	                margin: 90 * this.zoomRate.y + 'px 0 0 ' + 37 * this.zoomRate.x + 'px'
	            };
	        }
	    }
	};

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n<p>1.什么是PK拾：</p>\r\n<p>PK拾是竞猜10个开奖号码排列顺序的快开型彩种，玩家根据不同的玩法，竞猜不同位数中的号码排序</p>\r\n";

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "<div class=\"introduce\" v-bind:style=\"content\" v-html=\"rule\"></div>";

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "<div class=\"model\" v-show=\"dialogShow\" transition=\"message\"><div class=\"dialog\" v-bind:style=\"dialog\"><div class=\"close\" v-bind:style=\"close\" @touchend=\"dialogShow = false\"></div><div class=\"content\" v-bind:style=\"content\"></div><div v-bind:is=\"dialogImg[currentIndex].type\" v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\"></div><img v-bind:src=\"dialogImg[currentIndex].background\"/></div></div>";

/***/ },
/* 161 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    notice: {
	        'content': '?????',
	        'createdAt': 1469543980000,
	        'id': 6,
	        'title': 'title'
	    },
	    options: ['投注记录', '开奖记录', '游戏规则', '兑换礼品', '赠送好友']
	};

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {};

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    'createdAt': 1469548675000,
	    'money': 10000,
	    'code': 0,
	    'nickname': '测试用户222',
	    'openid': 'xxxxxxxxxxxx'
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(165)
	__vue_script__ = __webpack_require__(167)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] src\\components\\tip-modal.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(168)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  var id = "_v-691c031b/tip-modal.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue", function() {
				var newContent = require("!!./../../node_modules/.npminstall/css-loader/0.23.1/css-loader/index.js?sourceMap!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/style-rewriter.js!./../../node_modules/.npminstall/vue-loader/8.5.3/vue-loader/lib/selector.js?type=style&index=0!./tip-modal.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(7)();
	// imports
	
	
	// module
	exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /* 否则 scale 动画不起作用 */\r\n}\r\n\r\n.bounce-enter {\r\n    -webkit-animation: bounce-in .5s;\r\n            animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    -webkit-animation: bounce-out .5s;\r\n            animation: bounce-out .5s;\r\n}\r\n\r\n@-webkit-keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n}\r\n\r\n@-webkit-keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        -webkit-transform: scale(1);\r\n                transform: scale(1);\r\n    }\r\n    100% {\r\n        -webkit-transform: scale(0);\r\n                transform: scale(0);\r\n    }\r\n}\r\n", "", {"version":3,"sources":["/./src/components/tip-modal.vue?79187cbe"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;IACA,oBAAA;IACA,mBAAA;IACA,WAAA;IACA,aAAA;IACA,+BAAA;IACA,aAAA;IACA,mBAAA;IACA,mBAAA;IACA,mBAAA;CACA;;AAEA;IACA,sBAAA;IACA,qBAAA;CACA;;AAEA;IACA,iCAAA;YAAA,yBAAA;CACA;;AAEA;IACA,kCAAA;YAAA,0BAAA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAEA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA;;AAPA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;IACA;QACA,4BAAA;gBAAA,oBAAA;KACA;CACA","file":"tip-modal.vue","sourcesContent":["<template lang=\"pug\">\r\n\tdiv.tip-content(transition=\"bounce\",v-show=\"isShow\",v-html=\"content\")\r\n</template>\r\n<script>\r\nexport default {\r\n    props: [],\r\n    data() {\r\n        return {\r\n            isShow: false,\r\n            content: ''\r\n        }\r\n    },\r\n    methods: {\r\n        showTip(content) {\r\n            this.content = content\r\n            this.isShow = true\r\n            setTimeout(() => this.isShow = false, 3000)\r\n        }\r\n    },\r\n    events: {\r\n        showTip(event) {\r\n            this.showTip(event)\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tip-content {\r\n    display: table-cell;\r\n    margin: 0% 0 0 30%;\r\n    width: 40%;\r\n    padding: 5px;\r\n    background: rgba(0, 0, 0, .35);\r\n    color: white;\r\n    position: absolute;\r\n    text-align: center;\r\n    border-radius: 1em;\r\n}\r\n\r\n.bounce-transition {\r\n    display: inline-block;\r\n    /* 否则 scale 动画不起作用 */\r\n}\r\n\r\n.bounce-enter {\r\n    animation: bounce-in .5s;\r\n}\r\n\r\n.bounce-leave {\r\n    animation: bounce-out .5s;\r\n}\r\n\r\n@keyframes bounce-in {\r\n    0% {\r\n        transform: scale(0);\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n\r\n@keyframes bounce-out {\r\n    0% {\r\n        transform: scale(1);\r\n    }\r\n    100% {\r\n        transform: scale(0);\r\n    }\r\n}\r\n</style>\r\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = {
	    props: [],
	    data: function data() {
	        return {
	            isShow: false,
	            content: ''
	        };
	    },
	
	    methods: {
	        showTip: function showTip(content) {
	            var _this = this;
	
	            this.content = content;
	            this.isShow = true;
	            setTimeout(function () {
	                return _this.isShow = false;
	            }, 3000);
	        }
	    },
	    events: {
	        showTip: function showTip(event) {
	            this.showTip(event);
	        }
	    }
	};

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tip-content\" transition=\"bounce\" v-show=\"isShow\" v-html=\"content\"></div>";

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<background></background><menu-bar v-bind:game-data=\"gameData\" v-bind:notice=\"notice\" v-bind:zoom-rate=\"zoomRate\"></menu-bar><bet-and-bonus v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></bet-and-bonus><play-panel v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:lockmoney=\"lockmoney\" v-bind:error.sync=\"error\" v-bind:lotterynum.sync=\"lotterynum\" v-bind:count-down.sync=\"countDown\" v-bind:count-num.sync=\"countNum\"></play-panel><state v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:user-bet=\"userBet\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></state><message v-bind:zoom-rate=\"zoomRate\" v-bind:userinfo=\"userinfo\" v-bind:bets.sync=\"bets\" v-bind:error.sync=\"error\"></message><modal class=\"modal\" v-if=\"error\"></modal><tip-modal></tip-modal>";

/***/ },
/* 170 */
/***/ function(module, exports) {

	!function (a, b) {
	    module.exports = b(a)
	}(window, function (a, b) {
	    function c(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.invoke(b, e(c), function (a) {
	            g(b, a, d)
	        }) : j(b, d)
	    }
	
	    function d(b, c, d) {
	        a.WeixinJSBridge ? WeixinJSBridge.on(b, function (a) {
	            d && d.trigger && d.trigger(a), g(b, a, c)
	        }) : d ? j(b, d) : j(b, c)
	    }
	
	    function e(a) {
	        return a = a || {}, a.appId = z.appId, a.verifyAppId = z.appId, a.verifySignType = "sha1", a.verifyTimestamp = z.timestamp + "", a.verifyNonceStr = z.nonceStr, a.verifySignature = z.signature, a
	    }
	
	    function f(a) {
	        return {
	            timeStamp: a.timestamp + "",
	            nonceStr: a.nonceStr,
	            "package": a.package,
	            paySign: a.paySign,
	            signType: a.signType || "SHA1"
	        }
	    }
	
	    function g(a, b, c) {
	        var d, e, f;
	        switch (delete b.err_code, delete b.err_desc, delete b.err_detail, d = b.errMsg, d || (d = b.err_msg, delete b.err_msg, d = h(a, d, c), b.errMsg = d), c = c || {}, c._complete && (c._complete(b), delete c._complete), d = b.errMsg || "", z.debug && !c.isInnerInvoke && alert(JSON.stringify(b)), e = d.indexOf(":"), f = d.substring(e + 1)) {
	            case"ok":
	                c.success && c.success(b);
	                break;
	            case"cancel":
	                c.cancel && c.cancel(b);
	                break;
	            default:
	                c.fail && c.fail(b)
	        }
	        c.complete && c.complete(b)
	    }
	
	    function h(a, b) {
	        var d, e, f, g;
	        if (b) {
	            switch (d = b.indexOf(":"), a) {
	                case o.config:
	                    e = "config";
	                    break;
	                case o.openProductSpecificView:
	                    e = "openProductSpecificView";
	                    break;
	                default:
	                    e = b.substring(0, d), e = e.replace(/_/g, " "), e = e.replace(/\b\w+\b/g, function (a) {
	                        return a.substring(0, 1).toUpperCase() + a.substring(1)
	                    }), e = e.substring(0, 1).toLowerCase() + e.substring(1), e = e.replace(/ /g, ""), -1 != e.indexOf("Wcpay") && (e = e.replace("Wcpay", "WCPay")), f = p[e], f && (e = f)
	            }
	            g = b.substring(d + 1), "confirm" == g && (g = "ok"), "failed" == g && (g = "fail"), -1 != g.indexOf("failed_") && (g = g.substring(7)), -1 != g.indexOf("fail_") && (g = g.substring(5)), g = g.replace(/_/g, " "), g = g.toLowerCase(), ("access denied" == g || "no permission to execute" == g) && (g = "permission denied"), "config" == e && "function not exist" == g && (g = "ok"), b = e + ":" + g
	        }
	        return b
	    }
	
	    function i(a) {
	        var b, c, d, e;
	        if (a) {
	            for (b = 0, c = a.length; c > b; ++b)d = a[b], e = o[d], e && (a[b] = e);
	            return a
	        }
	    }
	
	    function j(a, b) {
	        if (!(!z.debug || b && b.isInnerInvoke)) {
	            var c = p[a];
	            c && (a = c), b && b._complete && delete b._complete, console.log('"' + a + '",', b || "")
	        }
	    }
	
	    function k() {
	        if (!("6.0.2" > w || y.systemType < 0)) {
	            var b = new Image;
	            y.appId = z.appId, y.initTime = x.initEndTime - x.initStartTime, y.preVerifyTime = x.preVerifyEndTime - x.preVerifyStartTime, C.getNetworkType({
	                isInnerInvoke: !0,
	                success: function (a) {
	                    y.networkType = a.networkType;
	                    var c = "https://open.weixin.qq.com/sdk/report?v=" + y.version + "&o=" + y.isPreVerifyOk + "&s=" + y.systemType + "&c=" + y.clientVersion + "&a=" + y.appId + "&n=" + y.networkType + "&i=" + y.initTime + "&p=" + y.preVerifyTime + "&u=" + y.url;
	                    b.src = c
	                }
	            })
	        }
	    }
	
	    function l() {
	        return (new Date).getTime()
	    }
	
	    function m(b) {
	        t && (a.WeixinJSBridge ? b() : q.addEventListener && q.addEventListener("WeixinJSBridgeReady", b, !1))
	    }
	
	    function n() {
	        C.invoke || (C.invoke = function (b, c, d) {
	            a.WeixinJSBridge && WeixinJSBridge.invoke(b, e(c), d)
	        }, C.on = function (b, c) {
	            a.WeixinJSBridge && WeixinJSBridge.on(b, c)
	        })
	    }
	
	    var o, p, q, r, s, t, u, v, w, x, y, z, A, B, C;
	    if (!a.jWeixin)return o = {
	        config: "preVerifyJSAPI",
	        onMenuShareTimeline: "menu:share:timeline",
	        onMenuShareAppMessage: "menu:share:appmessage",
	        onMenuShareQQ: "menu:share:qq",
	        onMenuShareWeibo: "menu:share:weiboApp",
	        onMenuShareQZone: "menu:share:QZone",
	        previewImage: "imagePreview",
	        getLocation: "geoLocation",
	        openProductSpecificView: "openProductViewWithPid",
	        addCard: "batchAddCard",
	        openCard: "batchViewCard",
	        chooseWXPay: "getBrandWCPayRequest"
	    }, p = function () {
	        var b, a = {};
	        for (b in o)a[o[b]] = b;
	        return a
	    }(), q = a.document,
	        r = q.title,
	        s = navigator.userAgent.toLowerCase(), t = -1 != s.indexOf("micromessenger"), u = -1 != s.indexOf("android"), v = -1 != s.indexOf("iphone") || -1 != s.indexOf("ipad"), w = function () {
	        var a = s.match(/micromessenger\/(\d+\.\d+\.\d+)/) || s.match(/micromessenger\/(\d+\.\d+)/);
	        return a ? a[1] : ""
	    }(), x = {initStartTime: l(), initEndTime: 0, preVerifyStartTime: 0, preVerifyEndTime: 0}, y = {
	        version: 1,
	        appId: "",
	        initTime: 0,
	        preVerifyTime: 0,
	        networkType: "",
	        isPreVerifyOk: 1,
	        systemType: v ? 1 : u ? 2 : -1,
	        clientVersion: w,
	        url: encodeURIComponent(location.href)
	    }, z = {}, A = {_completes: []}, B = {state: 0, res: {}}, m(function () {
	        x.initEndTime = l()
	    }), C = {
	        config: function (a) {
	            z = a, j("config", a);
	            var b = z.check === !1 ? !1 : !0;
	            m(function () {
	                var a, d, e;
	                if (b)c(o.config, {verifyJsApiList: i(z.jsApiList)}, function () {
	                    A._complete = function (a) {
	                        x.preVerifyEndTime = l(), B.state = 1, B.res = a
	                    }, A.success = function () {
	                        y.isPreVerifyOk = 0
	                    }, A.fail = function (a) {
	                        A._fail ? A._fail(a) : B.state = -1
	                    };
	                    var a = A._completes;
	                    return a.push(function () {
	                        z.debug || k()
	                    }), A.complete = function () {
	                        for (var c = 0, d = a.length; d > c; ++c)a[c]();
	                        A._completes = []
	                    }, A
	                }()), x.preVerifyStartTime = l(); else {
	                    for (B.state = 1, a = A._completes, d = 0, e = a.length; e > d; ++d)a[d]();
	                    A._completes = []
	                }
	            }), z.beta && n()
	        }, ready: function (a) {
	            0 != B.state ? a() : (A._completes.push(a), !t && z.debug && a())
	        }, error: function (a) {
	            "6.0.2" > w || (-1 == B.state ? a(B.res) : A._fail = a)
	        }, checkJsApi: function (a) {
	            var b = function (a) {
	                var c, d, b = a.checkResult;
	                for (c in b)d = p[c], d && (b[d] = b[c], delete b[c]);
	                return a
	            };
	            c("checkJsApi", {jsApiList: i(a.jsApiList)}, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var c = a.checkResult;
	                        c && (a.checkResult = JSON.parse(c))
	                    }
	                    a = b(a)
	                }, a
	            }())
	        }, onMenuShareTimeline: function (a) {
	            d(o.onMenuShareTimeline, {
	                complete: function () {
	                    c("shareTimeline", {
	                        title: a.title || r,
	                        desc: a.title || r,
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareAppMessage: function (a) {
	            d(o.onMenuShareAppMessage, {
	                complete: function () {
	                    c("sendAppMessage", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        link: a.link || location.href,
	                        img_url: a.imgUrl || "",
	                        type: a.type || "link",
	                        data_url: a.dataUrl || ""
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQQ: function (a) {
	            d(o.onMenuShareQQ, {
	                complete: function () {
	                    c("shareQQ", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareWeibo: function (a) {
	            d(o.onMenuShareWeibo, {
	                complete: function () {
	                    c("shareWeiboApp", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, onMenuShareQZone: function (a) {
	            d(o.onMenuShareQZone, {
	                complete: function () {
	                    c("shareQZone", {
	                        title: a.title || r,
	                        desc: a.desc || "",
	                        img_url: a.imgUrl || "",
	                        link: a.link || location.href
	                    }, a)
	                }
	            }, a)
	        }, startRecord: function (a) {
	            c("startRecord", {}, a)
	        }, stopRecord: function (a) {
	            c("stopRecord", {}, a)
	        }, onVoiceRecordEnd: function (a) {
	            d("onVoiceRecordEnd", a)
	        }, playVoice: function (a) {
	            c("playVoice", {localId: a.localId}, a)
	        }, pauseVoice: function (a) {
	            c("pauseVoice", {localId: a.localId}, a)
	        }, stopVoice: function (a) {
	            c("stopVoice", {localId: a.localId}, a)
	        }, onVoicePlayEnd: function (a) {
	            d("onVoicePlayEnd", a)
	        }, uploadVoice: function (a) {
	            c("uploadVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadVoice: function (a) {
	            c("downloadVoice", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, translateVoice: function (a) {
	            c("translateVoice", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, chooseImage: function (a) {
	            c("chooseImage", {
	                scene: "1|2",
	                count: a.count || 9,
	                sizeType: a.sizeType || ["original", "compressed"],
	                sourceType: a.sourceType || ["album", "camera"]
	            }, function () {
	                return a._complete = function (a) {
	                    if (u) {
	                        var b = a.localIds;
	                        b && (a.localIds = JSON.parse(b))
	                    }
	                }, a
	            }())
	        }, previewImage: function (a) {
	            c(o.previewImage, {current: a.current, urls: a.urls}, a)
	        }, uploadImage: function (a) {
	            c("uploadImage", {localId: a.localId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, downloadImage: function (a) {
	            c("downloadImage", {serverId: a.serverId, isShowProgressTips: 0 == a.isShowProgressTips ? 0 : 1}, a)
	        }, getNetworkType: function (a) {
	            var b = function (a) {
	                var c, d, e, b = a.errMsg;
	                if (a.errMsg = "getNetworkType:ok", c = a.subtype, delete a.subtype, c)a.networkType = c; else switch (d = b.indexOf(":"), e = b.substring(d + 1)) {
	                    case"wifi":
	                    case"edge":
	                    case"wwan":
	                        a.networkType = e;
	                        break;
	                    default:
	                        a.errMsg = "getNetworkType:fail"
	                }
	                return a
	            };
	            c("getNetworkType", {}, function () {
	                return a._complete = function (a) {
	                    a = b(a)
	                }, a
	            }())
	        }, openLocation: function (a) {
	            c("openLocation", {
	                latitude: a.latitude,
	                longitude: a.longitude,
	                name: a.name || "",
	                address: a.address || "",
	                scale: a.scale || 28,
	                infoUrl: a.infoUrl || ""
	            }, a)
	        }, getLocation: function (a) {
	            a = a || {}, c(o.getLocation, {type: a.type || "wgs84"}, function () {
	                return a._complete = function (a) {
	                    delete a.type
	                }, a
	            }())
	        }, hideOptionMenu: function (a) {
	            c("hideOptionMenu", {}, a)
	        }, showOptionMenu: function (a) {
	            c("showOptionMenu", {}, a)
	        }, closeWindow: function (a) {
	            a = a || {}, c("closeWindow", {immediate_close: a.immediateClose || 0}, a)
	        }, hideMenuItems: function (a) {
	            c("hideMenuItems", {menuList: a.menuList}, a)
	        }, showMenuItems: function (a) {
	            c("showMenuItems", {menuList: a.menuList}, a)
	        }, hideAllNonBaseMenuItem: function (a) {
	            c("hideAllNonBaseMenuItem", {}, a)
	        }, showAllNonBaseMenuItem: function (a) {
	            c("showAllNonBaseMenuItem", {}, a)
	        }, scanQRCode: function (a) {
	            a = a || {}, c("scanQRCode", {
	                needResult: a.needResult || 0,
	                scanType: a.scanType || ["qrCode", "barCode"]
	            }, function () {
	                return a._complete = function (a) {
	                    var b, c;
	                    v && (b = a.resultStr, b && (c = JSON.parse(b), a.resultStr = c && c.scan_code && c.scan_code.scan_result))
	                }, a
	            }())
	        }, openProductSpecificView: function (a) {
	            c(o.openProductSpecificView, {pid: a.productId, view_type: a.viewType || 0}, a)
	        }, addCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, card_ext: g.cardExt}, d.push(h);
	            c(o.addCard, {card_list: d}, function () {
	                return a._complete = function (a) {
	                    var c, d, e, b = a.card_list;
	                    if (b) {
	                        for (b = JSON.parse(b), c = 0, d = b.length; d > c; ++c)e = b[c], e.cardId = e.card_id, e.cardExt = e.card_ext, e.isSuccess = e.is_succ ? !0 : !1, delete e.card_id, delete e.card_ext, delete e.is_succ;
	                        a.cardList = b, delete a.card_list
	                    }
	                }, a
	            }())
	        }, chooseCard: function (a) {
	            c("chooseCard", {
	                app_id: z.appId,
	                location_id: a.shopId || "",
	                sign_type: a.signType || "SHA1",
	                card_id: a.cardId || "",
	                card_type: a.cardType || "",
	                card_sign: a.cardSign,
	                time_stamp: a.timestamp + "",
	                nonce_str: a.nonceStr
	            }, function () {
	                return a._complete = function (a) {
	                    a.cardList = a.choose_card_info, delete a.choose_card_info
	                }, a
	            }())
	        }, openCard: function (a) {
	            var e, f, g, h, b = a.cardList, d = [];
	            for (e = 0, f = b.length; f > e; ++e)g = b[e], h = {card_id: g.cardId, code: g.code}, d.push(h);
	            c(o.openCard, {card_list: d}, a)
	        }, chooseWXPay: function (a) {
	            c(o.chooseWXPay, f(a), a)
	        }
	    }, b && (a.wx = a.jWeixin = C), C
	});

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzdlMDhkNTQyNGEwYTI5NTlmYTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC92dWUvMS4wLjI2L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9wcm9jZXNzLzAuMTEuNS9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9qcXVlcnkvMy4xLjAvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlP2U2MzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/N2YwMSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vQXBwLnZ1ZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvYmFiZWwtcnVudGltZS82LjkuMi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZT81ZDVmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlPzM4MTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL0JHLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWU/Mzk3ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lNzQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlPzhhZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmciLCJ3ZWJwYWNrOi8vL01lbnVCYXIudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlPzgyMTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/NmI3NyIsIndlYnBhY2s6Ly8vT3B0aW9uc0RpYWxvZy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNleWxleW8gC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/MGVkZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT9lZDM4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/NmIzNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWU/MzBlMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvY291bnQtZG93bi5wbmciLCJ3ZWJwYWNrOi8vL0JldEFuZEJvbnVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzIiwid2VicGFjazovLy8uL34vLm5wbWluc3RhbGwvdnVlLXJlc291cmNlLzAuOS4zL3Z1ZS1yZXNvdXJjZS9kaXN0L3Z1ZS1yZXNvdXJjZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlPzU1NjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzM5MWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZT9jYmRlIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZyIsIndlYnBhY2s6Ly8vUGxheVBhbmVsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvNVjnrbnnoIEt5ou36LSdLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlPzhjMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9iMjdjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT9lNWUxIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvdGguanBnIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nIiwid2VicGFjazovLy9TdGF0ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT81MzhjIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/YTFhMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWU/NWZmYyIsIndlYnBhY2s6Ly8vQmV0TXVsdGlwbGUudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT84MDgxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlP2RmYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/ZjRiYiIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mmpfoibLmjKHmnb8ucG5nIiwid2VicGFjazovLy9NZXNzYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2i5ZWG5Z+OLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv6LWg6YCB5aW95Y+L6YeR5biBLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/otaDpgIEv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWU/ZWRkMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlP2M5MGQiLCJ3ZWJwYWNrOi8vL2JldEluZm8udnVlIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2JldFJlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzNkOGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/YjU4MSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9hZDBlIiwid2VicGFjazovLy9ib251c1JlY29yZC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWU/ZGUyYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZT81NjMyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlP2QzM2UiLCJ3ZWJwYWNrOi8vL0V4Y2hhbmdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaIucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlPzkwZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWU/NzM3OSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT9jOTEzIiwid2VicGFjazovLy9SZWNoYXJnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC81MDAwLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMDAucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLzorrDlvZXmjInpkq4ucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lnZcucG5nIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlP2Q0ZDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2Q4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT9mYzVkIiwid2VicGFjazovLy9ydWxlSW50cm9kdWNlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9ydWxlSW50cm8uaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlP2E5ZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWVzc2FnZS52dWU/OGJiNCIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL25vdGljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9zaW5nbGV1c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZT9kZmFhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWU/YzkzOCIsIndlYnBhY2s6Ly8vdGlwLW1vZGFsLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlP2NiZWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/ZDExZSIsIndlYnBhY2s6Ly8vLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUNBLGVBQUksR0FBSjtBQUNBLGVBQUksTUFBSixDQUFXLE1BQVgsRUFBbUIsVUFBUyxLQUFULEVBQWdCO0FBQy9CLFNBQUksT0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFRLElBQW5CLENBQVg7QUFDQSxTQUFJLE1BQU0sS0FBSyxLQUFMLENBQVksUUFBUSxJQUFULEdBQWlCLEVBQTVCLENBQVY7QUFDQSxTQUFJLE9BQU8sRUFBWCxFQUFlO0FBQ1gsZ0JBQU8sTUFBTSxJQUFiO0FBQ0g7QUFDRCxTQUFJLE1BQU0sRUFBVixFQUFjO0FBQ1YsZUFBTSxNQUFNLEdBQVo7QUFDSDtBQUNELFNBQUksTUFBTSxRQUFRLEVBQWxCO0FBQ0EsU0FBSSxNQUFNLEVBQVYsRUFBYztBQUNWLGVBQU0sTUFBTSxHQUFaO0FBQ0g7QUFDRCxZQUFPLENBQUMsT0FBTyxDQUFQLEdBQVcsT0FBTyxHQUFsQixHQUF3QixFQUF6QixJQUErQixHQUEvQixHQUFxQyxHQUFyQyxHQUEyQyxHQUFsRDtBQUNILEVBZEQ7QUFlQSxlQUFJLE1BQUosQ0FBVyxVQUFYLEVBQXVCLGlCQUFTO0FBQzVCLFlBQU8sSUFBSSxJQUFKLENBQVMsS0FBVCxFQUFnQixjQUFoQixFQUFQO0FBQ0gsRUFGRDtBQUdBLEtBQUksU0FBUyxFQUFiO0FBQ0EsdUJBQVksYUFBWixHQUE0QixJQUE1QixDQUFpQyxVQUFDLEdBQUQsRUFBUztBQUN0QyxjQUFTLElBQUksSUFBYjtBQUNBLGFBQVEsR0FBUixDQUFZLE1BQVo7QUFjSCxFQWhCRCxFQWdCRyxVQUFDLEdBQUQsRUFBUztBQUNSLGFBQVEsS0FBUixDQUFjLEdBQWQ7QUFDSCxFQWxCRDs7QUFxQkEsS0FBSSxPQUFPLGtCQUFRO0FBQ2YsU0FBSSxNQURXO0FBRWYsaUJBQVksRUFBRSxrQkFBRjtBQUZHLEVBQVIsQ0FBWCxDOzs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGFBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLFlBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQSwyQkFBMEI7QUFDMUIsMkJBQTBCO0FBQzFCO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQixNQUFNO0FBQ2hDO0FBQ0EsMkJBQTBCLE1BQU07QUFDaEM7QUFDQSxtQkFBa0IsTUFBTTtBQUN4QjtBQUNBLG1CQUFrQixNQUFNO0FBQ3hCO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBLG1CQUFrQixNQUFNO0FBQ3hCO0FBQ0EsbUJBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixRQUFRO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxJQUFJO0FBQ2YsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsSUFBSTtBQUNmLFlBQVcsUUFBUTtBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsc0JBQXFCLE1BQU07QUFDM0IsNkJBQTRCLE9BQU87O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7QUFDRCxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkIsWUFBVyxJQUFJO0FBQ2YsWUFBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsSUFBSTtBQUNmLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsSUFBSTtBQUNmLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsSUFBSTtBQUNmLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQUFXLGVBQWU7QUFDMUIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEIsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixhQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLO0FBQ2hCLFlBQVcsS0FBSztBQUNoQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEtBQUs7QUFDaEIsWUFBVyxLQUFLO0FBQ2hCLFlBQVcsSUFBSTtBQUNmLFlBQVcsaUJBQWlCO0FBQzVCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsS0FBSztBQUNoQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixZQUFXLElBQUk7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLO0FBQ2hCLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLFFBQVE7QUFDbkIsWUFBVyxRQUFRO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGdEQUErQztBQUMvQyxNQUFLO0FBQ0wsb0NBQW1DO0FBQ25DO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLG9DQUFtQztBQUNuQztBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLHNDQUFxQyxPQUFP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsS0FBSztBQUNsQixjQUFhLElBQUk7QUFDakIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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LGNBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxLQUFLO0FBQ2xCLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsS0FBSztBQUNsQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEtBQUs7QUFDbEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsSUFBSTtBQUNqQixjQUFhLFFBQVE7QUFDckIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixFQUFFOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN0SHRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxpQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZixVQUFTOztBQUVUO0FBQ0EsU0FBUSxpQ0FBaUM7QUFDekMsU0FBUSxvQkFBb0I7QUFDNUIsU0FBUSxzQ0FBc0M7QUFDOUMsU0FBUTtBQUNSLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZEQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsMENBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDhDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRSx1Q0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsV0FBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxXQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLGFBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSw0REFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxxRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxXQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakIsMkJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsMkNBQTBDO0FBQzFDLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0Msc0NBQXNDO0FBQzlFLHFDQUFvQyx1Q0FBdUM7QUFDM0UscUNBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLFFBQU87QUFDUDtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDLHNDQUFxQztBQUNyQyxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixhQUFhO0FBQ3BDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixrREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FB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QTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7O0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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RUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEwQiwyQkFBMkIsUUFBUSxpQkFBaUI7QUFDOUU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsS0FBSyxFQUFFLEtBQUssTUFBTSxFQUFFO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsNEJBQTJCO0FBQzNCO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQjtBQUNuQjs7QUFFQSx1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFD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QUN4QyxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDLEUiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiYnVpbGQvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzN2UwOGQ1NDI0YTBhMjk1OWZhMVxuICoqLyIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCdcbmltcG9ydCB3eCBmcm9tICd3ZWl4aW4tanMtc2RrJ1xuaW1wb3J0IFZ1ZVJlc291cmNlIGZyb20gJ3Z1ZS1yZXNvdXJjZSdcbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuL2pzL3JlcXVlc3QtbGlzdCdcblZ1ZS51c2UoVnVlUmVzb3VyY2UpXG5WdWUuZmlsdGVyKCd0aW1lJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBsZXQgaG91ciA9IE1hdGguZmxvb3IodmFsdWUgLyAzNjAwKVxuICAgIGxldCBtaW4gPSBNYXRoLmZsb29yKCh2YWx1ZSAlIDM2MDApIC8gNjApXG4gICAgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICBob3VyID0gJzAnICsgaG91clxuICAgIH1cbiAgICBpZiAobWluIDwgMTApIHtcbiAgICAgICAgbWluID0gJzAnICsgbWluXG4gICAgfVxuICAgIGxldCBzZWMgPSB2YWx1ZSAlIDYwXG4gICAgaWYgKHNlYyA8IDEwKSB7XG4gICAgICAgIHNlYyA9ICcwJyArIHNlY1xuICAgIH1cbiAgICByZXR1cm4gKGhvdXIgPiAwID8gaG91ciArICc6JyA6ICcnKSArIG1pbiArICc6JyArIHNlY1xufSlcblZ1ZS5maWx0ZXIoJ2RhdGV0aW1lJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoKVxufSlcbmxldCBjb25maWcgPSB7fVxuUmVxdWVzdExpc3QuZ2V0TWFpbkNvbmZpZygpLnRoZW4oKHJlcykgPT4geyAvL+S7juWQjuWPsOiOt+WPlumFjee9ruaWh+S7tlxuICAgIGNvbmZpZyA9IHJlcy5kYXRhXG4gICAgY29uc29sZS5sb2coY29uZmlnKVxuICAgICAgICAvLyB3eC5jb25maWcoe1xuICAgICAgICAvLyAgICAgZGVidWc6IHRydWUsXG4gICAgICAgIC8vICAgICBhcHBJZDogJzw/cGhwIGVjaG8gJHNpZ25QYWNrYWdlW1wiYXBwSWRcIl07Pz4nLFxuICAgICAgICAvLyAgICAgdGltZXN0YW1wOiA8P3BocCBlY2hvICRzaWduUGFja2FnZVtcInRpbWVzdGFtcFwiXTs/PixcbiAgICAgICAgLy8gICAgIG5vbmNlU3RyOiAnPD9waHAgZWNobyAkc2lnblBhY2thZ2VbXCJub25jZVN0clwiXTs/PicsXG4gICAgICAgIC8vICAgICBzaWduYXR1cmU6ICc8P3BocCBlY2hvICRzaWduUGFja2FnZVtcInNpZ25hdHVyZVwiXTs/PicsXG4gICAgICAgIC8vICAgICBqc0FwaUxpc3Q6IFtcbiAgICAgICAgLy8gICAgICAgICAvLyDmiYDmnInopoHosIPnlKjnmoQgQVBJIOmDveimgeWKoOWIsOi/meS4quWIl+ihqOS4rVxuICAgICAgICAvLyAgICAgICAgICdvbk1lbnVTaGFyZVRpbWVsaW5lJyxcbiAgICAgICAgLy8gICAgICAgICAnb25NZW51U2hhcmVBcHBNZXNzYWdlJyxcbiAgICAgICAgLy8gICAgICAgICAnY2hvb3NlSW1hZ2UnXG4gICAgICAgIC8vICAgICBdXG4gICAgICAgIC8vIH0pO1xufSwgKHJlcykgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IocmVzKVxufSlcblxuLy9odHRwczovL29wZW4ud2VpeGluLnFxLmNvbS9jb25uZWN0L29hdXRoMi9hdXRob3JpemU/YXBwaWQ9d3hmZmUxOTBkZWMzMjcxYTFjJnJlZGlyZWN0X3VyaT1odHRwOi8vbHN3ZWl4aW50ZXN0LmFwcGxpbnppLmNvbS9waHAvdXJsb3BlbmlkLnBocCZyZXNwb25zZV90eXBlPWNvZGUmc2NvcGU9c25zYXBpX3VzZXJpbmZvJnN0YXRlPTEyM1xudmFyIG1haW4gPSBuZXcgVnVlKHtcbiAgICBlbDogJ2JvZHknLFxuICAgIGNvbXBvbmVudHM6IHsgYXBwOiBBcHAgfVxufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21haW4uanNcbiAqKi8iLCIvKiFcbiAqIFZ1ZS5qcyB2MS4wLjI2XG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3Byb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24gZGVsKG9iaiwga2V5KSB7XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgICAgZGVsZXRlIG9iai5fZGF0YVtrZXldO1xuICAgICAgb2JqLl9kaWdlc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgaWYgKG9iLnZtcykge1xuICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdm0gPSBvYi52bXNbaV07XG4gICAgICB2bS5fdW5wcm94eShrZXkpO1xuICAgICAgdm0uX2RpZ2VzdCgpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgbGl0ZXJhbFZhbHVlUkUgPSAvXlxccz8odHJ1ZXxmYWxzZXwtP1tcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvO1xuXG5mdW5jdGlvbiBpc0xpdGVyYWwoZXhwKSB7XG4gIHJldHVybiBsaXRlcmFsVmFsdWVSRS50ZXN0KGV4cCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rjtcbn1cblxuLyoqXG4gKiBHdWFyZCB0ZXh0IG91dHB1dCwgbWFrZSBzdXJlIHVuZGVmaW5lZCBvdXRwdXRzXG4gKiBlbXB0eSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gX3RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIENoZWNrIGFuZCBjb252ZXJ0IHBvc3NpYmxlIG51bWVyaWMgc3RyaW5ncyB0byBudW1iZXJzXG4gKiBiZWZvcmUgc2V0dGluZyBiYWNrIHRvIGRhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfE51bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG59XG5cbi8qKlxuICogU3RyaXAgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWxzZX1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBhID09PSBiICYmIChhID09PSAweDIyIHx8IGEgPT09IDB4MjcpID8gc3RyLnNsaWNlKDEsIC0xKSA6IHN0cjtcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZztcblxuZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGwgPyBsID4gMSA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKSA6IGZuLmNhbGwoY3R4LCBhKSA6IGZuLmNhbGwoY3R4KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LWxpa2V9IGxpc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gc3RhcnQgaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuZCh0bywgZnJvbSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HO1xufVxuXG4vKipcbiAqIEFycmF5IHR5cGUgY2hlY2suXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZSBhIGZ1bmN0aW9uIHNvIGl0IG9ubHkgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlXG4gKiBpbnB1dCBzdG9wcyBhcnJpdmluZyBhZnRlciB0aGUgZ2l2ZW4gd2FpdCBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtOdW1iZXJ9IHdhaXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBfZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIE1hbnVhbCBpbmRleE9mIGJlY2F1c2UgaXQncyBzbGlnaHRseSBmYXN0ZXIgdGhhblxuICogbmF0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgb2JqKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjYW5jZWxsYWJsZSB2ZXJzaW9uIG9mIGFuIGFzeW5jIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjYW5jZWxsYWJsZShmbikge1xuICB2YXIgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIGNiO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICpcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIGEgPT0gYiB8fCAoaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYikgPyBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYikgOiBmYWxzZSk7XG4gIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG59XG5cbnZhciBoYXNQcm90byA9ICgnX19wcm90b19fJyBpbiB7fSk7XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vLyBVQSBzbmlmZmluZyBmb3Igd29ya2luZyBhcm91bmQgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3NcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiBVQS5pbmRleE9mKCd0cmlkZW50JykgPiAwO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lvcyA9IFVBICYmIC8oaXBob25lfGlwYWR8aXBvZHxpb3MpL2kudGVzdChVQSk7XG52YXIgaW9zVmVyc2lvbk1hdGNoID0gaXNJb3MgJiYgVUEubWF0Y2goL29zIChbXFxkX10rKS8pO1xudmFyIGlvc1ZlcnNpb24gPSBpb3NWZXJzaW9uTWF0Y2ggJiYgaW9zVmVyc2lvbk1hdGNoWzFdLnNwbGl0KCdfJyk7XG5cbi8vIGRldGVjdGluZyBpT1MgVUlXZWJWaWV3IGJ5IGluZGV4ZWREQlxudmFyIGhhc011dGF0aW9uT2JzZXJ2ZXJCdWcgPSBpb3NWZXJzaW9uICYmIE51bWJlcihpb3NWZXJzaW9uWzBdKSA+PSA5ICYmIE51bWJlcihpb3NWZXJzaW9uWzFdKSA+PSAzICYmICF3aW5kb3cuaW5kZXhlZERCO1xuXG52YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUU5KSB7XG4gIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdmFyIGlzV2Via2l0QW5pbSA9IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB0cmFuc2l0aW9uUHJvcCA9IGlzV2Via2l0VHJhbnMgPyAnV2Via2l0VHJhbnNpdGlvbicgOiAndHJhbnNpdGlvbic7XG4gIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIGFuaW1hdGlvblByb3AgPSBpc1dlYmtpdEFuaW0gPyAnV2Via2l0QW5pbWF0aW9uJyA6ICdhbmltYXRpb24nO1xuICBhbmltYXRpb25FbmRFdmVudCA9IGlzV2Via2l0QW5pbSA/ICd3ZWJraXRBbmltYXRpb25FbmQnIDogJ2FuaW1hdGlvbmVuZCc7XG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuIElkZWFsbHkgdGhpc1xuICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICogTXV0YXRpb25PYnNlcnZlciBpZiBpdCdzIGF2YWlsYWJsZSwgYW5kIGZhbGxiYWNrIHRvXG4gKiBzZXRUaW1lb3V0KDApLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKi9cblxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmICFoYXNNdXRhdGlvbk9ic2VydmVyQnVnKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY291bnRlcik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBjb3VudGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gd2VicGFjayBhdHRlbXB0cyB0byBpbmplY3QgYSBzaGltIGZvciBzZXRJbW1lZGlhdGVcbiAgICAvLyBpZiBpdCBpcyB1c2VkIGFzIGEgZ2xvYmFsLCBzbyB3ZSBoYXZlIHRvIHdvcmsgYXJvdW5kIHRoYXQgdG9cbiAgICAvLyBhdm9pZCBidW5kbGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgIHZhciBjb250ZXh0ID0gaW5Ccm93c2VyID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbiAgICB0aW1lckZ1bmMgPSBjb250ZXh0LnNldEltbWVkaWF0ZSB8fCBzZXRUaW1lb3V0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY2IsIGN0eCkge1xuICAgIHZhciBmdW5jID0gY3R4ID8gZnVuY3Rpb24gKCkge1xuICAgICAgY2IuY2FsbChjdHgpO1xuICAgIH0gOiBjYjtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jKTtcbiAgICBpZiAocGVuZGluZykgcmV0dXJuO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYyhuZXh0VGlja0hhbmRsZXIsIDApO1xuICB9O1xufSkoKTtcblxudmFyIF9TZXQgPSB1bmRlZmluZWQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBTZXQudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICBfU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5zZXRba2V5XSA9IDE7XG4gIH07XG4gIF9TZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQ2FjaGUobGltaXQpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2tleW1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbnZhciBwID0gQ2FjaGUucHJvdG90eXBlO1xuXG4vKipcbiAqIFB1dCA8dmFsdWU+IGludG8gdGhlIGNhY2hlIGFzc29jaWF0ZWQgd2l0aCA8a2V5Pi5cbiAqIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhcyByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3JcbiAqIHRoZSBuZXcgZW50cnkuIE90aGVyd2lzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKiAoaS5lLiBpZiB0aGVyZSB3YXMgZW5vdWdoIHJvb20gYWxyZWFkeSkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICovXG5cbnAucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHJlbW92ZWQ7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGVudHJ5ID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHRoaXMuX2tleW1hcFtrZXldID0gZW50cnk7XG4gICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnk7XG4gICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuc2l6ZSsrO1xuICB9XG4gIGVudHJ5LnZhbHVlID0gdmFsdWU7XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIFB1cmdlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGZyb20gdGhlXG4gKiBjYWNoZS4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiBjYWNoZSB3YXMgZW1wdHkuXG4gKi9cblxucC5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICBpZiAoZW50cnkpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XG4gICAgdGhpcy5oZWFkLm9sZGVyID0gdW5kZWZpbmVkO1xuICAgIGVudHJ5Lm5ld2VyID0gZW50cnkub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplLS07XG4gIH1cbiAgcmV0dXJuIGVudHJ5O1xufTtcblxuLyoqXG4gKiBHZXQgYW5kIHJlZ2lzdGVyIHJlY2VudCB1c2Ugb2YgPGtleT4uIFJldHVybnMgdGhlIHZhbHVlXG4gKiBhc3NvY2lhdGVkIHdpdGggPGtleT4gb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkVudHJ5XG4gKiBAcmV0dXJuIHtFbnRyeXwqfVxuICovXG5cbnAuZ2V0ID0gZnVuY3Rpb24gKGtleSwgcmV0dXJuRW50cnkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XG4gIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChlbnRyeSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuICAvLyBIRUFELS0tLS0tLS0tLS0tLS1UQUlMXG4gIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxuICAvLyAgIEEgIEIgIEMgIDxEPiAgRVxuICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7IC8vIEMgPC0tIEUuXG4gIH1cbiAgaWYgKGVudHJ5Lm9sZGVyKSB7XG4gICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjsgLy8gQy4gLS0+IEVcbiAgfVxuICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZDsgLy8gRCAtLXhcbiAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWw7IC8vIEQuIC0tPiBFXG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTsgLy8gRS4gPC0tIERcbiAgfVxuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcbn07XG5cbnZhciBjYWNoZSQxID0gbmV3IENhY2hlKDEwMDApO1xudmFyIGZpbHRlclRva2VuUkUgPSAvW15cXHMnXCJdK3wnW14nXSonfFwiW15cIl0qXCIvZztcbnZhciByZXNlcnZlZEFyZ1JFID0gL15pbiR8Xi0/XFxkKy87XG5cbi8qKlxuICogUGFyc2VyIHN0YXRlXG4gKi9cblxudmFyIHN0cjtcbnZhciBkaXI7XG52YXIgYztcbnZhciBwcmV2O1xudmFyIGk7XG52YXIgbDtcbnZhciBsYXN0RmlsdGVySW5kZXg7XG52YXIgaW5TaW5nbGU7XG52YXIgaW5Eb3VibGU7XG52YXIgY3VybHk7XG52YXIgc3F1YXJlO1xudmFyIHBhcmVuO1xuLyoqXG4gKiBQdXNoIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IGRpcmVjdGl2ZSBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICB2YXIgZXhwID0gc3RyLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpO1xuICB2YXIgZmlsdGVyO1xuICBpZiAoZXhwKSB7XG4gICAgZmlsdGVyID0ge307XG4gICAgdmFyIHRva2VucyA9IGV4cC5tYXRjaChmaWx0ZXJUb2tlblJFKTtcbiAgICBmaWx0ZXIubmFtZSA9IHRva2Vuc1swXTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZpbHRlci5hcmdzID0gdG9rZW5zLnNsaWNlKDEpLm1hcChwcm9jZXNzRmlsdGVyQXJnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlcikge1xuICAgIChkaXIuZmlsdGVycyA9IGRpci5maWx0ZXJzIHx8IFtdKS5wdXNoKGZpbHRlcik7XG4gIH1cbiAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXJndW1lbnQgaXMgZHluYW1pYyBhbmQgc3RyaXAgcXVvdGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzRmlsdGVyQXJnKGFyZykge1xuICBpZiAocmVzZXJ2ZWRBcmdSRS50ZXN0KGFyZykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRvTnVtYmVyKGFyZyksXG4gICAgICBkeW5hbWljOiBmYWxzZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMoYXJnKTtcbiAgICB2YXIgZHluYW1pYyA9IHN0cmlwcGVkID09PSBhcmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBkeW5hbWljID8gYXJnIDogc3RyaXBwZWQsXG4gICAgICBkeW5hbWljOiBkeW5hbWljXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgZGlyZWN0aXZlIHZhbHVlIGFuZCBleHRyYWN0IHRoZSBleHByZXNzaW9uXG4gKiBhbmQgaXRzIGZpbHRlcnMgaW50byBhIGRlc2NyaXB0b3IuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBcImEgKyAxIHwgdXBwZXJjYXNlXCIgd2lsbCB5aWVsZDpcbiAqIHtcbiAqICAgZXhwcmVzc2lvbjogJ2EgKyAxJyxcbiAqICAgZmlsdGVyczogW1xuICogICAgIHsgbmFtZTogJ3VwcGVyY2FzZScsIGFyZ3M6IG51bGwgfVxuICogICBdXG4gKiB9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZURpcmVjdGl2ZShzKSB7XG4gIHZhciBoaXQgPSBjYWNoZSQxLmdldChzKTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICAvLyByZXNldCBwYXJzZXIgc3RhdGVcbiAgc3RyID0gcztcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlO1xuICBjdXJseSA9IHNxdWFyZSA9IHBhcmVuID0gMDtcbiAgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgZGlyID0ge307XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAvLyBjaGVjayBzaW5nbGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gIWluU2luZ2xlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIC8vIGNoZWNrIGRvdWJsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSAhaW5Eb3VibGU7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICBzdHIuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbHJlYWR5IGhhcyBmaWx0ZXJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTticmVhazsgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTticmVhazsgLy8gJ1xuICAgICAgICBjYXNlIDB4Mjg6XG4gICAgICAgICAgcGFyZW4rKzticmVhazsgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgcGFyZW4tLTticmVhazsgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6XG4gICAgICAgICAgc3F1YXJlKys7YnJlYWs7IC8vIFtcbiAgICAgICAgY2FzZSAweDVEOlxuICAgICAgICAgIHNxdWFyZS0tO2JyZWFrOyAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjpcbiAgICAgICAgICBjdXJseSsrO2JyZWFrOyAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDpcbiAgICAgICAgICBjdXJseS0tO2JyZWFrOyAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgY2FjaGUkMS5wdXQocywgZGlyKTtcbiAgcmV0dXJuIGRpcjtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZURpcmVjdGl2ZTogcGFyc2VEaXJlY3RpdmVcbn0pO1xuXG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgY2FjaGUgPSB1bmRlZmluZWQ7XG52YXIgdGFnUkUgPSB1bmRlZmluZWQ7XG52YXIgaHRtbFJFID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgaW4gYSBSZWdFeHBcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVJlZ2V4KCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIGNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMV0pO1xuICB2YXIgdW5zYWZlT3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pO1xuICB0YWdSRSA9IG5ldyBSZWdFeHAodW5zYWZlT3BlbiArICcoKD86LnxcXFxcbikrPyknICsgdW5zYWZlQ2xvc2UgKyAnfCcgKyBvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcbiAgaHRtbFJFID0gbmV3IFJlZ0V4cCgnXicgKyB1bnNhZmVPcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyB1bnNhZmVDbG9zZSArICckJyk7XG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgdGVtcGxhdGUgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD4gfCBudWxsfVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB2YWx1ZVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaHRtbF1cbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW29uZVRpbWVdXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNvbXBpbGVSZWdleCgpO1xuICB9XG4gIHZhciBoaXQgPSBjYWNoZS5nZXQodGV4dCk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIGh0bWwsIHZhbHVlLCBmaXJzdCwgb25lVGltZTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGh0bWwgPSBodG1sUkUudGVzdChtYXRjaFswXSk7XG4gICAgdmFsdWUgPSBodG1sID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgb25lVGltZSA9IGZpcnN0ID09PSA0MjsgLy8gKlxuICAgIHZhbHVlID0gb25lVGltZSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdGFnOiB0cnVlLFxuICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgIGh0bWw6IGh0bWwsXG4gICAgICBvbmVUaW1lOiBvbmVUaW1lXG4gICAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pO1xuICB9XG4gIGNhY2hlLnB1dCh0ZXh0LCB0b2tlbnMpO1xuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHRva2Vuc1RvRXhwKHRva2Vucywgdm0pIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4sIHZtKTtcbiAgICB9KS5qb2luKCcrJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdm0sIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc2luZ2xlIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUb2tlbih0b2tlbiwgdm0sIHNpbmdsZSkge1xuICByZXR1cm4gdG9rZW4udGFnID8gdG9rZW4ub25lVGltZSAmJiB2bSA/ICdcIicgKyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgKyAnXCInIDogaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKSA6ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG59XG5cbi8qKlxuICogRm9yIGFuIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIGludGVycG9sYXRpb24gdGFncyxcbiAqIGUuZy4gYXR0cj1cInNvbWUte3t0aGluZyB8IGZpbHRlcn19XCIsIGluIG9yZGVyIHRvIGNvbWJpbmVcbiAqIHRoZSB3aG9sZSB0aGluZyBpbnRvIGEgc2luZ2xlIHdhdGNoYWJsZSBleHByZXNzaW9uLCB3ZVxuICogaGF2ZSB0byBpbmxpbmUgdGhvc2UgZmlsdGVycy4gVGhpcyBmdW5jdGlvbiBkb2VzIGV4YWN0bHlcbiAqIHRoYXQuIFRoaXMgaXMgYSBiaXQgaGFja3kgYnV0IGl0IGF2b2lkcyBoZWF2eSBjaGFuZ2VzXG4gKiB0byBkaXJlY3RpdmUgcGFyc2VyIGFuZCB3YXRjaGVyIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNpbmdsZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBmaWx0ZXJSRSA9IC9bXnxdXFx8W158XS87XG5mdW5jdGlvbiBpbmxpbmVGaWx0ZXJzKGV4cCwgc2luZ2xlKSB7XG4gIGlmICghZmlsdGVyUkUudGVzdChleHApKSB7XG4gICAgcmV0dXJuIHNpbmdsZSA/IGV4cCA6ICcoJyArIGV4cCArICcpJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUoZXhwKTtcbiAgICBpZiAoIWRpci5maWx0ZXJzKSB7XG4gICAgICByZXR1cm4gJygnICsgZXhwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3RoaXMuX2FwcGx5RmlsdGVycygnICsgZGlyLmV4cHJlc3Npb24gKyAvLyB2YWx1ZVxuICAgICAgJyxudWxsLCcgKyAvLyBvbGRWYWx1ZSAobnVsbCBmb3IgcmVhZClcbiAgICAgIEpTT04uc3RyaW5naWZ5KGRpci5maWx0ZXJzKSArIC8vIGZpbHRlciBkZXNjcmlwdG9yc1xuICAgICAgJyxmYWxzZSknOyAvLyB3cml0ZT9cbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHQgPSBPYmplY3QuZnJlZXplKHtcbiAgY29tcGlsZVJlZ2V4OiBjb21waWxlUmVnZXgsXG4gIHBhcnNlVGV4dDogcGFyc2VUZXh0LFxuICB0b2tlbnNUb0V4cDogdG9rZW5zVG9FeHBcbn0pO1xuXG52YXIgZGVsaW1pdGVycyA9IFsne3snLCAnfX0nXTtcbnZhciB1bnNhZmVEZWxpbWl0ZXJzID0gWyd7e3snLCAnfX19J107XG5cbnZhciBjb25maWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXMuXG4gICAqIEFsc28gZW5hYmxlcyBzdGFjayB0cmFjZSBmb3Igd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBhc3luYyByZW5kZXJpbmcuXG4gICAqL1xuXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdhcm4gYWdhaW5zdCBlcnJvcnMgY2F1Z2h0IHdoZW4gZXZhbHVhdGluZ1xuICAgKiBleHByZXNzaW9ucy5cbiAgICovXG5cbiAgd2FybkV4cHJlc3Npb25FcnJvcnM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgZGV2dG9vbHMgaW5zcGVjdGlvbi5cbiAgICogRGlzYWJsZWQgYnkgZGVmYXVsdCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAgICovXG5cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIEludGVybmFsIGZsYWcgdG8gaW5kaWNhdGUgdGhlIGRlbGltaXRlcnMgaGF2ZSBiZWVuXG4gICAqIGNoYW5nZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBfZGVsaW1pdGVyc0NoYW5nZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuXG4gIF9hc3NldFR5cGVzOiBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZWxlbWVudERpcmVjdGl2ZScsICdmaWx0ZXInLCAndHJhbnNpdGlvbicsICdwYXJ0aWFsJ10sXG5cbiAgLyoqXG4gICAqIHByb3AgYmluZGluZyBtb2Rlc1xuICAgKi9cblxuICBfcHJvcEJpbmRpbmdNb2Rlczoge1xuICAgIE9ORV9XQVk6IDAsXG4gICAgVFdPX1dBWTogMSxcbiAgICBPTkVfVElNRTogMlxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgYmF0Y2hlciBmbHVzaCBjeWNsZS5cbiAgICovXG5cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcblxufSwge1xuICBkZWxpbWl0ZXJzOiB7IC8qKlxuICAgICAgICAgICAgICAgICAqIEludGVycG9sYXRpb24gZGVsaW1pdGVycy4gQ2hhbmdpbmcgdGhlc2Ugd291bGQgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAqIHRoZSB0ZXh0IHBhcnNlciB0byByZS1jb21waWxlIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5PFN0cmluZz59XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gdmFsO1xuICAgICAgY29tcGlsZVJlZ2V4KCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9LFxuICB1bnNhZmVEZWxpbWl0ZXJzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdW5zYWZlRGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdW5zYWZlRGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB3YXJuID0gdW5kZWZpbmVkO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSB1bmRlZmluZWQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICFjb25maWcuc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWdWUgd2Fybl06ICcgKyBtc2cgKyAodm0gPyBmb3JtYXRDb21wb25lbnROYW1lKHZtKSA6ICcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX2lzVnVlID8gdm0uJG9wdGlvbnMubmFtZSA6IHZtLm5hbWU7XG4gICAgICByZXR1cm4gbmFtZSA/ICcgKGZvdW5kIGluIGNvbXBvbmVudDogPCcgKyBoeXBoZW5hdGUobmFtZSkgKyAnPiknIDogJyc7XG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRCZWZvcmUgd2l0aCB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmVXaXRoVHJhbnNpdGlvbihlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgYXBwbHlUcmFuc2l0aW9uKGVsLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlV2l0aFRyYW5zaXRpb24oZWwsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIC0xLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlKGVsKTtcbiAgfSwgdm0sIGNiKTtcbn1cblxuLyoqXG4gKiBBcHBseSB0cmFuc2l0aW9ucyB3aXRoIGFuIG9wZXJhdGlvbiBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiAgICAgICAgICAgICAgICAgIDE6IGVudGVyXG4gKiAgICAgICAgICAgICAgICAgLTE6IGxlYXZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIHRoZSBhY3R1YWwgRE9NIG9wZXJhdGlvblxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uKGVsLCBkaXJlY3Rpb24sIG9wLCB2bSwgY2IpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSBlbC5fX3ZfdHJhbnM7XG4gIGlmICghdHJhbnNpdGlvbiB8fFxuICAvLyBza2lwIGlmIHRoZXJlIGFyZSBubyBqcyBob29rcyBhbmQgQ1NTIHRyYW5zaXRpb24gaXNcbiAgLy8gbm90IHN1cHBvcnRlZFxuICAhdHJhbnNpdGlvbi5ob29rcyAmJiAhdHJhbnNpdGlvbkVuZEV2ZW50IHx8XG4gIC8vIHNraXAgdHJhbnNpdGlvbnMgZm9yIGluaXRpYWwgY29tcGlsZVxuICAhdm0uX2lzQ29tcGlsZWQgfHxcbiAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IGEgcGFyZW50IGRpcmVjdGl2ZVxuICAvLyBkdXJpbmcgdGhlIHBhcmVudCdzIGNvbXBpbGF0aW9uIHBoYXNlLCBza2lwIHRoZVxuICAvLyBhbmltYXRpb24uXG4gIHZtLiRwYXJlbnQgJiYgIXZtLiRwYXJlbnQuX2lzQ29tcGlsZWQpIHtcbiAgICBvcCgpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFjdGlvbiA9IGRpcmVjdGlvbiA+IDAgPyAnZW50ZXInIDogJ2xlYXZlJztcbiAgdHJhbnNpdGlvblthY3Rpb25dKG9wLCBjYik7XG59XG5cbnZhciB0cmFuc2l0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFwcGVuZFdpdGhUcmFuc2l0aW9uOiBhcHBlbmRXaXRoVHJhbnNpdGlvbixcbiAgYmVmb3JlV2l0aFRyYW5zaXRpb246IGJlZm9yZVdpdGhUcmFuc2l0aW9uLFxuICByZW1vdmVXaXRoVHJhbnNpdGlvbjogcmVtb3ZlV2l0aFRyYW5zaXRpb24sXG4gIGFwcGx5VHJhbnNpdGlvbjogYXBwbHlUcmFuc2l0aW9uXG59KTtcblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RvciA9IGVsO1xuICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbkRvYyhub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fCBkb2MgPT09IHBhcmVudCB8fCAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gX2F0dHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gIHZhciB2YWwgPSBub2RlLmdldEF0dHJpYnV0ZShfYXR0cik7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QmluZEF0dHIobm9kZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGdldEF0dHIobm9kZSwgJ3YtYmluZDonICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcHJlc2VuY2Ugb2YgYSBiaW5kIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCc6JyArIG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2LWJpbmQ6JyArIG5hbWUpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBiZWZvcmUgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldCk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGFmdGVyIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbi8qKlxuICogUHJlcGVuZCBlbCB0byB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHByZXBlbmQoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYiwgdXNlQ2FwdHVyZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIHNob3J0aGFuZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgY2IpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xufVxuXG4vKipcbiAqIEZvciBJRTkgY29tcGF0OiB3aGVuIGJvdGggY2xhc3MgYW5kIDpjbGFzcyBhcmUgcHJlc2VudFxuICogZ2V0QXR0cmlidXRlKCdjbGFzcycpIHJldHVybnMgd3JvbmcgdmFsdWUuLi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcbiAgdmFyIGNsYXNzbmFtZSA9IGVsLmNsYXNzTmFtZTtcbiAgaWYgKHR5cGVvZiBjbGFzc25hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgY2xhc3NuYW1lID0gY2xhc3NuYW1lLmJhc2VWYWwgfHwgJyc7XG4gIH1cbiAgcmV0dXJuIGNsYXNzbmFtZTtcbn1cblxuLyoqXG4gKiBJbiBJRTksIHNldEF0dHJpYnV0ZSgnY2xhc3MnKSB3aWxsIHJlc3VsdCBpbiBlbXB0eSBjbGFzc1xuICogaWYgdGhlIGVsZW1lbnQgYWxzbyBoYXMgdGhlIDpjbGFzcyBhdHRyaWJ1dGU7IEhvd2V2ZXIgaW5cbiAqIFBoYW50b21KUywgc2V0dGluZyBgY2xhc3NOYW1lYCBkb2VzIG5vdCB3b3JrIG9uIFNWRyBlbGVtZW50cy4uLlxuICogU28gd2UgaGF2ZSB0byBkbyBhIGNvbmRpdGlvbmFsIGNoZWNrIGhlcmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHNldENsYXNzKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiAhL3N2ZyQvLnRlc3QoZWwubmFtZXNwYWNlVVJJKSkge1xuICAgIGVsLmNsYXNzTmFtZSA9IGNscztcbiAgfSBlbHNlIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIElFICYgU1ZHXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgc2V0Q2xhc3MoZWwsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBnZXRDbGFzcyhlbCkgKyAnICc7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIHNldENsYXNzKGVsLCBjdXIudHJpbSgpKTtcbiAgfVxuICBpZiAoIWVsLmNsYXNzTmFtZSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcmF3IGNvbnRlbnQgaW5zaWRlIGFuIGVsZW1lbnQgaW50byBhIHRlbXBvcmFyeVxuICogY29udGFpbmVyIGRpdlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNGcmFnbWVudFxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50KGVsLCBhc0ZyYWdtZW50KSB7XG4gIHZhciBjaGlsZDtcbiAgdmFyIHJhd0NvbnRlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNUZW1wbGF0ZShlbCkgJiYgaXNGcmFnbWVudChlbC5jb250ZW50KSkge1xuICAgIGVsID0gZWwuY29udGVudDtcbiAgfVxuICBpZiAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdHJpbU5vZGUoZWwpO1xuICAgIHJhd0NvbnRlbnQgPSBhc0ZyYWdtZW50ID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICB3aGlsZSAoY2hpbGQgPSBlbC5maXJzdENoaWxkKSB7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICByYXdDb250ZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd0NvbnRlbnQ7XG59XG5cbi8qKlxuICogVHJpbSBwb3NzaWJsZSBlbXB0eSBoZWFkL3RhaWwgdGV4dCBhbmQgY29tbWVudFxuICogbm9kZXMgaW5zaWRlIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHRyaW1Ob2RlKG5vZGUpIHtcbiAgdmFyIGNoaWxkO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZXF1ZW5jZXMgKi9cbiAgd2hpbGUgKChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHdoaWxlICgoY2hpbGQgPSBub2RlLmxhc3RDaGlsZCwgaXNUcmltbWFibGUoY2hpbGQpKSkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VxdWVuY2VzICovXG59XG5cbmZ1bmN0aW9uIGlzVHJpbW1hYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIW5vZGUuZGF0YS50cmltKCkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIHRlbXBsYXRlIHRhZy5cbiAqIE5vdGUgaWYgdGhlIHRlbXBsYXRlIGFwcGVhcnMgaW5zaWRlIGFuIFNWRyBpdHMgdGFnTmFtZVxuICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBcImFuY2hvclwiIGZvciBwZXJmb3JtaW5nIGRvbSBpbnNlcnRpb24vcmVtb3ZhbHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICogLSBmcmFnbWVudCBpbnN0YW5jZVxuICogLSB2LWh0bWxcbiAqIC0gdi1pZlxuICogLSB2LWZvclxuICogLSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtCb29sZWFufSBwZXJzaXN0IC0gSUUgdHJhc2hlcyBlbXB0eSB0ZXh0Tm9kZXMgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXMgdGhlIGFuY2hvciBuZWVkcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uLWVtcHR5IHRvIGJlIHBlcnNpc3RlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICogQHJldHVybiB7Q29tbWVudHxUZXh0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuZGVidWcgPyBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGVyc2lzdCA/ICcgJyA6ICcnKTtcbiAgYW5jaG9yLl9fdl9hbmNob3IgPSB0cnVlO1xuICByZXR1cm4gYW5jaG9yO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21wb25lbnQgcmVmIGF0dHJpYnV0ZSB0aGF0IHN0YXJ0cyB3aXRoICQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbnZhciByZWZSRSA9IC9edi1yZWY6LztcblxuZnVuY3Rpb24gZmluZFJlZihub2RlKSB7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgaWYgKHJlZlJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbWVsaXplKG5hbWUucmVwbGFjZShyZWZSRSwgJycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgYSBmdW5jdGlvbiB0byBhIHJhbmdlIG9mIG5vZGVzIC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcFxuICovXG5cbmZ1bmN0aW9uIG1hcE5vZGVSYW5nZShub2RlLCBlbmQsIG9wKSB7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG4gICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgb3Aobm9kZSk7XG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cbiAgb3AoZW5kKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSByYW5nZSBvZiBub2RlcyB3aXRoIHRyYW5zaXRpb24sIHN0b3JlXG4gKiB0aGUgbm9kZXMgaW4gYSBmcmFnbWVudCB3aXRoIGNvcnJlY3Qgb3JkZXJpbmcsXG4gKiBhbmQgY2FsbCBjYWxsYmFjayB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBzdGFydFxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGVSYW5nZShzdGFydCwgZW5kLCB2bSwgZnJhZywgY2IpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlbW92ZWQgPSAwO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgbWFwTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVuZCkgZG9uZSA9IHRydWU7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgICByZW1vdmVXaXRoVHJhbnNpdGlvbihub2RlLCB2bSwgb25SZW1vdmVkKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uUmVtb3ZlZCgpIHtcbiAgICByZW1vdmVkKys7XG4gICAgaWYgKGRvbmUgJiYgcmVtb3ZlZCA+PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gIH1cbn1cblxudmFyIGNvbW1vblRhZ1JFID0gL14oZGl2fHB8c3BhbnxpbWd8YXxifGl8YnJ8dWx8b2x8bGl8aDF8aDJ8aDN8aDR8aDV8aDZ8Y29kZXxwcmV8dGFibGV8dGh8dGR8dHJ8Zm9ybXxsYWJlbHxpbnB1dHxzZWxlY3R8b3B0aW9ufG5hdnxhcnRpY2xlfHNlY3Rpb258aGVhZGVyfGZvb3RlcikkL2k7XG52YXIgcmVzZXJ2ZWRUYWdSRSA9IC9eKHNsb3R8cGFydGlhbHxjb21wb25lbnQpJC9pO1xuXG52YXIgaXNVbmtub3duRWxlbWVudCA9IHVuZGVmaW5lZDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlzVW5rbm93bkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHRhZykge1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgIHJldHVybiBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU0MDUyNlxuICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgdW5rbm93biBmb3Igc29tZSBcIkludGVyYWN0aXZlIGVsZW1lbnRzLlwiXG4gICAgICAgICEvXihkYXRhfHRpbWV8cnRjfHJifGRldGFpbHN8ZGlhbG9nfHN1bW1hcnkpJC8udGVzdCh0YWcpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgY29tcG9uZW50LCBpZiB5ZXMgcmV0dXJuIGl0c1xuICogY29tcG9uZW50IGlkLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzQXR0cnMgPSBlbC5oYXNBdHRyaWJ1dGVzKCk7XG4gIGlmICghY29tbW9uVGFnUkUudGVzdCh0YWcpICYmICFyZXNlcnZlZFRhZ1JFLnRlc3QodGFnKSkge1xuICAgIGlmIChyZXNvbHZlQXNzZXQob3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSB7XG4gICAgICByZXR1cm4geyBpZDogdGFnIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpcyA9IGhhc0F0dHJzICYmIGdldElzQmluZGluZyhlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaXMpIHtcbiAgICAgICAgcmV0dXJuIGlzO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudE5hbWVNYXAgJiYgb3B0aW9ucy5fY29tcG9uZW50TmFtZU1hcFt0YWddO1xuICAgICAgICBpZiAoZXhwZWN0ZWRUYWcpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gJyArICdkaWQgeW91IG1lYW4gPCcgKyBleHBlY3RlZFRhZyArICc+PyAnICsgJ0hUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlIGtlYmFiLWNhc2UgaW4gdGVtcGxhdGVzLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVW5rbm93bkVsZW1lbnQoZWwsIHRhZykpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICsgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgKyAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoYXNBdHRycykge1xuICAgIHJldHVybiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IFwiaXNcIiBiaW5kaW5nIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRJc0JpbmRpbmcoZWwsIG9wdGlvbnMpIHtcbiAgLy8gZHluYW1pYyBzeW50YXhcbiAgdmFyIGV4cCA9IGVsLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgaWYgKHJlc29sdmVBc3NldChvcHRpb25zLCAnY29tcG9uZW50cycsIGV4cCkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHJldHVybiB7IGlkOiBleHAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwID0gZ2V0QmluZEF0dHIoZWwsICdpcycpO1xuICAgIGlmIChleHAgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgaWQ6IGV4cCwgZHluYW1pYzogdHJ1ZSB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gKlxuICogQHBhcmFtIHsqfSBwYXJlbnRWYWxcbiAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKi9cblxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShjaGlsZFZhbC5jYWxsKHRoaXMpLCBwYXJlbnRWYWwuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4oKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodm0pIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodm0pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogRWxcbiAqL1xuXG5zdHJhdHMuZWwgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSAmJiBjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1RoZSBcImVsXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJldCA9IGNoaWxkVmFsIHx8IHBhcmVudFZhbDtcbiAgLy8gaW52b2tlIHRoZSBlbGVtZW50IGZhY3RvcnkgaWYgdGhpcyBpcyBpbnN0YW5jZSBtZXJnZVxuICByZXR1cm4gdm0gJiYgdHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyA/IHJldC5jYWxsKHZtKSA6IHJldDtcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHBhcmFtIGF0dHJpYnV0ZXMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLmluaXQgPSBzdHJhdHMuY3JlYXRlZCA9IHN0cmF0cy5yZWFkeSA9IHN0cmF0cy5hdHRhY2hlZCA9IHN0cmF0cy5kZXRhY2hlZCA9IHN0cmF0cy5iZWZvcmVDb21waWxlID0gc3RyYXRzLmNvbXBpbGVkID0gc3RyYXRzLmJlZm9yZURlc3Ryb3kgPSBzdHJhdHMuZGVzdHJveWVkID0gc3RyYXRzLmFjdGl2YXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID8gcGFyZW50VmFsID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOiBpc0FycmF5KGNoaWxkVmFsKSA/IGNoaWxkVmFsIDogW2NoaWxkVmFsXSA6IHBhcmVudFZhbDtcbn07XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbCA/IGV4dGVuZChyZXMsIGd1YXJkQXJyYXlBc3NldHMoY2hpbGRWYWwpKSA6IHJlcztcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBFdmVudHMgJiBXYXRjaGVycy5cbiAqXG4gKiBFdmVudHMgJiB3YXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuXG5zdHJhdHMud2F0Y2ggPSBzdHJhdHMuZXZlbnRzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFpc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5cbnN0cmF0cy5wcm9wcyA9IHN0cmF0cy5tZXRob2RzID0gc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gZGVmYXVsdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgPyBwYXJlbnRWYWwgOiBjaGlsZFZhbDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIGNvbXBvbmVudCBvcHRpb25zIGdldCBjb252ZXJ0ZWQgdG8gYWN0dWFsXG4gKiBjb25zdHJ1Y3RvcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBndWFyZENvbXBvbmVudHMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmNvbXBvbmVudHMgPSBndWFyZEFycmF5QXNzZXRzKG9wdGlvbnMuY29tcG9uZW50cyk7XG4gICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgIHZhciBkZWY7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYXAgPSBvcHRpb25zLl9jb21wb25lbnROYW1lTWFwID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXTtcbiAgICAgIGlmIChjb21tb25UYWdSRS50ZXN0KGtleSkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBhIGFsbCBsb3dlcmNhc2UgPC0+IGtlYmFiLWNhc2UgbWFwcGluZyBmb3JcbiAgICAgIC8vIHBvc3NpYmxlIGN1c3RvbSBlbGVtZW50IGNhc2UgZXJyb3Igd2FybmluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWFwW2tleS5yZXBsYWNlKC8tL2csICcnKS50b0xvd2VyQ2FzZSgpXSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgfVxuICAgICAgZGVmID0gY29tcG9uZW50c1trZXldO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGVmKSkge1xuICAgICAgICBjb21wb25lbnRzW2tleV0gPSBWdWUuZXh0ZW5kKGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRQcm9wcyhvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIHZhciBpLCB2YWw7XG4gIGlmIChpc0FycmF5KHByb3BzKSkge1xuICAgIG9wdGlvbnMucHJvcHMgPSB7fTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMucHJvcHNbdmFsLm5hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXlzW2ldXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzW2tleXNbaV1dID0geyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHdWFyZCBhbiBBcnJheS1mb3JtYXQgYXNzZXRzIG9wdGlvbiBhbmQgY29udmVydGVkIGl0XG4gKiBpbnRvIHRoZSBrZXktdmFsdWUgT2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXNzZXRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRBcnJheUFzc2V0cyhhc3NldHMpIHtcbiAgaWYgKGlzQXJyYXkoYXNzZXRzKSkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgaSA9IGFzc2V0cy5sZW5ndGg7XG4gICAgdmFyIGFzc2V0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRzW2ldO1xuICAgICAgdmFyIGlkID0gdHlwZW9mIGFzc2V0ID09PSAnZnVuY3Rpb24nID8gYXNzZXQub3B0aW9ucyAmJiBhc3NldC5vcHRpb25zLm5hbWUgfHwgYXNzZXQuaWQgOiBhc3NldC5uYW1lIHx8IGFzc2V0LmlkO1xuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FycmF5LXN5bnRheCBhc3NldHMgbXVzdCBwcm92aWRlIGEgXCJuYW1lXCIgb3IgXCJpZFwiIGZpZWxkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzW2lkXSA9IGFzc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiBhc3NldHM7XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSB7VnVlfSBbdm1dIC0gaWYgdm0gaXMgcHJlc2VudCwgaW5kaWNhdGVzIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgYW4gaW5zdGFudGlhdGlvbiBtZXJnZS5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgZ3VhcmRDb21wb25lbnRzKGNoaWxkKTtcbiAgZ3VhcmRQcm9wcyhjaGlsZCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNoaWxkLnByb3BzRGF0YSAmJiAhdm0pIHtcbiAgICAgIHdhcm4oJ3Byb3BzRGF0YSBjYW4gb25seSBiZSB1c2VkIGFzIGFuIGluc3RhbnRpYXRpb24gb3B0aW9uLicpO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBpZiAoY2hpbGRbJ2V4dGVuZHMnXSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBjaGlsZFsnZXh0ZW5kcyddID09PSAnZnVuY3Rpb24nID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGRbJ2V4dGVuZHMnXS5vcHRpb25zLCB2bSkgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZFsnZXh0ZW5kcyddLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgdmFyIG1peGluT3B0aW9ucyA9IG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSA/IG1peGluLm9wdGlvbnMgOiBtaXhpbjtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluT3B0aW9ucywgdm0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtCb29sZWFufSB3YXJuTWlzc2luZ1xuICogQHJldHVybiB7T2JqZWN0fEZ1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3NldChvcHRpb25zLCB0eXBlLCBpZCwgd2Fybk1pc3NpbmcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICB2YXIgY2FtZWxpemVkSWQ7XG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8XG4gIC8vIGNhbWVsQ2FzZSBJRFxuICBhc3NldHNbY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCldIHx8XG4gIC8vIFBhc2NhbCBDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsaXplZElkLnNsaWNlKDEpXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbn07XG5cbi8qKlxuICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAqL1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRvQXJyYXkodGhpcy5zdWJzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47WydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZScsICdzb3J0JywgJ3JldmVyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCBhIG5ldyB2YWx1ZVxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckc2V0JywgZnVuY3Rpb24gJHNldChpbmRleCwgdmFsKSB7XG4gIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRoaXMubGVuZ3RoID0gTnVtYmVyKGluZGV4KSArIDE7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdO1xufSk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleCBvciB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpdGVtXG4gKi9cblxuZGVmKGFycmF5UHJvdG8sICckcmVtb3ZlJywgZnVuY3Rpb24gJHJlbW92ZShpdGVtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcywgaXRlbSk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufSk7XG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciBpbiBjZXJ0YWluIGNhc2VzLCBlLmcuXG4gKiB2LWZvciBzY29wZSBhbGlhcyBhbmQgcHJvcHMsIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvblxuICogYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIFNvIHdoZW5ldmVyIHdlIHdhbnQgdG8gc2V0IGEgcmVhY3RpdmUgcHJvcGVydHkgd2l0aG91dCBmb3JjaW5nXG4gKiBjb252ZXJzaW9uIG9uIHRoZSBuZXcgdmFsdWUsIHdlIHdyYXAgdGhhdCBjYWxsIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICovXG5cbnZhciBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcblxuZnVuY3Rpb24gd2l0aG91dENvbnZlcnNpb24oZm4pIHtcbiAgc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICBmbigpO1xuICBzaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG8gPyBwcm90b0F1Z21lbnQgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gSW5zdGFuY2UgbWV0aG9kc1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRoaXMuY29udmVydChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIG93bmVyIHZtLCBzbyB0aGF0IHdoZW4gJHNldC8kZGVsZXRlIG11dGF0aW9uc1xuICogaGFwcGVuIHdlIGNhbiBub3RpZnkgb3duZXIgdm1zIHRvIHByb3h5IHRoZSBrZXlzIGFuZFxuICogZGlnZXN0IHRoZSB3YXRjaGVycy4gVGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBvYmplY3RcbiAqIGlzIG9ic2VydmVkIGFzIGFuIGluc3RhbmNlJ3Mgcm9vdCAkZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuYWRkVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgKHRoaXMudm1zIHx8ICh0aGlzLnZtcyA9IFtdKSkucHVzaCh2bSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvd25lciB2bS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IGlzXG4gKiBzd2FwcGVkIG91dCBhcyBhbiBpbnN0YW5jZSdzICRkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUucmVtb3ZlVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgdGhpcy52bXMuJHJlbW92ZSh2bSk7XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKi9cblxuZnVuY3Rpb24gcHJvdG9BdWdtZW50KHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50KHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKiBAcmV0dXJuIHtPYnNlcnZlcnx1bmRlZmluZWR9XG4gKiBAc3RhdGljXG4gKi9cblxuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgdm0pIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoc2hvdWxkQ29udmVydCAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmICF2YWx1ZS5faXNWdWUpIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKG9iICYmIHZtKSB7XG4gICAgb2IuYWRkVm0odm0pO1xuICB9XG4gIHJldHVybiBvYjtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAodmFyIGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsdWVbaV07XG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG52YXIgdXRpbCA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUsXG5cdHNldDogc2V0LFxuXHRkZWw6IGRlbCxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzTGl0ZXJhbDogaXNMaXRlcmFsLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHR0b0Jvb2xlYW46IHRvQm9vbGVhbixcblx0c3RyaXBRdW90ZXM6IHN0cmlwUXVvdGVzLFxuXHRjYW1lbGl6ZTogY2FtZWxpemUsXG5cdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuXHRjbGFzc2lmeTogY2xhc3NpZnksXG5cdGJpbmQ6IGJpbmQsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdGRlZjogZGVmLFxuXHRkZWJvdW5jZTogX2RlYm91bmNlLFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRjYW5jZWxsYWJsZTogY2FuY2VsbGFibGUsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdGRldnRvb2xzOiBkZXZ0b29scyxcblx0aXNJRTogaXNJRSxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0FuZHJvaWQ6IGlzQW5kcm9pZCxcblx0aXNJb3M6IGlzSW9zLFxuXHRpb3NWZXJzaW9uTWF0Y2g6IGlvc1ZlcnNpb25NYXRjaCxcblx0aW9zVmVyc2lvbjogaW9zVmVyc2lvbixcblx0aGFzTXV0YXRpb25PYnNlcnZlckJ1ZzogaGFzTXV0YXRpb25PYnNlcnZlckJ1Zyxcblx0Z2V0IHRyYW5zaXRpb25Qcm9wICgpIHsgcmV0dXJuIHRyYW5zaXRpb25Qcm9wOyB9LFxuXHRnZXQgdHJhbnNpdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIHRyYW5zaXRpb25FbmRFdmVudDsgfSxcblx0Z2V0IGFuaW1hdGlvblByb3AgKCkgeyByZXR1cm4gYW5pbWF0aW9uUHJvcDsgfSxcblx0Z2V0IGFuaW1hdGlvbkVuZEV2ZW50ICgpIHsgcmV0dXJuIGFuaW1hdGlvbkVuZEV2ZW50OyB9LFxuXHRuZXh0VGljazogbmV4dFRpY2ssXG5cdGdldCBfU2V0ICgpIHsgcmV0dXJuIF9TZXQ7IH0sXG5cdHF1ZXJ5OiBxdWVyeSxcblx0aW5Eb2M6IGluRG9jLFxuXHRnZXRBdHRyOiBnZXRBdHRyLFxuXHRnZXRCaW5kQXR0cjogZ2V0QmluZEF0dHIsXG5cdGhhc0JpbmRBdHRyOiBoYXNCaW5kQXR0cixcblx0YmVmb3JlOiBiZWZvcmUsXG5cdGFmdGVyOiBhZnRlcixcblx0cmVtb3ZlOiByZW1vdmUsXG5cdHByZXBlbmQ6IHByZXBlbmQsXG5cdHJlcGxhY2U6IHJlcGxhY2UsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdGV4dHJhY3RDb250ZW50OiBleHRyYWN0Q29udGVudCxcblx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuXHRpc1RlbXBsYXRlOiBpc1RlbXBsYXRlLFxuXHRjcmVhdGVBbmNob3I6IGNyZWF0ZUFuY2hvcixcblx0ZmluZFJlZjogZmluZFJlZixcblx0bWFwTm9kZVJhbmdlOiBtYXBOb2RlUmFuZ2UsXG5cdHJlbW92ZU5vZGVSYW5nZTogcmVtb3ZlTm9kZVJhbmdlLFxuXHRpc0ZyYWdtZW50OiBpc0ZyYWdtZW50LFxuXHRnZXRPdXRlckhUTUw6IGdldE91dGVySFRNTCxcblx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRjaGVja0NvbXBvbmVudEF0dHI6IGNoZWNrQ29tcG9uZW50QXR0cixcblx0Y29tbW9uVGFnUkU6IGNvbW1vblRhZ1JFLFxuXHRyZXNlcnZlZFRhZ1JFOiByZXNlcnZlZFRhZ1JFLFxuXHRnZXQgd2FybiAoKSB7IHJldHVybiB3YXJuOyB9XG59KTtcblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBUaGUgbWFpbiBpbml0IHNlcXVlbmNlLiBUaGlzIGlzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICogaW5zdGFuY2UsIGluY2x1ZGluZyBvbmVzIHRoYXQgYXJlIGNyZWF0ZWQgZnJvbSBleHRlbmRlZFxuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhpcyBvcHRpb25zIG9iamVjdCBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVzdWx0IG9mIG1lcmdpbmcgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIGFuZCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy4kZWwgPSBudWxsO1xuICAgIHRoaXMuJHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuJHJvb3QgPSB0aGlzLiRwYXJlbnQgPyB0aGlzLiRwYXJlbnQuJHJvb3QgOiB0aGlzO1xuICAgIHRoaXMuJGNoaWxkcmVuID0gW107XG4gICAgdGhpcy4kcmVmcyA9IHt9OyAvLyBjaGlsZCB2bSByZWZlcmVuY2VzXG4gICAgdGhpcy4kZWxzID0ge307IC8vIGVsZW1lbnQgcmVmZXJlbmNlc1xuICAgIHRoaXMuX3dhdGNoZXJzID0gW107IC8vIGFsbCB3YXRjaGVycyBhcyBhbiBhcnJheVxuICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBbXTsgLy8gYWxsIGRpcmVjdGl2ZXNcblxuICAgIC8vIGEgdWlkXG4gICAgdGhpcy5fdWlkID0gdWlkKys7XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHRoaXMuX2lzVnVlID0gdHJ1ZTtcblxuICAgIC8vIGV2ZW50cyBib29ra2VlcGluZ1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9OyAvLyByZWdpc3RlcmVkIGNhbGxiYWNrc1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0ge307IC8vIGZvciAkYnJvYWRjYXN0IG9wdGltaXphdGlvblxuXG4gICAgLy8gZnJhZ21lbnQgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgIHRoaXMuX2lzRnJhZ21lbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9mcmFnbWVudCA9IC8vIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQgPSAvLyBAdHlwZSB7VGV4dHxDb21tZW50fVxuICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gbnVsbDsgLy8gQHR5cGUge1RleHR8Q29tbWVudH1cblxuICAgIC8vIGxpZmVjeWNsZSBzdGF0ZVxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRoaXMuX2lzUmVhZHkgPSB0aGlzLl9pc0F0dGFjaGVkID0gdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRoaXMuX3ZGb3JSZW1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3VubGlua0ZuID0gbnVsbDtcblxuICAgIC8vIGNvbnRleHQ6XG4gICAgLy8gaWYgdGhpcyBpcyBhIHRyYW5zY2x1ZGVkIGNvbXBvbmVudCwgY29udGV4dFxuICAgIC8vIHdpbGwgYmUgdGhlIGNvbW1vbiBwYXJlbnQgdm0gb2YgdGhpcyBpbnN0YW5jZVxuICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5fY29udGV4dCB8fCB0aGlzLiRwYXJlbnQ7XG5cbiAgICAvLyBzY29wZTpcbiAgICAvLyBpZiB0aGlzIGlzIGluc2lkZSBhbiBpbmxpbmUgdi1mb3IsIHRoZSBzY29wZVxuICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgLy8gcmVwZWF0IGZyYWdtZW50LiB0aGlzIGlzIHVzZWQgZm9yIGxpbmtpbmcgcHJvcHNcbiAgICAvLyBhbmQgY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgdGhpcy5fc2NvcGUgPSBvcHRpb25zLl9zY29wZTtcblxuICAgIC8vIGZyYWdtZW50OlxuICAgIC8vIGlmIHRoaXMgaW5zdGFuY2UgaXMgY29tcGlsZWQgaW5zaWRlIGEgRnJhZ21lbnQsIGl0XG4gICAgLy8gbmVlZHMgdG8gcmVpZ3N0ZXIgaXRzZWxmIGFzIGEgY2hpbGQgb2YgdGhhdCBmcmFnbWVudFxuICAgIC8vIGZvciBhdHRhY2gvZGV0YWNoIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgdGhpcy5fZnJhZyA9IG9wdGlvbnMuX2ZyYWc7XG4gICAgaWYgKHRoaXMuX2ZyYWcpIHtcbiAgICAgIHRoaXMuX2ZyYWcuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIHNlbGYgaW50byBwYXJlbnQgLyB0cmFuc2NsdXNpb24gaG9zdFxuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudC4kY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBvcHRpb25zLlxuICAgIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBzZXQgcmVmXG4gICAgdGhpcy5fdXBkYXRlUmVmKCk7XG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgYXMgZW1wdHkgb2JqZWN0LlxuICAgIC8vIGl0IHdpbGwgYmUgZmlsbGVkIHVwIGluIF9pbml0RGF0YSgpLlxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIC8vIGNhbGwgaW5pdCBob29rXG4gICAgdGhpcy5fY2FsbEhvb2soJ2luaXQnKTtcblxuICAgIC8vIGluaXRpYWxpemUgZGF0YSBvYnNlcnZhdGlvbiBhbmQgc2NvcGUgaW5oZXJpdGFuY2UuXG4gICAgdGhpcy5faW5pdFN0YXRlKCk7XG5cbiAgICAvLyBzZXR1cCBldmVudCBzeXN0ZW0gYW5kIG9wdGlvbiBldmVudHMuXG4gICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgLy8gY2FsbCBjcmVhdGVkIGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgLy8gaWYgYGVsYCBvcHRpb24gaXMgcGFzc2VkLCBzdGFydCBjb21waWxhdGlvbi5cbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG4vLyBhY3Rpb25zXG52YXIgQVBQRU5EID0gMDtcbnZhciBQVVNIID0gMTtcbnZhciBJTkNfU1VCX1BBVEhfREVQVEggPSAyO1xudmFyIFBVU0hfU1VCX1BBVEggPSAzO1xuXG4vLyBzdGF0ZXNcbnZhciBCRUZPUkVfUEFUSCA9IDA7XG52YXIgSU5fUEFUSCA9IDE7XG52YXIgQkVGT1JFX0lERU5UID0gMjtcbnZhciBJTl9JREVOVCA9IDM7XG52YXIgSU5fU1VCX1BBVEggPSA0O1xudmFyIElOX1NJTkdMRV9RVU9URSA9IDU7XG52YXIgSU5fRE9VQkxFX1FVT1RFID0gNjtcbnZhciBBRlRFUl9QQVRIID0gNztcbnZhciBFUlJPUiA9IDg7XG5cbnZhciBwYXRoU3RhdGVNYWNoaW5lID0gW107XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX1BBVEhdID0ge1xuICAnd3MnOiBbQkVGT1JFX1BBVEhdLFxuICAnaWRlbnQnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9QQVRIXSA9IHtcbiAgJ3dzJzogW0lOX1BBVEhdLFxuICAnLic6IFtCRUZPUkVfSURFTlRdLFxuICAnWyc6IFtJTl9TVUJfUEFUSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbQkVGT1JFX0lERU5UXSA9IHtcbiAgJ3dzJzogW0JFRk9SRV9JREVOVF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9JREVOVF0gPSB7XG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJzAnOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICdudW1iZXInOiBbSU5fSURFTlQsIEFQUEVORF0sXG4gICd3cyc6IFtJTl9QQVRILCBQVVNIXSxcbiAgJy4nOiBbQkVGT1JFX0lERU5ULCBQVVNIXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIFBVU0hdLFxuICAnZW9mJzogW0FGVEVSX1BBVEgsIFBVU0hdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NVQl9QQVRIXSA9IHtcbiAgXCInXCI6IFtJTl9TSU5HTEVfUVVPVEUsIEFQUEVORF0sXG4gICdcIic6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF0sXG4gICdbJzogW0lOX1NVQl9QQVRILCBJTkNfU1VCX1BBVEhfREVQVEhdLFxuICAnXSc6IFtJTl9QQVRILCBQVVNIX1NVQl9QQVRIXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9TSU5HTEVfUVVPVEVdID0ge1xuICBcIidcIjogW0lOX1NVQl9QQVRILCBBUFBFTkRdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtJTl9ET1VCTEVfUVVPVEVdID0ge1xuICAnXCInOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fRE9VQkxFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIGNoYXJhY3RlciBpbiBhIGtleXBhdGguXG4gKlxuICogQHBhcmFtIHtDaGFyfSBjaFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aENoYXJUeXBlKGNoKSB7XG4gIGlmIChjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdlb2YnO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgMHg1QjogLy8gW1xuICAgIGNhc2UgMHg1RDogLy8gXVxuICAgIGNhc2UgMHgyRTogLy8gLlxuICAgIGNhc2UgMHgyMjogLy8gXCJcbiAgICBjYXNlIDB4Mjc6IC8vICdcbiAgICBjYXNlIDB4MzA6XG4gICAgICAvLyAwXG4gICAgICByZXR1cm4gY2g7XG5cbiAgICBjYXNlIDB4NUY6IC8vIF9cbiAgICBjYXNlIDB4MjQ6XG4gICAgICAvLyAkXG4gICAgICByZXR1cm4gJ2lkZW50JztcblxuICAgIGNhc2UgMHgyMDogLy8gU3BhY2VcbiAgICBjYXNlIDB4MDk6IC8vIFRhYlxuICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgIGNhc2UgMHgwRDogLy8gUmV0dXJuXG4gICAgY2FzZSAweEEwOiAvLyBOby1icmVhayBzcGFjZVxuICAgIGNhc2UgMHhGRUZGOiAvLyBCeXRlIE9yZGVyIE1hcmtcbiAgICBjYXNlIDB4MjAyODogLy8gTGluZSBTZXBhcmF0b3JcbiAgICBjYXNlIDB4MjAyOTpcbiAgICAgIC8vIFBhcmFncmFwaCBTZXBhcmF0b3JcbiAgICAgIHJldHVybiAnd3MnO1xuICB9XG5cbiAgLy8gYS16LCBBLVpcbiAgaWYgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N0EgfHwgY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1QSkge1xuICAgIHJldHVybiAnaWRlbnQnO1xuICB9XG5cbiAgLy8gMS05XG4gIGlmIChjb2RlID49IDB4MzEgJiYgY29kZSA8PSAweDM5KSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgcmV0dXJuICdlbHNlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzdWJQYXRoLCByZXR1cm4gaXRzIHBsYWluIGZvcm0gaWYgaXQgaXNcbiAqIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLiBPdGhlcndpc2UgcHJlcGVuZCB0aGVcbiAqIGR5bmFtaWMgaW5kaWNhdG9yICgqKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFN1YlBhdGgocGF0aCkge1xuICB2YXIgdHJpbW1lZCA9IHBhdGgudHJpbSgpO1xuICAvLyBpbnZhbGlkIGxlYWRpbmcgMFxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcwJyAmJiBpc05hTihwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNMaXRlcmFsKHRyaW1tZWQpID8gc3RyaXBRdW90ZXModHJpbW1lZCkgOiAnKicgKyB0cmltbWVkO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIHBhdGggaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheXx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIG1vZGUgPSBCRUZPUkVfUEFUSDtcbiAgdmFyIHN1YlBhdGhEZXB0aCA9IDA7XG4gIHZhciBjLCBuZXdDaGFyLCBrZXksIHR5cGUsIHRyYW5zaXRpb24sIGFjdGlvbiwgdHlwZU1hcDtcblxuICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gIGFjdGlvbnNbUFVTSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tBUFBFTkRdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gbmV3Q2hhcjtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ICs9IG5ld0NoYXI7XG4gICAgfVxuICB9O1xuXG4gIGFjdGlvbnNbSU5DX1NVQl9QQVRIX0RFUFRIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBhY3Rpb25zW0FQUEVORF0oKTtcbiAgICBzdWJQYXRoRGVwdGgrKztcbiAgfTtcblxuICBhY3Rpb25zW1BVU0hfU1VCX1BBVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdWJQYXRoRGVwdGggPiAwKSB7XG4gICAgICBzdWJQYXRoRGVwdGgtLTtcbiAgICAgIG1vZGUgPSBJTl9TVUJfUEFUSDtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJQYXRoRGVwdGggPSAwO1xuICAgICAga2V5ID0gZm9ybWF0U3ViUGF0aChrZXkpO1xuICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uc1tQVVNIXSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZVVuZXNjYXBlUXVvdGUoKSB7XG4gICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdO1xuICAgIGlmIChtb2RlID09PSBJTl9TSU5HTEVfUVVPVEUgJiYgbmV4dENoYXIgPT09IFwiJ1wiIHx8IG1vZGUgPT09IElOX0RPVUJMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgaW5kZXgrKztcbiAgICAgIG5ld0NoYXIgPSAnXFxcXCcgKyBuZXh0Q2hhcjtcbiAgICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG1vZGUgIT0gbnVsbCkge1xuICAgIGluZGV4Kys7XG4gICAgYyA9IHBhdGhbaW5kZXhdO1xuXG4gICAgaWYgKGMgPT09ICdcXFxcJyAmJiBtYXliZVVuZXNjYXBlUXVvdGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IGdldFBhdGhDaGFyVHlwZShjKTtcbiAgICB0eXBlTWFwID0gcGF0aFN0YXRlTWFjaGluZVttb2RlXTtcbiAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwWydlbHNlJ10gfHwgRVJST1I7XG5cbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gRVJST1IpIHtcbiAgICAgIHJldHVybjsgLy8gcGFyc2UgZXJyb3JcbiAgICB9XG5cbiAgICBtb2RlID0gdHJhbnNpdGlvblswXTtcbiAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dO1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIG5ld0NoYXIgPSB0cmFuc2l0aW9uWzJdO1xuICAgICAgbmV3Q2hhciA9IG5ld0NoYXIgPT09IHVuZGVmaW5lZCA/IGMgOiBuZXdDaGFyO1xuICAgICAgaWYgKGFjdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IEFGVEVSX1BBVEgpIHtcbiAgICAgIGtleXMucmF3ID0gcGF0aDtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4dGVybmFsIHBhcnNlIHRoYXQgY2hlY2sgZm9yIGEgY2FjaGUgaGl0IGZpcnN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgaGl0ID0gcGF0aENhY2hlLmdldChwYXRoKTtcbiAgaWYgKCFoaXQpIHtcbiAgICBoaXQgPSBwYXJzZShwYXRoKTtcbiAgICBpZiAoaGl0KSB7XG4gICAgICBwYXRoQ2FjaGUucHV0KHBhdGgsIGhpdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoaXQ7XG59XG5cbi8qKlxuICogR2V0IGZyb20gYW4gb2JqZWN0IGZyb20gYSBwYXRoIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihwYXRoKS5nZXQob2JqKTtcbn1cblxuLyoqXG4gKiBXYXJuIGFnYWluc3Qgc2V0dGluZyBub24tZXhpc3RlbnQgcm9vdCBwYXRoIG9uIGEgdm0uXG4gKi9cblxudmFyIHdhcm5Ob25FeGlzdGVudDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5Ob25FeGlzdGVudCA9IGZ1bmN0aW9uIChwYXRoLCB2bSkge1xuICAgIHdhcm4oJ1lvdSBhcmUgc2V0dGluZyBhIG5vbi1leGlzdGVudCBwYXRoIFwiJyArIHBhdGgucmF3ICsgJ1wiICcgKyAnb24gYSB2bSBpbnN0YW5jZS4gQ29uc2lkZXIgcHJlLWluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgJyArICd3aXRoIHRoZSBcImRhdGFcIiBvcHRpb24gZm9yIG1vcmUgcmVsaWFibGUgcmVhY3Rpdml0eSAnICsgJ2FuZCBiZXR0ZXIgcGVyZm9ybWFuY2UuJywgdm0pO1xuICB9O1xufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICB9XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdCwga2V5O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGFzdCA9IG9iajtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgIGtleSA9IHBhcnNlRXhwcmVzc2lvbihrZXkuc2xpY2UoMSkpLmdldC5jYWxsKG9yaWdpbmFsLCBvcmlnaW5hbCk7XG4gICAgfVxuICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXN0Ll9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQobGFzdCwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9iai5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQob2JqLCBrZXksIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgcGF0aCA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZVBhdGg6IHBhcnNlUGF0aCxcbiAgZ2V0UGF0aDogZ2V0UGF0aCxcbiAgc2V0UGF0aDogc2V0UGF0aFxufSk7XG5cbnZhciBleHByZXNzaW9uQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBhbGxvd2VkS2V5d29yZHMgPSAnTWF0aCxEYXRlLHRoaXMsdHJ1ZSxmYWxzZSxudWxsLHVuZGVmaW5lZCxJbmZpbml0eSxOYU4sJyArICdpc05hTixpc0Zpbml0ZSxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSwnICsgJ2VuY29kZVVSSUNvbXBvbmVudCxwYXJzZUludCxwYXJzZUZsb2F0JztcbnZhciBhbGxvd2VkS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGFsbG93ZWRLZXl3b3Jkcy5yZXBsYWNlKC8sL2csICdcXFxcYnwnKSArICdcXFxcYiknKTtcblxuLy8ga2V5d29yZHMgdGhhdCBkb24ndCBtYWtlIHNlbnNlIGluc2lkZSBleHByZXNzaW9uc1xudmFyIGltcHJvcGVyS2V5d29yZHMgPSAnYnJlYWssY2FzZSxjbGFzcyxjYXRjaCxjb25zdCxjb250aW51ZSxkZWJ1Z2dlcixkZWZhdWx0LCcgKyAnZGVsZXRlLGRvLGVsc2UsZXhwb3J0LGV4dGVuZHMsZmluYWxseSxmb3IsZnVuY3Rpb24saWYsJyArICdpbXBvcnQsaW4saW5zdGFuY2VvZixsZXQscmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksJyArICd2YXIsd2hpbGUsd2l0aCx5aWVsZCxlbnVtLGF3YWl0LGltcGxlbWVudHMscGFja2FnZSwnICsgJ3Byb3RlY3RlZCxzdGF0aWMsaW50ZXJmYWNlLHByaXZhdGUscHVibGljJztcbnZhciBpbXByb3BlcktleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBpbXByb3BlcktleXdvcmRzLnJlcGxhY2UoLywvZywgJ1xcXFxifCcpICsgJ1xcXFxiKScpO1xuXG52YXIgd3NSRSA9IC9cXHMvZztcbnZhciBuZXdsaW5lUkUgPSAvXFxuL2c7XG52YXIgc2F2ZVJFID0gL1tcXHssXVxccypbXFx3XFwkX10rXFxzKjp8KCcoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgKXxuZXcgfHR5cGVvZiB8dm9pZCAvZztcbnZhciByZXN0b3JlUkUgPSAvXCIoXFxkKylcIi9nO1xudmFyIHBhdGhUZXN0UkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXXxcXFtcXGQrXFxdfFxcW1tBLVphLXpfJF1bXFx3JF0qXFxdKSokLztcbnZhciBpZGVudFJFID0gL1teXFx3JFxcLl0oPzpbQS1aYS16XyRdW1xcdyRdKikvZztcbnZhciBsaXRlcmFsVmFsdWVSRSQxID0gL14oPzp0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfEluZmluaXR5fE5hTikkLztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogU2F2ZSAvIFJld3JpdGUgLyBSZXN0b3JlXG4gKlxuICogV2hlbiByZXdyaXRpbmcgcGF0aHMgZm91bmQgaW4gYW4gZXhwcmVzc2lvbiwgaXQgaXNcbiAqIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBsZXR0ZXIgc2VxdWVuY2VzIHRvIGJlIGZvdW5kIGluXG4gKiBzdHJpbmdzIGFuZCBPYmplY3QgbGl0ZXJhbCBwcm9wZXJ0eSBrZXlzLiBUaGVyZWZvcmUgd2VcbiAqIHJlbW92ZSBhbmQgc3RvcmUgdGhlc2UgcGFydHMgaW4gYSB0ZW1wb3JhcnkgYXJyYXksIGFuZFxuICogcmVzdG9yZSB0aGVtIGFmdGVyIHRoZSBwYXRoIHJld3JpdGUuXG4gKi9cblxudmFyIHNhdmVkID0gW107XG5cbi8qKlxuICogU2F2ZSByZXBsYWNlclxuICpcbiAqIFRoZSBzYXZlIHJlZ2V4IGNhbiBtYXRjaCB0d28gcG9zc2libGUgY2FzZXM6XG4gKiAxLiBBbiBvcGVuaW5nIG9iamVjdCBsaXRlcmFsXG4gKiAyLiBBIHN0cmluZ1xuICogSWYgbWF0Y2hlZCBhcyBhIHBsYWluIHN0cmluZywgd2UgbmVlZCB0byBlc2NhcGUgaXRzXG4gKiBuZXdsaW5lcywgc2luY2UgdGhlIHN0cmluZyBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgd2hlblxuICogZ2VuZXJhdGluZyB0aGUgZnVuY3Rpb24gYm9keS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gaXNTdHJpbmcgLSBzdHIgaWYgbWF0Y2hlZCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSAtIHBsYWNlaG9sZGVyIHdpdGggaW5kZXhcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKHN0ciwgaXNTdHJpbmcpIHtcbiAgdmFyIGkgPSBzYXZlZC5sZW5ndGg7XG4gIHNhdmVkW2ldID0gaXNTdHJpbmcgPyBzdHIucmVwbGFjZShuZXdsaW5lUkUsICdcXFxcbicpIDogc3RyO1xuICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xufVxuXG4vKipcbiAqIFBhdGggcmV3cml0ZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXdyaXRlKHJhdykge1xuICB2YXIgYyA9IHJhdy5jaGFyQXQoMCk7XG4gIHZhciBwYXRoID0gcmF3LnNsaWNlKDEpO1xuICBpZiAoYWxsb3dlZEtleXdvcmRzUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVybiByYXc7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignXCInKSA+IC0xID8gcGF0aC5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSkgOiBwYXRoO1xuICAgIHJldHVybiBjICsgJ3Njb3BlLicgKyBwYXRoO1xuICB9XG59XG5cbi8qKlxuICogUmVzdG9yZSByZXBsYWNlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpIC0gbWF0Y2hlZCBzYXZlIGluZGV4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZShzdHIsIGkpIHtcbiAgcmV0dXJuIHNhdmVkW2ldO1xufVxuXG4vKipcbiAqIFJld3JpdGUgYW4gZXhwcmVzc2lvbiwgcHJlZml4aW5nIGFsbCBwYXRoIGFjY2Vzc29ycyB3aXRoXG4gKiBgc2NvcGUuYCBhbmQgZ2VuZXJhdGUgZ2V0dGVyL3NldHRlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUdldHRlcihleHApIHtcbiAgaWYgKGltcHJvcGVyS2V5d29yZHNSRS50ZXN0KGV4cCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIHVzaW5nIHJlc2VydmVkIGtleXdvcmRzIGluIGV4cHJlc3Npb246ICcgKyBleHApO1xuICB9XG4gIC8vIHJlc2V0IHN0YXRlXG4gIHNhdmVkLmxlbmd0aCA9IDA7XG4gIC8vIHNhdmUgc3RyaW5ncyBhbmQgb2JqZWN0IGxpdGVyYWwga2V5c1xuICB2YXIgYm9keSA9IGV4cC5yZXBsYWNlKHNhdmVSRSwgc2F2ZSkucmVwbGFjZSh3c1JFLCAnJyk7XG4gIC8vIHJld3JpdGUgYWxsIHBhdGhzXG4gIC8vIHBhZCAxIHNwYWNlIGhlcmUgYmVjYXVzZSB0aGUgcmVnZXggbWF0Y2hlcyAxIGV4dHJhIGNoYXJcbiAgYm9keSA9ICgnICcgKyBib2R5KS5yZXBsYWNlKGlkZW50UkUsIHJld3JpdGUpLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKTtcbiAgcmV0dXJuIG1ha2VHZXR0ZXJGbihib2R5KTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGdldHRlciBmdW5jdGlvbi4gUmVxdWlyZXMgZXZhbC5cbiAqXG4gKiBXZSBpc29sYXRlIHRoZSB0cnkvY2F0Y2ggc28gaXQgZG9lc24ndCBhZmZlY3QgdGhlXG4gKiBvcHRpbWl6YXRpb24gb2YgdGhlIHBhcnNlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgbm90IGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXJGbihib2R5KSB7XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdzY29wZScsICdyZXR1cm4gJyArIGJvZHkgKyAnOycpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIGRlZmF1bHQgYnVpbGQgb2YgVnVlLmpzIGluIGFuIGVudmlyb25tZW50ICcgKyAnd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArICdVc2UgdGhlIENTUC1jb21wbGlhbnQgYnVpbGQgaW5zdGVhZDogJyArICdodHRwOi8vdnVlanMub3JnL2d1aWRlL2luc3RhbGxhdGlvbi5odG1sI0NTUC1jb21wbGlhbnQtYnVpbGQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9vcDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlU2V0dGVyKGV4cCkge1xuICB2YXIgcGF0aCA9IHBhcnNlUGF0aChleHApO1xuICBpZiAocGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIHZhbCkge1xuICAgICAgc2V0UGF0aChzY29wZSwgcGF0aCwgdmFsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBzZXR0ZXIgZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBleHByZXNzaW9uIGludG8gcmUtd3JpdHRlbiBnZXR0ZXIvc2V0dGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5lZWRTZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihleHAsIG5lZWRTZXQpIHtcbiAgZXhwID0gZXhwLnRyaW0oKTtcbiAgLy8gdHJ5IGNhY2hlXG4gIHZhciBoaXQgPSBleHByZXNzaW9uQ2FjaGUuZ2V0KGV4cCk7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAobmVlZFNldCAmJiAhaGl0LnNldCkge1xuICAgICAgaGl0LnNldCA9IGNvbXBpbGVTZXR0ZXIoaGl0LmV4cCk7XG4gICAgfVxuICAgIHJldHVybiBoaXQ7XG4gIH1cbiAgdmFyIHJlcyA9IHsgZXhwOiBleHAgfTtcbiAgcmVzLmdldCA9IGlzU2ltcGxlUGF0aChleHApICYmIGV4cC5pbmRleE9mKCdbJykgPCAwXG4gIC8vIG9wdGltaXplZCBzdXBlciBzaW1wbGUgZ2V0dGVyXG4gID8gbWFrZUdldHRlckZuKCdzY29wZS4nICsgZXhwKVxuICAvLyBkeW5hbWljIGdldHRlclxuICA6IGNvbXBpbGVHZXR0ZXIoZXhwKTtcbiAgaWYgKG5lZWRTZXQpIHtcbiAgICByZXMuc2V0ID0gY29tcGlsZVNldHRlcihleHApO1xuICB9XG4gIGV4cHJlc3Npb25DYWNoZS5wdXQoZXhwLCByZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBzaW1wbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU2ltcGxlUGF0aChleHApIHtcbiAgcmV0dXJuIHBhdGhUZXN0UkUudGVzdChleHApICYmXG4gIC8vIGRvbid0IHRyZWF0IGxpdGVyYWwgdmFsdWVzIGFzIHBhdGhzXG4gICFsaXRlcmFsVmFsdWVSRSQxLnRlc3QoZXhwKSAmJlxuICAvLyBNYXRoIGNvbnN0YW50cyBlLmcuIE1hdGguUEksIE1hdGguRSBldGMuXG4gIGV4cC5zbGljZSgwLCA1KSAhPT0gJ01hdGguJztcbn1cblxudmFyIGV4cHJlc3Npb24gPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VFeHByZXNzaW9uOiBwYXJzZUV4cHJlc3Npb24sXG4gIGlzU2ltcGxlUGF0aDogaXNTaW1wbGVQYXRoXG59KTtcblxuLy8gd2UgaGF2ZSB0d28gc2VwYXJhdGUgcXVldWVzOiBvbmUgZm9yIGRpcmVjdGl2ZSB1cGRhdGVzXG4vLyBhbmQgb25lIGZvciB1c2VyIHdhdGNoZXIgcmVnaXN0ZXJlZCB2aWEgJHdhdGNoKCkuXG4vLyB3ZSB3YW50IHRvIGd1YXJhbnRlZSBkaXJlY3RpdmUgdXBkYXRlcyB0byBiZSBjYWxsZWRcbi8vIGJlZm9yZSB1c2VyIHdhdGNoZXJzIHNvIHRoYXQgd2hlbiB1c2VyIHdhdGNoZXJzIGFyZVxuLy8gdHJpZ2dlcmVkLCB0aGUgRE9NIHdvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIGluIHVwZGF0ZWRcbi8vIHN0YXRlLlxuXG52YXIgcXVldWUgPSBbXTtcbnZhciB1c2VyUXVldWUgPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXNldCB0aGUgYmF0Y2hlcidzIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIHJlc2V0QmF0Y2hlclN0YXRlKCkge1xuICBxdWV1ZS5sZW5ndGggPSAwO1xuICB1c2VyUXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGNpcmN1bGFyID0ge307XG4gIHdhaXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaEJhdGNoZXJRdWV1ZSgpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICBydW5CYXRjaGVyUXVldWUocXVldWUpO1xuICAgIHJ1bkJhdGNoZXJRdWV1ZSh1c2VyUXVldWUpO1xuICAgIC8vIHVzZXIgd2F0Y2hlcnMgdHJpZ2dlcmVkIG1vcmUgd2F0Y2hlcnMsXG4gICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkZXBsZXRlc1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgfVxuICAgIC8vIGRldiB0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgICByZXNldEJhdGNoZXJTdGF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogUnVuIHRoZSB3YXRjaGVycyBpbiBhIHNpbmdsZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZXJRdWV1ZShxdWV1ZSkge1xuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBmb3Igd2F0Y2hlciAnICsgJ3dpdGggZXhwcmVzc2lvbiBcIicgKyB3YXRjaGVyLmV4cHJlc3Npb24gKyAnXCInLCB3YXRjaGVyLnZtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmZ1bmN0aW9uIHB1c2hXYXRjaGVyKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIHB1c2ggd2F0Y2hlciBpbnRvIGFwcHJvcHJpYXRlIHF1ZXVlXG4gICAgdmFyIHEgPSB3YXRjaGVyLnVzZXIgPyB1c2VyUXVldWUgOiBxdWV1ZTtcbiAgICBoYXNbaWRdID0gcS5sZW5ndGg7XG4gICAgcS5wdXNoKHdhdGNoZXIpO1xuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaEJhdGNoZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGlzRm4gPSB0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMucHJldkVycm9yID0gbnVsbDsgLy8gZm9yIGFzeW5jIGVycm9yIHN0YWNrc1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXIvc2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwT3JGbiwgdGhpcy50d29XYXkpO1xuICAgIHRoaXMuZ2V0dGVyID0gcmVzLmdldDtcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KCk7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgdmFyIHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgZXhwcmVzc2lvbiAnICsgJ1wiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIjogJyArIGUudG9TdHJpbmcoKSwgdGhpcy52bSk7XG4gICAgfVxuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnBvc3RQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICB0aGlzLmFmdGVyR2V0KCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJzLCB0cnVlKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgJyArICdcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCI6ICcgKyBlLnRvU3RyaW5nKCksIHRoaXMudm0pO1xuICAgIH1cbiAgfVxuICAvLyB0d28td2F5IHN5bmMgZm9yIHYtZm9yIGFsaWFzXG4gIHZhciBmb3JDb250ZXh0ID0gc2NvcGUuJGZvckNvbnRleHQ7XG4gIGlmIChmb3JDb250ZXh0ICYmIGZvckNvbnRleHQuYWxpYXMgPT09IHRoaXMuZXhwcmVzc2lvbikge1xuICAgIGlmIChmb3JDb250ZXh0LmZpbHRlcnMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0d28td2F5IGJpbmRpbmcgb24gJyArICdhIHYtZm9yIGFsaWFzICgnICsgdGhpcy5leHByZXNzaW9uICsgJyksIGFuZCB0aGUgJyArICd2LWZvciBoYXMgZmlsdGVycy4gVGhpcyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5LiAnICsgJ0VpdGhlciByZW1vdmUgdGhlIGZpbHRlcnMgb3IgdXNlIGFuIGFycmF5IG9mICcgKyAnb2JqZWN0cyBhbmQgYmluZCB0byBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMudm0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3JDb250ZXh0Ll93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2NvcGUuJGtleSkge1xuICAgICAgICAvLyBvcmlnaW5hbCBpcyBhbiBvYmplY3RcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZVtzY29wZS4ka2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yQ29udGV4dC5yYXdWYWx1ZS4kc2V0KHNjb3BlLiRpbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFByZXBhcmUgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5iZWZvcmVHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IG51bGw7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3dcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2hhbGxvdykge1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jIHx8ICFjb25maWcuYXN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHF1ZXVlZCwgb25seSBvdmVyd3JpdGUgc2hhbGxvdyB3aXRoIG5vbi1zaGFsbG93LFxuICAgIC8vIGJ1dCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuXG4gICAgdGhpcy5zaGFsbG93ID0gdGhpcy5xdWV1ZWQgPyBzaGFsbG93ID8gdGhpcy5zaGFsbG93IDogZmFsc2UgOiAhIXNoYWxsb3c7XG4gICAgdGhpcy5xdWV1ZWQgPSB0cnVlO1xuICAgIC8vIHJlY29yZCBiZWZvcmUtcHVzaCBlcnJvciBzdGFjayBpbiBkZWJ1ZyBtb2RlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnKSB7XG4gICAgICB0aGlzLnByZXZFcnJvciA9IG5ldyBFcnJvcignW3Z1ZV0gYXN5bmMgc3RhY2sgdHJhY2UnKTtcbiAgICB9XG4gICAgcHVzaFdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmF0Y2hlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIGJhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAvLyBoYXZlIG11dGF0ZWQ7IGJ1dCBvbmx5IGRvIHNvIGlmIHRoaXMgaXMgYVxuICAgIC8vIG5vbi1zaGFsbG93IHVwZGF0ZSAoY2F1c2VkIGJ5IGEgdm0gZGlnZXN0KS5cbiAgICAoaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkgJiYgIXRoaXMuc2hhbGxvdykge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIGluIGRlYnVnICsgYXN5bmMgbW9kZSwgd2hlbiBhIHdhdGNoZXIgY2FsbGJhY2tzXG4gICAgICAvLyB0aHJvd3MsIHdlIGFsc28gdGhyb3cgdGhlIHNhdmVkIGJlZm9yZS1wdXNoIGVycm9yXG4gICAgICAvLyBzbyB0aGUgZnVsbCBjcm9zcy10aWNrIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZS5cbiAgICAgIHZhciBwcmV2RXJyb3IgPSB0aGlzLnByZXZFcnJvcjtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmRlYnVnICYmIHByZXZFcnJvcikge1xuICAgICAgICB0aGlzLnByZXZFcnJvciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBwcmV2RXJyb3I7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBhdm9pZCBvdmVyd3JpdGluZyBhbm90aGVyIHdhdGNoZXIgdGhhdCBpcyBiZWluZ1xuICAvLyBjb2xsZWN0ZWQuXG4gIHZhciBjdXJyZW50ID0gRGVwLnRhcmdldDtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgRGVwLnRhcmdldCA9IGN1cnJlbnQ7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZCBvciBpcyBwZXJmb3JtaW5nIGEgdi1mb3JcbiAgICAvLyByZS1yZW5kZXIgKHRoZSB3YXRjaGVyIGxpc3QgaXMgdGhlbiBmaWx0ZXJlZCBieSB2LWZvcikuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgIHRoaXMudm0uX3dhdGNoZXJzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudm0gPSB0aGlzLmNiID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjcnVzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCwgc2Vlbikge1xuICB2YXIgaSA9IHVuZGVmaW5lZCxcbiAgICAgIGtleXMgPSB1bmRlZmluZWQ7XG4gIGlmICghc2Vlbikge1xuICAgIHNlZW4gPSBzZWVuT2JqZWN0cztcbiAgICBzZWVuLmNsZWFyKCk7XG4gIH1cbiAgdmFyIGlzQSA9IGlzQXJyYXkodmFsKTtcbiAgdmFyIGlzTyA9IGlzT2JqZWN0KHZhbCk7XG4gIGlmICgoaXNBIHx8IGlzTykgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgICB9IGVsc2UgaWYgKGlzTykge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dCQxID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hdHRyID0gdGhpcy5lbC5ub2RlVHlwZSA9PT0gMyA/ICdkYXRhJyA6ICd0ZXh0Q29udGVudCc7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsW3RoaXMuYXR0cl0gPSBfdG9TdHJpbmcodmFsdWUpO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwKTtcbnZhciBpZFNlbGVjdG9yQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbnZhciBtYXAgPSB7XG4gIGVmYXVsdDogWzAsICcnLCAnJ10sXG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXVxufTtcblxubWFwLnRkID0gbWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPSBtYXAub3B0Z3JvdXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPicsICc8L3NlbGVjdD4nXTtcblxubWFwLnRoZWFkID0gbWFwLnRib2R5ID0gbWFwLmNvbGdyb3VwID0gbWFwLmNhcHRpb24gPSBtYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxubWFwLmcgPSBtYXAuZGVmcyA9IG1hcC5zeW1ib2wgPSBtYXAudXNlID0gbWFwLmltYWdlID0gbWFwLnRleHQgPSBtYXAuY2lyY2xlID0gbWFwLmVsbGlwc2UgPSBtYXAubGluZSA9IG1hcC5wYXRoID0gbWFwLnBvbHlnb24gPSBtYXAucG9seWxpbmUgPSBtYXAucmVjdCA9IFsxLCAnPHN2ZyAnICsgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcgKyAneG1sbnM6ZXY9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcIicgKyAndmVyc2lvbj1cIjEuMVwiPicsICc8L3N2Zz4nXTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBzdXBwb3J0ZWQgdGVtcGxhdGUgbm9kZSB3aXRoIGFcbiAqIERvY3VtZW50RnJhZ21lbnQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNSZWFsVGVtcGxhdGUobm9kZSkge1xuICByZXR1cm4gaXNUZW1wbGF0ZShub2RlKSAmJiBpc0ZyYWdtZW50KG5vZGUuY29udGVudCk7XG59XG5cbnZhciB0YWdSRSQxID0gLzwoW1xcdzotXSspLztcbnZhciBlbnRpdHlSRSA9IC8mIz9cXHcrPzsvO1xudmFyIGNvbW1lbnRSRSA9IC88IS0tLztcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRlbXBsYXRlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqIERldGVybWluZXMgY29ycmVjdCB3cmFwcGluZyBieSB0YWcgdHlwZXMuIFdyYXBwaW5nXG4gKiBzdHJhdGVneSBmb3VuZCBpbiBqUXVlcnkgJiBjb21wb25lbnQvZG9taWZ5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZVN0cmluZywgcmF3KSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgY2FjaGVLZXkgPSByYXcgPyB0ZW1wbGF0ZVN0cmluZyA6IHRlbXBsYXRlU3RyaW5nLnRyaW0oKTtcbiAgdmFyIGhpdCA9IHRlbXBsYXRlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIHRhZ01hdGNoID0gdGVtcGxhdGVTdHJpbmcubWF0Y2godGFnUkUkMSk7XG4gIHZhciBlbnRpdHlNYXRjaCA9IGVudGl0eVJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuICB2YXIgY29tbWVudE1hdGNoID0gY29tbWVudFJFLnRlc3QodGVtcGxhdGVTdHJpbmcpO1xuXG4gIGlmICghdGFnTWF0Y2ggJiYgIWVudGl0eU1hdGNoICYmICFjb21tZW50TWF0Y2gpIHtcbiAgICAvLyB0ZXh0IG9ubHksIHJldHVybiBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSB0YWdNYXRjaCAmJiB0YWdNYXRjaFsxXTtcbiAgICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5lZmF1bHQ7XG4gICAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgbm9kZS5pbm5lckhUTUwgPSBwcmVmaXggKyB0ZW1wbGF0ZVN0cmluZyArIHN1ZmZpeDtcbiAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3KSB7XG4gICAgdHJpbU5vZGUoZnJhZyk7XG4gIH1cbiAgdGVtcGxhdGVDYWNoZS5wdXQoY2FjaGVLZXksIGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50KG5vZGUpIHtcbiAgLy8gaWYgaXRzIGEgdGVtcGxhdGUgdGFnIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCxcbiAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LiBIb3dldmVyLCBpT1MgU2FmYXJpIGhhc1xuICAvLyBidWcgd2hlbiB1c2luZyBkaXJlY3RseSBjbG9uZWQgdGVtcGxhdGUgY29udGVudCB3aXRoIHRvdWNoXG4gIC8vIGV2ZW50cyBhbmQgY2FuIGNhdXNlIGNyYXNoZXMgd2hlbiB0aGUgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBET00sIHNvIHdlXG4gIC8vIGhhdmUgdG8gdHJlYXQgdGVtcGxhdGUgZWxlbWVudHMgYXMgc3RyaW5nIHRlbXBsYXRlcy4gKCMyODA1KVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS5pbm5lckhUTUwpO1xuICB9XG4gIC8vIHNjcmlwdCB0ZW1wbGF0ZVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnU0NSSVBUJykge1xuICAgIHJldHVybiBzdHJpbmdUb0ZyYWdtZW50KG5vZGUudGV4dENvbnRlbnQpO1xuICB9XG4gIC8vIG5vcm1hbCBub2RlLCBjbG9uZSBpdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgdmFyIGNsb25lZE5vZGUgPSBjbG9uZU5vZGUobm9kZSk7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgY2hpbGQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gIHdoaWxlIChjaGlsZCA9IGNsb25lZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBmcmFnLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuICB0cmltTm9kZShmcmFnKTtcbiAgcmV0dXJuIGZyYWc7XG59XG5cbi8vIFRlc3QgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgU2FmYXJpIHRlbXBsYXRlIGNsb25pbmcgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93dWcuY2dpP2lkPTEzNzc1NVxudmFyIGhhc0Jyb2tlblRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYS5pbm5lckhUTUwgPSAnPHRlbXBsYXRlPjE8L3RlbXBsYXRlPic7XG4gICAgcmV0dXJuICFhLmNsb25lTm9kZSh0cnVlKS5maXJzdENoaWxkLmlubmVySFRNTDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8vIFRlc3QgZm9yIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgY2xvbmUgYnVnXG52YXIgaGFzVGV4dGFyZWFDbG9uZUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdC5wbGFjZWhvbGRlciA9ICd0JztcbiAgICByZXR1cm4gdC5jbG9uZU5vZGUodHJ1ZSkudmFsdWUgPT09ICd0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogMS4gRGVhbCB3aXRoIFNhZmFyaSBjbG9uaW5nIG5lc3RlZCA8dGVtcGxhdGU+IGJ1ZyBieVxuICogICAgbWFudWFsbHkgY2xvbmluZyBhbGwgdGVtcGxhdGUgaW5zdGFuY2VzLlxuICogMi4gRGVhbCB3aXRoIElFMTAvMTEgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnIGJ5IHNldHRpbmdcbiAqICAgIHRoZSBjb3JyZWN0IHZhbHVlIGFmdGVyIGNsb25pbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoKTtcbiAgfVxuICB2YXIgcmVzID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gIHZhciBpLCBvcmlnaW5hbCwgY2xvbmVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc0Jyb2tlblRlbXBsYXRlKSB7XG4gICAgdmFyIHRlbXBDbG9uZSA9IHJlcztcbiAgICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICB0ZW1wQ2xvbmUgPSByZXMuY29udGVudDtcbiAgICB9XG4gICAgb3JpZ2luYWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgY2xvbmVkID0gdGVtcENsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RlbXBsYXRlJyk7XG4gICAgICBpID0gY2xvbmVkLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2xvbmVkW2ldLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNsb25lTm9kZShvcmlnaW5hbFtpXSksIGNsb25lZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaGFzVGV4dGFyZWFDbG9uZUJ1Zykge1xuICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIHJlcy52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpO1xuICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCkge1xuICAgICAgICBjbG9uZWQgPSByZXMucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjbG9uZWRbaV0udmFsdWUgPSBvcmlnaW5hbFtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbiBhbmQgbm9ybWFsaXplcyBpdCBpbnRvIGFcbiAqIGEgRG9jdW1lbnRGcmFnbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcGFydGlhbCBvciBhXG4gKiBpbnN0YW5jZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHRlbXBsYXRlXG4gKiAgICAgICAgUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gKiAgICAgICAgLSBEb2N1bWVudEZyYWdtZW50IG9iamVjdFxuICogICAgICAgIC0gTm9kZSBvYmplY3Qgb2YgdHlwZSBUZW1wbGF0ZVxuICogICAgICAgIC0gaWQgc2VsZWN0b3I6ICcjc29tZS10ZW1wbGF0ZS1pZCdcbiAqICAgICAgICAtIHRlbXBsYXRlIHN0cmluZzogJzxkaXY+PHNwYW4+e3ttc2d9fTwvc3Bhbj48L2Rpdj4nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJhd1xuICogICAgICAgIGlubGluZSBIVE1MIGludGVycG9sYXRpb24uIERvIG5vdCBjaGVjayBmb3IgaWRcbiAqICAgICAgICBzZWxlY3RvciBhbmQga2VlcCB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzaG91bGRDbG9uZSwgcmF3KSB7XG4gIHZhciBub2RlLCBmcmFnO1xuXG4gIC8vIGlmIHRoZSB0ZW1wbGF0ZSBpcyBhbHJlYWR5IGEgZG9jdW1lbnQgZnJhZ21lbnQsXG4gIC8vIGRvIG5vdGhpbmdcbiAgaWYgKGlzRnJhZ21lbnQodGVtcGxhdGUpKSB7XG4gICAgdHJpbU5vZGUodGVtcGxhdGUpO1xuICAgIHJldHVybiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZSh0ZW1wbGF0ZSkgOiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaWQgc2VsZWN0b3JcbiAgICBpZiAoIXJhdyAmJiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gaWQgc2VsZWN0b3IgY2FuIGJlIGNhY2hlZCB0b29cbiAgICAgIGZyYWcgPSBpZFNlbGVjdG9yQ2FjaGUuZ2V0KHRlbXBsYXRlKTtcbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcGxhdGUuc2xpY2UoMSkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudChub2RlKTtcbiAgICAgICAgICAvLyBzYXZlIHNlbGVjdG9yIHRvIGNhY2hlXG4gICAgICAgICAgaWRTZWxlY3RvckNhY2hlLnB1dCh0ZW1wbGF0ZSwgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIHN0cmluZyB0ZW1wbGF0ZVxuICAgICAgZnJhZyA9IHN0cmluZ1RvRnJhZ21lbnQodGVtcGxhdGUsIHJhdyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgLy8gYSBkaXJlY3Qgbm9kZVxuICAgIGZyYWcgPSBub2RlVG9GcmFnbWVudCh0ZW1wbGF0ZSk7XG4gIH1cblxuICByZXR1cm4gZnJhZyAmJiBzaG91bGRDbG9uZSA/IGNsb25lTm9kZShmcmFnKSA6IGZyYWc7XG59XG5cbnZhciB0ZW1wbGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICBjbG9uZU5vZGU6IGNsb25lTm9kZSxcbiAgcGFyc2VUZW1wbGF0ZTogcGFyc2VUZW1wbGF0ZVxufSk7XG5cbnZhciBodG1sID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gYSBjb21tZW50IG5vZGUgbWVhbnMgdGhpcyBpcyBhIGJpbmRpbmcgZm9yXG4gICAgLy8ge3t7IGlubGluZSB1bmVzY2FwZWQgaHRtbCB9fX1cbiAgICBpZiAodGhpcy5lbC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgLy8gaG9sZCBub2Rlc1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCBwcm9wZXIgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1odG1sJyk7XG4gICAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMuc3dhcCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHN3YXA6IGZ1bmN0aW9uIHN3YXAodmFsdWUpIHtcbiAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgdmFyIGkgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZW1vdmUodGhpcy5ub2Rlc1tpXSk7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbmV3IHZhbHVlIHRvIGEgZnJhZ21lbnRcbiAgICAvLyBkbyBub3QgYXR0ZW1wdCB0byByZXRyaWV2ZSBmcm9tIGlkIHNlbGVjdG9yXG4gICAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAvLyBzYXZlIGEgcmVmZXJlbmNlIHRvIHRoZXNlIG5vZGVzIHNvIHdlIGNhbiByZW1vdmUgbGF0ZXJcbiAgICB0aGlzLm5vZGVzID0gdG9BcnJheShmcmFnLmNoaWxkTm9kZXMpO1xuICAgIGJlZm9yZShmcmFnLCB0aGlzLmFuY2hvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGEgcGFydGlhbGx5LWNvbXBpbGVkIGZyYWdtZW50LlxuICogQ2FuIG9wdGlvbmFsbHkgY29tcGlsZSBjb250ZW50IHdpdGggYSBjaGlsZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rZXJcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnXG4gKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHBhcmFtIHtGcmFnbWVudH0gW3BhcmVudEZyYWddXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50KGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5jaGlsZEZyYWdzID0gW107XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50RnJhZyA9IHBhcmVudEZyYWc7XG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcyk7XG4gIH1cbiAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgdmFyIHNpbmdsZSA9IHRoaXMuc2luZ2xlID0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAvLyBkbyBub3QgZ28gc2luZ2xlIG1vZGUgaWYgdGhlIG9ubHkgbm9kZSBpcyBhbiBhbmNob3JcbiAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3ZfYW5jaG9yO1xuICBpZiAoc2luZ2xlKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZy5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMuYmVmb3JlID0gc2luZ2xlQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gc2luZ2xlUmVtb3ZlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZSA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcignZnJhZ21lbnQtZW5kJyk7XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICBwcmVwZW5kKHRoaXMubm9kZSwgZnJhZyk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgdGhpcy5iZWZvcmUgPSBtdWx0aUJlZm9yZTtcbiAgICB0aGlzLnJlbW92ZSA9IG11bHRpUmVtb3ZlO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IHRoaXM7XG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGhvb2sodGhpcy5jaGlsZHJlbltpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1ldGhvZCh0aGlzLm5vZGUsIHRhcmdldCwgdGhpcy52bSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWFwTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICB9KTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBmcmFnbWVudCBmb3IgcmVtb3ZhbC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgIC8vIGZyYWdtZW50cywgZGVwdGgtZmlyc3RcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uYmVmb3JlUmVtb3ZlKGZhbHNlKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBDYWxsIGRlc3Ryb3kgZm9yIGFsbCBjb250YWluZWQgaW5zdGFuY2VzLFxuICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgIC8vIERlZmVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBrZWVwIHRoZSBjaGlsZHJlbiB0byBjYWxsIGRldGFjaCBob29rc1xuICAgIC8vIG9uIHRoZW0uXG4gICAgdGhpcy5jaGlsZHJlbltpXS4kZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBkaXNhYmxlIHRoZSB3YXRjaGVycyBvbiBhbGwgdGhlIGRpcmVjdGl2ZXNcbiAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgLy8gZHVyaW5nIHJlbW92YWwuXG4gICAgZGlyc1tpXS5fd2F0Y2hlciAmJiBkaXJzW2ldLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZfZnJhZyA9IG51bGw7XG4gIHRoaXMudW5saW5rKCk7XG59O1xuXG4vKipcbiAqIENhbGwgYXR0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaChjaGlsZCkge1xuICBpZiAoIWNoaWxkLl9pc0F0dGFjaGVkICYmIGluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsIGRldGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBkZXRhY2goY2hpbGQpIHtcbiAgaWYgKGNoaWxkLl9pc0F0dGFjaGVkICYmICFpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgY2hpbGQuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICB9XG59XG5cbnZhciBsaW5rZXJDYWNoZSA9IG5ldyBDYWNoZSg1MDAwKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGFcbiAqIGZyYWdtZW50LiBDYWNoZXMgdGhlIGNvbXBpbGVkIGxpbmtlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50RmFjdG9yeSh2bSwgZWwpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2YXIgdGVtcGxhdGU7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbCA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc1N0cmluZyB8fCBpc1RlbXBsYXRlKGVsKSAmJiAhZWwuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICB0ZW1wbGF0ZSA9IHBhcnNlVGVtcGxhdGUoZWwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIC8vIGxpbmtlciBjYW4gYmUgY2FjaGVkLCBidXQgb25seSBmb3IgY29tcG9uZW50c1xuICB2YXIgbGlua2VyO1xuICB2YXIgY2lkID0gdm0uY29uc3RydWN0b3IuY2lkO1xuICBpZiAoY2lkID4gMCkge1xuICAgIHZhciBjYWNoZUlkID0gY2lkICsgKGlzU3RyaW5nID8gZWwgOiBnZXRPdXRlckhUTUwoZWwpKTtcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZCk7XG4gICAgaWYgKCFsaW5rZXIpIHtcbiAgICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgICAgIGxpbmtlckNhY2hlLnB1dChjYWNoZUlkLCBsaW5rZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5saW5rZXIgPSBsaW5rZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnJhZ21lbnQgaW5zdGFuY2Ugd2l0aCBnaXZlbiBob3N0IGFuZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gaG9zdFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBwYXJlbnRGcmFnXG4gKi9cblxuRnJhZ21lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdmFyIGZyYWcgPSBjbG9uZU5vZGUodGhpcy50ZW1wbGF0ZSk7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5saW5rZXIsIHRoaXMudm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKTtcbn07XG5cbnZhciBPTiA9IDcwMDtcbnZhciBNT0RFTCA9IDgwMDtcbnZhciBCSU5EID0gODUwO1xudmFyIFRSQU5TSVRJT04gPSAxMTAwO1xudmFyIEVMID0gMTUwMDtcbnZhciBDT01QT05FTlQgPSAxNTAwO1xudmFyIFBBUlRJQUwgPSAxNzUwO1xudmFyIElGID0gMjEwMDtcbnZhciBGT1IgPSAyMjAwO1xudmFyIFNMT1QgPSAyMzAwO1xuXG52YXIgdWlkJDMgPSAwO1xuXG52YXIgdkZvciA9IHtcblxuICBwcmlvcml0eTogRk9SLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBwYXJhbXM6IFsndHJhY2stYnknLCAnc3RhZ2dlcicsICdlbnRlci1zdGFnZ2VyJywgJ2xlYXZlLXN0YWdnZXInXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHN1cHBvcnQgXCJpdGVtIGluL29mIGl0ZW1zXCIgc3ludGF4XG4gICAgdmFyIGluTWF0Y2ggPSB0aGlzLmV4cHJlc3Npb24ubWF0Y2goLyguKikgKD86aW58b2YpICguKikvKTtcbiAgICBpZiAoaW5NYXRjaCkge1xuICAgICAgdmFyIGl0TWF0Y2ggPSBpbk1hdGNoWzFdLm1hdGNoKC9cXCgoLiopLCguKilcXCkvKTtcbiAgICAgIGlmIChpdE1hdGNoKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdE1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGl0TWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uID0gaW5NYXRjaFsyXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWxpYXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB2LWZvciBleHByZXNzaW9uIFwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYWxpYXMgaXMgcmVxdWlyZWQuJywgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdWlkIGFzIGEgY2FjaGUgaWRlbnRpZmllclxuICAgIHRoaXMuaWQgPSAnX192LWZvcl9fJyArICsrdWlkJDM7XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGFuIG9wdGlvbiBsaXN0LFxuICAgIC8vIHNvIHRoYXQgd2Uga25vdyBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgPHNlbGVjdD4nc1xuICAgIC8vIHYtbW9kZWwgd2hlbiB0aGUgb3B0aW9uIGxpc3QgaGFzIGNoYW5nZWQuXG4gICAgLy8gYmVjYXVzZSB2LW1vZGVsIGhhcyBhIGxvd2VyIHByaW9yaXR5IHRoYW4gdi1mb3IsXG4gICAgLy8gdGhlIHYtbW9kZWwgaXMgbm90IGJvdW5kIGhlcmUgeWV0LCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gcmV0cml2ZSBpdCBpbiB0aGUgYWN0dWFsIHVwZGF0ZU1vZGVsKCkgZnVuY3Rpb24uXG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICB0aGlzLmlzT3B0aW9uID0gKHRhZyA9PT0gJ09QVElPTicgfHwgdGFnID09PSAnT1BUR1JPVVAnKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCc7XG5cbiAgICAvLyBzZXR1cCBhbmNob3Igbm9kZXNcbiAgICB0aGlzLnN0YXJ0ID0gY3JlYXRlQW5jaG9yKCd2LWZvci1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCd2LWZvci1lbmQnKTtcbiAgICByZXBsYWNlKHRoaXMuZWwsIHRoaXMuZW5kKTtcbiAgICBiZWZvcmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuXG4gICAgLy8gY2FjaGVcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIGZyYWdtZW50IGZhY3RvcnlcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIHRoaXMuZWwpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICB0aGlzLmRpZmYoZGF0YSk7XG4gICAgdGhpcy51cGRhdGVSZWYoKTtcbiAgICB0aGlzLnVwZGF0ZU1vZGVsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpZmYsIGJhc2VkIG9uIG5ldyBkYXRhIGFuZCBvbGQgZGF0YSwgZGV0ZXJtaW5lIHRoZVxuICAgKiBtaW5pbXVtIGFtb3VudCBvZiBET00gbWFuaXB1bGF0aW9ucyBuZWVkZWQgdG8gbWFrZSB0aGVcbiAgICogRE9NIHJlZmxlY3QgdGhlIG5ldyBkYXRhIEFycmF5LlxuICAgKlxuICAgKiBUaGUgYWxnb3JpdGhtIGRpZmZzIHRoZSBuZXcgZGF0YSBBcnJheSBieSBzdG9yaW5nIGFcbiAgICogaGlkZGVuIHJlZmVyZW5jZSB0byBhbiBvd25lciB2bSBpbnN0YW5jZSBvbiBwcmV2aW91c2x5XG4gICAqIHNlZW4gZGF0YS4gVGhpcyBhbGxvd3MgdXMgdG8gYWNoaWV2ZSBPKG4pIHdoaWNoIGlzXG4gICAqIGJldHRlciB0aGFuIGEgbGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmFzZWQgYWxnb3JpdGhtLFxuICAgKiB3aGljaCBpcyBPKG0gKiBuKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICAgKi9cblxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKGRhdGEpIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgQXJyYXkgd2FzIGNvbnZlcnRlZCBmcm9tIGFuIE9iamVjdFxuICAgIHZhciBpdGVtID0gZGF0YVswXTtcbiAgICB2YXIgY29udmVydGVkRnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdCA9IGlzT2JqZWN0KGl0ZW0pICYmIGhhc093bihpdGVtLCAnJGtleScpICYmIGhhc093bihpdGVtLCAnJHZhbHVlJyk7XG5cbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIG9sZEZyYWdzID0gdGhpcy5mcmFncztcbiAgICB2YXIgZnJhZ3MgPSB0aGlzLmZyYWdzID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICB2YXIgYWxpYXMgPSB0aGlzLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgdmFyIGluRG9jdW1lbnQgPSBpbkRvYyhzdGFydCk7XG4gICAgdmFyIGluaXQgPSAhb2xkRnJhZ3M7XG4gICAgdmFyIGksIGwsIGZyYWcsIGtleSwgdmFsdWUsIHByaW1pdGl2ZTtcblxuICAgIC8vIEZpcnN0IHBhc3MsIGdvIHRocm91Z2ggdGhlIG5ldyBBcnJheSBhbmQgZmlsbCB1cFxuICAgIC8vIHRoZSBuZXcgZnJhZ3MgYXJyYXkuIElmIGEgcGllY2Ugb2YgZGF0YSBoYXMgYSBjYWNoZWRcbiAgICAvLyBpbnN0YW5jZSBmb3IgaXQsIHdlIHJldXNlIGl0LiBPdGhlcndpc2UgYnVpbGQgYSBuZXdcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBmb3IgKGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAga2V5ID0gY29udmVydGVkRnJvbU9iamVjdCA/IGl0ZW0uJGtleSA6IG51bGw7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiR2YWx1ZSA6IGl0ZW07XG4gICAgICBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgICAgZnJhZyA9ICFpbml0ICYmIHRoaXMuZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaSwga2V5KTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIC8vIHJldXNhYmxlIGZyYWdtZW50XG4gICAgICAgIGZyYWcucmV1c2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gdXBkYXRlICRpbmRleFxuICAgICAgICBmcmFnLnNjb3BlLiRpbmRleCA9IGk7XG4gICAgICAgIC8vIHVwZGF0ZSAka2V5XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlLiRrZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGl0ZXJhdG9yXG4gICAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAgIGZyYWcuc2NvcGVbaXRlcmF0b3JdID0ga2V5ICE9PSBudWxsID8ga2V5IDogaTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZGF0YSBmb3IgdHJhY2stYnksIG9iamVjdCByZXBlYXQgJlxuICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgICBpZiAodHJhY2tCeUtleSB8fCBjb252ZXJ0ZWRGcm9tT2JqZWN0IHx8IHByaW1pdGl2ZSkge1xuICAgICAgICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYWcuc2NvcGVbYWxpYXNdID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5ldyBpc250YW5jZVxuICAgICAgICBmcmFnID0gdGhpcy5jcmVhdGUodmFsdWUsIGFsaWFzLCBpLCBrZXkpO1xuICAgICAgICBmcmFnLmZyZXNoID0gIWluaXQ7XG4gICAgICB9XG4gICAgICBmcmFnc1tpXSA9IGZyYWc7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBmcmFnLmJlZm9yZShlbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlJ3JlIGRvbmUgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAoaW5pdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNlY29uZCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBvbGQgZnJhZ21lbnRzIGFuZFxuICAgIC8vIGRlc3Ryb3kgdGhvc2Ugd2hvIGFyZSBub3QgcmV1c2VkIChhbmQgcmVtb3ZlIHRoZW1cbiAgICAvLyBmcm9tIGNhY2hlKVxuICAgIHZhciByZW1vdmFsSW5kZXggPSAwO1xuICAgIHZhciB0b3RhbFJlbW92ZWQgPSBvbGRGcmFncy5sZW5ndGggLSBmcmFncy5sZW5ndGg7XG4gICAgLy8gd2hlbiByZW1vdmluZyBhIGxhcmdlIG51bWJlciBvZiBmcmFnbWVudHMsIHdhdGNoZXIgcmVtb3ZhbFxuICAgIC8vIHR1cm5zIG91dCB0byBiZSBhIHBlcmYgYm90dGxlbmVjaywgc28gd2UgYmF0Y2ggdGhlIHdhdGNoZXJcbiAgICAvLyByZW1vdmFscyBpbnRvIGEgc2luZ2xlIGZpbHRlciBjYWxsIVxuICAgIHRoaXMudm0uX3ZGb3JSZW1vdmluZyA9IHRydWU7XG4gICAgZm9yIChpID0gMCwgbCA9IG9sZEZyYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnJhZyA9IG9sZEZyYWdzW2ldO1xuICAgICAgaWYgKCFmcmFnLnJldXNlZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKGZyYWcsIHJlbW92YWxJbmRleCsrLCB0b3RhbFJlbW92ZWQsIGluRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZtLl92Rm9yUmVtb3ZpbmcgPSBmYWxzZTtcbiAgICBpZiAocmVtb3ZhbEluZGV4KSB7XG4gICAgICB0aGlzLnZtLl93YXRjaGVycyA9IHRoaXMudm0uX3dhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykge1xuICAgICAgICByZXR1cm4gdy5hY3RpdmU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBwYXNzLCBtb3ZlL2luc2VydCBuZXcgZnJhZ21lbnRzIGludG8gdGhlXG4gICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgdmFyIHRhcmdldFByZXYsIHByZXZFbCwgY3VycmVudFByZXY7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gZnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gZnJhZ3NbaV07XG4gICAgICAvLyB0aGlzIGlzIHRoZSBmcmFnIHRoYXQgd2Ugc2hvdWxkIGJlIGFmdGVyXG4gICAgICB0YXJnZXRQcmV2ID0gZnJhZ3NbaSAtIDFdO1xuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldiA/IHRhcmdldFByZXYuc3RhZ2dlckNiID8gdGFyZ2V0UHJldi5zdGFnZ2VyQW5jaG9yIDogdGFyZ2V0UHJldi5lbmQgfHwgdGFyZ2V0UHJldi5ub2RlIDogc3RhcnQ7XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmV2ICE9PSB0YXJnZXRQcmV2ICYmICghY3VycmVudFByZXYgfHxcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBtb3ZpbmcgYSBzaW5nbGUgaXRlbS5cbiAgICAgICAgLy8gdGhhbmtzIHRvIHN1Z2dlc3Rpb25zIGJ5IEBsaXZvcmFzIGluICMxODA3XG4gICAgICAgIGZpbmRQcmV2RnJhZyhjdXJyZW50UHJldiwgc3RhcnQsIHRoaXMuaWQpICE9PSB0YXJnZXRQcmV2KSkge1xuICAgICAgICAgIHRoaXMubW92ZShmcmFnLCBwcmV2RWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuX2hvc3Q7XG4gICAgLy8gY3JlYXRlIGl0ZXJhdGlvbiBzY29wZVxuICAgIHZhciBwYXJlbnRTY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSk7XG4gICAgLy8gcmVmIGhvbGRlciBmb3IgdGhlIHNjb3BlXG4gICAgc2NvcGUuJHJlZnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRyZWZzKTtcbiAgICBzY29wZS4kZWxzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kZWxzKTtcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGU7XG4gICAgLy8gZm9yIHR3by13YXkgYmluZGluZyBvbiBhbGlhc1xuICAgIHNjb3BlLiRmb3JDb250ZXh0ID0gdGhpcztcbiAgICAvLyBkZWZpbmUgc2NvcGUgcHJvcGVydGllc1xuICAgIC8vIGltcG9ydGFudDogZGVmaW5lIHRoZSBzY29wZSBhbGlhcyB3aXRob3V0IGZvcmNlZCBjb252ZXJzaW9uXG4gICAgLy8gc28gdGhhdCBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmVzIHJlbWFpbiBub24tcmVhY3RpdmUuXG4gICAgd2l0aG91dENvbnZlcnNpb24oZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsIGFsaWFzLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICckaW5kZXgnLCBpbmRleCk7XG4gICAgaWYgKGtleSkge1xuICAgICAgZGVmaW5lUmVhY3RpdmUoc2NvcGUsICcka2V5Jywga2V5KTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLiRrZXkpIHtcbiAgICAgIC8vIGF2b2lkIGFjY2lkZW50YWwgZmFsbGJhY2tcbiAgICAgIGRlZihzY29wZSwgJyRrZXknLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlcmF0b3IpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCB0aGlzLml0ZXJhdG9yLCBrZXkgIT09IG51bGwgPyBrZXkgOiBpbmRleCk7XG4gICAgfVxuICAgIHZhciBmcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZShob3N0LCBzY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgZnJhZy5mb3JJZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5jYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpO1xuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHYtcmVmIG9uIG93bmVyIHZtLlxuICAgKi9cblxuICB1cGRhdGVSZWY6IGZ1bmN0aW9uIHVwZGF0ZVJlZigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5kZXNjcmlwdG9yLnJlZjtcbiAgICBpZiAoIXJlZikgcmV0dXJuO1xuICAgIHZhciBoYXNoID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRyZWZzO1xuICAgIHZhciByZWZzO1xuICAgIGlmICghdGhpcy5mcm9tT2JqZWN0KSB7XG4gICAgICByZWZzID0gdGhpcy5mcmFncy5tYXAoZmluZFZtRnJvbUZyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZzID0ge307XG4gICAgICB0aGlzLmZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgcmVmc1tmcmFnLnNjb3BlLiRrZXldID0gZmluZFZtRnJvbUZyYWcoZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGFzaFtyZWZdID0gcmVmcztcbiAgfSxcblxuICAvKipcbiAgICogRm9yIG9wdGlvbiBsaXN0cywgdXBkYXRlIHRoZSBjb250YWluaW5nIHYtbW9kZWwgb25cbiAgICogcGFyZW50IDxzZWxlY3Q+LlxuICAgKi9cblxuICB1cGRhdGVNb2RlbDogZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgaWYgKHRoaXMuaXNPcHRpb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgbW9kZWwgPSBwYXJlbnQgJiYgcGFyZW50Ll9fdl9tb2RlbDtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBtb2RlbC5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGZyYWcsIGluZGV4LCBwcmV2RWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhZ2dlckFtb3VudCA9IHRoaXMuZ2V0U3RhZ2dlcihmcmFnLCBpbmRleCwgbnVsbCwgJ2VudGVyJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgLy8gY3JlYXRlIGFuIGFuY2hvciBhbmQgaW5zZXJ0IGl0IHN5bmNocm9ub3VzbHksXG4gICAgICAvLyBzbyB0aGF0IHdlIGNhbiByZXNvbHZlIHRoZSBjb3JyZWN0IG9yZGVyIHdpdGhvdXRcbiAgICAgIC8vIHdvcnJ5aW5nIGFib3V0IHNvbWUgZWxlbWVudHMgbm90IGluc2VydGVkIHlldFxuICAgICAgdmFyIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvcjtcbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGFuY2hvciA9IGZyYWcuc3RhZ2dlckFuY2hvciA9IGNyZWF0ZUFuY2hvcignc3RhZ2dlci1hbmNob3InKTtcbiAgICAgICAgYW5jaG9yLl9fdl9mcmFnID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGFmdGVyKGFuY2hvciwgcHJldkVsKTtcbiAgICAgIHZhciBvcCA9IGZyYWcuc3RhZ2dlckNiID0gY2FuY2VsbGFibGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAgIGZyYWcuYmVmb3JlKGFuY2hvcik7XG4gICAgICAgIHJlbW92ZShhbmNob3IpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldCA9IHByZXZFbC5uZXh0U2libGluZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgLy8gcmVzZXQgZW5kIGFuY2hvciBwb3NpdGlvbiBpbiBjYXNlIHRoZSBwb3NpdGlvbiB3YXMgbWVzc2VkIHVwXG4gICAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGRyYWctbi1kcm9wIGxpYnJhcnkuXG4gICAgICAgIGFmdGVyKHRoaXMuZW5kLCBwcmV2RWwpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGZyYWcuYmVmb3JlKHRhcmdldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudC4gSGFuZGxlcyBzdGFnZ2VyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbkRvY3VtZW50XG4gICAqL1xuXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZyYWcsIGluZGV4LCB0b3RhbCwgaW5Eb2N1bWVudCkge1xuICAgIGlmIChmcmFnLnN0YWdnZXJDYikge1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IuY2FuY2VsKCk7XG4gICAgICBmcmFnLnN0YWdnZXJDYiA9IG51bGw7XG4gICAgICAvLyBpdCdzIG5vdCBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgZnJhZyB0byBiZSByZW1vdmVkXG4gICAgICAvLyB0d2ljZSwgc28gaWYgd2UgaGF2ZSBhIHBlbmRpbmcgc3RhZ2dlciBjYWxsYmFjayxcbiAgICAgIC8vIGl0IG1lYW5zIHRoaXMgZnJhZyBpcyBxdWV1ZWQgZm9yIGVudGVyIGJ1dCByZW1vdmVkXG4gICAgICAvLyBiZWZvcmUgaXRzIHRyYW5zaXRpb24gc3RhcnRlZC4gU2luY2UgaXQgaXMgYWxyZWFkeVxuICAgICAgLy8gZGVzdHJveWVkLCB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBpbiBkZXRhY2hlZCBzdGF0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCAnbGVhdmUnKTtcbiAgICBpZiAoaW5Eb2N1bWVudCAmJiBzdGFnZ2VyQW1vdW50KSB7XG4gICAgICB2YXIgb3AgPSBmcmFnLnN0YWdnZXJDYiA9IGNhbmNlbGxhYmxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgICBmcmFnLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KG9wLCBzdGFnZ2VyQW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmUgYSBmcmFnbWVudCB0byBhIG5ldyBwb3NpdGlvbi5cbiAgICogRm9yY2Ugbm8gdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge05vZGV9IHByZXZFbFxuICAgKi9cblxuICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKGZyYWcsIHByZXZFbCkge1xuICAgIC8vIGZpeCBhIGNvbW1vbiBpc3N1ZSB3aXRoIFNvcnRhYmxlOlxuICAgIC8vIGlmIHByZXZFbCBkb2Vzbid0IGhhdmUgbmV4dFNpYmxpbmcsIHRoaXMgbWVhbnMgaXQnc1xuICAgIC8vIGJlZW4gZHJhZ2dlZCBhZnRlciB0aGUgZW5kIGFuY2hvci4gSnVzdCByZS1wb3NpdGlvblxuICAgIC8vIHRoZSBlbmQgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXByZXZFbC5uZXh0U2libGluZykge1xuICAgICAgdGhpcy5lbmQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmVuZCk7XG4gICAgfVxuICAgIGZyYWcuYmVmb3JlKHByZXZFbC5uZXh0U2libGluZywgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBhIGZyYWdtZW50IHVzaW5nIHRyYWNrLWJ5IG9yIHRoZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICAgKi9cblxuICBjYWNoZUZyYWc6IGZ1bmN0aW9uIGNhY2hlRnJhZyh2YWx1ZSwgZnJhZywgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBpZDtcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tCeUtleSAhPT0gJyRpbmRleCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgICAgIGRlZih2YWx1ZSwgaWQsIGZyYWcpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0Zyb3plbiB2LWZvciBvYmplY3RzIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IHRyYWNrZWQsIG1ha2Ugc3VyZSB0byAnICsgJ3Byb3ZpZGUgYSB0cmFjay1ieSBrZXkuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcucmF3ID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIGNhY2hlZCBmcmFnbWVudCBmcm9tIHRoZSB2YWx1ZS9pbmRleC9rZXlcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkRnJhZzogZnVuY3Rpb24gZ2V0Q2FjaGVkRnJhZyh2YWx1ZSwgaW5kZXgsIGtleSkge1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgZnJhZztcbiAgICBpZiAoa2V5IHx8IHRyYWNrQnlLZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSBnZXRUcmFja0J5S2V5KGluZGV4LCBrZXksIHZhbHVlLCB0cmFja0J5S2V5KTtcbiAgICAgIGZyYWcgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZyA9IHZhbHVlW3RoaXMuaWRdO1xuICAgIH1cbiAgICBpZiAoZnJhZyAmJiAoZnJhZy5yZXVzZWQgfHwgZnJhZy5mcmVzaCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdGhpcy53YXJuRHVwbGljYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZyYWdtZW50IGZyb20gY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICovXG5cbiAgZGVsZXRlQ2FjaGVkRnJhZzogZnVuY3Rpb24gZGVsZXRlQ2FjaGVkRnJhZyhmcmFnKSB7XG4gICAgdmFyIHZhbHVlID0gZnJhZy5yYXc7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBzY29wZSA9IGZyYWcuc2NvcGU7XG4gICAgdmFyIGluZGV4ID0gc2NvcGUuJGluZGV4O1xuICAgIC8vIGZpeCAjOTQ4OiBhdm9pZCBhY2NpZGVudGFsbHkgZmFsbCB0aHJvdWdoIHRvXG4gICAgLy8gYSBwYXJlbnQgcmVwZWF0ZXIgd2hpY2ggaGFwcGVucyB0byBoYXZlICRrZXkuXG4gICAgdmFyIGtleSA9IGhhc093bihzY29wZSwgJyRrZXknKSAmJiBzY29wZS4ka2V5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIGlmICh0cmFja0J5S2V5IHx8IGtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVt0aGlzLmlkXSA9IG51bGw7XG4gICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIGdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgdmFyIHRyYW5zID0gZnJhZy5ub2RlLl9fdl90cmFucztcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rcztcbiAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICByZXR1cm4gaG9vayA/IGhvb2suY2FsbChmcmFnLCBpbmRleCwgdG90YWwpIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzIHRoZSB2YWx1ZSBiZWZvcmUgcGlwaW5nIGl0IHRocm91Z2ggdGhlXG4gICAqIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqL1xuXG4gIF9wcmVQcm9jZXNzOiBmdW5jdGlvbiBfcHJlUHJvY2Vzcyh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHZhbHVlIGFmdGVyIGl0IGhhcyBiZWVuIHBpcGVkIHRocm91Z2hcbiAgICogdGhlIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSBmb3IgdGhpcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZVxuICAgKiB3YXRjaGVyJ3MgZGVwZW5kZW5jeSBjb2xsZWN0aW9uIHBoYXNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICovXG5cbiAgX3Bvc3RQcm9jZXNzOiBmdW5jdGlvbiBfcG9zdFByb2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB2YXIga2V5O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXNbaV0gPSB7XG4gICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHJhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSB8fCBbXTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZGVzY3JpcHRvci5yZWYpIHtcbiAgICAgICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmc1t0aGlzLmRlc2NyaXB0b3IucmVmXSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZnJhZ3MubGVuZ3RoO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmZyYWdzW2ldO1xuICAgICAgICB0aGlzLmRlbGV0ZUNhY2hlZEZyYWcoZnJhZyk7XG4gICAgICAgIGZyYWcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZmluZCB0aGUgcHJldmlvdXMgZWxlbWVudCB0aGF0IGlzIGEgZnJhZ21lbnRcbiAqIGFuY2hvci4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGRlc3Ryb3llZCBmcmFnJ3NcbiAqIGVsZW1lbnQgY291bGQgc3RpbGwgYmUgbGluZ2VyaW5nIGluIHRoZSBET00gYmVmb3JlIGl0c1xuICogbGVhdmluZyB0cmFuc2l0aW9uIGZpbmlzaGVzLCBidXQgaXRzIGluc2VydGVkIGZsYWdcbiAqIHNob3VsZCBoYXZlIGJlZW4gc2V0IHRvIGZhbHNlIHNvIHdlIGNhbiBza2lwIHRoZW0uXG4gKlxuICogSWYgdGhpcyBpcyBhIGJsb2NrIHJlcGVhdCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2Ugb25seVxuICogcmV0dXJuIGZyYWcgdGhhdCBpcyBib3VuZCB0byB0aGlzIHYtZm9yLiAoc2VlICM5MjkpXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHBhcmFtIHtDb21tZW50fFRleHR9IGFuY2hvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kUHJldkZyYWcoZnJhZywgYW5jaG9yLCBpZCkge1xuICB2YXIgZWwgPSBmcmFnLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBmcmFnID0gZWwuX192X2ZyYWc7XG4gIHdoaWxlICgoIWZyYWcgfHwgZnJhZy5mb3JJZCAhPT0gaWQgfHwgIWZyYWcuaW5zZXJ0ZWQpICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZnJhZyA9IGVsLl9fdl9mcmFnO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2bSBmcm9tIGEgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gIHZhciBub2RlID0gZnJhZy5ub2RlO1xuICAvLyBoYW5kbGUgbXVsdGktbm9kZSBmcmFnXG4gIGlmIChmcmFnLmVuZCkge1xuICAgIHdoaWxlICghbm9kZS5fX3Z1ZV9fICYmIG5vZGUgIT09IGZyYWcuZW5kICYmIG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS5fX3Z1ZV9fO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoTWF0aC5mbG9vcihuKSk7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmV0W2ldID0gaTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHJhY2sgYnkga2V5IGZvciBhbiBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0J5S2V5XVxuICovXG5cbmZ1bmN0aW9uIGdldFRyYWNrQnlLZXkoaW5kZXgsIGtleSwgdmFsdWUsIHRyYWNrQnlLZXkpIHtcbiAgcmV0dXJuIHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdHJhY2tCeUtleS5jaGFyQXQoMCkubWF0Y2goL1xcdy8pID8gZ2V0UGF0aCh2YWx1ZSwgdHJhY2tCeUtleSkgOiB2YWx1ZVt0cmFja0J5S2V5XSA6IGtleSB8fCB2YWx1ZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdkZvci53YXJuRHVwbGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgd2FybignRHVwbGljYXRlIHZhbHVlIGZvdW5kIGluIHYtZm9yPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnLiBVc2UgdHJhY2stYnk9XCIkaW5kZXhcIiBpZiAnICsgJ3lvdSBhcmUgZXhwZWN0aW5nIGR1cGxpY2F0ZSB2YWx1ZXMuJywgdGhpcy52bSk7XG4gIH07XG59XG5cbnZhciB2SWYgPSB7XG5cbiAgcHJpb3JpdHk6IElGLFxuICB0ZXJtaW5hbDogdHJ1ZSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgaWYgKCFlbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZShuZXh0KTtcbiAgICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgbWFpbiBibG9ja1xuICAgICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtaWYnKTtcbiAgICAgIHJlcGxhY2UoZWwsIHRoaXMuYW5jaG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nLCB0aGlzLnZtKTtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmZyYWcpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbDtcbiAgICB9XG4gICAgLy8gbGF6eSBpbml0IGZhY3RvcnlcbiAgICBpZiAoIXRoaXMuZmFjdG9yeSkge1xuICAgICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgdGhpcy5mcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUVsICYmICF0aGlzLmVsc2VGcmFnKSB7XG4gICAgICBpZiAoIXRoaXMuZWxzZUZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy5lbHNlRWwuX2NvbnRleHQgfHwgdGhpcy52bSwgdGhpcy5lbHNlRWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbHNlRnJhZyA9IHRoaXMuZWxzZUZhY3RvcnkuY3JlYXRlKHRoaXMuX2hvc3QsIHRoaXMuX3Njb3BlLCB0aGlzLl9mcmFnKTtcbiAgICAgIHRoaXMuZWxzZUZyYWcuYmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3cgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBjaGVjayBlbHNlIGJsb2NrXG4gICAgdmFyIG5leHQgPSB0aGlzLmVsLm5leHRFbGVtZW50U2libGluZztcbiAgICBpZiAobmV4dCAmJiBnZXRBdHRyKG5leHQsICd2LWVsc2UnKSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5lbHNlRWwgPSBuZXh0O1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXBwbHkodGhpcy5lbCwgdmFsdWUpO1xuICAgIGlmICh0aGlzLmVsc2VFbCkge1xuICAgICAgdGhpcy5hcHBseSh0aGlzLmVsc2VFbCwgIXZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KGVsLCB2YWx1ZSkge1xuICAgIGlmIChpbkRvYyhlbCkpIHtcbiAgICAgIGFwcGx5VHJhbnNpdGlvbihlbCwgdmFsdWUgPyAxIDogLTEsIHRvZ2dsZSwgdGhpcy52bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvZ2dsZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0JDIgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaXNSYW5nZSA9IGVsLnR5cGUgPT09ICdyYW5nZSc7XG4gICAgdmFyIGxhenkgPSB0aGlzLnBhcmFtcy5sYXp5O1xuICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcmFtcy5udW1iZXI7XG4gICAgdmFyIGRlYm91bmNlID0gdGhpcy5wYXJhbXMuZGVib3VuY2U7XG5cbiAgICAvLyBoYW5kbGUgY29tcG9zaXRpb24gZXZlbnRzLlxuICAgIC8vICAgaHR0cDovL2Jsb2cuZXZhbnlvdS5tZS8yMDE0LzAxLzAzL2NvbXBvc2l0aW9uLWV2ZW50L1xuICAgIC8vIHNraXAgdGhpcyBmb3IgQW5kcm9pZCBiZWNhdXNlIGl0IGhhbmRsZXMgY29tcG9zaXRpb25cbiAgICAvLyBldmVudHMgcXVpdGUgZGlmZmVyZW50bHkuIEFuZHJvaWQgZG9lc24ndCB0cmlnZ2VyXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIGZvciBsYW5ndWFnZSBpbnB1dCBtZXRob2RzIGUuZy5cbiAgICAvLyBDaGluZXNlLCBidXQgaW5zdGVhZCB0cmlnZ2VycyB0aGVtIGZvciBzcGVsbGluZ1xuICAgIC8vIHN1Z2dlc3Rpb25zLi4uIChzZWUgRGlzY3Vzc2lvbi8jMTYyKVxuICAgIHZhciBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICBpZiAoIWlzQW5kcm9pZCAmJiAhaXNSYW5nZSkge1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcG9zaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBpbiBJRTExIHRoZSBcImNvbXBvc2l0aW9uZW5kXCIgZXZlbnQgZmlyZXMgQUZURVJcbiAgICAgICAgLy8gdGhlIFwiaW5wdXRcIiBldmVudCwgc28gdGhlIGlucHV0IGhhbmRsZXIgaXMgYmxvY2tlZFxuICAgICAgICAvLyBhdCB0aGUgZW5kLi4uIGhhdmUgdG8gY2FsbCBpdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAjMTMyNzogaW4gbGF6eSBtb2RlIHRoaXMgaXMgdW5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IG1lc3Npbmcgd2l0aCB0aGUgaW5wdXQgd2hlbiB1c2VyIGlzIHR5cGluZyxcbiAgICAvLyBhbmQgZm9yY2UgdXBkYXRlIG9uIGJsdXIuXG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgaWYgKCFpc1JhbmdlICYmICFsYXp5KSB7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGRvIG5vdCBzeW5jIHZhbHVlIGFmdGVyIGZyYWdtZW50IHJlbW92YWwgKCMyMDE3KVxuICAgICAgICBpZiAoIXNlbGYuX2ZyYWcgfHwgc2VsZi5fZnJhZy5pbnNlcnRlZCkge1xuICAgICAgICAgIHNlbGYucmF3TGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTm93IGF0dGFjaCB0aGUgbWFpbiBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSB0aGlzLnJhd0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbXBvc2luZyB8fCAhc2VsZi5fYm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IG51bWJlciB8fCBpc1JhbmdlID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWwpO1xuICAgICAgLy8gZm9yY2UgdXBkYXRlIG9uIG5leHQgdGljayB0byBhdm9pZCBsb2NrICYgc2FtZSB2YWx1ZVxuICAgICAgLy8gYWxzbyBvbmx5IHVwZGF0ZSB3aGVuIHVzZXIgaXMgbm90IHR5cGluZ1xuICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYm91bmQgJiYgIXNlbGYuZm9jdXNlZCkge1xuICAgICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYXBwbHkgZGVib3VuY2VcbiAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBfZGVib3VuY2UodGhpcy5saXN0ZW5lciwgZGVib3VuY2UpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgalF1ZXJ5IGV2ZW50cywgc2luY2UgalF1ZXJ5LnRyaWdnZXIoKSBkb2Vzbid0XG4gICAgLy8gdHJpZ2dlciBuYXRpdmUgZXZlbnRzIGluIHNvbWUgY2FzZXMgYW5kIHNvbWUgcGx1Z2luc1xuICAgIC8vIHJlbHkgb24gJC50cmlnZ2VyKClcbiAgICAvL1xuICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIGlmIGEgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdXNpbmdcbiAgICAvLyBqUXVlcnksIGl0IGlzIGFsc28gcmVtb3ZlZCB3aXRoIGpRdWVyeSwgdGhhdCdzIHdoeVxuICAgIC8vIHdlIGRvIHRoZSBjaGVjayBmb3IgZWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgYW5kXG4gICAgLy8gc3RvcmUgdGhhdCBjaGVjayByZXN1bHQgb24gaXRzZWxmLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgLy8gZWFzaWVyIHRlc3QgY292ZXJhZ2UgY29udHJvbCBieSB1bnNldHRpbmcgdGhlIGdsb2JhbFxuICAgIC8vIGpRdWVyeSB2YXJpYWJsZSBpbiB0ZXN0cy5cbiAgICB0aGlzLmhhc2pRdWVyeSA9IHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHRoaXMuaGFzalF1ZXJ5KSB7XG4gICAgICB2YXIgbWV0aG9kID0galF1ZXJ5LmZuLm9uID8gJ29uJyA6ICdiaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5yYXdMaXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKVttZXRob2RdKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnJhd0xpc3RlbmVyKTtcbiAgICAgIGlmICghbGF6eSkge1xuICAgICAgICB0aGlzLm9uKCdpbnB1dCcsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElFOSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnQgb24gYmFja3NwYWNlL2RlbC9jdXRcbiAgICBpZiAoIWxhenkgJiYgaXNJRTkpIHtcbiAgICAgIHRoaXMub24oJ2N1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soc2VsZi5saXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gNDYgfHwgZS5rZXlDb2RlID09PSA4KSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSB8fCBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmIGVsLnZhbHVlLnRyaW0oKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIC8vICMzMDI5IG9ubHkgdXBkYXRlIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIFRoaXMgcHJldmVudFxuICAgIC8vIGJyb3dzZXJzIGZyb20gb3ZlcndyaXRpbmcgdmFsdWVzIGxpa2Ugc2VsZWN0aW9uU3RhcnRcbiAgICB2YWx1ZSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB0aGlzLmVsLnZhbHVlID0gdmFsdWU7XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYXNqUXVlcnkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBqUXVlcnkuZm4ub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICAgIGpRdWVyeShlbClbbWV0aG9kXSgnY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICBqUXVlcnkoZWwpW21ldGhvZF0oJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmFkaW8gPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB2YWx1ZSBvdmVyd3JpdGUgdmlhIHYtYmluZDp2YWx1ZVxuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSkge1xuICAgICAgICByZXR1cm4gZWwuX3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHNlbGYucGFyYW1zLm51bWJlcikge1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuc2V0KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gIH1cbn07XG5cbnZhciBzZWxlY3QgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAvLyBtZXRob2QgdG8gZm9yY2UgdXBkYXRlIERPTSB1c2luZyBsYXRlc3QgdmFsdWUuXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLl93YXRjaGVyKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKHNlbGYuX3dhdGNoZXIuZ2V0KCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0XG4gICAgdmFyIG11bHRpcGxlID0gdGhpcy5tdWx0aXBsZSA9IGVsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKTtcblxuICAgIC8vIGF0dGFjaCBsaXN0ZW5lclxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShlbCwgbXVsdGlwbGUpO1xuICAgICAgdmFsdWUgPSBzZWxmLnBhcmFtcy5udW1iZXIgPyBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh0b051bWJlcikgOiB0b051bWJlcih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIHNlbGYuc2V0KHZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub24oJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuXG4gICAgLy8gaWYgaGFzIGluaXRpYWwgdmFsdWUsIHNldCBhZnRlckJpbmRcbiAgICB2YXIgaW5pdFZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlLCB0cnVlKTtcbiAgICBpZiAobXVsdGlwbGUgJiYgaW5pdFZhbHVlLmxlbmd0aCB8fCAhbXVsdGlwbGUgJiYgaW5pdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuXG4gICAgLy8gQWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBGaXJlZm94IHJlc2V0c1xuICAgIC8vIHNlbGVjdGVkSW5kZXggd2l0aCB2YWx1ZSAtMSB0byAwIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAvLyBpcyBhcHBlbmRlZCB0byBhIG5ldyBwYXJlbnQsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvXG4gICAgLy8gZm9yY2UgYSBET00gdXBkYXRlIHdoZW5ldmVyIHRoYXQgaGFwcGVucy4uLlxuICAgIHRoaXMudm0uJG9uKCdob29rOmF0dGFjaGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgbmV4dFRpY2soX3RoaXMuZm9yY2VVcGRhdGUpO1xuICAgIH0pO1xuICAgIGlmICghaW5Eb2MoZWwpKSB7XG4gICAgICBuZXh0VGljayh0aGlzLmZvcmNlVXBkYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB2YXIgbXVsdGkgPSB0aGlzLm11bHRpcGxlICYmIGlzQXJyYXkodmFsdWUpO1xuICAgIHZhciBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgICB2YXIgaSA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIHZhciBvcCwgdmFsO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG9wID0gb3B0aW9uc1tpXTtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICBvcC5zZWxlY3RlZCA9IG11bHRpID8gaW5kZXhPZiQxKHZhbHVlLCB2YWwpID4gLTEgOiBsb29zZUVxdWFsKHZhbHVlLCB2YWwpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aGlzLnZtLiRvZmYoJ2hvb2s6YXR0YWNoZWQnLCB0aGlzLmZvcmNlVXBkYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgc2VsZWN0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtTZWxlY3RFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBtdWx0aVxuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtBcnJheXwqfVxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlKGVsLCBtdWx0aSwgaW5pdCkge1xuICB2YXIgcmVzID0gbXVsdGkgPyBbXSA6IG51bGw7XG4gIHZhciBvcCwgdmFsLCBzZWxlY3RlZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wID0gZWwub3B0aW9uc1tpXTtcbiAgICBzZWxlY3RlZCA9IGluaXQgPyBvcC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgOiBvcC5zZWxlY3RlZDtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHZhbCA9IG9wLmhhc093blByb3BlcnR5KCdfdmFsdWUnKSA/IG9wLl92YWx1ZSA6IG9wLnZhbHVlO1xuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIHJlcy5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIE5hdGl2ZSBBcnJheS5pbmRleE9mIHVzZXMgc3RyaWN0IGVxdWFsLCBidXQgaW4gdGhpc1xuICogY2FzZSB3ZSBuZWVkIHRvIG1hdGNoIHN0cmluZy9udW1iZXJzIHdpdGggY3VzdG9tIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mJDEoYXJyLCB2YWwpIHtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgY2hlY2tib3ggPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gZWwuX3ZhbHVlIDogc2VsZi5wYXJhbXMubnVtYmVyID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5WYWx1ZSgpIHtcbiAgICAgIHZhciB2YWwgPSBlbC5jaGVja2VkO1xuICAgICAgaWYgKHZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdHJ1ZVZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1vZGVsID0gc2VsZi5fd2F0Y2hlci52YWx1ZTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICB2YXIgdmFsID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC4kcmVtb3ZlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0KGdldEJvb2xlYW5WYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBpbmRleE9mKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpID4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICB0ZXh0OiB0ZXh0JDIsXG4gIHJhZGlvOiByYWRpbyxcbiAgc2VsZWN0OiBzZWxlY3QsXG4gIGNoZWNrYm94OiBjaGVja2JveFxufTtcblxudmFyIG1vZGVsID0ge1xuXG4gIHByaW9yaXR5OiBNT0RFTCxcbiAgdHdvV2F5OiB0cnVlLFxuICBoYW5kbGVyczogaGFuZGxlcnMsXG4gIHBhcmFtczogWydsYXp5JywgJ251bWJlcicsICdkZWJvdW5jZSddLFxuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBlbGVtZW50czpcbiAgICogICA8c2VsZWN0PlxuICAgKiAgIDx0ZXh0YXJlYT5cbiAgICogICA8aW5wdXQgdHlwZT1cIipcIj5cbiAgICogICAgIC0gdGV4dFxuICAgKiAgICAgLSBjaGVja2JveFxuICAgKiAgICAgLSByYWRpb1xuICAgKiAgICAgLSBudW1iZXJcbiAgICovXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBmcmllbmRseSB3YXJuaW5nLi4uXG4gICAgdGhpcy5jaGVja0ZpbHRlcnMoKTtcbiAgICBpZiAodGhpcy5oYXNSZWFkICYmICF0aGlzLmhhc1dyaXRlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgYSByZWFkLW9ubHkgZmlsdGVyIHdpdGggJyArICd2LW1vZGVsPVwiJyArIHRoaXMuZGVzY3JpcHRvci5yYXcgKyAnXCIuICcgKyAnWW91IG1pZ2h0IHdhbnQgdG8gdXNlIGEgdHdvLXdheSBmaWx0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuJywgdGhpcy52bSk7XG4gICAgfVxuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2VsLnR5cGVdIHx8IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMuc2VsZWN0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudCB0eXBlOiAnICsgdGFnLCB0aGlzLnZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwuX192X21vZGVsID0gdGhpcztcbiAgICBoYW5kbGVyLmJpbmQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlO1xuICAgIHRoaXMuX3VuYmluZCA9IGhhbmRsZXIudW5iaW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayByZWFkL3dyaXRlIGZpbHRlciBzdGF0cy5cbiAgICovXG5cbiAgY2hlY2tGaWx0ZXJzOiBmdW5jdGlvbiBjaGVja0ZpbHRlcnMoKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm47XG4gICAgdmFyIGkgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZmlsdGVyID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGZpbHRlci5yZWFkKSB7XG4gICAgICAgIHRoaXMuaGFzUmVhZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLndyaXRlKSB7XG4gICAgICAgIHRoaXMuaGFzV3JpdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGw7XG4gICAgdGhpcy5fdW5iaW5kICYmIHRoaXMuX3VuYmluZCgpO1xuICB9XG59O1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl0sXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDBcbn07XG5cbmZ1bmN0aW9uIGtleUZpbHRlcihoYW5kbGVyLCBrZXlzKSB7XG4gIHZhciBjb2RlcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBrZXkuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoY2hhckNvZGUgPiA0NyAmJiBjaGFyQ29kZSA8IDU4KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICBjaGFyQ29kZSA9IGtleS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiA2NCAmJiBjaGFyQ29kZSA8IDkxKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleUNvZGVzW2tleV07XG4gIH0pO1xuICBjb2RlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgY29kZXMpO1xuICByZXR1cm4gZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgaWYgKGNvZGVzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RvcEZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wSGFuZGxlcihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZkZpbHRlcihoYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmSGFuZGxlcihlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgb24kMSA9IHtcblxuICBwcmlvcml0eTogT04sXG4gIGFjY2VwdFN0YXRlbWVudDogdHJ1ZSxcbiAga2V5Q29kZXM6IGtleUNvZGVzLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gZGVhbCB3aXRoIGlmcmFtZXNcbiAgICBpZiAodGhpcy5lbC50YWdOYW1lID09PSAnSUZSQU1FJyAmJiB0aGlzLmFyZyAhPT0gJ2xvYWQnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uKHNlbGYuZWwuY29udGVudFdpbmRvdywgc2VsZi5hcmcsIHNlbGYuaGFuZGxlciwgc2VsZi5tb2RpZmllcnMuY2FwdHVyZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMuaWZyYW1lQmluZCk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGhhbmRsZXIpIHtcbiAgICAvLyBzdHViIGEgbm9vcCBmb3Igdi1vbiB3aXRoIG5vIHZhbHVlLFxuICAgIC8vIGUuZy4gQG1vdXNlZG93bi5wcmV2ZW50XG4gICAgaWYgKCF0aGlzLmRlc2NyaXB0b3IucmF3KSB7XG4gICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ3Ytb246JyArIHRoaXMuYXJnICsgJz1cIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIgZXhwZWN0cyBhIGZ1bmN0aW9uIHZhbHVlLCAnICsgJ2dvdCAnICsgaGFuZGxlciwgdGhpcy52bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgbW9kaWZpZXJzXG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnN0b3ApIHtcbiAgICAgIGhhbmRsZXIgPSBzdG9wRmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllcnMucHJldmVudCkge1xuICAgICAgaGFuZGxlciA9IHByZXZlbnRGaWx0ZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zZWxmKSB7XG4gICAgICBoYW5kbGVyID0gc2VsZkZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8ga2V5IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RpZmllcnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9PSAnc3RvcCcgJiYga2V5ICE9PSAncHJldmVudCcgJiYga2V5ICE9PSAnc2VsZicgJiYga2V5ICE9PSAnY2FwdHVyZSc7XG4gICAgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuaWZyYW1lQmluZCkge1xuICAgICAgdGhpcy5pZnJhbWVCaW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKHRoaXMuZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIsIHRoaXMubW9kaWZpZXJzLmNhcHR1cmUpO1xuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5pZnJhbWVCaW5kID8gdGhpcy5lbC5jb250ZW50V2luZG93IDogdGhpcy5lbDtcbiAgICBpZiAodGhpcy5oYW5kbGVyKSB7XG4gICAgICBvZmYoZWwsIHRoaXMuYXJnLCB0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW1zLSddO1xudmFyIGNhbWVsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kLztcbnZhciBwcm9wQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgdGVzdEVsID0gbnVsbDtcblxudmFyIHN0eWxlID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5lbC5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUucmVkdWNlKGV4dGVuZCwge30pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNhY2hlIG9iamVjdCBzdHlsZXMgc28gdGhhdCBvbmx5IGNoYW5nZWQgcHJvcHNcbiAgICAvLyBhcmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlIHx8ICh0aGlzLmNhY2hlID0ge30pO1xuICAgIHZhciBuYW1lLCB2YWw7XG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIHZhbCA9IHZhbHVlW25hbWVdO1xuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWw7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHByb3AsIHZhbHVlKSB7XG4gICAgcHJvcCA9IG5vcm1hbGl6ZShwcm9wKTtcbiAgICBpZiAoIXByb3ApIHJldHVybjsgLy8gdW5zdXBwb3J0ZWQgcHJvcFxuICAgIC8vIGNhc3QgcG9zc2libGUgbnVtYmVycy9ib29sZWFucyBpbnRvIHN0cmluZ3NcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWUgKz0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YXIgaXNJbXBvcnRhbnQgPSBpbXBvcnRhbnRSRS50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJyc7XG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignSXRcXCdzIHByb2JhYmx5IGEgYmFkIGlkZWEgdG8gdXNlICFpbXBvcnRhbnQgd2l0aCBpbmxpbmUgcnVsZXMuICcgKyAnVGhpcyBmZWF0dXJlIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFZ1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKS50cmltKCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcC5rZWJhYiwgdmFsdWUsIGlzSW1wb3J0YW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGVbcHJvcC5jYW1lbF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZVtwcm9wLmNhbWVsXSA9ICcnO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIENTUyBwcm9wZXJ0eSBuYW1lLlxuICogLSBjYWNoZSByZXN1bHRcbiAqIC0gYXV0byBwcmVmaXhcbiAqIC0gY2FtZWxDYXNlIC0+IGRhc2gtY2FzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF07XG4gIH1cbiAgdmFyIHJlcyA9IHByZWZpeChwcm9wKTtcbiAgcHJvcENhY2hlW3Byb3BdID0gcHJvcENhY2hlW3Jlc10gPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQXV0byBkZXRlY3QgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBmb3IgYSBDU1MgcHJvcGVydHkuXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTIzNjkyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXgocHJvcCkge1xuICBwcm9wID0gaHlwaGVuYXRlKHByb3ApO1xuICB2YXIgY2FtZWwgPSBjYW1lbGl6ZShwcm9wKTtcbiAgdmFyIHVwcGVyID0gY2FtZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbC5zbGljZSgxKTtcbiAgaWYgKCF0ZXN0RWwpIHtcbiAgICB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuICB2YXIgaSA9IHByZWZpeGVzLmxlbmd0aDtcbiAgdmFyIHByZWZpeGVkO1xuICBpZiAoY2FtZWwgIT09ICdmaWx0ZXInICYmIGNhbWVsIGluIHRlc3RFbC5zdHlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWJhYjogcHJvcCxcbiAgICAgIGNhbWVsOiBjYW1lbFxuICAgIH07XG4gIH1cbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtlYmFiOiBwcmVmaXhlc1tpXSArIHByb3AsXG4gICAgICAgIGNhbWVsOiBwcmVmaXhlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8geGxpbmtcbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhsaW5rUkUgPSAvXnhsaW5rOi87XG5cbi8vIGNoZWNrIGZvciBhdHRyaWJ1dGVzIHRoYXQgcHJvaGliaXQgaW50ZXJwb2xhdGlvbnNcbnZhciBkaXNhbGxvd2VkSW50ZXJwQXR0clJFID0gL152LXxeOnxeQHxeKD86aXN8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLW1vZGV8ZGVib3VuY2V8dHJhY2stYnl8c3RhZ2dlcnxlbnRlci1zdGFnZ2VyfGxlYXZlLXN0YWdnZXIpJC87XG4vLyB0aGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBhbHNvIHNldCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbi8vIGJlY2F1c2UgdGhleSBvbmx5IGFmZmVjdCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxudmFyIGF0dHJXaXRoUHJvcHNSRSA9IC9eKD86dmFsdWV8Y2hlY2tlZHxzZWxlY3RlZHxtdXRlZCkkLztcbi8vIHRoZXNlIGF0dHJpYnV0ZXMgZXhwZWN0IGVudW1yYXRlZCB2YWx1ZXMgb2YgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4vLyBidXQgYXJlIG5vdCBib29sZWFuIGF0dHJpYnV0ZXNcbnZhciBlbnVtZXJhdGVkQXR0clJFID0gL14oPzpkcmFnZ2FibGV8Y29udGVudGVkaXRhYmxlfHNwZWxsY2hlY2spJC87XG5cbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3Jcbi8vIGJpbmRpbmcgdi1tb2RlbCB0byBvYmplY3QgdmFsdWVzXG52YXIgbW9kZWxQcm9wcyA9IHtcbiAgdmFsdWU6ICdfdmFsdWUnLFxuICAndHJ1ZS12YWx1ZSc6ICdfdHJ1ZVZhbHVlJyxcbiAgJ2ZhbHNlLXZhbHVlJzogJ19mYWxzZVZhbHVlJ1xufTtcblxudmFyIGJpbmQkMSA9IHtcblxuICBwcmlvcml0eTogQklORCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgdmFyIHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAvLyBzaG91bGQgYmUgZGVlcCB3YXRjaCBvbiBvYmplY3QgbW9kZVxuICAgIGlmICghYXR0cikge1xuICAgICAgdGhpcy5kZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludGVycG9sYXRpb24gYmluZGluZ3NcbiAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZGVzY3JpcHRvcjtcbiAgICB2YXIgdG9rZW5zID0gZGVzY3JpcHRvci5pbnRlcnA7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgLy8gaGFuZGxlIGludGVycG9sYXRpb25zIHdpdGggb25lLXRpbWUgdG9rZW5zXG4gICAgICBpZiAoZGVzY3JpcHRvci5oYXNPbmVUaW1lKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHRva2Vuc1RvRXhwKHRva2VucywgdGhpcy5fc2NvcGUgfHwgdGhpcy52bSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWxsb3cgYmluZGluZyBvbiBuYXRpdmUgYXR0cmlidXRlc1xuICAgICAgaWYgKGRpc2FsbG93ZWRJbnRlcnBBdHRyUkUudGVzdChhdHRyKSB8fCBhdHRyID09PSAnbmFtZScgJiYgKHRhZyA9PT0gJ1BBUlRJQUwnIHx8IHRhZyA9PT0gJ1NMT1QnKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICcgKyAnYXR0cmlidXRlIGludGVycG9sYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gVnVlLmpzICcgKyAnZGlyZWN0aXZlcyBhbmQgc3BlY2lhbCBhdHRyaWJ1dGVzLicsIHRoaXMudm0pO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmF3ID0gYXR0ciArICc9XCInICsgZGVzY3JpcHRvci5yYXcgKyAnXCI6ICc7XG4gICAgICAgIC8vIHdhcm4gc3JjXG4gICAgICAgIGlmIChhdHRyID09PSAnc3JjJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzcmNcIiBhdHRyaWJ1dGUgd2lsbCBjYXVzZSAnICsgJ2EgNDA0IHJlcXVlc3QuIFVzZSB2LWJpbmQ6c3JjIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3YXJuIHN0eWxlXG4gICAgICAgIGlmIChhdHRyID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgd2FybihyYXcgKyAnaW50ZXJwb2xhdGlvbiBpbiBcInN0eWxlXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICd0aGUgYXR0cmlidXRlIHRvIGJlIGRpc2NhcmRlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gJyArICdVc2Ugdi1iaW5kOnN0eWxlIGluc3RlYWQuJywgdGhpcy52bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhdHRyID0gdGhpcy5hcmc7XG4gICAgaWYgKHRoaXMuYXJnKSB7XG4gICAgICB0aGlzLmhhbmRsZVNpbmdsZShhdHRyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlIHx8IHt9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gc2hhcmUgb2JqZWN0IGhhbmRsZXIgd2l0aCB2LWJpbmQ6Y2xhc3NcbiAgaGFuZGxlT2JqZWN0OiBzdHlsZS5oYW5kbGVPYmplY3QsXG5cbiAgaGFuZGxlU2luZ2xlOiBmdW5jdGlvbiBoYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBpbnRlcnAgPSB0aGlzLmRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgYXR0ciA9IGNhbWVsaXplKGF0dHIpO1xuICAgIH1cbiAgICBpZiAoIWludGVycCAmJiBhdHRyV2l0aFByb3BzUkUudGVzdChhdHRyKSAmJiBhdHRyIGluIGVsKSB7XG4gICAgICB2YXIgYXR0clZhbHVlID0gYXR0ciA9PT0gJ3ZhbHVlJyA/IHZhbHVlID09IG51bGwgLy8gSUU5IHdpbGwgc2V0IGlucHV0LnZhbHVlIHRvIFwibnVsbFwiIGZvciBudWxsLi4uXG4gICAgICA/ICcnIDogdmFsdWUgOiB2YWx1ZTtcblxuICAgICAgaWYgKGVsW2F0dHJdICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgZWxbYXR0cl0gPSBhdHRyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdO1xuICAgIGlmICghaW50ZXJwICYmIG1vZGVsUHJvcCkge1xuICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgLy8gdXBkYXRlIHYtbW9kZWwgaWYgcHJlc2VudFxuICAgICAgdmFyIG1vZGVsID0gZWwuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzZXQgdmFsdWUgYXR0cmlidXRlIGZvciB0ZXh0YXJlYVxuICAgIGlmIChhdHRyID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmIChlbnVtZXJhdGVkQXR0clJFLnRlc3QoYXR0cikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlZGdlIGNhc2UgIzE5NjA6XG4gICAgICAgIC8vIGNsYXNzIGludGVycG9sYXRpb24gc2hvdWxkIG5vdCBvdmVyd3JpdGUgVnVlIHRyYW5zaXRpb24gY2xhc3NcbiAgICAgICAgaWYgKGVsLl9fdl90cmFucykge1xuICAgICAgICAgIHZhbHVlICs9ICcgJyArIGVsLl9fdl90cmFucy5pZCArICctdHJhbnNpdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2xhc3MoZWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoeGxpbmtSRS50ZXN0KGF0dHIpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGF0dHIsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsID0ge1xuXG4gIHByaW9yaXR5OiBFTCxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5hcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5pZCA9IGNhbWVsaXplKHRoaXMuYXJnKTtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChoYXNPd24ocmVmcywgaWQpKSB7XG4gICAgICByZWZzW2lkXSA9IHRoaXMuZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHJlZnMsIGlkLCB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdmFyIHJlZnMgPSAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJGVscztcbiAgICBpZiAocmVmc1t0aGlzLmlkXSA9PT0gdGhpcy5lbCkge1xuICAgICAgcmVmc1t0aGlzLmlkXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVmID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1yZWY6JyArIHRoaXMuYXJnICsgJyBtdXN0IGJlIHVzZWQgb24gYSBjaGlsZCAnICsgJ2NvbXBvbmVudC4gRm91bmQgb24gPCcgKyB0aGlzLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+LicsIHRoaXMudm0pO1xuICB9XG59O1xuXG52YXIgY2xvYWsgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB0aGlzLnZtLiRvbmNlKCdwcmUtaG9vazpjb21waWxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBtdXN0IGV4cG9ydCBwbGFpbiBvYmplY3RcbnZhciBkaXJlY3RpdmVzID0ge1xuICB0ZXh0OiB0ZXh0JDEsXG4gIGh0bWw6IGh0bWwsXG4gICdmb3InOiB2Rm9yLFxuICAnaWYnOiB2SWYsXG4gIHNob3c6IHNob3csXG4gIG1vZGVsOiBtb2RlbCxcbiAgb246IG9uJDEsXG4gIGJpbmQ6IGJpbmQkMSxcbiAgZWw6IGVsLFxuICByZWY6IHJlZixcbiAgY2xvYWs6IGNsb2FrXG59O1xuXG52YXIgdkNsYXNzID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0Q2xhc3ModmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENsYXNzKG5vcm1hbGl6ZSQxKHZhbHVlKSk7XG4gICAgfVxuICB9LFxuXG4gIHNldENsYXNzOiBmdW5jdGlvbiBzZXRDbGFzcyh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYW51cCh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSB2YWx1ZVtpXTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgYXBwbHkodGhpcy5lbCwgdmFsLCBhZGRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJldktleXMgPSB2YWx1ZTtcbiAgfSxcblxuICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKHZhbHVlKSB7XG4gICAgdmFyIHByZXZLZXlzID0gdGhpcy5wcmV2S2V5cztcbiAgICBpZiAoIXByZXZLZXlzKSByZXR1cm47XG4gICAgdmFyIGkgPSBwcmV2S2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGtleSA9IHByZXZLZXlzW2ldO1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIGFwcGx5KHRoaXMuZWwsIGtleSwgcmVtb3ZlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzIChwb3RlbnRpYWxseSBjb250YWluaW5nIG9iamVjdHMpXG4gKiBpbnRvIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXk8U3RyaW5nfE9iamVjdD59IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheTxTdHJpbmc+fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSQxKHZhbHVlKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBfa2V5ID0gdmFsdWVbaV07XG4gICAgICBpZiAoX2tleSkge1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzLnB1c2goX2tleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBfa2V5KSB7XG4gICAgICAgICAgICBpZiAoX2tleVtrXSkgcmVzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGNsYXNzL2NsYXNzZXMgb24gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGNsYXNzIG5hbWUuIFRoaXMgbWF5IG9yIG1heSBub3RcbiAqICAgICAgICAgICAgICAgICAgICAgY29udGFpbiBhIHNwYWNlIGNoYXJhY3RlciwgaW4gc3VjaCBhXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2UnbGwgZGVhbCB3aXRoIG11bHRpcGxlIGNsYXNzXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWVzIGF0IG9uY2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIGFwcGx5KGVsLCBrZXksIGZuKSB7XG4gIGtleSA9IGtleS50cmltKCk7XG4gIGlmIChrZXkuaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIGZuKGVsLCBrZXkpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUga2V5IGNvbnRhaW5zIG9uZSBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMuXG4gIC8vIFNpbmNlIGEgY2xhc3MgbmFtZSBkb2Vzbid0IGFjY2VwdCBzdWNoIGNoYXJhY3RlcnMsIHdlXG4gIC8vIHRyZWF0IGl0IGFzIG11bHRpcGxlIGNsYXNzZXMuXG4gIHZhciBrZXlzID0ga2V5LnNwbGl0KC9cXHMrLyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmbihlbCwga2V5c1tpXSk7XG4gIH1cbn1cblxudmFyIGNvbXBvbmVudCA9IHtcblxuICBwcmlvcml0eTogQ09NUE9ORU5ULFxuXG4gIHBhcmFtczogWydrZWVwLWFsaXZlJywgJ3RyYW5zaXRpb24tbW9kZScsICdpbmxpbmUtdGVtcGxhdGUnXSxcblxuICAvKipcbiAgICogU2V0dXAuIFR3byBwb3NzaWJsZSB1c2FnZXM6XG4gICAqXG4gICAqIC0gc3RhdGljOlxuICAgKiAgIDxjb21wPiBvciA8ZGl2IHYtY29tcG9uZW50PVwiY29tcFwiPlxuICAgKlxuICAgKiAtIGR5bmFtaWM6XG4gICAqICAgPGNvbXBvbmVudCA6aXM9XCJ2aWV3XCI+XG4gICAqL1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgaWYgKCF0aGlzLmVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGtlZXAtYWxpdmUgY2FjaGVcbiAgICAgIHRoaXMua2VlcEFsaXZlID0gdGhpcy5wYXJhbXMua2VlcEFsaXZlO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZVxuICAgICAgaWYgKHRoaXMucGFyYW1zLmlubGluZVRlbXBsYXRlKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgaW5saW5lIHRlbXBsYXRlIGFzIGEgRG9jdW1lbnRGcmFnbWVudFxuICAgICAgICB0aGlzLmlubGluZVRlbXBsYXRlID0gZXh0cmFjdENvbnRlbnQodGhpcy5lbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBjb21wb25lbnQgcmVzb2x1dGlvbiByZWxhdGVkIHN0YXRlXG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IHRoaXMuQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIC8vIHRyYW5zaXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHMgPSAwO1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbENiID0gbnVsbDtcbiAgICAgIC8vIGNyZWF0ZSBhIHJlZiBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWNvbXBvbmVudCcpO1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgICAvLyByZW1vdmUgaXMgYXR0cmlidXRlLlxuICAgICAgLy8gdGhpcyBpcyByZW1vdmVkIGR1cmluZyBjb21waWxhdGlvbiwgYnV0IGJlY2F1c2UgY29tcGlsYXRpb24gaXNcbiAgICAgIC8vIGNhY2hlZCwgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVzZWQgZWxzZXdoZXJlIHRoaXMgYXR0cmlidXRlXG4gICAgICAvLyB3aWxsIHJlbWFpbiBhdCBsaW5rIHRpbWUuXG4gICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCc6aXMnKTtcbiAgICAgIC8vIHJlbW92ZSByZWYsIHNhbWUgYXMgYWJvdmVcbiAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCd2LXJlZjonICsgaHlwaGVuYXRlKHRoaXMuZGVzY3JpcHRvci5yZWYpKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXRpYywgYnVpbGQgcmlnaHQgbm93LlxuICAgICAgaWYgKHRoaXMubGl0ZXJhbCkge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudCh0aGlzLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2Nhbm5vdCBtb3VudCBjb21wb25lbnQgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiICcgKyAnb24gYWxyZWFkeSBtb3VudGVkIGVsZW1lbnQ6ICcgKyB0aGlzLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1YmxpYyB1cGRhdGUsIGNhbGxlZCBieSB0aGUgd2F0Y2hlciBpbiB0aGUgZHluYW1pY1xuICAgKiBsaXRlcmFsIHNjZW5hcmlvLCBlLmcuIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5saXRlcmFsKSB7XG4gICAgICB0aGlzLnNldENvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggZHluYW1pYyBjb21wb25lbnRzLiBNYXkgcmVzb2x2ZSB0aGUgY29tcG9uZW50XG4gICAqIGFzeW5jaHJvbm91c2x5LCBhbmQgcGVyZm9ybSB0cmFuc2l0aW9uIGJhc2VkIG9uXG4gICAqIHNwZWNpZmllZCB0cmFuc2l0aW9uIG1vZGUuIEFjY2VwdHMgYSBmZXcgYWRkaXRpb25hbFxuICAgKiBhcmd1bWVudHMgc3BlY2lmaWNhbGx5IGZvciB2dWUtcm91dGVyLlxuICAgKlxuICAgKiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGZ1bGwgdHJhbnNpdGlvbiBpc1xuICAgKiBmaW5pc2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQodmFsdWUsIGNiKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlUGVuZGluZygpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGN1cnJlbnRcbiAgICAgIHRoaXMudW5idWlsZCh0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRWTSwgY2IpO1xuICAgICAgdGhpcy5jaGlsZFZNID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYubW91bnRDb21wb25lbnQoY2IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbiAgICogdGhlIGNoaWxkIHZtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVzb2x2ZUNvbXBvbmVudDogZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBzZWxmLkNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQub3B0aW9ucy5uYW1lIHx8ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBudWxsKTtcbiAgICAgIHNlbGYuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgICB0aGlzLnZtLl9yZXNvbHZlQ29tcG9uZW50KHZhbHVlLCB0aGlzLnBlbmRpbmdDb21wb25lbnRDYik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgY3VycmVudCBjb25zdHJ1Y3RvciBhbmRcbiAgICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGRvZXNuJ3QgY2FyZVxuICAgKiB3aGV0aGVyIHRoZSBuZXcgY29tcG9uZW50IGFuZCB0aGUgb2xkIG9uZSBhcmUgYWN0dWFsbHlcbiAgICogdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGNiKSB7XG4gICAgLy8gYWN0dWFsIG1vdW50XG4gICAgdGhpcy51bmJ1aWxkKHRydWUpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWN0aXZhdGVIb29rcyA9IHRoaXMuQ29tcG9uZW50Lm9wdGlvbnMuYWN0aXZhdGU7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgdmFyIG5ld0NvbXBvbmVudCA9IHRoaXMuYnVpbGQoKTtcbiAgICBpZiAoYWN0aXZhdGVIb29rcyAmJiAhY2FjaGVkKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICBjYWxsQWN0aXZhdGVIb29rcyhhY3RpdmF0ZUhvb2tzLCBuZXdDb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYud2FpdGluZ0ZvciAhPT0gbmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBuZXdDb21wb25lbnQuX3VwZGF0ZVJlZigpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZXMgb3IgdW5iaW5kcyBiZWZvcmUgYW4gYXN5bmNcbiAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICogcGVuZGluZyBjYWxsYmFjay5cbiAgICovXG5cbiAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb21wb25lbnRDYikge1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZXh0cmFPcHRpb25zKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiB0aGlzLkNvbXBvbmVudE5hbWUsXG4gICAgICAgIGVsOiBjbG9uZU5vZGUodGhpcy5lbCksXG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYWRkIHRoZSBjaGlsZCB3aXRoIGNvcnJlY3QgcGFyZW50XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGl0cyBwYXJlbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgcGFyZW50OiB0aGlzLl9ob3N0IHx8IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIG5vIGlubGluZS10ZW1wbGF0ZSwgdGhlbiB0aGUgY29tcGlsZWRcbiAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgX2xpbmtlckNhY2hhYmxlOiAhdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgX3JlZjogdGhpcy5kZXNjcmlwdG9yLnJlZixcbiAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfaXNSb3V0ZXJWaWV3OiB0aGlzLl9pc1JvdXRlclZpZXcsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICAgICAgX2NvbnRleHQ6IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgLy8gcGFzcyBpbiB0aGUgb3duZXIgZnJhZ21lbnQgb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgIC8vIHRyYWNrIG9mIGl0cyBjb250YWluZWQgY29tcG9uZW50cyBpbiBvcmRlciB0b1xuICAgICAgICAvLyBjYWxsIGF0dGFjaC9kZXRhY2ggaG9va3MgZm9yIHRoZW0uXG4gICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICB9O1xuICAgICAgLy8gZXh0cmEgb3B0aW9uc1xuICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXSA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndHJhbnNpdGlvbicpICYmIGNoaWxkLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ2V0IGEgY2FjaGVkIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZ2V0Q2FjaGVkOiBmdW5jdGlvbiBnZXRDYWNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcEFsaXZlICYmIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogVGVhcmRvd24gdGhlIGN1cnJlbnQgY2hpbGQsIGJ1dCBkZWZlcnMgY2xlYW51cCBzb1xuICAgKiB0aGF0IHdlIGNhbiBzZXBhcmF0ZSB0aGUgZGVzdHJveSBhbmQgcmVtb3ZhbCBzdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWZlclxuICAgKi9cblxuICB1bmJ1aWxkOiBmdW5jdGlvbiB1bmJ1aWxkKGRlZmVyKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0Zvcikge1xuICAgICAgaWYgKCF0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICBpZiAoIWNoaWxkIHx8IHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICBjaGlsZC5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBjaGlsZC5fdXBkYXRlUmVmKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICogdGhlIGNsZWFudXAgYWZ0ZXIgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQsIGNiKSB7XG4gICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgLy8gd2UgbWF5IGhhdmUgYSBjb21wb25lbnQgc3dpdGNoIHdoZW4gYSBwcmV2aW91c1xuICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb25seSBvbmUgbGFzdGVzdCBpbnNlcnRpb24gY2JcbiAgICAgIC8vIHdoZW4gdGhlIGV4aXN0aW5nIHRyYW5zaXRpb24gZmluaXNoZXMuICgjMTExOSlcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFscy0tO1xuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IoKTtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0dWFsbHkgc3dhcCB0aGUgY29tcG9uZW50cywgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiB0cmFuc2l0aW9uIG1vZGUuIERlZmF1bHRzIHRvIHNpbXVsdGFuZW91cy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24odGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAvLyBmb3IgZGV2dG9vbCBpbnNwZWN0aW9uXG4gICAgaWYgKGN1cnJlbnQpIGN1cnJlbnQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZFZNID0gdGFyZ2V0O1xuICAgIHN3aXRjaCAoc2VsZi5wYXJhbXMudHJhbnNpdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgJ2luLW91dCc6XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvdXQtaW4nOlxuICAgICAgICBzZWxmLnJlbW92ZShjdXJyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LiRiZWZvcmUoc2VsZi5hbmNob3IsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbmJpbmQuXG4gICAqL1xuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICAvLyBEbyBub3QgZGVmZXIgY2xlYW51cCB3aGVuIHVuYmluZGluZ1xuICAgIHRoaXMudW5idWlsZCgpO1xuICAgIC8vIGRlc3Ryb3kgYWxsIGtlZXAtYWxpdmUgY2FjaGVkIGluc3RhbmNlc1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0uJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFjdGl2YXRlIGhvb2tzIGluIG9yZGVyIChhc3luY2hyb25vdXMpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaG9va3NcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVIb29rcyhob29rcywgdm0sIGNiKSB7XG4gIHZhciB0b3RhbCA9IGhvb2tzLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIGhvb2tzWzBdLmNhbGwodm0sIG5leHQpO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICgrK2NhbGxlZCA+PSB0b3RhbCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3NbY2FsbGVkXS5jYWxsKHZtLCBuZXh0KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BCaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG52YXIgZW1wdHkgPSB7fTtcblxuLy8gcmVnZXhlc1xudmFyIGlkZW50UkUkMSA9IC9eWyRfYS16QS1aXStbXFx3JF0qJC87XG52YXIgc2V0dGFibGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKFxcLltBLVphLXpfJF1bXFx3JF0qfFxcW1teXFxbXFxdXStcXF0pKiQvO1xuXG4vKipcbiAqIENvbXBpbGUgcHJvcHMgb24gYSByb290IGVsZW1lbnQgYW5kIHJldHVyblxuICogYSBwcm9wcyBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtBcnJheX0gcHJvcE9wdGlvbnNcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHJldHVybiB7RnVuY3Rpb259IHByb3BzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVByb3BzKGVsLCBwcm9wT3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BPcHRpb25zKTtcbiAgdmFyIGkgPSBuYW1lcy5sZW5ndGg7XG4gIHZhciBvcHRpb25zLCBuYW1lLCBhdHRyLCB2YWx1ZSwgcGF0aCwgcGFyc2VkLCBwcm9wO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgIG9wdGlvbnMgPSBwcm9wT3B0aW9uc1tuYW1lXSB8fCBlbXB0eTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICckZGF0YScpIHtcbiAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgJGRhdGEgYXMgcHJvcC4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgIGlmICghaWRlbnRSRSQxLnRlc3QocGF0aCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nLCB2bSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9wID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgbW9kZTogcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZLFxuICAgICAgcmF3OiBudWxsXG4gICAgfTtcblxuICAgIGF0dHIgPSBoeXBoZW5hdGUobmFtZSk7XG4gICAgLy8gZmlyc3QgY2hlY2sgZHluYW1pYyB2ZXJzaW9uXG4gICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyKSkgPT09IG51bGwpIHtcbiAgICAgIGlmICgodmFsdWUgPSBnZXRCaW5kQXR0cihlbCwgYXR0ciArICcuc3luYycpKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVk7XG4gICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5vbmNlJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGFzIGR5bmFtaWMgYmluZGluZyFcbiAgICAgIHByb3AucmF3ID0gdmFsdWU7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHBhcnNlZC5leHByZXNzaW9uO1xuICAgICAgcHJvcC5maWx0ZXJzID0gcGFyc2VkLmZpbHRlcnM7XG4gICAgICAvLyBjaGVjayBiaW5kaW5nIHR5cGVcbiAgICAgIGlmIChpc0xpdGVyYWwodmFsdWUpICYmICFwYXJzZWQuZmlsdGVycykge1xuICAgICAgICAvLyBmb3IgZXhwcmVzc2lvbnMgY29udGFpbmluZyBsaXRlcmFsIG51bWJlcnMgYW5kXG4gICAgICAgIC8vIGJvb2xlYW5zLCB0aGVyZSdzIG5vIG5lZWQgdG8gc2V0dXAgYSBwcm9wIGJpbmRpbmcsXG4gICAgICAgIC8vIHNvIHdlIGNhbiBvcHRpbWl6ZSB0aGVtIGFzIGEgb25lLXRpbWUgc2V0LlxuICAgICAgICBwcm9wLm9wdGltaXplZExpdGVyYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgLy8gY2hlY2sgbm9uLXNldHRhYmxlIHBhdGggZm9yIHR3by13YXkgYmluZGluZ3NcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvcC5tb2RlID09PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkgJiYgIXNldHRhYmxlUGF0aFJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfV0FZO1xuICAgICAgICAgIHdhcm4oJ0Nhbm5vdCBiaW5kIHR3by13YXkgcHJvcCB3aXRoIG5vbi1zZXR0YWJsZSAnICsgJ3BhcmVudCBwYXRoOiAnICsgdmFsdWUsIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5wYXJlbnRQYXRoID0gdmFsdWU7XG5cbiAgICAgIC8vIHdhcm4gcmVxdWlyZWQgdHdvLXdheVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy50d29XYXkgJiYgcHJvcC5tb2RlICE9PSBwcm9wQmluZGluZ01vZGVzLlRXT19XQVkpIHtcbiAgICAgICAgd2FybignUHJvcCBcIicgKyBuYW1lICsgJ1wiIGV4cGVjdHMgYSB0d28td2F5IGJpbmRpbmcgdHlwZS4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRBdHRyKGVsLCBhdHRyKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBsaXRlcmFsIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gY2hlY2sgcG9zc2libGUgY2FtZWxDYXNlIHByb3AgdXNhZ2VcbiAgICAgIHZhciBsb3dlckNhc2VOYW1lID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAvW0EtWlxcLV0vLnRlc3QobmFtZSkgJiYgKGVsLmdldEF0dHJpYnV0ZShsb3dlckNhc2VOYW1lKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSkgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUpIHx8IGVsLmdldEF0dHJpYnV0ZSgnOicgKyBsb3dlckNhc2VOYW1lICsgJy5vbmNlJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd2LWJpbmQ6JyArIGxvd2VyQ2FzZU5hbWUgKyAnLm9uY2UnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJzonICsgbG93ZXJDYXNlTmFtZSArICcuc3luYycpIHx8IGVsLmdldEF0dHJpYnV0ZSgndi1iaW5kOicgKyBsb3dlckNhc2VOYW1lICsgJy5zeW5jJykpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm4oJ1Bvc3NpYmxlIHVzYWdlIGVycm9yIGZvciBwcm9wIGAnICsgbG93ZXJDYXNlTmFtZSArICdgIC0gJyArICdkaWQgeW91IG1lYW4gYCcgKyBhdHRyICsgJ2A/IEhUTUwgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgcmVtZW1iZXIgdG8gdXNlICcgKyAna2ViYWItY2FzZSBmb3IgcHJvcHMgaW4gdGVtcGxhdGVzLicsIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xuICAgICAgICAvLyB3YXJuIG1pc3NpbmcgcmVxdWlyZWRcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiAnICsgbmFtZSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHByb3BzIHRvIGEgdm0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VQcm9wc0xpbmtGbihwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJvcHNMaW5rRm4odm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9O1xuICAgIHZhciBpbmxpbmVQcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzRGF0YTtcbiAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB2YXIgcHJvcCwgcGF0aCwgb3B0aW9ucywgdmFsdWUsIHJhdztcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICByYXcgPSBwcm9wLnJhdztcbiAgICAgIHBhdGggPSBwcm9wLnBhdGg7XG4gICAgICBvcHRpb25zID0gcHJvcC5vcHRpb25zO1xuICAgICAgdm0uX3Byb3BzW3BhdGhdID0gcHJvcDtcbiAgICAgIGlmIChpbmxpbmVQcm9wcyAmJiBoYXNPd24oaW5saW5lUHJvcHMsIHBhdGgpKSB7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCBpbmxpbmVQcm9wc1twYXRoXSk7XG4gICAgICB9aWYgKHJhdyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIGFic2VudCBwcm9wXG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgLy8gZHluYW1pYyBwcm9wXG4gICAgICAgIGlmIChwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuT05FX1RJTUUpIHtcbiAgICAgICAgICAvLyBvbmUgdGltZSBiaW5kaW5nXG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0uX2NvbnRleHQgfHwgdm0pLiRnZXQocHJvcC5wYXJlbnRQYXRoKTtcbiAgICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2bS5fY29udGV4dCkge1xuICAgICAgICAgICAgLy8gZHluYW1pYyBiaW5kaW5nXG4gICAgICAgICAgICB2bS5fYmluZERpcih7XG4gICAgICAgICAgICAgIG5hbWU6ICdwcm9wJyxcbiAgICAgICAgICAgICAgZGVmOiBwcm9wRGVmLFxuICAgICAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgICAgICB9LCBudWxsLCBudWxsLCBzY29wZSk7IC8vIGVsLCBob3N0LCBzY29wZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2VcbiAgICAgICAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZtLiRnZXQocHJvcC5wYXJlbnRQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcC5vcHRpbWl6ZWRMaXRlcmFsKSB7XG4gICAgICAgIC8vIG9wdGltaXplZCBsaXRlcmFsLCBjYXN0IGl0IGFuZCBqdXN0IHNldCBvbmNlXG4gICAgICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwUXVvdGVzKHJhdyk7XG4gICAgICAgIHZhbHVlID0gc3RyaXBwZWQgPT09IHJhdyA/IHRvQm9vbGVhbih0b051bWJlcihyYXcpKSA6IHN0cmlwcGVkO1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwsIGJ1dCB3ZSBuZWVkIHRvIGNhdGVyIGZvclxuICAgICAgICAvLyBCb29sZWFuIHByb3BzIHdpdGggbm8gdmFsdWUsIG9yIHdpdGggc2FtZVxuICAgICAgICAvLyBsaXRlcmFsIHZhbHVlIChlLmcuIGRpc2FibGVkPVwiZGlzYWJsZWRcIilcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtbG9hZGVyL2lzc3Vlcy8xODJcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnR5cGUgPT09IEJvb2xlYW4gJiYgKHJhdyA9PT0gJycgfHwgcmF3ID09PSBoeXBoZW5hdGUocHJvcC5uYW1lKSkgPyB0cnVlIDogcmF3O1xuICAgICAgICBpbml0UHJvcCh2bSwgcHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcHJvcCB3aXRoIGEgcmF3VmFsdWUsIGFwcGx5aW5nIG5lY2Vzc2FyeSBjb2Vyc2lvbnMsXG4gKiBkZWZhdWx0IHZhbHVlcyAmIGFzc2VydGlvbnMgYW5kIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIHdpdGhcbiAqIHByb2Nlc3NlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHJhd1ZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NQcm9wVmFsdWUodm0sIHByb3AsIHJhd1ZhbHVlLCBmbikge1xuICB2YXIgaXNTaW1wbGUgPSBwcm9wLmR5bmFtaWMgJiYgaXNTaW1wbGVQYXRoKHByb3AucGFyZW50UGF0aCk7XG4gIHZhciB2YWx1ZSA9IHJhd1ZhbHVlO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCk7XG4gIH1cbiAgdmFsdWUgPSBjb2VyY2VQcm9wKHByb3AsIHZhbHVlLCB2bSk7XG4gIHZhciBjb2VyY2VkID0gdmFsdWUgIT09IHJhd1ZhbHVlO1xuICBpZiAoIWFzc2VydFByb3AocHJvcCwgdmFsdWUsIHZtKSkge1xuICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1NpbXBsZSAmJiAhY29lcmNlZCkge1xuICAgIHdpdGhvdXRDb252ZXJzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKHZhbHVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmbih2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wJ3MgaW5pdGlhbCB2YWx1ZSBvbiBhIHZtIGFuZCBpdHMgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICBwcm9jZXNzUHJvcFZhbHVlKHZtLCBwcm9wLCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sIHByb3AucGF0aCwgdmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBwcm9wJ3MgdmFsdWUgb24gYSB2bS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlUHJvcCh2bSwgcHJvcCwgdmFsdWUpIHtcbiAgcHJvY2Vzc1Byb3BWYWx1ZSh2bSwgcHJvcCwgdmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZtW3Byb3AucGF0aF0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3ApIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgaWYgKCFoYXNPd24ob3B0aW9ucywgJ2RlZmF1bHQnKSkge1xuICAgIC8vIGFic2VudCBib29sZWFuIHZhbHVlIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgcmV0dXJuIG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkZWYgPSBvcHRpb25zWydkZWZhdWx0J107XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6ICcgKyAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJywgdm0pO1xuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMudHlwZSAhPT0gRnVuY3Rpb24gPyBkZWYuY2FsbCh2bSkgOiBkZWY7XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIHZhbHVlLCB2bSkge1xuICBpZiAoIXByb3Aub3B0aW9ucy5yZXF1aXJlZCAmJiAoIC8vIG5vbi1yZXF1aXJlZFxuICBwcm9wLnJhdyA9PT0gbnVsbCB8fCAvLyBhYnNjZW50XG4gIHZhbHVlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCIuJyArICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGZvcm1hdFR5cGUpLmpvaW4oJywgJykgKyAnLCBnb3QgJyArIGZvcm1hdFZhbHVlKHZhbHVlKSArICcuJywgdm0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IG9wdGlvbnMudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgcHJvcC5uYW1lICsgJ1wiLicsIHZtKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRm9yY2UgcGFyc2luZyB2YWx1ZSB3aXRoIGNvZXJjZSBvcHRpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZnVuY3Rpb24gY29lcmNlUHJvcChwcm9wLCB2YWx1ZSwgdm0pIHtcbiAgdmFyIGNvZXJjZSA9IHByb3Aub3B0aW9ucy5jb2VyY2U7XG4gIGlmICghY29lcmNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGNvZXJjZSBmb3IgcHJvcCBcIicgKyBwcm9wLm5hbWUgKyAnXCI6IGV4cGVjdGVkIGZ1bmN0aW9uLCBnb3QgJyArIHR5cGVvZiBjb2VyY2UgKyAnLicsIHZtKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZTtcbiAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ251bWJlcic7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBCb29sZWFuKSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRnVuY3Rpb24pIHtcbiAgICBleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nO1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gT2JqZWN0KSB7XG4gICAgZXhwZWN0ZWRUeXBlID0gJ29iamVjdCc7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBBcnJheSkge1xuICAgIGV4cGVjdGVkVHlwZSA9ICdhcnJheSc7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9O1xufVxuXG4vKipcbiAqIEZvcm1hdCB0eXBlIGZvciBvdXRwdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA/IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpIDogJ2N1c3RvbSB0eXBlJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59XG5cbnZhciBiaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG5cbnZhciBwcm9wRGVmID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy52bTtcbiAgICB2YXIgcGFyZW50ID0gY2hpbGQuX2NvbnRleHQ7XG4gICAgLy8gcGFzc2VkIGluIGZyb20gY29tcGlsZXIgZGlyZWN0bHlcbiAgICB2YXIgcHJvcCA9IHRoaXMuZGVzY3JpcHRvci5wcm9wO1xuICAgIHZhciBjaGlsZEtleSA9IHByb3AucGF0aDtcbiAgICB2YXIgcGFyZW50S2V5ID0gcHJvcC5wYXJlbnRQYXRoO1xuICAgIHZhciB0d29XYXkgPSBwcm9wLm1vZGUgPT09IGJpbmRpbmdNb2Rlcy5UV09fV0FZO1xuXG4gICAgdmFyIHBhcmVudFdhdGNoZXIgPSB0aGlzLnBhcmVudFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihwYXJlbnQsIHBhcmVudEtleSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdXBkYXRlUHJvcChjaGlsZCwgcHJvcCwgdmFsKTtcbiAgICB9LCB7XG4gICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgIGZpbHRlcnM6IHByb3AuZmlsdGVycyxcbiAgICAgIC8vIGltcG9ydGFudDogcHJvcHMgbmVlZCB0byBiZSBvYnNlcnZlZCBvbiB0aGVcbiAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIGluaXRQcm9wKGNoaWxkLCBwcm9wLCBwYXJlbnRXYXRjaGVyLnZhbHVlKTtcblxuICAgIC8vIHNldHVwIHR3by13YXkgYmluZGluZ1xuICAgIGlmICh0d29XYXkpIHtcbiAgICAgIC8vIGltcG9ydGFudDogZGVmZXIgdGhlIGNoaWxkIHdhdGNoZXIgY3JlYXRpb24gdW50aWxcbiAgICAgIC8vIHRoZSBjcmVhdGVkIGhvb2sgKGFmdGVyIGRhdGEgb2JzZXJ2YXRpb24pXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kb25jZSgncHJlLWhvb2s6Y3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jaGlsZFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjaGlsZCwgY2hpbGRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN5bmMgdXB3YXJkIGJlZm9yZSBwYXJlbnQgc3luYyBkb3duLlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgLy8gbXV0YXRlcyBhIHByb3AgYXJyYXksIHRoZW4gcmVwbGFjZXMgaXQuICgjMTY4MylcbiAgICAgICAgICBzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpO1xuICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgdGhpcy5jaGlsZFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSQxID0gW107XG52YXIgcXVldWVkID0gZmFsc2U7XG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICBxdWV1ZSQxLnB1c2goam9iKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIHRoZSBxdWV1ZSwgYW5kIGRvIG9uZSBmb3JjZWQgcmVmbG93IGJlZm9yZVxuICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWUkMVtpXSgpO1xuICB9XG4gIHF1ZXVlJDEgPSBbXTtcbiAgcXVldWVkID0gZmFsc2U7XG4gIC8vIGR1bW15IHJldHVybiwgc28ganMgbGludGVycyBkb24ndCBjb21wbGFpbiBhYm91dFxuICAvLyB1bnVzZWQgdmFyaWFibGUgZlxuICByZXR1cm4gZjtcbn1cblxudmFyIFRZUEVfVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xudmFyIHRyYW5zRHVyYXRpb25Qcm9wID0gdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nO1xudmFyIGFuaW1EdXJhdGlvblByb3AgPSBhbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcblxuLyoqXG4gKiBJZiBhIGp1c3QtZW50ZXJlZCBlbGVtZW50IGlzIGFwcGxpZWQgdGhlXG4gKiBsZWF2ZSBjbGFzcyB3aGlsZSBpdHMgZW50ZXIgdHJhbnNpdGlvbiBoYXNuJ3Qgc3RhcnRlZCB5ZXQsXG4gKiBhbmQgdGhlIHRyYW5zaXRpb25lZCBwcm9wZXJ0eSBoYXMgdGhlIHNhbWUgdmFsdWUgZm9yIGJvdGhcbiAqIGVudGVyL2xlYXZlLCB0aGVuIHRoZSBsZWF2ZSB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZCBhbmRcbiAqIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiBUaGlzIGZ1bmN0aW9uIGVuc3VyZXNcbiAqIGl0cyBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGhhcyBzdGFydGVkXG4gKiBieSB3YWl0aW5nIGZvciBkb3VibGUgcmFmLlxuICpcbiAqIEl0IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCBvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCBDU1NcbiAqIHRyYW5zaXRpb25zIGJ1dCBub3QgcmFmIChlLmcuIEFuZHJvaWQgNC4yIGJyb3dzZXIpIC0gc2luY2VcbiAqIHRoZXNlIGVudmlyb25tZW50cyBhcmUgdXN1YWxseSBzbG93LCB3ZSBhcmUgZ2l2aW5nIGl0IGFcbiAqIHJlbGF0aXZlbHkgbGFyZ2UgdGltZW91dC5cbiAqL1xuXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgd2FpdEZvclRyYW5zaXRpb25TdGFydCA9IHJhZlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbj8gZnVuY3Rpb24gKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHNldFRpbWVvdXQoZm4sIDUwKTtcbn07XG5cbi8qKlxuICogQSBUcmFuc2l0aW9uIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgc3RhdGUgYW5kIGxvZ2ljXG4gKiBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBob29rc1xuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdm0pIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuZW50ZXJDbGFzcyA9IGhvb2tzICYmIGhvb2tzLmVudGVyQ2xhc3MgfHwgaWQgKyAnLWVudGVyJztcbiAgdGhpcy5sZWF2ZUNsYXNzID0gaG9va3MgJiYgaG9va3MubGVhdmVDbGFzcyB8fCBpZCArICctbGVhdmUnO1xuICB0aGlzLmhvb2tzID0gaG9va3M7XG4gIHRoaXMudm0gPSB2bTtcbiAgLy8gYXN5bmMgc3RhdGVcbiAgdGhpcy5wZW5kaW5nQ3NzRXZlbnQgPSB0aGlzLnBlbmRpbmdDc3NDYiA9IHRoaXMuY2FuY2VsID0gdGhpcy5wZW5kaW5nSnNDYiA9IHRoaXMub3AgPSB0aGlzLmNiID0gbnVsbDtcbiAgdGhpcy5qdXN0RW50ZXJlZCA9IGZhbHNlO1xuICB0aGlzLmVudGVyZWQgPSB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcbiAgLy8gY2hlY2sgY3NzIHRyYW5zaXRpb24gdHlwZVxuICB0aGlzLnR5cGUgPSBob29rcyAmJiBob29rcy50eXBlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gVFlQRV9UUkFOU0lUSU9OICYmIHRoaXMudHlwZSAhPT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHdhcm4oJ2ludmFsaWQgQ1NTIHRyYW5zaXRpb24gdHlwZSBmb3IgdHJhbnNpdGlvbj1cIicgKyB0aGlzLmlkICsgJ1wiOiAnICsgdGhpcy50eXBlLCB2bSk7XG4gICAgfVxuICB9XG4gIC8vIGJpbmRcbiAgdmFyIHNlbGYgPSB0aGlzO1snZW50ZXJOZXh0VGljaycsICdlbnRlckRvbmUnLCAnbGVhdmVOZXh0VGljaycsICdsZWF2ZURvbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgc2VsZlttXSA9IGJpbmQoc2VsZlttXSwgc2VsZik7XG4gIH0pO1xufVxuXG52YXIgcCQxID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbi8qKlxuICogU3RhcnQgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBlbnRlciB0cmFuc2l0aW9uIHRyaWdnZXJlZFxuICogMi4gY2FsbCBiZWZvcmVFbnRlciBob29rXG4gKiAzLiBhZGQgZW50ZXIgY2xhc3NcbiAqIDQuIGluc2VydC9zaG93IGVsZW1lbnRcbiAqIDUuIGNhbGwgZW50ZXIgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDYuIHJlZmxvd1xuICogNy4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uOlxuICogICAgICAgIHJlbW92ZSBjbGFzcyBub3csIHdhaXQgZm9yIHRyYW5zaXRpb25lbmQsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBhbmltYXRpb25lbmQsIHJlbW92ZSBjbGFzcyxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBub3cgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDguIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyRW50ZXIgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIGluc2VydC9zaG93IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmVudGVyID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlRW50ZXInKTtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICBvcCgpO1xuICB0aGlzLmVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignZW50ZXInKTtcbiAgaWYgKHRoaXMuZW50ZXJlZCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkO1xuICBwdXNoSm9iKHRoaXMuZW50ZXJOZXh0VGljayk7XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlck5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIHByZXZlbnQgdHJhbnNpdGlvbiBza2lwcGluZ1xuICB0aGlzLmp1c3RFbnRlcmVkID0gdHJ1ZTtcbiAgd2FpdEZvclRyYW5zaXRpb25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgfSk7XG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMuZW50ZXJDbGFzcyk7XG4gIGlmICghdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICAgIC8vIHRyaWdnZXIgdHJhbnNpdGlvbiBieSByZW1vdmluZyBlbnRlciBjbGFzcyBub3dcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYihhbmltYXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJEb25lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRlcmVkID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJFbnRlcicpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xufTtcblxuLyoqXG4gKiBTdGFydCBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBsZWF2ZSB0cmFuc2l0aW9uIHRyaWdnZXJlZC5cbiAqIDIuIGNhbGwgYmVmb3JlTGVhdmUgaG9va1xuICogMy4gYWRkIGxlYXZlIGNsYXNzICh0cmlnZ2VyIGNzcyB0cmFuc2l0aW9uKVxuICogNC4gY2FsbCBsZWF2ZSBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNS4gcmVmbG93IGlmIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKiA2LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGVuZCBldmVudCwgcmVtb3ZlIGNsYXNzLCB0aGVuIGRvbmUgaWZcbiAqICAgICAgICB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA3LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckxlYXZlIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSByZW1vdmUvaGlkZSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUxlYXZlJyk7XG4gIHRoaXMub3AgPSBvcDtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKTtcbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmxlYXZlQ2FuY2VsbGVkO1xuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEpvYih0aGlzLmxlYXZlTmV4dFRpY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZU5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5sZWF2ZUNsYXNzKTtcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICB0aGlzLnNldHVwQ3NzQ2IoZXZlbnQsIHRoaXMubGVhdmVEb25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlZnQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB0aGlzLm9wKCk7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyTGVhdmUnKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbiAgdGhpcy5vcCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5jYW5jZWxQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdDc3NDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIG9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpO1xuICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgfVxuICBpZiAoaGFzUGVuZGluZykge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgfVxuICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICB0aGlzLmNhbmNlbC5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCBzeW5jaHJvbm91cyBob29rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCwgcG90ZW50aWFsbHktYXN5bmMgaG9vayBmdW5jdGlvbi5cbiAqIFdlIGNoZWNrIGZvciB0aGUgbGVuZ3RoIG9mIGFyZ3VtZW50cyB0byBzZWUgaWYgdGhlIGhvb2tcbiAqIGV4cGVjdHMgYSBgZG9uZWAgY2FsbGJhY2suIElmIHRydWUsIHRoZSB0cmFuc2l0aW9uJ3MgZW5kXG4gKiB3aWxsIGJlIGRldGVybWluZWQgYnkgd2hlbiB0aGUgdXNlciBjYWxscyB0aGF0IGNhbGxiYWNrO1xuICogb3RoZXJ3aXNlLCB0aGUgZW5kIGlzIGRldGVybWluZWQgYnkgdGhlIENTUyB0cmFuc2l0aW9uIG9yXG4gKiBhbmltYXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2tXaXRoQ2IgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgaG9vayA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXTtcbiAgaWYgKGhvb2spIHtcbiAgICBpZiAoaG9vay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBlbmRpbmdKc0NiID0gY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSk7XG4gICAgfVxuICAgIGhvb2suY2FsbCh0aGlzLnZtLCB0aGlzLmVsLCB0aGlzLnBlbmRpbmdKc0NiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wJDEuZ2V0Q3NzVHJhbnNpdGlvblR5cGUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgLy8gdGhpcyBzb2x2ZXMgdGhlIGlzc3VlIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzIG5vdFxuICAvLyBmaXJpbmcgdW50aWwgdGhlIHBhZ2UgaXMgdmlzaWJsZSBhZ2Fpbi5cbiAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAvLyBDU1MgdHJhbnNpdGlvbnMuXG4gIGRvY3VtZW50LmhpZGRlbiB8fFxuICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UgfHxcbiAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgaXNIaWRkZW4odGhpcy5lbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgfHwgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlO1xuICB2YXIgaW5saW5lU3R5bGVzID0gdGhpcy5lbC5zdHlsZTtcbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gIHZhciB0cmFuc0R1cmF0aW9uID0gaW5saW5lU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF07XG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmltRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF07XG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdID0gdHlwZTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogU2V0dXAgYSBDU1MgdHJhbnNpdGlvbmVuZC9hbmltYXRpb25lbmQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbnAkMS5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbCA9IHRoaXMuZWw7XG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBvZmYoZWwsIGV2ZW50LCBvbkVuZCk7XG4gICAgICBzZWxmLnBlbmRpbmdDc3NFdmVudCA9IHNlbGYucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb24oZWwsIGV2ZW50LCBvbkVuZCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgaGlkZGVuIC0gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0XG4gKiBza2lwIHRoZSB0cmFuc2l0aW9uIGFsbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNIaWRkZW4oZWwpIHtcbiAgaWYgKC9zdmckLy50ZXN0KGVsLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAvLyBTVkcgZWxlbWVudHMgZG8gbm90IGhhdmUgb2Zmc2V0KFdpZHRofEhlaWdodClcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjbGllbnQgcmVjdFxuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuICEocmVjdC53aWR0aCB8fCByZWN0LmhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiQxID0ge1xuXG4gIHByaW9yaXR5OiBUUkFOU0lUSU9OLFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGlkLCBvbGRJZCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgLy8gcmVzb2x2ZSBvbiBvd25lciB2bVxuICAgIHZhciBob29rcyA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAndHJhbnNpdGlvbnMnLCBpZCk7XG4gICAgaWQgPSBpZCB8fCAndic7XG4gICAgb2xkSWQgPSBvbGRJZCB8fCAndic7XG4gICAgZWwuX192X3RyYW5zID0gbmV3IFRyYW5zaXRpb24oZWwsIGlkLCBob29rcywgdGhpcy52bSk7XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG9sZElkICsgJy10cmFuc2l0aW9uJyk7XG4gICAgYWRkQ2xhc3MoZWwsIGlkICsgJy10cmFuc2l0aW9uJyk7XG4gIH1cbn07XG5cbnZhciBpbnRlcm5hbERpcmVjdGl2ZXMgPSB7XG4gIHN0eWxlOiBzdHlsZSxcbiAgJ2NsYXNzJzogdkNsYXNzLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgcHJvcDogcHJvcERlZixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiQxXG59O1xuXG4vLyBzcGVjaWFsIGJpbmRpbmcgcHJlZml4ZXNcbnZhciBiaW5kUkUgPSAvXnYtYmluZDp8XjovO1xudmFyIG9uUkUgPSAvXnYtb246fF5ALztcbnZhciBkaXJBdHRyUkUgPSAvXnYtKFteOl0rKSg/OiR8OiguKikkKS87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXlxcLl0rL2c7XG52YXIgdHJhbnNpdGlvblJFID0gL14odi1iaW5kOnw6KT90cmFuc2l0aW9uJC87XG5cbi8vIGRlZmF1bHQgZGlyZWN0aXZlIHByaW9yaXR5XG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG52YXIgREVGQVVMVF9URVJNSU5BTF9QUklPUklUWSA9IDIwMDA7XG5cbi8qKlxuICogQ29tcGlsZSBhIHRlbXBsYXRlIGFuZCByZXR1cm4gYSByZXVzYWJsZSBjb21wb3NpdGUgbGlua1xuICogZnVuY3Rpb24sIHdoaWNoIHJlY3Vyc2l2ZWx5IGNvbnRhaW5zIG1vcmUgbGluayBmdW5jdGlvbnNcbiAqIGluc2lkZS4gVGhpcyB0b3AgbGV2ZWwgY29tcGlsZSBmdW5jdGlvbiB3b3VsZCBub3JtYWxseVxuICogYmUgY2FsbGVkIG9uIGluc3RhbmNlIHJvb3Qgbm9kZXMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gKiBmb3IgcGFydGlhbCBjb21waWxhdGlvbiBpZiB0aGUgcGFydGlhbCBhcmd1bWVudCBpcyB0cnVlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjb21wb3NpdGUgbGluayBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGxcbiAqIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXNcbiAqIGNyZWF0ZWQgZHVyaW5nIHRoZSBsaW5raW5nIHBoYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFydGlhbFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZShlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnQgPyBjb21waWxlTm9kZShlbCwgb3B0aW9ucykgOiBudWxsO1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgIWlzU2NyaXB0KGVsKSAmJiBlbC5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3QoZWwuY2hpbGROb2Rlcywgb3B0aW9ucykgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGNvbXBvc2l0ZSBsaW5rZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGEgYWxyZWFkeVxuICAgKiBjb21waWxlZCBwaWVjZSBvZiBET00sIHdoaWNoIGluc3RhbnRpYXRlcyBhbGwgZGlyZWN0aXZlXG4gICAqIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gW2hvc3RdIC0gaG9zdCB2bSBvZiB0cmFuc2NsdWRlZCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gbGluayBjb250ZXh0IGZyYWdtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGVsLmNoaWxkTm9kZXMpO1xuICAgIC8vIGxpbmtcbiAgICB2YXIgZGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtDYXB0dXJlcigpIHtcbiAgICAgIGlmIChub2RlTGlua0ZuKSBub2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgaWYgKGNoaWxkTGlua0ZuKSBjaGlsZExpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH0sIHZtKTtcbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBkaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmtlciB0byBhIHZtL2VsZW1lbnQgcGFpciBhbmQgY2FwdHVyZSB0aGVcbiAqIGRpcmVjdGl2ZXMgY3JlYXRlZCBkdXJpbmcgdGhlIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlua2VyXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5mdW5jdGlvbiBsaW5rQW5kQ2FwdHVyZShsaW5rZXIsIHZtKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHJlc2V0IGRpcmVjdGl2ZXMgYmVmb3JlIGV2ZXJ5IGNhcHR1cmUgaW4gcHJvZHVjdGlvblxuICAgIC8vIG1vZGUsIHNvIHRoYXQgd2hlbiB1bmxpbmtpbmcgd2UgZG9uJ3QgbmVlZCB0byBzcGxpY2VcbiAgICAvLyB0aGVtIG91dCAod2hpY2ggdHVybnMgb3V0IHRvIGJlIGEgcGVyZiBoaXQpLlxuICAgIC8vIHRoZXkgYXJlIGtlcHQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAgLy8gdXNlZnVsIGZvciBWdWUncyBvd24gdGVzdHMuXG4gICAgdm0uX2RpcmVjdGl2ZXMgPSBbXTtcbiAgfVxuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgbGlua2VyKCk7XG4gIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgfVxuICByZXR1cm4gZGlycztcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvcihhLCBiKSB7XG4gIGEgPSBhLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG4vKipcbiAqIExpbmtlciBmdW5jdGlvbnMgcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0XG4gKiB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXMgaW5zdGFuY2VzIGdlbmVyYXRlZCBkdXJpbmdcbiAqIHRoZSBwcm9jZXNzLlxuICpcbiAqIFdlIGNyZWF0ZSB1bmxpbmsgZnVuY3Rpb25zIHdpdGggb25seSB0aGUgbmVjZXNzYXJ5XG4gKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7VnVlfSBbY29udGV4dF1cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb250ZXh0RGlyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVbmxpbmtGbih2bSwgZGlycywgY29udGV4dCwgY29udGV4dERpcnMpIHtcbiAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgdW5saW5rLmRpcnMgPSBkaXJzO1xuICByZXR1cm4gdW5saW5rO1xufVxuXG4vKipcbiAqIFRlYXJkb3duIHBhcnRpYWwgbGlua2VkIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAqL1xuXG5mdW5jdGlvbiB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGRpcnNbaV0uX3RlYXJkb3duKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRlc3Ryb3lpbmcpIHtcbiAgICAgIHZtLl9kaXJlY3RpdmVzLiRyZW1vdmUoZGlyc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBsaW5rIHByb3BzIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZUFuZExpbmtQcm9wcyh2bSwgZWwsIHByb3BzLCBzY29wZSkge1xuICB2YXIgcHJvcHNMaW5rRm4gPSBjb21waWxlUHJvcHMoZWwsIHByb3BzLCB2bSk7XG4gIHZhciBwcm9wRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9wc0xpbmtGbih2bSwgc2NvcGUpO1xuICB9LCB2bSk7XG4gIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHByb3BEaXJzKTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSByb290IGVsZW1lbnQgb2YgYW4gaW5zdGFuY2UuXG4gKlxuICogMS4gYXR0cnMgb24gY29udGV4dCBjb250YWluZXIgKGNvbnRleHQgc2NvcGUpXG4gKiAyLiBhdHRycyBvbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIHJvb3Qgbm9kZSwgaWZcbiAqICAgIHJlcGxhY2U6dHJ1ZSAoY2hpbGQgc2NvcGUpXG4gKlxuICogSWYgdGhpcyBpcyBhIGZyYWdtZW50IGluc3RhbmNlLCB3ZSBvbmx5IG5lZWQgdG8gY29tcGlsZSAxLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVSb290KGVsLCBvcHRpb25zLCBjb250ZXh0T3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9jb250YWluZXJBdHRycztcbiAgdmFyIHJlcGxhY2VyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzO1xuICB2YXIgY29udGV4dExpbmtGbiwgcmVwbGFjZXJMaW5rRm47XG5cbiAgLy8gb25seSBuZWVkIHRvIGNvbXBpbGUgb3RoZXIgYXR0cmlidXRlcyBmb3JcbiAgLy8gbm9uLWZyYWdtZW50IGluc3RhbmNlc1xuICBpZiAoZWwubm9kZVR5cGUgIT09IDExKSB7XG4gICAgLy8gZm9yIGNvbXBvbmVudHMsIGNvbnRhaW5lciBhbmQgcmVwbGFjZXIgbmVlZCB0byBiZVxuICAgIC8vIGNvbXBpbGVkIHNlcGFyYXRlbHkgYW5kIGxpbmtlZCBpbiBkaWZmZXJlbnQgc2NvcGVzLlxuICAgIGlmIChvcHRpb25zLl9hc0NvbXBvbmVudCkge1xuICAgICAgLy8gMi4gY29udGFpbmVyIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChjb250YWluZXJBdHRycyAmJiBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICBjb250ZXh0TGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoY29udGFpbmVyQXR0cnMsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsYWNlckF0dHJzKSB7XG4gICAgICAgIC8vIDMuIHJlcGxhY2VyIGF0dHJpYnV0ZXNcbiAgICAgICAgcmVwbGFjZXJMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhyZXBsYWNlckF0dHJzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWNvbXBvbmVudCwganVzdCBjb21waWxlIGFzIGEgbm9ybWFsIGVsZW1lbnQuXG4gICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKGVsLmF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbnRhaW5lckF0dHJzKSB7XG4gICAgLy8gd2FybiBjb250YWluZXIgZGlyZWN0aXZlcyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VzXG4gICAgdmFyIG5hbWVzID0gY29udGFpbmVyQXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAvLyBhbGxvdyB2dWUtbG9hZGVyL3Z1ZWlmeSBzY29wZWQgY3NzIGF0dHJpYnV0ZXNcbiAgICAgIHJldHVybiBhdHRyLm5hbWUuaW5kZXhPZignX3YtJykgPCAwICYmXG4gICAgICAvLyBhbGxvdyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICFvblJFLnRlc3QoYXR0ci5uYW1lKSAmJlxuICAgICAgLy8gYWxsb3cgc2xvdHNcbiAgICAgIGF0dHIubmFtZSAhPT0gJ3Nsb3QnO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgcmV0dXJuICdcIicgKyBhdHRyLm5hbWUgKyAnXCInO1xuICAgIH0pO1xuICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwbHVyYWwgPSBuYW1lcy5sZW5ndGggPiAxO1xuICAgICAgd2FybignQXR0cmlidXRlJyArIChwbHVyYWwgPyAncyAnIDogJyAnKSArIG5hbWVzLmpvaW4oJywgJykgKyAocGx1cmFsID8gJyBhcmUnIDogJyBpcycpICsgJyBpZ25vcmVkIG9uIGNvbXBvbmVudCAnICsgJzwnICsgb3B0aW9ucy5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPiBiZWNhdXNlICcgKyAndGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50IGluc3RhbmNlOiAnICsgJ2h0dHA6Ly92dWVqcy5vcmcvZ3VpZGUvY29tcG9uZW50cy5odG1sI0ZyYWdtZW50LUluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBvcHRpb25zLl9yZXBsYWNlckF0dHJzID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvb3RMaW5rRm4odm0sIGVsLCBzY29wZSkge1xuICAgIC8vIGxpbmsgY29udGV4dCBzY29wZSBkaXJzXG4gICAgdmFyIGNvbnRleHQgPSB2bS5fY29udGV4dDtcbiAgICB2YXIgY29udGV4dERpcnM7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dExpbmtGbikge1xuICAgICAgY29udGV4dERpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4oY29udGV4dCwgZWwsIG51bGwsIHNjb3BlKTtcbiAgICAgIH0sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIGxpbmsgc2VsZlxuICAgIHZhciBzZWxmRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZXBsYWNlckxpbmtGbikgcmVwbGFjZXJMaW5rRm4odm0sIGVsKTtcbiAgICB9LCB2bSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHVubGluayBmdW5jdGlvbiB0aGF0IHRlYXJzZG93biBjb250ZXh0XG4gICAgLy8gY29udGFpbmVyIGRpcmVjdGl2ZXMuXG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgc2VsZkRpcnMsIGNvbnRleHQsIGNvbnRleHREaXJzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbiBiYXNlZCBvbiB0aGVcbiAqIG5vZGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICBpZiAodHlwZSA9PT0gMSAmJiAhaXNTY3JpcHQobm9kZSkpIHtcbiAgICByZXR1cm4gY29tcGlsZUVsZW1lbnQobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyAmJiBub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChlbC52YWx1ZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0b2tlbnNUb0V4cCh0b2tlbnMpKTtcbiAgICAgIGVsLnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm47XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgdmFyIGF0dHJzID0gaGFzQXR0cnMgJiYgdG9BcnJheShlbC5hdHRyaWJ1dGVzKTtcbiAgLy8gY2hlY2sgdGVybWluYWwgZGlyZWN0aXZlcyAoZm9yICYgaWYpXG4gIGlmIChoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBhdHRycywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgZWxlbWVudCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgY29tcG9uZW50XG4gIGlmICghbGlua0ZuKSB7XG4gICAgbGlua0ZuID0gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gIGlmICghbGlua0ZuICYmIGhhc0F0dHJzKSB7XG4gICAgbGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoYXR0cnMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBsaW5rRm47XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHRleHROb2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuLlxuICpcbiAqIEBwYXJhbSB7VGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0ZXh0Tm9kZUxpbmtGblxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgbWFya2VkIHRleHQgbm9kZXNcbiAgaWYgKG5vZGUuX3NraXApIHtcbiAgICByZXR1cm4gcmVtb3ZlVGV4dDtcbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBwYXJzZVRleHQobm9kZS53aG9sZVRleHQpO1xuICBpZiAoIXRva2Vucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbWFyayBhZGphY2VudCB0ZXh0IG5vZGVzIGFzIHNraXBwZWQsXG4gIC8vIGJlY2F1c2Ugd2UgYXJlIHVzaW5nIG5vZGUud2hvbGVUZXh0IHRvIGNvbXBpbGVcbiAgLy8gYWxsIGFkamFjZW50IHRleHQgbm9kZXMgdG9nZXRoZXIuIFRoaXMgZml4ZXNcbiAgLy8gaXNzdWVzIGluIElFIHdoZXJlIHNvbWV0aW1lcyBpdCBzcGxpdHMgdXAgYSBzaW5nbGVcbiAgLy8gdGV4dCBub2RlIGludG8gbXVsdGlwbGUgb25lcy5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgbmV4dC5fc2tpcCA9IHRydWU7XG4gICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gIH1cblxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgdmFyIGVsLCB0b2tlbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgZWwgPSB0b2tlbi50YWcgPyBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuICByZXR1cm4gbWFrZVRleHROb2RlTGlua0ZuKHRva2VucywgZnJhZywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTGlua2VyIGZvciBhbiBza2lwcGVkIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZVRleHQodm0sIG5vZGUpIHtcbiAgcmVtb3ZlKG5vZGUpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBzaW5nbGUgdGV4dCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NUZXh0VG9rZW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgdmFyIGVsO1xuICBpZiAodG9rZW4ub25lVGltZSkge1xuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4udmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3YtaHRtbCcpO1xuICAgICAgc2V0VG9rZW5UeXBlKCdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIHdpbGwgY2xlYW4gdXAgZW1wdHkgdGV4dE5vZGVzIGR1cmluZ1xuICAgICAgLy8gZnJhZy5jbG9uZU5vZGUodHJ1ZSksIHNvIHdlIGhhdmUgdG8gZ2l2ZSBpdFxuICAgICAgLy8gc29tZXRoaW5nIGhlcmUuLi5cbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKTtcbiAgICAgIHNldFRva2VuVHlwZSgndGV4dCcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRUb2tlblR5cGUodHlwZSkge1xuICAgIGlmICh0b2tlbi5kZXNjcmlwdG9yKSByZXR1cm47XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHRva2VuLnZhbHVlKTtcbiAgICB0b2tlbi5kZXNjcmlwdG9yID0ge1xuICAgICAgbmFtZTogdHlwZSxcbiAgICAgIGRlZjogZGlyZWN0aXZlc1t0eXBlXSxcbiAgICAgIGV4cHJlc3Npb246IHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnNcbiAgICB9O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgdGV4dE5vZGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSB0b2tlbnNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ1xuICovXG5cbmZ1bmN0aW9uIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRleHROb2RlTGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUpIHtcbiAgICB2YXIgZnJhZ0Nsb25lID0gZnJhZy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSB0b0FycmF5KGZyYWdDbG9uZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgdG9rZW4sIHZhbHVlLCBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgaWYgKHRva2VuLnRhZykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IChzY29wZSB8fCB2bSkuJGV2YWwodmFsdWUpO1xuICAgICAgICAgIGlmICh0b2tlbi5odG1sKSB7XG4gICAgICAgICAgICByZXBsYWNlKG5vZGUsIHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm0uX2JpbmREaXIodG9rZW4uZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZWwsIGZyYWdDbG9uZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIG5vZGUgbGlzdCBhbmQgcmV0dXJuIGEgY2hpbGRMaW5rRm4uXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZUxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGVMaXN0KG5vZGVMaXN0LCBvcHRpb25zKSB7XG4gIHZhciBsaW5rRm5zID0gW107XG4gIHZhciBub2RlTGlua0ZuLCBjaGlsZExpbmtGbiwgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgbm9kZUxpbmtGbiA9IGNvbXBpbGVOb2RlKG5vZGUsIG9wdGlvbnMpO1xuICAgIGNoaWxkTGlua0ZuID0gIShub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwpICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiYgbm9kZS5oYXNDaGlsZE5vZGVzKCkgPyBjb21waWxlTm9kZUxpc3Qobm9kZS5jaGlsZE5vZGVzLCBvcHRpb25zKSA6IG51bGw7XG4gICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuKTtcbiAgfVxuICByZXR1cm4gbGlua0Zucy5sZW5ndGggPyBtYWtlQ2hpbGRMaW5rRm4obGlua0ZucykgOiBudWxsO1xufVxuXG4vKipcbiAqIE1ha2UgYSBjaGlsZCBsaW5rIGZ1bmN0aW9uIGZvciBhIG5vZGUncyBjaGlsZE5vZGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBsaW5rRm5zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gY2hpbGRMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlQ2hpbGRMaW5rRm4obGlua0Zucykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hpbGRMaW5rRm4odm0sIG5vZGVzLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHZhciBub2RlLCBub2RlTGlua0ZuLCBjaGlsZHJlbkxpbmtGbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGwgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGw7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuICAgICAgbm9kZUxpbmtGbiA9IGxpbmtGbnNbaSsrXTtcbiAgICAgIGNoaWxkcmVuTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgLy8gY2FjaGUgY2hpbGROb2RlcyBiZWZvcmUgbGlua2luZyBwYXJlbnQsIGZpeCAjNjU3XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgIGlmIChub2RlTGlua0ZuKSB7XG4gICAgICAgIG5vZGVMaW5rRm4odm0sIG5vZGUsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbkxpbmtGbikge1xuICAgICAgICBjaGlsZHJlbkxpbmtGbih2bSwgY2hpbGROb2RlcywgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgZWxlbWVudCBkaXJlY3RpdmVzIChjdXN0b20gZWxlbWVudHMgdGhhdCBzaG91bGRcbiAqIGJlIHJlc292bGVkIGFzIHRlcm1pbmFsIGRpcmVjdGl2ZXMpLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tFbGVtZW50RGlyZWN0aXZlcyhlbCwgb3B0aW9ucykge1xuICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoY29tbW9uVGFnUkUudGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkZWYgPSByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKTtcbiAgaWYgKGRlZikge1xuICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCB0YWcsICcnLCBvcHRpb25zLCBkZWYpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudC4gSWYgeWVzLCByZXR1cm5cbiAqIGEgY29tcG9uZW50IGxpbmsgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucykge1xuICB2YXIgY29tcG9uZW50ID0gY2hlY2tDb21wb25lbnRBdHRyKGVsLCBvcHRpb25zKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIHZhciByZWYgPSBmaW5kUmVmKGVsKTtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6ICdjb21wb25lbnQnLFxuICAgICAgcmVmOiByZWYsXG4gICAgICBleHByZXNzaW9uOiBjb21wb25lbnQuaWQsXG4gICAgICBkZWY6IGludGVybmFsRGlyZWN0aXZlcy5jb21wb25lbnQsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgbGl0ZXJhbDogIWNvbXBvbmVudC5keW5hbWljXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50TGlua0ZuID0gZnVuY3Rpb24gY29tcG9uZW50TGlua0ZuKHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUoKHNjb3BlIHx8IHZtKS4kcmVmcywgcmVmLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgfTtcbiAgICBjb21wb25lbnRMaW5rRm4udGVybWluYWwgPSB0cnVlO1xuICAgIHJldHVybiBjb21wb25lbnRMaW5rRm47XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBhbiBlbGVtZW50IGZvciB0ZXJtaW5hbCBkaXJlY3RpdmVzIGluIGZpeGVkIG9yZGVyLlxuICogSWYgaXQgZmluZHMgb25lLCByZXR1cm4gYSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IGF0dHJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIGF0dHJzLCBvcHRpb25zKSB7XG4gIC8vIHNraXAgdi1wcmVcbiAgaWYgKGdldEF0dHIoZWwsICd2LXByZScpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNraXA7XG4gIH1cbiAgLy8gc2tpcCB2LWVsc2UgYmxvY2ssIGJ1dCBvbmx5IGlmIGZvbGxvd2luZyB2LWlmXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3YtZWxzZScpKSB7XG4gICAgdmFyIHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaGFzQXR0cmlidXRlKCd2LWlmJykpIHtcbiAgICAgIHJldHVybiBza2lwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRyLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBtYXRjaGVkLCBkaXJOYW1lLCByYXdOYW1lLCBhcmcsIGRlZiwgdGVybURlZjtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBhdHRycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICBpZiAobWF0Y2hlZCA9IG5hbWUubWF0Y2goZGlyQXR0clJFKSkge1xuICAgICAgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgbWF0Y2hlZFsxXSk7XG4gICAgICBpZiAoZGVmICYmIGRlZi50ZXJtaW5hbCkge1xuICAgICAgICBpZiAoIXRlcm1EZWYgfHwgKGRlZi5wcmlvcml0eSB8fCBERUZBVUxUX1RFUk1JTkFMX1BSSU9SSVRZKSA+IHRlcm1EZWYucHJpb3JpdHkpIHtcbiAgICAgICAgICB0ZXJtRGVmID0gZGVmO1xuICAgICAgICAgIHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMoYXR0ci5uYW1lKTtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgZGlyTmFtZSA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgYXJnID0gbWF0Y2hlZFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXJtRGVmKSB7XG4gICAgcmV0dXJuIG1ha2VUZXJtaW5hbE5vZGVMaW5rRm4oZWwsIGRpck5hbWUsIHZhbHVlLCBvcHRpb25zLCB0ZXJtRGVmLCByYXdOYW1lLCBhcmcsIG1vZGlmaWVycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcCgpIHt9XG5za2lwLnRlcm1pbmFsID0gdHJ1ZTtcblxuLyoqXG4gKiBCdWlsZCBhIG5vZGUgbGluayBmdW5jdGlvbiBmb3IgYSB0ZXJtaW5hbCBkaXJlY3RpdmUuXG4gKiBBIHRlcm1pbmFsIGxpbmsgZnVuY3Rpb24gdGVybWluYXRlcyB0aGUgY3VycmVudFxuICogY29tcGlsYXRpb24gcmVjdXJzaW9uIGFuZCBoYW5kbGVzIGNvbXBpbGF0aW9uIG9mIHRoZVxuICogc3VidHJlZSBpbiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkaXJOYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Jhd05hbWVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2FyZ11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgZGlyTmFtZSwgdmFsdWUsIG9wdGlvbnMsIGRlZiwgcmF3TmFtZSwgYXJnLCBtb2RpZmllcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgbmFtZTogZGlyTmFtZSxcbiAgICBhcmc6IGFyZyxcbiAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICBmaWx0ZXJzOiBwYXJzZWQuZmlsdGVycyxcbiAgICByYXc6IHZhbHVlLFxuICAgIGF0dHI6IHJhd05hbWUsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgZGVmOiBkZWZcbiAgfTtcbiAgLy8gY2hlY2sgcmVmIGZvciB2LWZvciBhbmQgcm91dGVyLXZpZXdcbiAgaWYgKGRpck5hbWUgPT09ICdmb3InIHx8IGRpck5hbWUgPT09ICdyb3V0ZXItdmlldycpIHtcbiAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICB9XG4gIHZhciBmbiA9IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCBkZXNjcmlwdG9yLnJlZiwgbnVsbCk7XG4gICAgfVxuICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG4gIGZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgZGlycyA9IFtdO1xuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnMsIG1hdGNoZWQ7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFsdWUgPSByYXdWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgdG9rZW5zID0gcGFyc2VUZXh0KHZhbHVlKTtcbiAgICAvLyByZXNldCBhcmdcbiAgICBhcmcgPSBudWxsO1xuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXG4gICAgLy8gYXR0cmlidXRlIGludGVycG9sYXRpb25zXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdmFsdWUgPSB0b2tlbnNUb0V4cCh0b2tlbnMpO1xuICAgICAgYXJnID0gbmFtZTtcbiAgICAgIHB1c2hEaXIoJ2JpbmQnLCBkaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAvLyB3YXJuIGFnYWluc3QgbWl4aW5nIG11c3RhY2hlcyB3aXRoIHYtYmluZFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5uYW1lID09PSAnOmNsYXNzJyB8fCBhdHRyLm5hbWUgPT09ICd2LWJpbmQ6Y2xhc3MnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdhcm4oJ2NsYXNzPVwiJyArIHJhd1ZhbHVlICsgJ1wiOiBEbyBub3QgbWl4IG11c3RhY2hlIGludGVycG9sYXRpb24gJyArICdhbmQgdi1iaW5kIGZvciBcImNsYXNzXCIgb24gdGhlIHNhbWUgZWxlbWVudC4gVXNlIG9uZSBvciB0aGUgb3RoZXIuJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICBtb2RpZmllcnMubGl0ZXJhbCA9ICFiaW5kUkUudGVzdChuYW1lKTtcbiAgICAgICAgcHVzaERpcigndHJhbnNpdGlvbicsIGludGVybmFsRGlyZWN0aXZlcy50cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIHB1c2hEaXIoJ29uJywgZGlyZWN0aXZlcy5vbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBkaXJOYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICBwdXNoRGlyKCdiaW5kJywgZGlyZWN0aXZlcy5iaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID0gbmFtZS5tYXRjaChkaXJBdHRyUkUpKSB7XG4gICAgICAgICAgICAgIGRpck5hbWUgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgICBhcmcgPSBtYXRjaGVkWzJdO1xuXG4gICAgICAgICAgICAgIC8vIHNraXAgdi1lbHNlICh3aGVuIHVzZWQgd2l0aCB2LXNob3cpXG4gICAgICAgICAgICAgIGlmIChkaXJOYW1lID09PSAnZWxzZScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpckRlZiA9IHJlc29sdmVBc3NldChvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpck5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAoZGlyRGVmKSB7XG4gICAgICAgICAgICAgICAgcHVzaERpcihkaXJOYW1lLCBkaXJEZWYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpck5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZlxuICAgKiBAcGFyYW0ge0FycmF5fSBbaW50ZXJwVG9rZW5zXVxuICAgKi9cblxuICBmdW5jdGlvbiBwdXNoRGlyKGRpck5hbWUsIGRlZiwgaW50ZXJwVG9rZW5zKSB7XG4gICAgdmFyIGhhc09uZVRpbWVUb2tlbiA9IGludGVycFRva2VucyAmJiBoYXNPbmVUaW1lKGludGVycFRva2Vucyk7XG4gICAgdmFyIHBhcnNlZCA9ICFoYXNPbmVUaW1lVG9rZW4gJiYgcGFyc2VEaXJlY3RpdmUodmFsdWUpO1xuICAgIGRpcnMucHVzaCh7XG4gICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgYXR0cjogcmF3TmFtZSxcbiAgICAgIHJhdzogcmF3VmFsdWUsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIGFyZzogYXJnLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAvLyBjb252ZXJzaW9uIGZyb20gaW50ZXJwb2xhdGlvbiBzdHJpbmdzIHdpdGggb25lLXRpbWUgdG9rZW5cbiAgICAgIC8vIHRvIGV4cHJlc3Npb24gaXMgZGlmZmVyZWQgdW50aWwgZGlyZWN0aXZlIGJpbmQgdGltZSBzbyB0aGF0IHdlXG4gICAgICAvLyBoYXZlIGFjY2VzcyB0byB0aGUgYWN0dWFsIHZtIGNvbnRleHQgZm9yIG9uZS10aW1lIGJpbmRpbmdzLlxuICAgICAgZXhwcmVzc2lvbjogcGFyc2VkICYmIHBhcnNlZC5leHByZXNzaW9uLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgaW50ZXJwOiBpbnRlcnBUb2tlbnMsXG4gICAgICBoYXNPbmVUaW1lOiBoYXNPbmVUaW1lVG9rZW5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkaXJzLmxlbmd0aCkge1xuICAgIHJldHVybiBtYWtlTm9kZUxpbmtGbihkaXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIG1vZGlmaWVycyBmcm9tIGRpcmVjdGl2ZSBhdHRyaWJ1dGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBpID0gbWF0Y2gubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlc1ttYXRjaFtpXS5zbGljZSgxKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGluayBmdW5jdGlvbiBmb3IgYWxsIGRpcmVjdGl2ZXMgb24gYSBzaW5nbGUgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJlY3RpdmVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gZGlyZWN0aXZlc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VOb2RlTGlua0ZuKGRpcmVjdGl2ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vZGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIHJldmVyc2UgYXBwbHkgYmVjYXVzZSBpdCdzIHNvcnRlZCBsb3cgdG8gaGlnaFxuICAgIHZhciBpID0gZGlyZWN0aXZlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX2JpbmREaXIoZGlyZWN0aXZlc1tpXSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gaW50ZXJwb2xhdGlvbiBzdHJpbmcgY29udGFpbnMgb25lLXRpbWUgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNPbmVUaW1lKHRva2Vucykge1xuICB2YXIgaSA9IHRva2Vucy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodG9rZW5zW2ldLm9uZVRpbWUpIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2NyaXB0KGVsKSB7XG4gIHJldHVybiBlbC50YWdOYW1lID09PSAnU0NSSVBUJyAmJiAoIWVsLmhhc0F0dHJpYnV0ZSgndHlwZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAndGV4dC9qYXZhc2NyaXB0Jyk7XG59XG5cbnZhciBzcGVjaWFsQ2hhclJFID0gL1teXFx3XFwtOlxcLl0vO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gZWxlbWVudCBvciBhIERvY3VtZW50RnJhZ21lbnQgYmFzZWQgb24gYVxuICogaW5zdGFuY2Ugb3B0aW9uIG9iamVjdC4gVGhpcyBhbGxvd3MgdXMgdG8gdHJhbnNjbHVkZVxuICogYSB0ZW1wbGF0ZSBub2RlL2ZyYWdtZW50IGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAqIHNvIHRoZSBwcm9jZXNzZWQgZnJhZ21lbnQgY2FuIHRoZW4gYmUgY2xvbmVkIGFuZCByZXVzZWRcbiAqIGluIHYtZm9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNjbHVkZShlbCwgb3B0aW9ucykge1xuICAvLyBleHRyYWN0IGNvbnRhaW5lciBhdHRyaWJ1dGVzIHRvIHBhc3MgdGhlbSBkb3duXG4gIC8vIHRvIGNvbXBpbGVyLCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSBjb21waWxlZCBpblxuICAvLyBwYXJlbnQgc2NvcGUuIHdlIGFyZSBtdXRhdGluZyB0aGUgb3B0aW9ucyBvYmplY3QgaGVyZVxuICAvLyBhc3N1bWluZyB0aGUgc2FtZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGZvciBjb21waWxlXG4gIC8vIHJpZ2h0IGFmdGVyIHRoaXMuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5fY29udGFpbmVyQXR0cnMgPSBleHRyYWN0QXR0cnMoZWwpO1xuICB9XG4gIC8vIGZvciB0ZW1wbGF0ZSB0YWdzLCB3aGF0IHdlIHdhbnQgaXMgaXRzIGNvbnRlbnQgYXNcbiAgLy8gYSBkb2N1bWVudEZyYWdtZW50IChmb3IgZnJhZ21lbnQgaW5zdGFuY2VzKVxuICBpZiAoaXNUZW1wbGF0ZShlbCkpIHtcbiAgICBlbCA9IHBhcnNlVGVtcGxhdGUoZWwpO1xuICB9XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50ICYmICFvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLnRlbXBsYXRlID0gJzxzbG90Pjwvc2xvdD4nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgb3B0aW9ucy5fY29udGVudCA9IGV4dHJhY3RDb250ZW50KGVsKTtcbiAgICAgIGVsID0gdHJhbnNjbHVkZVRlbXBsYXRlKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnJhZ21lbnQoZWwpKSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZUFuY2hvcigndi1lbmQnLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArICc8Ym9keT4uIFRoaXMgd2lsbCByZXBsYWNlIDxib2R5PiBlbnRpcmVseS4gWW91ICcgKyAnc2hvdWxkIHByb2JhYmx5IHVzZSBgcmVwbGFjZTogZmFsc2VgIGhlcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyB0aGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgbXVzdFxuICAgICAgLy8gYmVjb21lIGEgZnJhZ21lbnQgaW5zdGFuY2U6IGJhc2ljYWxseSBhbnl0aGluZyB0aGF0XG4gICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICBpZiAoXG4gICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIC8vIG5vbi1lbGVtZW50IHRlbXBsYXRlXG4gICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fCBoYXNCaW5kQXR0cihyZXBsYWNlciwgJ2lzJykgfHxcbiAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykgfHxcbiAgICAgIC8vIGlmIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBleHRyYWN0QXR0cnMocmVwbGFjZXIpO1xuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcik7XG4gICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gKiBpbnRvIGEgcGxhaW4gb2JqZWN0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAqIHRoZSBjbGFzcyBuYW1lcyBhcmUgbWVyZ2VkIHByb3Blcmx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICogQHBhcmFtIHtFbGVtZW50fSB0b1xuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgdmFyIGF0dHJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIG5hbWUsIHZhbHVlO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZS50cmltKCkpKSB7XG4gICAgICB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICBhZGRDbGFzcyh0bywgY2xzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNjYW4gYW5kIGRldGVybWluZSBzbG90IGNvbnRlbnQgZGlzdHJpYnV0aW9uLlxuICogV2UgZG8gdGhpcyBkdXJpbmcgdHJhbnNjbHVzaW9uIGluc3RlYWQgYXQgY29tcGlsZSB0aW1lIHNvIHRoYXRcbiAqIHRoZSBkaXN0cmlidXRpb24gaXMgZGVjb3VwbGVkIGZyb20gdGhlIGNvbXBpbGF0aW9uIG9yZGVyIG9mXG4gKiB0aGUgc2xvdHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyh2bSwgY29udGVudCkge1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbnRlbnRzID0gdm0uX3Nsb3RDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBlbCwgbmFtZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGVsID0gY29udGVudC5jaGlsZHJlbltpXTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGlmIChuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgIChjb250ZW50c1tuYW1lXSB8fCAoY29udGVudHNbbmFtZV0gPSBbXSkpLnB1c2goZWwpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0QmluZEF0dHIoZWwsICdzbG90JykpIHtcbiAgICAgIHdhcm4oJ1RoZSBcInNsb3RcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzdGF0aWMuJywgdm0uJHBhcmVudCk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBjb250ZW50cykge1xuICAgIGNvbnRlbnRzW25hbWVdID0gZXh0cmFjdEZyYWdtZW50KGNvbnRlbnRzW25hbWVdLCBjb250ZW50KTtcbiAgfVxuICBpZiAoY29udGVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB2YXIgbm9kZXMgPSBjb250ZW50LmNoaWxkTm9kZXM7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBub2Rlc1swXS5ub2RlVHlwZSA9PT0gMyAmJiAhbm9kZXNbMF0uZGF0YS50cmltKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGVudHNbJ2RlZmF1bHQnXSA9IGV4dHJhY3RGcmFnbWVudChjb250ZW50LmNoaWxkTm9kZXMsIGNvbnRlbnQpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBxdWFsaWZpZWQgY29udGVudCBub2RlcyBmcm9tIGEgbm9kZSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVzXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudChub2RlcywgcGFyZW50KSB7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBub2RlcyA9IHRvQXJyYXkobm9kZXMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKGlzVGVtcGxhdGUobm9kZSkgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWlmJykgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCd2LWZvcicpKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gcGFyc2VUZW1wbGF0ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxuICByZXR1cm4gZnJhZztcbn1cblxuXG5cbnZhciBjb21waWxlciA9IE9iamVjdC5mcmVlemUoe1xuXHRjb21waWxlOiBjb21waWxlLFxuXHRjb21waWxlQW5kTGlua1Byb3BzOiBjb21waWxlQW5kTGlua1Byb3BzLFxuXHRjb21waWxlUm9vdDogY29tcGlsZVJvb3QsXG5cdHRyYW5zY2x1ZGU6IHRyYW5zY2x1ZGUsXG5cdHJlc29sdmVTbG90czogcmVzb2x2ZVNsb3RzXG59KTtcblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBBY2Nlc3NvciBmb3IgYCRkYXRhYCBwcm9wZXJ0eSwgc2luY2Ugc2V0dGluZyAkZGF0YVxuICAgKiByZXF1aXJlcyBvYnNlcnZpbmcgdGhlIG5ldyBvYmplY3QgYW5kIHVwZGF0aW5nXG4gICAqIHByb3hpZWQgcHJvcGVydGllcy5cbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3RGF0YSkge1xuICAgICAgaWYgKG5ld0RhdGEgIT09IHRoaXMuX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0RGF0YShuZXdEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgc2NvcGUgb2YgYW4gaW5zdGFuY2UsIHdoaWNoIGNvbnRhaW5zOlxuICAgKiAtIG9ic2VydmVkIGRhdGFcbiAgICogLSBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAqIC0gdXNlciBtZXRob2RzXG4gICAqIC0gbWV0YSBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0UHJvcHMoKTtcbiAgICB0aGlzLl9pbml0TWV0YSgpO1xuICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICB0aGlzLl9pbml0Q29tcHV0ZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwcm9wcy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICB2YXIgZWwgPSBvcHRpb25zLmVsO1xuICAgIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKHByb3BzICYmICFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdQcm9wcyB3aWxsIG5vdCBiZSBjb21waWxlZCBpZiBubyBgZWxgIG9wdGlvbiBpcyAnICsgJ3Byb3ZpZGVkIGF0IGluc3RhbnRpYXRpb24uJywgdGhpcyk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBjb252ZXJ0IHN0cmluZyBzZWxlY3RvcnMgaW50byBlbGVtZW50IG5vd1xuICAgIGVsID0gb3B0aW9ucy5lbCA9IHF1ZXJ5KGVsKTtcbiAgICB0aGlzLl9wcm9wc1VubGlua0ZuID0gZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgcHJvcHNcbiAgICAvLyBwcm9wcyBtdXN0IGJlIGxpbmtlZCBpbiBwcm9wZXIgc2NvcGUgaWYgaW5zaWRlIHYtZm9yXG4gICAgPyBjb21waWxlQW5kTGlua1Byb3BzKHRoaXMsIGVsLCBwcm9wcywgdGhpcy5fc2NvcGUpIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFGbiA9IHRoaXMuJG9wdGlvbnMuZGF0YTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEgPSBkYXRhRm4gPyBkYXRhRm4oKSA6IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4nLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGksIGtleTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vIHRoZXJlIGFyZSB0d28gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbiBwcm94eSBhIGRhdGEga2V5OlxuICAgICAgLy8gMS4gaXQncyBub3QgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcFxuICAgICAgLy8gMi4gaXQncyBwcm92aWRlZCB2aWEgYSBpbnN0YW50aWF0aW9uIG9wdGlvbiBBTkQgdGhlcmUgYXJlIG5vXG4gICAgICAvLyAgICB0ZW1wbGF0ZSBwcm9wIHByZXNlbnRcbiAgICAgIGlmICghcHJvcHMgfHwgIWhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB0aGlzLl9wcm94eShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ0RhdGEgZmllbGQgXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgZGVmaW5lZCAnICsgJ2FzIGEgcHJvcC4gVG8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlIGZvciBhIHByb3AsIHVzZSB0aGUgXCJkZWZhdWx0XCIgJyArICdwcm9wIG9wdGlvbjsgaWYgeW91IHdhbnQgdG8gcGFzcyBwcm9wIHZhbHVlcyB0byBhbiBpbnN0YW50aWF0aW9uICcgKyAnY2FsbCwgdXNlIHRoZSBcInByb3BzRGF0YVwiIG9wdGlvbi4nLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RGF0YVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fZGF0YSA9IG5ld0RhdGE7XG4gICAgdmFyIGtleXMsIGtleSwgaTtcbiAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIShrZXkgaW4gbmV3RGF0YSkpIHtcbiAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlIGZvciBjaGFuZ2VkIHZhbHVlc1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgdGhpcy5fZGlnZXN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAgICogdm0ucHJvcCA9PT0gdm0uX2RhdGEucHJvcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgIC8vIGJlIGNhbGxlZCBieSBjaGlsZCBzY29wZXMgdmlhXG4gICAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnVwZGF0ZSh0cnVlKTsgLy8gc2hhbGxvdyB1cGRhdGVzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB0aGlzKTtcbiAgICAgICAgICBkZWYuc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXQgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZSA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdGhpcykgOiBiaW5kKHVzZXJEZWYuZ2V0LCB0aGlzKSA6IG5vb3A7XG4gICAgICAgICAgZGVmLnNldCA9IHVzZXJEZWYuc2V0ID8gYmluZCh1c2VyRGVmLnNldCwgdGhpcykgOiBub29wO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlcihnZXR0ZXIsIG93bmVyKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgaW5zdGFuY2UgbWV0aG9kcy4gTWV0aG9kcyBtdXN0IGJlIGJvdW5kIHRvIHRoZVxuICAgKiBpbnN0YW5jZSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhc3NlZCBkb3duIGFzIGEgcHJvcCB0b1xuICAgKiBjaGlsZCBjb21wb25lbnRzLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMuJG9wdGlvbnMubWV0aG9kcztcbiAgICBpZiAobWV0aG9kcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgdGhpc1trZXldID0gYmluZChtZXRob2RzW2tleV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgIGlmIChtZXRhcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGFzKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvO1xuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgaW5zdGFuY2UncyBvcHRpb24gZXZlbnRzICYgd2F0Y2hlcnMuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgd2UgcHVsbCBpdCBmcm9tIHRoZVxuICAgKiBpbnN0YW5jZSdzIG1ldGhvZHMgYnkgbmFtZS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICByZWdpc3RlckNvbXBvbmVudEV2ZW50cyh0aGlzLCBvcHRpb25zLmVsKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYWxsYmFja3ModGhpcywgJyRvbicsIG9wdGlvbnMuZXZlbnRzKTtcbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJHdhdGNoJywgb3B0aW9ucy53YXRjaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHYtb24gZXZlbnRzIG9uIGEgY2hpbGQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHZtLCBlbCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgdmFyIG5hbWUsIHZhbHVlLCBoYW5kbGVyO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgIGlmIChldmVudFJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShldmVudFJFLCAnJyk7XG4gICAgICAgIC8vIGZvcmNlIHRoZSBleHByZXNzaW9uIGludG8gYSBzdGF0ZW1lbnQgc28gdGhhdFxuICAgICAgICAvLyBpdCBhbHdheXMgZHluYW1pY2FsbHkgcmVzb2x2ZXMgdGhlIG1ldGhvZCB0byBjYWxsICgjMjY3MClcbiAgICAgICAgLy8ga2luZGEgdWdseSBoYWNrLCBidXQgZG9lcyB0aGUgam9iLlxuICAgICAgICB2YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgICAgICBpZiAoaXNTaW1wbGVQYXRoKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlICs9ICcuYXBwbHkodGhpcywgJGFyZ3VtZW50cyknO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXIgPSAodm0uX3Njb3BlIHx8IHZtLl9jb250ZXh0KS4kZXZhbCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGhhbmRsZXIuX2Zyb21QYXJlbnQgPSB0cnVlO1xuICAgICAgICB2bS4kb24obmFtZS5yZXBsYWNlKGV2ZW50UkUpLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2tzIGZvciBvcHRpb24gZXZlbnRzIGFuZCB3YXRjaGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3Modm0sIGFjdGlvbiwgaGFzaCkge1xuICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgIHZhciBoYW5kbGVycywga2V5LCBpLCBqO1xuICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFzaFtrZXldO1xuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byByZWdpc3RlciBhbiBldmVudC93YXRjaCBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuICBmdW5jdGlvbiByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBoYW5kbGVyO1xuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bVthY3Rpb25dKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMgJiYgbWV0aG9kc1toYW5kbGVyXTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdm1bYWN0aW9uXShrZXksIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ1Vua25vd24gbWV0aG9kOiBcIicgKyBoYW5kbGVyICsgJ1wiIHdoZW4gJyArICdyZWdpc3RlcmluZyBjYWxsYmFjayBmb3IgJyArIGFjdGlvbiArICc6IFwiJyArIGtleSArICdcIi4nLCB2bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIuaGFuZGxlciwgaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHJlY3Vyc2l2ZSBhdHRhY2hlZC9kZXRhY2hlZCBjYWxsc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RE9NSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kb24oJ2hvb2s6YXR0YWNoZWQnLCBvbkF0dGFjaGVkKTtcbiAgICB0aGlzLiRvbignaG9vazpkZXRhY2hlZCcsIG9uRGV0YWNoZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25BdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsQXR0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBhdHRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsQXR0YWNoKGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRldGFjaGVkKCkge1xuICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxEZXRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGRldGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxEZXRhY2goY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgdGhpcy4kZW1pdCgncHJlLWhvb2s6JyArIGhvb2spO1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJG9wdGlvbnNbaG9va107XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSBsaW5rcyBhIERPTSBlbGVtZW50IHdpdGggYSBwaWVjZSBvZiBkYXRhLFxuICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24uXG4gKiBJdCByZWdpc3RlcnMgYSB3YXRjaGVyIHdpdGggdGhlIGV4cHJlc3Npb24gYW5kIGNhbGxzXG4gKiB0aGUgRE9NIHVwZGF0ZSBmdW5jdGlvbiB3aGVuIGEgY2hhbmdlIGlzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvclxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gbmFtZVxuICogICAgICAgICAgICAgICAgIC0ge09iamVjdH0gZGVmXG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXk8T2JqZWN0Pn0gW2ZpbHRlcnNdXG4gKiAgICAgICAgICAgICAgICAgLSB7T2JqZWN0fSBbbW9kaWZpZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFyZ1xuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gcmF3XG4gKiAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBbcmVmXVxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtpbnRlcnBdXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW2hhc09uZVRpbWVdXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF0gLSB0cmFuc2NsdXNpb24gaG9zdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIC0gdi1mb3Igc2NvcGVcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGlyZWN0aXZlKGRlc2NyaXB0b3IsIHZtLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgdGhpcy52bSA9IHZtO1xuICB0aGlzLmVsID0gZWw7XG4gIC8vIGNvcHkgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG4gIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG4gIHRoaXMubmFtZSA9IGRlc2NyaXB0b3IubmFtZTtcbiAgdGhpcy5leHByZXNzaW9uID0gZGVzY3JpcHRvci5leHByZXNzaW9uO1xuICB0aGlzLmFyZyA9IGRlc2NyaXB0b3IuYXJnO1xuICB0aGlzLm1vZGlmaWVycyA9IGRlc2NyaXB0b3IubW9kaWZpZXJzO1xuICB0aGlzLmZpbHRlcnMgPSBkZXNjcmlwdG9yLmZpbHRlcnM7XG4gIHRoaXMubGl0ZXJhbCA9IHRoaXMubW9kaWZpZXJzICYmIHRoaXMubW9kaWZpZXJzLmxpdGVyYWw7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gIHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIC8vIGxpbmsgY29udGV4dFxuICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5fZnJhZyA9IGZyYWc7XG4gIC8vIHN0b3JlIGRpcmVjdGl2ZXMgb24gbm9kZSBpbiBkZXYgbW9kZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgdGhpcy5lbC5fdnVlX2RpcmVjdGl2ZXMgPSB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyB8fCBbXTtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy5wdXNoKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGlyZWN0aXZlLCBtaXhpbiBkZWZpbml0aW9uIHByb3BlcnRpZXMsXG4gKiBzZXR1cCB0aGUgd2F0Y2hlciwgY2FsbCBkZWZpbml0aW9uIGJpbmQoKSBhbmQgdXBkYXRlKClcbiAqIGlmIHByZXNlbnQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuXG4gIC8vIHJlbW92ZSBhdHRyaWJ1dGVcbiAgaWYgKChuYW1lICE9PSAnY2xvYWsnIHx8IHRoaXMudm0uX2lzQ29tcGlsZWQpICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICB2YXIgYXR0ciA9IGRlc2NyaXB0b3IuYXR0ciB8fCAndi0nICsgbmFtZTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8vIGNvcHkgZGVmIHByb3BlcnRpZXNcbiAgdmFyIGRlZiA9IGRlc2NyaXB0b3IuZGVmO1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMudXBkYXRlID0gZGVmO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZCh0aGlzLCBkZWYpO1xuICB9XG5cbiAgLy8gc2V0dXAgZGlyZWN0aXZlIHBhcmFtc1xuICB0aGlzLl9zZXR1cFBhcmFtcygpO1xuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKCk7XG4gIH1cbiAgdGhpcy5fYm91bmQgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdyk7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZXhwcmVzc2lvbiB8fCB0aGlzLm1vZGlmaWVycykgJiYgKHRoaXMudXBkYXRlIHx8IHRoaXMudHdvV2F5KSAmJiAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKSkge1xuICAgIC8vIHdyYXBwZWQgdXBkYXRlciBmb3IgY29udGV4dFxuICAgIHZhciBkaXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlID0gbm9vcCQxO1xuICAgIH1cbiAgICB2YXIgcHJlUHJvY2VzcyA9IHRoaXMuX3ByZVByb2Nlc3MgPyBiaW5kKHRoaXMuX3ByZVByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQodGhpcy5fcG9zdFByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih0aGlzLnZtLCB0aGlzLmV4cHJlc3Npb24sIHRoaXMuX3VwZGF0ZSwgLy8gY2FsbGJhY2tcbiAgICB7XG4gICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICB0d29XYXk6IHRoaXMudHdvV2F5LFxuICAgICAgZGVlcDogdGhpcy5kZWVwLFxuICAgICAgcHJlUHJvY2VzczogcHJlUHJvY2VzcyxcbiAgICAgIHBvc3RQcm9jZXNzOiBwb3N0UHJvY2VzcyxcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuICAgIC8vIHYtbW9kZWwgd2l0aCBpbml0YWwgaW5saW5lIHZhbHVlIG5lZWQgdG8gc3luYyBiYWNrIHRvXG4gICAgLy8gbW9kZWwgaW5zdGVhZCBvZiB1cGRhdGUgdG8gRE9NIG9uIGluaXQuIFRoZXkgd291bGRcbiAgICAvLyBzZXQgdGhlIGFmdGVyQmluZCBob29rIHRvIGluZGljYXRlIHRoYXQuXG4gICAgaWYgKHRoaXMuYWZ0ZXJCaW5kKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlKHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhbGwgcGFyYW0gYXR0cmlidXRlcywgZS5nLiB0cmFjay1ieSxcbiAqIHRyYW5zaXRpb24tbW9kZSwgZXRjLi4uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAvLyBzd2FwIHRoZSBwYXJhbXMgYXJyYXkgd2l0aCBhIGZyZXNoIG9iamVjdC5cbiAgdGhpcy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaSA9IHBhcmFtcy5sZW5ndGg7XG4gIHZhciBrZXksIHZhbCwgbWFwcGVkS2V5O1xuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0gaHlwaGVuYXRlKHBhcmFtc1tpXSk7XG4gICAgbWFwcGVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICB2YWwgPSBnZXRCaW5kQXR0cih0aGlzLmVsLCBrZXkpO1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGF0aWNcbiAgICAgIHZhbCA9IGdldEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGEgd2F0Y2hlciBmb3IgYSBkeW5hbWljIHBhcmFtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbVdhdGNoZXIgPSBmdW5jdGlvbiAoa2V5LCBleHByZXNzaW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdW53YXRjaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kd2F0Y2goZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgc2VsZi5wYXJhbXNba2V5XSA9IHZhbDtcbiAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gaW1tZWRpYXRlIG1vZGUsXG4gICAgLy8gb25seSBjYWxsIHRoZSBwYXJhbSBjaGFuZ2UgY2FsbGJhY2tzIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5wYXJhbVdhdGNoZXJzICYmIHNlbGYucGFyYW1XYXRjaGVyc1trZXldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB1c2VyOiBmYWxzZVxuICB9KTsodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2godW53YXRjaCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgaWYgKGV4cHJlc3Npb24gJiYgdGhpcy5hY2NlcHRTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHByZXNzaW9uKSkge1xuICAgIHZhciBmbiA9IHBhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKS5nZXQ7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZTtcbiAgICAgIGZuLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICBoYW5kbGVyID0gc2NvcGUuX2FwcGx5RmlsdGVycyhoYW5kbGVyLCBudWxsLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oJ0RpcmVjdGl2ZS5zZXQoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0d29XYXknICsgJ2RpcmVjdGl2ZXMuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoaWxlIHByZXZlbnRpbmcgdGhhdCBmdW5jdGlvbiBmcm9tXG4gKiB0cmlnZ2VyaW5nIHVwZGF0ZXMgb24gdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX2xvY2tlZCA9IHRydWU7XG4gIGZuLmNhbGwoc2VsZik7XG4gIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICBvbih0aGlzLmVsLCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7KHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pKS5wdXNoKFtldmVudCwgaGFuZGxlcl0pO1xufTtcblxuLyoqXG4gKiBUZWFyZG93biB0aGUgd2F0Y2hlciBhbmQgY2FsbCB1bmJpbmQuXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZCkge1xuICAgIHRoaXMuX2JvdW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudW5iaW5kKSB7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2F0Y2hlcikge1xuICAgICAgdGhpcy5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBvZmYodGhpcy5lbCwgbGlzdGVuZXJzW2ldWzBdLCBsaXN0ZW5lcnNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW53YXRjaEZucyA9IHRoaXMuX3BhcmFtVW53YXRjaEZucztcbiAgICBpZiAodW53YXRjaEZucykge1xuICAgICAgaSA9IHVud2F0Y2hGbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1bndhdGNoRm5zW2ldKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIHRoaXMudm0gPSB0aGlzLmVsID0gdGhpcy5fd2F0Y2hlciA9IHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB2LXJlZiBmb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuX3JlZjtcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0KS4kcmVmcztcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgaWYgKHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNbcmVmXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2NsdWRlLCBjb21waWxlIGFuZCBsaW5rIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGEgcHJlLWNvbXBpbGVkIGxpbmtlciBpcyBhdmFpbGFibGUsIHRoYXQgbWVhbnMgdGhlXG4gICAqIHBhc3NlZCBpbiBlbGVtZW50IHdpbGwgYmUgcHJlLXRyYW5zY2x1ZGVkIGFuZCBjb21waWxlZFxuICAgKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICAgKlxuICAgKiBPdGhlcndpc2Ugd2UgbmVlZCB0byBjYWxsIHRyYW5zY2x1ZGUvY29tcGlsZS9saW5rIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblxuICAgIC8vIHRyYW5zY2x1ZGUgYW5kIGluaXQgZWxlbWVudFxuICAgIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgcmVmZXJlbmNlOyB0aGlzIHN0ZXAgYWxzbyBpbmplY3RzXG4gICAgLy8gdGhlIHRlbXBsYXRlIGFuZCBjYWNoZXMgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsID0gZWw7XG4gICAgZWwgPSB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0RWxlbWVudChlbCk7XG5cbiAgICAvLyBoYW5kbGUgdi1wcmUgb24gcm9vdCBub2RlICgjMjAyNilcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb290IGlzIGFsd2F5cyBjb21waWxlZCBwZXItaW5zdGFuY2UsIGJlY2F1c2VcbiAgICAvLyBjb250YWluZXIgYXR0cnMgYW5kIHByb3BzIGNhbiBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZS5cbiAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnM7XG4gICAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90IGRpc3RyaWJ1dGlvblxuICAgIHJlc29sdmVTbG90cyh0aGlzLCBvcHRpb25zLl9jb250ZW50KTtcblxuICAgIC8vIGNvbXBpbGUgYW5kIGxpbmsgdGhlIHJlc3RcbiAgICB2YXIgY29udGVudExpbmtGbjtcbiAgICB2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgLy8gY29tcG9uZW50IGNvbXBpbGF0aW9uIGNhbiBiZSBjYWNoZWRcbiAgICAvLyBhcyBsb25nIGFzIGl0J3Mgbm90IHVzaW5nIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChvcHRpb25zLl9saW5rZXJDYWNoYWJsZSkge1xuICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyO1xuICAgICAgaWYgKCFjb250ZW50TGlua0ZuKSB7XG4gICAgICAgIGNvbnRlbnRMaW5rRm4gPSBjdG9yLmxpbmtlciA9IGNvbXBpbGUoZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpbmsgcGhhc2VcbiAgICAvLyBtYWtlIHN1cmUgdG8gbGluayByb290IHdpdGggcHJvcCBzY29wZSFcbiAgICB2YXIgcm9vdFVubGlua0ZuID0gcm9vdExpbmtlcih0aGlzLCBlbCwgdGhpcy5fc2NvcGUpO1xuICAgIHZhciBjb250ZW50VW5saW5rRm4gPSBjb250ZW50TGlua0ZuID8gY29udGVudExpbmtGbih0aGlzLCBlbCkgOiBjb21waWxlKGVsLCBvcHRpb25zKSh0aGlzLCBlbCk7XG5cbiAgICAvLyByZWdpc3RlciBjb21wb3NpdGUgdW5saW5rIGZ1bmN0aW9uXG4gICAgLy8gdG8gYmUgY2FsbGVkIGR1cmluZyBpbnN0YW5jZSBkZXN0cnVjdGlvblxuICAgIHRoaXMuX3VubGlua0ZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcm9vdFVubGlua0ZuKCk7XG4gICAgICAvLyBwYXNzaW5nIGRlc3Ryb3lpbmc6IHRydWUgdG8gYXZvaWQgc2VhcmNoaW5nIGFuZFxuICAgICAgLy8gc3BsaWNpbmcgdGhlIGRpcmVjdGl2ZXNcbiAgICAgIGNvbnRlbnRVbmxpbmtGbih0cnVlKTtcbiAgICB9O1xuXG4gICAgLy8gZmluYWxseSByZXBsYWNlIG9yaWdpbmFsXG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZSkge1xuICAgICAgcmVwbGFjZShvcmlnaW5hbCwgZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQ29tcGlsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdjb21waWxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gICAqICRtb3VudCgpIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChpc0ZyYWdtZW50KGVsKSkge1xuICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG4gICAgICB0aGlzLiRlbCA9IHRoaXMuX2ZyYWdtZW50U3RhcnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgdGhpcy5fZnJhZ21lbnRFbmQgPSBlbC5sYXN0Q2hpbGQ7XG4gICAgICAvLyBzZXQgcGVyc2lzdGVkIHRleHQgYW5jaG9ycyB0byBlbXB0eVxuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50U3RhcnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRTdGFydC5kYXRhID0gdGhpcy5fZnJhZ21lbnRFbmQuZGF0YSA9ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5fZnJhZ21lbnQgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwgPSBlbDtcbiAgICB9XG4gICAgdGhpcy4kZWwuX192dWVfXyA9IHRoaXM7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZUNvbXBpbGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBiaW5kIGEgZGlyZWN0aXZlIHRvIGFuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gcGFyc2VkIGRpcmVjdGl2ZSBkZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgIC0gdGFyZ2V0IG5vZGVcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB0aGlzLl9kaXJlY3RpdmVzLnB1c2gobmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biBhbiBpbnN0YW5jZSwgdW5vYnNlcnZlcyB0aGUgZGF0YSwgdW5iaW5kIGFsbCB0aGVcbiAgICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgLSB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgIHZhciBwZW5kaW5nUmVtb3ZhbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAvLyBjYWxsYmFjayBvZiB0aGlzLiRyZW1vdmUoKSwgb3IgaWYgcmVtb3ZlIGFuZCBkZWZlckNsZWFudXAgYXJlIGZhbHNlLlxuICAgIC8vIEluIGFueSBjYXNlIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG90aGVyIHJlbW92aW5nLCB1bmJpbmRpbmcgYW5kXG4gICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgdmFyIGNsZWFudXBJZlBvc3NpYmxlID0gZnVuY3Rpb24gY2xlYW51cElmUG9zc2libGUoKSB7XG4gICAgICBpZiAoZGVzdHJveVJlYWR5ICYmICFwZW5kaW5nUmVtb3ZhbCAmJiAhZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgICAgcGVuZGluZ1JlbW92YWwgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZ1JlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQuIG9ubHkgbmVjZXNzYXJ5XG4gICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgLy8gdW5yZWdpc3RlciByZWYgKHJlbW92ZTogdHJ1ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICB9XG4gICAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gICAgaSA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgIGlmICh0aGlzLl9wcm9wc1VubGlua0ZuKSB7XG4gICAgICB0aGlzLl9wcm9wc1VubGlua0ZuKCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAgIC8vIGRpcmVjdGl2ZS1vd25lZCB3YXRjaGVycy5cbiAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3VubGlua0ZuKCk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveVJlYWR5ID0gdHJ1ZTtcbiAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBhbnkuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gb3duZXIgZnJhZ21lbnRcbiAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgIC8vIGRlZmVyIHJpZ2h0IHdoZW4gYSBmcmFnbWVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS5fX29iX18pIHtcbiAgICAgIHRoaXMuX2RhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCByZWZlcmVuY2VzIHRvIHByaXZhdGUgcHJvcGVydGllcyBhbmQgb3RoZXJcbiAgICAvLyBpbnN0YW5jZXMuIHByZXNlcnZlIHJlZmVyZW5jZSB0byBfZGF0YSBzbyB0aGF0IHByb3h5XG4gICAgLy8gYWNjZXNzb3JzIHN0aWxsIHdvcmsuIFRoZSBvbmx5IHBvdGVudGlhbCBzaWRlIGVmZmVjdFxuICAgIC8vIGhlcmUgaXMgdGhhdCBtdXRhdGluZyB0aGUgaW5zdGFuY2UgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgICAvLyBtYXkgYWZmZWN0IHRoZSBzdGF0ZSBvZiBvdGhlciBjb21wb25lbnRzIHRoYXQgYXJlIHN0aWxsXG4gICAgLy8gb2JzZXJ2aW5nIHRoZSBzYW1lIG9iamVjdCwgYnV0IHRoYXQgc2VlbXMgdG8gYmUgYVxuICAgIC8vIHJlYXNvbmFibGUgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB1c2VyIHJhdGhlciB0aGFuXG4gICAgLy8gYWx3YXlzIHRocm93aW5nIGFuIGVycm9yIG9uIHRoZW0uXG4gICAgdGhpcy4kZWwgPSB0aGlzLiRwYXJlbnQgPSB0aGlzLiRyb290ID0gdGhpcy4kY2hpbGRyZW4gPSB0aGlzLl93YXRjaGVycyA9IHRoaXMuX2NvbnRleHQgPSB0aGlzLl9zY29wZSA9IHRoaXMuX2RpcmVjdGl2ZXMgPSBudWxsO1xuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHRoaXMuX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB0aGlzLiRvZmYoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWlzY01peGluIChWdWUpIHtcbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlzdCBvZiBmaWx0ZXIgKGRlc2NyaXB0b3JzKSB0byBhIHZhbHVlLlxuICAgKiBVc2luZyBwbGFpbiBmb3IgbG9vcHMgaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAgICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICAgKiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBbb2xkVmFsdWVdXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnNcbiAgICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICAgIHZhciBmaWx0ZXIsIGZuLCBhcmdzLCBhcmcsIG9mZnNldCwgaSwgbCwgaiwgaztcbiAgICBmb3IgKGkgPSAwLCBsID0gZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlcnNbd3JpdGUgPyBsIC0gaSAtIDEgOiBpXTtcbiAgICAgIGZuID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyLm5hbWUsIHRydWUpO1xuICAgICAgaWYgKCFmbikgY29udGludWU7XG4gICAgICBmbiA9IHdyaXRlID8gZm4ud3JpdGUgOiBmbi5yZWFkIHx8IGZuO1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICBhcmdzID0gd3JpdGUgPyBbdmFsdWUsIG9sZFZhbHVlXSA6IFt2YWx1ZV07XG4gICAgICBvZmZzZXQgPSB3cml0ZSA/IDIgOiAxO1xuICAgICAgaWYgKGZpbHRlci5hcmdzKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGsgPSBmaWx0ZXIuYXJncy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXTtcbiAgICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWMgPyB0aGlzLiRnZXQoYXJnLnZhbHVlKSA6IGFyZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgY29tcG9uZW50LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgY29tcG9uZW50XG4gICAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICogUmVzb2x2ZXMgc3luY2hyb25vdXNseSBpZiBhbHJlYWR5IHJlc29sdmVkLCBvdGhlcndpc2VcbiAgICogcmVzb2x2ZXMgYXN5bmNocm9ub3VzbHkgYW5kIGNhY2hlcyB0aGUgcmVzb2x2ZWRcbiAgICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBjYikge1xuICAgIHZhciBmYWN0b3J5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZhY3RvcnkgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFjdG9yeSA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnY29tcG9uZW50cycsIHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgaWYgKCFmYWN0b3J5Lm9wdGlvbnMpIHtcbiAgICAgIGlmIChmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICAgIC8vIGNhY2hlZFxuICAgICAgICBjYihmYWN0b3J5LnJlc29sdmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICAgICAgZmFjdG9yeS5jYWxsKHRoaXMsIGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gVnVlLmV4dGVuZChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnOiAnICsgdmFsdWUgOiAnJykgKyAnLiAnICsgKHJlYXNvbiA/ICdcXG5SZWFzb246ICcgKyByZWFzb24gOiAnJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIGNvbXBvbmVudFxuICAgICAgY2IoZmFjdG9yeSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgZmlsdGVyUkUkMSA9IC9bXnxdXFx8W158XS87XG5cbmZ1bmN0aW9uIGRhdGFBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKGV4cCwgYXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKGFzU3RhdGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlbWVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXMuZ2V0LmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgICAgc2VsZi4kYXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVzLmdldC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICogVGhlIGV4cHJlc3Npb24gbXVzdCBiZSBhIHZhbGlkIGxlZnQtaGFuZFxuICAgKiBleHByZXNzaW9uIGluIGFuIGFzc2lnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAgICogQHBhcmFtIHsqfSB2YWxcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gKGV4cCwgdmFsKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRXhwcmVzc2lvbihleHAsIHRydWUpO1xuICAgIGlmIChyZXMgJiYgcmVzLnNldCkge1xuICAgICAgcmVzLnNldC5jYWxsKHRoaXMsIHRoaXMsIHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBwcm9wZXJ0eSBvbiB0aGUgVk1cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsKHRoaXMuX2RhdGEsIGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGV4cHJlc3Npb24sIHRyaWdnZXIgY2FsbGJhY2sgd2hlbiBpdHNcbiAgICogdmFsdWUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGV4cE9yRm5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZGVlcFxuICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gaW1tZWRpYXRlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIHVud2F0Y2hGblxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHBhcnNlZDtcbiAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZShleHBPckZuKTtcbiAgICAgIGV4cE9yRm4gPSBwYXJzZWQuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIHtcbiAgICAgIGRlZXA6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWVwLFxuICAgICAgc3luYzogb3B0aW9ucyAmJiBvcHRpb25zLnN5bmMsXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICB1c2VyOiAhb3B0aW9ucyB8fCBvcHRpb25zLnVzZXIgIT09IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGEgdGV4dCBkaXJlY3RpdmUsIGluY2x1ZGluZyBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRldmFsID0gZnVuY3Rpb24gKHRleHQsIGFzU3RhdGVtZW50KSB7XG4gICAgLy8gY2hlY2sgZm9yIGZpbHRlcnMuXG4gICAgaWYgKGZpbHRlclJFJDEudGVzdCh0ZXh0KSkge1xuICAgICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKHRleHQpO1xuICAgICAgLy8gdGhlIGZpbHRlciByZWdleCBjaGVjayBtaWdodCBnaXZlIGZhbHNlIHBvc2l0aXZlXG4gICAgICAvLyBmb3IgcGlwZXMgaW5zaWRlIHN0cmluZ3MsIHNvIGl0J3MgcG9zc2libGUgdGhhdFxuICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGFueSBmaWx0ZXJzIGhlcmVcbiAgICAgIHZhciB2YWwgPSB0aGlzLiRnZXQoZGlyLmV4cHJlc3Npb24sIGFzU3RhdGVtZW50KTtcbiAgICAgIHJldHVybiBkaXIuZmlsdGVycyA/IHRoaXMuX2FwcGx5RmlsdGVycyh2YWwsIG51bGwsIGRpci5maWx0ZXJzKSA6IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gZmlsdGVyXG4gICAgICByZXR1cm4gdGhpcy4kZ2V0KHRleHQsIGFzU3RhdGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgcGllY2Ugb2YgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dCh0ZXh0KTtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2bS4kZXZhbCh0b2tlbnNbMF0udmFsdWUpICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4udGFnID8gdm0uJGV2YWwodG9rZW4udmFsdWUpIDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZyBpbnN0YW5jZSBkYXRhIGFzIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAqIHNvIHRoYXQgaXQgaXMgZWFzaWVyIHRvIGluc3BlY3QgaW4gY29uc29sZS5cbiAgICogVGhpcyBtZXRob2QgYXNzdW1lcyBjb25zb2xlIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRsb2cgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBkYXRhID0gcGF0aCA/IGdldFBhdGgodGhpcy5fZGF0YSwgcGF0aCkgOiB0aGlzLl9kYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhID0gY2xlYW4oZGF0YSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgY29tcHV0ZWQgZmllbGRzXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBkYXRhW2tleV0gPSBjbGVhbih0aGlzW2tleV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY2xlYW4odGhpc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogXCJjbGVhblwiIGEgZ2V0dGVyL3NldHRlciBjb252ZXJ0ZWQgb2JqZWN0IGludG8gYSBwbGFpblxuICAgKiBvYmplY3QgY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IC0gb2JqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG9uLWluc3RhbmNlIG5leHRUaWNrLiBUaGUgY2FsbGJhY2sgaXNcbiAgICogYXV0by1ib3VuZCB0byB0aGUgaW5zdGFuY2UsIGFuZCB0aGlzIGF2b2lkcyBjb21wb25lbnRcbiAgICogbW9kdWxlcyBoYXZpbmcgdG8gcmVseSBvbiB0aGUgZ2xvYmFsIFZ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBpbnN0YW5jZSB0byB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFwcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYXBwZW5kLCBhcHBlbmRXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRwcmVwZW5kVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0LmZpcnN0Q2hpbGQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBiZWZvcmUgdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRiZWZvcmUgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMsIHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uLCBiZWZvcmVXaXRoQ2IsIGJlZm9yZVdpdGhUcmFuc2l0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGluc3RhbmNlIGFmdGVyIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYWZ0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24pIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuJGJlZm9yZSh0YXJnZXQubmV4dFNpYmxpbmcsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGFwcGVuZFRvKHRhcmdldC5wYXJlbnROb2RlLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGluc3RhbmNlIGZyb20gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRyZW1vdmUgPSBmdW5jdGlvbiAoY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICB9XG4gICAgdmFyIGluRG9jdW1lbnQgPSB0aGlzLl9pc0F0dGFjaGVkICYmIGluRG9jKHRoaXMuJGVsKTtcbiAgICAvLyBpZiB3ZSBhcmUgbm90IGluIGRvY3VtZW50LCBubyBuZWVkIHRvIGNoZWNrXG4gICAgLy8gZm9yIHRyYW5zaXRpb25zXG4gICAgaWYgKCFpbkRvY3VtZW50KSB3aXRoVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVhbENiID0gZnVuY3Rpb24gcmVhbENiKCkge1xuICAgICAgaWYgKGluRG9jdW1lbnQpIHNlbGYuX2NhbGxIb29rKCdkZXRhY2hlZCcpO1xuICAgICAgaWYgKGNiKSBjYigpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2lzRnJhZ21lbnQpIHtcbiAgICAgIHJlbW92ZU5vZGVSYW5nZSh0aGlzLl9mcmFnbWVudFN0YXJ0LCB0aGlzLl9mcmFnbWVudEVuZCwgdGhpcywgdGhpcy5fZnJhZ21lbnQsIHJlYWxDYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSA/IHJlbW92ZVdpdGhDYiA6IHJlbW92ZVdpdGhUcmFuc2l0aW9uO1xuICAgICAgb3AodGhpcy4kZWwsIHRoaXMsIHJlYWxDYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaGFyZWQgRE9NIGluc2VydGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMSAtIG9wIGZvciBub24tdHJhbnNpdGlvbiBpbnNlcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3AyIC0gb3AgZm9yIHRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEByZXR1cm4gdm1cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5zZXJ0KHZtLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgb3AxLCBvcDIpIHtcbiAgICB0YXJnZXQgPSBxdWVyeSh0YXJnZXQpO1xuICAgIHZhciB0YXJnZXRJc0RldGFjaGVkID0gIWluRG9jKHRhcmdldCk7XG4gICAgdmFyIG9wID0gd2l0aFRyYW5zaXRpb24gPT09IGZhbHNlIHx8IHRhcmdldElzRGV0YWNoZWQgPyBvcDEgOiBvcDI7XG4gICAgdmFyIHNob3VsZENhbGxIb29rID0gIXRhcmdldElzRGV0YWNoZWQgJiYgIXZtLl9pc0F0dGFjaGVkICYmICFpbkRvYyh2bS4kZWwpO1xuICAgIGlmICh2bS5faXNGcmFnbWVudCkge1xuICAgICAgbWFwTm9kZVJhbmdlKHZtLl9mcmFnbWVudFN0YXJ0LCB2bS5fZnJhZ21lbnRFbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG9wKG5vZGUsIHRhcmdldCwgdm0pO1xuICAgICAgfSk7XG4gICAgICBjYiAmJiBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcCh2bS4kZWwsIHRhcmdldCwgdm0sIGNiKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZENhbGxIb29rKSB7XG4gICAgICB2bS5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3Igc2VsZWN0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKSA6IGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBvcGVyYXRpb24gdGhhdCB0YWtlcyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VnVlfSB2bSAtIHVudXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlbCwgdGFyZ2V0LCB2bSwgY2IpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRCZWZvcmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBiZWZvcmVXaXRoQ2IoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVXaXRoQ2IoZWwsIHZtLCBjYikge1xuICAgIHJlbW92ZShlbCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c0FQSSAoVnVlKSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgc2VsZi4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBjYnM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtMSk7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHNob3VsZFByb3BhZ2F0ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBpc1NvdXJjZSB8fCAhY2JzO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGhhY2t5IHNvbHV0aW9uIHRvIHRoZSBxdWVzdGlvbiByYWlzZWRcbiAgICAgIC8vIGluICMyMTAyOiBmb3IgYW4gaW5saW5lIGNvbXBvbmVudCBsaXN0ZW5lciBsaWtlIDxjb21wIEB0ZXN0PVwiZG9UaGlzXCI+LFxuICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAvLyBuZWVkIHRvIHRyZWF0IHRoZXNlIGlubGluZSBjYWxsYmFja3MgZGlmZmVyZW50bHkuXG4gICAgICB2YXIgaGFzUGFyZW50Q2JzID0gaXNTb3VyY2UgJiYgY2JzLnNvbWUoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1BhcmVudENicykge1xuICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcbiAgICAgICAgdmFyIHJlcyA9IGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFByb3BhZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYnJvYWRjYXN0IGFuIGV2ZW50IHRvIGFsbCBjaGlsZHJlbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gICAgLy8gdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gYnJvYWRjYXN0LlxuICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW47XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgICAgLy8gb24gY2hpbGRyZW5cbiAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGNoaWxkLiRlbWl0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIGlmIChzaG91bGRQcm9wYWdhdGUpIHtcbiAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgIC8vIG9uIHBhcmVudHNcbiAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgc2hvdWxkUHJvcGFnYXRlID0gcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpc3RlbmVyIGNvdW50cyBvbiBhbGwgcGFyZW50cy5cbiAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgKiBubyBjaGlsZCBoYXMgbGlzdGVuZWQgdG8gYSBjZXJ0YWluIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICAgKi9cblxuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIGZ1bmN0aW9uIG1vZGlmeUxpc3RlbmVyQ291bnQodm0sIGV2ZW50LCBjb3VudCkge1xuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAgIC8vIHRvIGRvIGJvb2trZWVwaW5nIGZvciB0aGVtXG4gICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID0gKHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdIHx8IDApICsgY291bnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlQVBJIChWdWUpIHtcbiAgLyoqXG4gICAqIFNldCBpbnN0YW5jZSB0YXJnZXQgZWxlbWVudCBhbmQga2ljayBvZmYgdGhlIGNvbXBpbGF0aW9uXG4gICAqIHByb2Nlc3MuIFRoZSBwYXNzZWQgaW4gYGVsYCBjYW4gYmUgYSBzZWxlY3RvciBzdHJpbmcsIGFuXG4gICAqIGV4aXN0aW5nIEVsZW1lbnQsIG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIGJsb2NrXG4gICAqIGluc3RhbmNlcykuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fHN0cmluZ30gZWxcbiAgICogQHB1YmxpY1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLl9pc0NvbXBpbGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJyRtb3VudCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbCA9IHF1ZXJ5KGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICB0aGlzLl9jb21waWxlKGVsKTtcbiAgICB0aGlzLl9pbml0RE9NSG9va3MoKTtcbiAgICBpZiAoaW5Eb2ModGhpcy4kZWwpKSB7XG4gICAgICB0aGlzLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgICAgIHJlYWR5LmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG9uY2UoJ2hvb2s6YXR0YWNoZWQnLCByZWFkeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIGFuIGluc3RhbmNlIGFzIHJlYWR5LlxuICAgKi9cblxuICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICB0aGlzLl9pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9jYWxsSG9vaygncmVhZHknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgaW5zdGFuY2UsIHNpbXBseSBkZWxlZ2F0ZSB0byB0aGUgaW50ZXJuYWxcbiAgICogX2Rlc3Ryb3kuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlLCBkZWZlckNsZWFudXApIHtcbiAgICB0aGlzLl9kZXN0cm95KHJlbW92ZSwgZGVmZXJDbGVhbnVwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFydGlhbGx5IGNvbXBpbGUgYSBwaWVjZSBvZiBET00gYW5kIHJldHVybiBhXG4gICAqIGRlY29tcGlsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsXG4gICAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAgICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRjb21waWxlID0gZnVuY3Rpb24gKGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIHJldHVybiBjb21waWxlKGVsLCB0aGlzLiRvcHRpb25zLCB0cnVlKSh0aGlzLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBleHBvc2VkIFZ1ZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBBUEkgY29udmVudGlvbnM6XG4gKiAtIHB1YmxpYyBBUEkgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGAkYFxuICogLSBpbnRlcm5hbCBtZXRob2RzL3Byb3BlcnRpZXMgYXJlIHByZWZpeGVkIHdpdGggYF9gXG4gKiAtIG5vbi1wcmVmaXhlZCBwcm9wZXJ0aWVzIGFyZSBhc3N1bWVkIHRvIGJlIHByb3hpZWQgdXNlclxuICogICBkYXRhLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFZ1ZShvcHRpb25zKSB7XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbi8vIGluc3RhbGwgaW50ZXJuYWxzXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xubWlzY01peGluKFZ1ZSk7XG5cbi8vIGluc3RhbGwgaW5zdGFuY2UgQVBJc1xuZGF0YUFQSShWdWUpO1xuZG9tQVBJKFZ1ZSk7XG5ldmVudHNBUEkoVnVlKTtcbmxpZmVjeWNsZUFQSShWdWUpO1xuXG52YXIgc2xvdCA9IHtcblxuICBwcmlvcml0eTogU0xPVCxcbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIHRoaXMgd2FzIHJlc29sdmVkIGR1cmluZyBjb21wb25lbnQgdHJhbnNjbHVzaW9uXG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcmFtcy5uYW1lIHx8ICdkZWZhdWx0JztcbiAgICB2YXIgY29udGVudCA9IHRoaXMudm0uX3Nsb3RDb250ZW50cyAmJiB0aGlzLnZtLl9zbG90Q29udGVudHNbbmFtZV07XG4gICAgaWYgKCFjb250ZW50IHx8ICFjb250ZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy5mYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBpbGUoY29udGVudC5jbG9uZU5vZGUodHJ1ZSksIHRoaXMudm0uX2NvbnRleHQsIHRoaXMudm0pO1xuICAgIH1cbiAgfSxcblxuICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKGNvbnRlbnQsIGNvbnRleHQsIGhvc3QpIHtcbiAgICBpZiAoY29udGVudCAmJiBjb250ZXh0KSB7XG4gICAgICBpZiAodGhpcy5lbC5oYXNDaGlsZE5vZGVzKCkgJiYgY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBjb250ZW50LmNoaWxkTm9kZXNbMF0ubm9kZVR5cGUgPT09IDEgJiYgY29udGVudC5jaGlsZE5vZGVzWzBdLmhhc0F0dHJpYnV0ZSgndi1pZicpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBpbnNlcnRlZCBzbG90IGhhcyB2LWlmXG4gICAgICAgIC8vIGluamVjdCBmYWxsYmFjayBjb250ZW50IGFzIHRoZSB2LWVsc2VcbiAgICAgICAgdmFyIGVsc2VCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGVsc2VCbG9jay5zZXRBdHRyaWJ1dGUoJ3YtZWxzZScsICcnKTtcbiAgICAgICAgZWxzZUJsb2NrLmlubmVySFRNTCA9IHRoaXMuZWwuaW5uZXJIVE1MO1xuICAgICAgICAvLyB0aGUgZWxzZSBibG9jayBzaG91bGQgYmUgY29tcGlsZWQgaW4gY2hpbGQgc2NvcGVcbiAgICAgICAgZWxzZUJsb2NrLl9jb250ZXh0ID0gdGhpcy52bTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbHNlQmxvY2spO1xuICAgICAgfVxuICAgICAgdmFyIHNjb3BlID0gaG9zdCA/IGhvc3QuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoY29udGVudCwgaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIH1cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgdGhpcy5jb21waWxlKGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpLCB0aGlzLnZtKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy51bmxpbmspIHtcbiAgICAgIHRoaXMudW5saW5rKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGFydGlhbCA9IHtcblxuICBwcmlvcml0eTogUEFSVElBTCxcblxuICBwYXJhbXM6IFsnbmFtZSddLFxuXG4gIC8vIHdhdGNoIGNoYW5nZXMgdG8gbmFtZSBmb3IgZHluYW1pYyBwYXJ0aWFsc1xuICBwYXJhbVdhdGNoZXJzOiB7XG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSh2YWx1ZSkge1xuICAgICAgdklmLnJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1wYXJ0aWFsJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5wYXJhbXMubmFtZSk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoaWQpIHtcbiAgICB2YXIgcGFydGlhbCA9IHJlc29sdmVBc3NldCh0aGlzLnZtLiRvcHRpb25zLCAncGFydGlhbHMnLCBpZCwgdHJ1ZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbCk7XG4gICAgICB2SWYuaW5zZXJ0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZWxlbWVudERpcmVjdGl2ZXMgPSB7XG4gIHNsb3Q6IHNsb3QsXG4gIHBhcnRpYWw6IHBhcnRpYWxcbn07XG5cbnZhciBjb252ZXJ0QXJyYXkgPSB2Rm9yLl9wb3N0UHJvY2VzcztcblxuLyoqXG4gKiBMaW1pdCBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IChEZWNpbWFsIGV4cGVjdGVkKVxuICovXG5cbmZ1bmN0aW9uIGxpbWl0QnkoYXJyLCBuLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID8gcGFyc2VJbnQob2Zmc2V0LCAxMCkgOiAwO1xuICBuID0gdG9OdW1iZXIobik7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgPyBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKSA6IGFycjtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlbGltaXRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSAuLi5kYXRhS2V5c1xuICovXG5cbmZ1bmN0aW9uIGZpbHRlckJ5KGFyciwgc2VhcmNoLCBkZWxpbWl0ZXIpIHtcbiAgYXJyID0gY29udmVydEFycmF5KGFycik7XG4gIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihzZWFyY2gpO1xuICB9XG4gIC8vIGNhc3QgdG8gbG93ZXJjYXNlIHN0cmluZ1xuICBzZWFyY2ggPSAoJycgKyBzZWFyY2gpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIGFsbG93IG9wdGlvbmFsIGBpbmAgZGVsaW1pdGVyXG4gIC8vIGJlY2F1c2Ugd2h5IG5vdFxuICB2YXIgbiA9IGRlbGltaXRlciA9PT0gJ2luJyA/IDMgOiAyO1xuICAvLyBleHRyYWN0IGFuZCBmbGF0dGVuIGtleXNcbiAgdmFyIGtleXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0b0FycmF5KGFyZ3VtZW50cywgbikpO1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpdGVtLCBrZXksIHZhbCwgajtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IGFycltpXTtcbiAgICB2YWwgPSBpdGVtICYmIGl0ZW0uJHZhbHVlIHx8IGl0ZW07XG4gICAgaiA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChqKSB7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGtleSA9IGtleXNbal07XG4gICAgICAgIGlmIChrZXkgPT09ICcka2V5JyAmJiBjb250YWlucyhpdGVtLiRrZXksIHNlYXJjaCkgfHwgY29udGFpbnMoZ2V0UGF0aCh2YWwsIGtleSksIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXMucHVzaChpdGVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGFpbnMoaXRlbSwgc2VhcmNoKSkge1xuICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8U3RyaW5nPnxGdW5jdGlvbn0gLi4uc29ydEtleXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3JkZXJdXG4gKi9cblxuZnVuY3Rpb24gb3JkZXJCeShhcnIpIHtcbiAgdmFyIGNvbXBhcmF0b3IgPSBudWxsO1xuICB2YXIgc29ydEtleXMgPSB1bmRlZmluZWQ7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuXG4gIC8vIGRldGVybWluZSBvcmRlciAobGFzdCBhcmd1bWVudClcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gIHZhciBvcmRlciA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcbiAgICBvcmRlciA9IG9yZGVyIDwgMCA/IC0xIDogMTtcbiAgICBhcmdzID0gYXJncy5sZW5ndGggPiAxID8gYXJncy5zbGljZSgwLCAtMSkgOiBhcmdzO1xuICB9IGVsc2Uge1xuICAgIG9yZGVyID0gMTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBzb3J0S2V5cyAmIGNvbXBhcmF0b3JcbiAgdmFyIGZpcnN0QXJnID0gYXJnc1swXTtcbiAgaWYgKCFmaXJzdEFyZykge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gY3VzdG9tIGNvbXBhcmF0b3JcbiAgICBjb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmaXJzdEFyZyhhLCBiKSAqIG9yZGVyO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyaW5nIGtleXMuIGZsYXR0ZW4gZmlyc3RcbiAgICBzb3J0S2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3MpO1xuICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYiwgaSkge1xuICAgICAgaSA9IGkgfHwgMDtcbiAgICAgIHJldHVybiBpID49IHNvcnRLZXlzLmxlbmd0aCAtIDEgPyBiYXNlQ29tcGFyZShhLCBiLCBpKSA6IGJhc2VDb21wYXJlKGEsIGIsIGkpIHx8IGNvbXBhcmF0b3IoYSwgYiwgaSArIDEpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlQ29tcGFyZShhLCBiLCBzb3J0S2V5SW5kZXgpIHtcbiAgICB2YXIgc29ydEtleSA9IHNvcnRLZXlzW3NvcnRLZXlJbmRleF07XG4gICAgaWYgKHNvcnRLZXkpIHtcbiAgICAgIGlmIChzb3J0S2V5ICE9PSAnJGtleScpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGIpICYmICckdmFsdWUnIGluIGIpIGIgPSBiLiR2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgICAgYiA9IGlzT2JqZWN0KGIpID8gZ2V0UGF0aChiLCBzb3J0S2V5KSA6IGI7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXI7XG4gIH1cblxuICAvLyBzb3J0IG9uIGEgY29weSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBhcnJheVxuICByZXR1cm4gYXJyLnNsaWNlKCkuc29ydChjb21wYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBTdHJpbmcgY29udGFpbiBoZWxwZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHZhbCwgc2VhcmNoKSB7XG4gIHZhciBpO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2tleXNbaV1dLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY29udGFpbnModmFsW2ldLCBzZWFyY2gpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+IC0xO1xuICB9XG59XG5cbnZhciBkaWdpdHNSRSA9IC8oXFxkezN9KSg/PVxcZCkvZztcblxuLy8gYXNzZXQgY29sbGVjdGlvbnMgbXVzdCBiZSBhIHBsYWluIG9iamVjdC5cbnZhciBmaWx0ZXJzID0ge1xuXG4gIG9yZGVyQnk6IG9yZGVyQnksXG4gIGZpbHRlckJ5OiBmaWx0ZXJCeSxcbiAgbGltaXRCeTogbGltaXRCeSxcblxuICAvKipcbiAgICogU3RyaW5naWZ5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZW50XG4gICAqL1xuXG4gIGpzb246IHtcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKHZhbHVlLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBpbmRlbnQgOiAyKTtcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQWJjJ1xuICAgKi9cblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FCQydcbiAgICovXG5cbiAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogJ0FiQycgPT4gJ2FiYydcbiAgICovXG5cbiAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogMTIzNDUgPT4gJDEyLDM0NS4wMFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbHMgRGVjaW1hbCBwbGFjZXNcbiAgICovXG5cbiAgY3VycmVuY3k6IGZ1bmN0aW9uIGN1cnJlbmN5KHZhbHVlLCBfY3VycmVuY3ksIGRlY2ltYWxzKSB7XG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSB8fCAhdmFsdWUgJiYgdmFsdWUgIT09IDApIHJldHVybiAnJztcbiAgICBfY3VycmVuY3kgPSBfY3VycmVuY3kgIT0gbnVsbCA/IF9jdXJyZW5jeSA6ICckJztcbiAgICBkZWNpbWFscyA9IGRlY2ltYWxzICE9IG51bGwgPyBkZWNpbWFscyA6IDI7XG4gICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgIHZhciBfaW50ID0gZGVjaW1hbHMgPyBzdHJpbmdpZmllZC5zbGljZSgwLCAtMSAtIGRlY2ltYWxzKSA6IHN0cmluZ2lmaWVkO1xuICAgIHZhciBpID0gX2ludC5sZW5ndGggJSAzO1xuICAgIHZhciBoZWFkID0gaSA+IDAgPyBfaW50LnNsaWNlKDAsIGkpICsgKF9pbnQubGVuZ3RoID4gMyA/ICcsJyA6ICcnKSA6ICcnO1xuICAgIHZhciBfZmxvYXQgPSBkZWNpbWFscyA/IHN0cmluZ2lmaWVkLnNsaWNlKC0xIC0gZGVjaW1hbHMpIDogJyc7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICByZXR1cm4gc2lnbiArIF9jdXJyZW5jeSArIGhlYWQgKyBfaW50LnNsaWNlKGkpLnJlcGxhY2UoZGlnaXRzUkUsICckMSwnKSArIF9mbG9hdDtcbiAgfSxcblxuICAvKipcbiAgICogJ2l0ZW0nID0+ICdpdGVtcydcbiAgICpcbiAgICogQHBhcmFtc1xuICAgKiAgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb3JyZXNwb25kaW5nIHRvXG4gICAqICB0aGUgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSAuLi4gZm9ybXMgb2YgdGhlIHdvcmQgdG9cbiAgICogIGJlIHBsdXJhbGl6ZWQuIFdoZW4gdGhlIG51bWJlciB0byBiZSBwbHVyYWxpemVkXG4gICAqICBleGNlZWRzIHRoZSBsZW5ndGggb2YgdGhlIGFyZ3MsIGl0IHdpbGwgdXNlIHRoZSBsYXN0XG4gICAqICBlbnRyeSBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqICBlLmcuIFsnc2luZ2xlJywgJ2RvdWJsZScsICd0cmlwbGUnLCAnbXVsdGlwbGUnXVxuICAgKi9cblxuICBwbHVyYWxpemU6IGZ1bmN0aW9uIHBsdXJhbGl6ZSh2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gdmFsdWUgJSAxMCAtIDE7XG4gICAgICByZXR1cm4gaW5kZXggaW4gYXJncyA/IGFyZ3NbaW5kZXhdIDogYXJnc1tsZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWJvdW5jZSBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5ID0gMzAwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoaGFuZGxlciwgZGVsYXkpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICBpZiAoIWRlbGF5KSB7XG4gICAgICBkZWxheSA9IDMwMDtcbiAgICB9XG4gICAgcmV0dXJuIF9kZWJvdW5jZShoYW5kbGVyLCBkZWxheSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluc3RhbGxHbG9iYWxBUEkgKFZ1ZSkge1xuICAvKipcbiAgICogVnVlIGFuZCBldmVyeSBjb25zdHJ1Y3RvciB0aGF0IGV4dGVuZHMgVnVlIGhhcyBhblxuICAgKiBhc3NvY2lhdGVkIG9wdGlvbnMgb2JqZWN0LCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgZHVyaW5nXG4gICAqIGNvbXBpbGF0aW9uIHN0ZXBzIGFzIGB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnNgLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgc2VlbiBhcyB0aGUgZGVmYXVsdCBvcHRpb25zIG9mIGV2ZXJ5XG4gICAqIFZ1ZSBpbnN0YW5jZS5cbiAgICovXG5cbiAgVnVlLm9wdGlvbnMgPSB7XG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcbiAgICBlbGVtZW50RGlyZWN0aXZlczogZWxlbWVudERpcmVjdGl2ZXMsXG4gICAgZmlsdGVyczogZmlsdGVycyxcbiAgICB0cmFuc2l0aW9uczoge30sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgcGFydGlhbHM6IHt9LFxuICAgIHJlcGxhY2U6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogRXhwb3NlIHVzZWZ1bCBpbnRlcm5hbHNcbiAgICovXG5cbiAgVnVlLnV0aWwgPSB1dGlsO1xuICBWdWUuY29uZmlnID0gY29uZmlnO1xuICBWdWUuc2V0ID0gc2V0O1xuICBWdWVbJ2RlbGV0ZSddID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNhZ2UgLyBwbHVnaW5zXG4gICAqL1xuXG4gIFZ1ZS5jb21waWxlciA9IGNvbXBpbGVyO1xuICBWdWUuRnJhZ21lbnRGYWN0b3J5ID0gRnJhZ21lbnRGYWN0b3J5O1xuICBWdWUuaW50ZXJuYWxEaXJlY3RpdmVzID0gaW50ZXJuYWxEaXJlY3RpdmVzO1xuICBWdWUucGFyc2VycyA9IHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHRleHQ6IHRleHQsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGRpcmVjdGl2ZTogZGlyZWN0aXZlLFxuICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgfTtcblxuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuZE9wdGlvbnNcbiAgICovXG5cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgaXNGaXJzdEV4dGVuZCA9IFN1cGVyLmNpZCA9PT0gMDtcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCAmJiBleHRlbmRPcHRpb25zLl9DdG9yKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWNhdGVycyBhbmQgdGhlIGh5cGhlbi4nKTtcbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBTdWIgPSBjcmVhdGVDbGFzcyhuYW1lIHx8ICdWdWVDb21wb25lbnQnKTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzRmlyc3RFeHRlbmQpIHtcbiAgICAgIGV4dGVuZE9wdGlvbnMuX0N0b3IgPSBTdWI7XG4gICAgfVxuICAgIHJldHVybiBTdWI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3ViLWNsYXNzIGNvbnN0cnVjdG9yIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUuIFRoaXMgZ2l2ZXMgdXMgbXVjaCBuaWNlciBvdXRwdXQgd2hlblxuICAgKiBsb2dnaW5nIGluc3RhbmNlcyBpbiB0aGUgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKG5hbWUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyAqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiAnICsgY2xhc3NpZnkobmFtZSkgKyAnIChvcHRpb25zKSB7IHRoaXMuX2luaXQob3B0aW9ucykgfScpKCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYyAqL1xuICB9XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBzeXN0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblxuICAgKi9cblxuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIGdsb2JhbCBtaXhpbiBieSBtZXJnaW5nIGl0IGludG8gdGhlIGRlZmF1bHRcbiAgICogb3B0aW9ucy5cbiAgICovXG5cbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgVnVlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoVnVlLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBzaWduYXR1cmU6XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0geyp9IGRlZmluaXRpb25cbiAgICovXG5cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiAoY29tbW9uVGFnUkUudGVzdChpZCkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGlkKSkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBpZiAoIWRlZmluaXRpb24ubmFtZSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmluaXRpb24gPSBWdWUuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvc2UgaW50ZXJuYWwgdHJhbnNpdGlvbiBBUElcbiAgZXh0ZW5kKFZ1ZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uKTtcbn1cblxuaW5zdGFsbEdsb2JhbEFQSShWdWUpO1xuXG5WdWUudmVyc2lvbiA9ICcxLjAuMjYnO1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5Ccm93c2VyICYmIC9DaHJvbWVcXC9cXGQrLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgfVxuICB9XG59LCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLzEuMC4yNi92dWUvZGlzdC92dWUuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Byb2Nlc3MvMC4xMS41L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4vKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4wXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDctMDdUMjE6NDRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4xLjBcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuMFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDRcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOlxuXHQvLyBJRTogKltkaXNhYmxlZF06bm90KGJ1dHRvbiwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIG9wdGdyb3VwLCBvcHRpb24sIG1lbnVpdGVtLCBmaWVsZHNldClcblx0Ly8gbm90IElFOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9ybSBlbGVtZW50cyBhbmQgb3B0aW9uIGVsZW1lbnRzIGZvciBleHBsaWNpdCBkaXNhYmxpbmdcblx0XHRyZXR1cm4gXCJsYWJlbFwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0Ly8gQ2hlY2sgbm9uLWRpc2FibGVkIGZvcm0gZWxlbWVudHMgZm9yIGZpZWxkc2V0W2Rpc2FibGVkXSBhbmNlc3RvcnNcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgKFxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTYtMTErXG5cdFx0XHRcdC8vIEFuY2VzdHJ5IGlzIGNvdmVyZWQgZm9yIHVzXG5cdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGFzc3VtZSBhbnkgbm9uLTxvcHRpb24+IHVuZGVyIGZpZWxkc2V0W2Rpc2FibGVkXSBpcyBkaXNhYmxlZFxuXHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHQoXCJsYWJlbFwiIGluIGVsZW0gfHwgIWRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSkgIT09IGRpc2FibGVkXG5cdFx0XHQpO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0XHRyZXNvbHZlLmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0ICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBKU09OLnBhcnNlKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICksXG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbCxcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0dmFsID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdO1xuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiByYWYoKSB7XG5cdGlmICggdGltZXJJZCApIHtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKTtcblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRvcHQuZHVyYXRpb24gPSB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRcdG9wdC5kdXJhdGlvbiA6IG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID9cblx0XHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgP1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICkgOlxuXHRcdFx0d2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGlmICggd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSggdGltZXJJZCApO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdH1cblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVuY2FjaGVkIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIlwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbiwgcmVjdCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBlbGVtZW50IGlzIG5vdCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpXG5cdFx0aWYgKCByZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0ICkge1xuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2pxdWVyeS8zLjEuMC9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcQXBwLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTA2OTI1MTBiL0FwcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9BcHAudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuYm9keSB7XFxuICAgIG1hcmdpbjogMDtcXG59XFxuXFxuaHRtbCxcXG5ib2R5IHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4udGFibGUge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG59XFxuXFxuZGl2Lm1vZGFsIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC42KTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHotaW5kZXg6IDk5OTtcXG59XFxuXFxuLnRhYmxlLWNlbGwge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvQXBwLnZ1ZT80NzFkYjk5ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnSkE7SUFDQSxVQUFBO0NBQ0E7O0FBRUE7O0lBRUEsYUFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLG9DQUFBO0lBQ0EsU0FBQTtJQUNBLFFBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0EsbUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiQXBwLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgICAgIGJhY2tncm91bmRcXG4gICAgICAgIG1lbnUtYmFyKHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIix2LWJpbmQ6bm90aWNlPVxcXCJub3RpY2VcXFwiLHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIilcXG4gICAgICAgIGJldC1hbmQtYm9udXModi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmxvY2ttb25leT1cXFwibG9ja21vbmV5XFxcIix2LWJpbmQ6ZXJyb3Iuc3luYz1cXFwiZXJyb3JcXFwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XFxcImxvdHRlcnludW1cXFwiLHYtYmluZDpjb3VudC1kb3duLnN5bmM9XFxcImNvdW50RG93blxcXCIsdi1iaW5kOmNvdW50LW51bS5zeW5jPVxcXCJjb3VudE51bVxcXCIpXFxuICAgICAgICBwbGF5LXBhbmVsKHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIix2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIix2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiLHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiLHYtYmluZDpsb2NrbW9uZXk9XFxcImxvY2ttb25leVxcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIix2LWJpbmQ6bG90dGVyeW51bS5zeW5jPVxcXCJsb3R0ZXJ5bnVtXFxcIix2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVxcXCJjb3VudERvd25cXFwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cXFwiY291bnROdW1cXFwiKVxcbiAgICAgICAgc3RhdGUodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDp1c2VyLWJldD1cXFwidXNlckJldFxcXCIsdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIsdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIilcXG4gICAgICAgIC8vLSBiZXQtbXVsdGlwbGVcXG4gICAgICAgIG1lc3NhZ2Uodi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiLHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiLHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiLHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIpXFxuICAgICAgICBtb2RhbC5tb2RhbCh2LWlmPVxcXCJlcnJvclxcXCIpXFxuICAgICAgICB0aXAtbW9kYWxcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuaW1wb3J0IEJhY2tncm91bmQgZnJvbSAnLi9jb21wb25lbnRzL0JhY2tncm91bmQudnVlJ1xcbmltcG9ydCBNZW51QmFyIGZyb20gJy4vY29tcG9uZW50cy9NZW51QmFyLnZ1ZSdcXG5pbXBvcnQgQmV0QW5kQm9udXMgZnJvbSAnLi9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSdcXG5pbXBvcnQgUGxheVBhbmVsIGZyb20gJy4vY29tcG9uZW50cy9QbGF5UGFuZWwudnVlJ1xcbmltcG9ydCBTdGF0ZSBmcm9tICcuL2NvbXBvbmVudHMvU3RhdGUudnVlJ1xcbmltcG9ydCBCZXRNdWx0aXBsZSBmcm9tICcuL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlJ1xcbmltcG9ydCBNZXNzYWdlIGZyb20gJy4vY29tcG9uZW50cy9NZXNzYWdlLnZ1ZSdcXG5pbXBvcnQgZ2FtZURhdGEgZnJvbSAnLi9kYXRhL2RhdGEnIC8vICDliqDovb3mqKHmnb/mlbDmja5cXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBwcm9wczogW10sXFxuICAgIHJlYWR5KCkge1xcbiAgICAgICAgbGV0IHRoYXQgPSB0aGlzXFxuICAgICAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxcbiAgICAgICAgICAgIHRoYXQuc2NyZWVuU2l6ZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuaW5pdCgpXFxuICAgIH0sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHVzZXJCZXQ6IHtcXG4gICAgICAgICAgICAgICAgYmV0bW9uZXk6IDEwMDAgLy/pu5jorqTkuIvms6jph5Hpop3kuLoxMDAwXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBnYW1lRGF0YTogZ2FtZURhdGEsXFxuICAgICAgICAgICAgbG90dGVyeW51bTogeyAvL+W8gOWllue7k+aenFxcbiAgICAgICAgICAgICAgICBpZDogJycsXFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogMCxcXG4gICAgICAgICAgICAgICAgbG90dGVyeW51bXM6ICcnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjb3VudERvd246IDMwMCwgLy8g5YCS6K6h5pe256eS5pWwXFxuICAgICAgICAgICAgY291bnROdW06IDMwMCwgLy/lvIDlpZbml7bpl7Tpl7TpmpQg6buY6K6kM+WIhumSn1xcbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcXG4gICAgICAgICAgICBiZXRzOiBbXSwgLy8g5LiL5rOo6ZuG5ZCI77yM5Y+v5Lul5Y2V5qyh5LiL5aSa5rOoXFxuICAgICAgICAgICAgbm90aWNlOiByZXF1aXJlKCcuL2RhdGEvbm90aWNlJyksXFxuICAgICAgICAgICAgdXNlcmluZm86IHJlcXVpcmUoJy4vZGF0YS9zaW5nbGV1c2VyJyksXFxuICAgICAgICAgICAgc3RhZ2VTaXplOiB7IC8vIOaVtOS9k+eUu+W4g+Wkp+WwjyzmiYDmnInlj5jljJbnu4Tku7blho3mrKHln7rnoYDkuIrkuZjku6XmlL7lpKflgI3njodcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDY0MCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDA4XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzY3JlZW5TaXplOiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIGluaXQoKSB7XFxuICAgICAgICAgICAgLy8g5Yid5aeL5YyW6K+75Y+W5pWw5o2uXFxuXFxuICAgICAgICAgICAgLy8g6K+75Y+W5byA5aWW5pWw5o2uXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKHJlcyA9PiB0aGlzLmxvdHRlcnludW0gPSByZXMuZGF0YSlcXG4gICAgICAgICAgICB0aGlzLmdldFVzZXJJbmZvQnlOZXQoKVxcbiAgICAgICAgICAgICAgICAvLyDojrflj5blhazlkYrmlbDmja5cXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdnZXRMYXN0Tm90aWNlJylcXG4gICAgICAgIH0sXFxuICAgICAgICBzaG93KCkge30sXFxuICAgICAgICBnZXRVc2VySW5mb0J5TmV0KCkgeyAvL+S7jue9kee7nOiOt+WPlnVzZXLkv6Hmga9cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyQ29kZUZyb21OZXQoUmVxdWVzdExpc3QuZ2V0Q29kZSgpKS50aGVuKHJlcyA9PiB7XFxuICAgICAgICAgICAgICAgIC8vIOiOt+WPlueUqOaIt+aVsOaNrlxcbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhhdC51c2VyaW5mbywgcmVzLmRhdGEpXFxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcXG4gICAgICAgICAgICB9LCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMuZGF0YSkpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICB6b29tUmF0ZSgpIHsgLy8g5Yid5aeL5YyW5pS+5aSn5YCN546HXFxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnNjcmVlblNpemUud2lkdGggLyB0aGlzLnN0YWdlU2l6ZS53aWR0aFxcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY3JlZW5TaXplLmhlaWdodCAvIHRoaXMuc3RhZ2VTaXplLmhlaWdodFxcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHg6IHgsXFxuICAgICAgICAgICAgICAgIHk6IHlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbG9ja21vbmV5KCkgeyAvL+mUgeWumumHkeminVxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJldHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmV0c1tpXS5iZXRtb25leVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGV2ZW50czoge1xcbiAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcXG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3Nob3dNZXNzYWdlJywgZXZlbnQpXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0VXNlckluZm8oZXZlbnQpIHtcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyaW5mbyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmluZm8pKSkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzLmRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoYXQudXNlcmluZm8sIHJlcy5kYXRhKVxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LnVzZXJpbmZvT3BlbmlkID0gcmVzLmRhdGEub3BlbmlkXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0TGFzdE5vdGljZShldmVudCkge1xcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldExhc3ROb3RpY2UoKS50aGVuKHJlcyA9PiB0aGlzLm5vdGljZSA9IHJlcy5kYXRhLCByZXMgPT4gY29uc29sZS5lcnJvcihyZXMpKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNhbmNlbGJldChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnY2FuY2VsQmV0JylcXG4gICAgICAgIH0sXFxuICAgICAgICByZWxvYWRpbmZvKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5pbml0KClcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDop6blj5HplJnor6/vvIzlubbmiZPlvIDpga7nvanlsYJcXG4gICAgICAgIGVycm9yKCkge1xcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2hvd1RpcChldmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd1RpcCcsIGV2ZW50KVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wb25lbnRzOiB7XFxuICAgICAgICAnbW9kYWwnOiB7XFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJtb2RhbFxcXCI+PC9kaXY+J1xcbiAgICAgICAgfSxcXG4gICAgICAgICd0aXAtbW9kYWwnOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZScpLFxcbiAgICAgICAgJ2JhY2tncm91bmQnOiBCYWNrZ3JvdW5kLFxcbiAgICAgICAgJ21lbnUtYmFyJzogTWVudUJhcixcXG4gICAgICAgICdiZXQtYW5kLWJvbnVzJzogQmV0QW5kQm9udXMsXFxuICAgICAgICAncGxheS1wYW5lbCc6IFBsYXlQYW5lbCxcXG4gICAgICAgICdzdGF0ZSc6IFN0YXRlLFxcbiAgICAgICAgJ2JldC1tdWx0aXBsZSc6IEJldE11bHRpcGxlLFxcbiAgICAgICAgJ21lc3NhZ2UnOiBNZXNzYWdlXFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbmJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxufVxcblxcbmRpdi5tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAuNik7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiA5OTk7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL0FwcC52dWVcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH0pLFxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG5cdFx0aWYobmV3T2JqKSB7XG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlcztcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdGlmIChtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG5cdFx0Ly8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuXHRcdGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJztcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgICBtZW51LWJhcih2LWJpbmQ6Z2FtZS1kYXRhPVwiZ2FtZURhdGFcIix2LWJpbmQ6bm90aWNlPVwibm90aWNlXCIsdi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIpXG4gICAgICAgIGJldC1hbmQtYm9udXModi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHBsYXktcGFuZWwodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6dXNlci1iZXQ9XCJ1c2VyQmV0XCIsdi1iaW5kOmJldHMuc3luYz1cImJldHNcIix2LWJpbmQ6bG9ja21vbmV5PVwibG9ja21vbmV5XCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiLHYtYmluZDpsb3R0ZXJ5bnVtLnN5bmM9XCJsb3R0ZXJ5bnVtXCIsdi1iaW5kOmNvdW50LWRvd24uc3luYz1cImNvdW50RG93blwiLHYtYmluZDpjb3VudC1udW0uc3luYz1cImNvdW50TnVtXCIpXG4gICAgICAgIHN0YXRlKHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiLHYtYmluZDp1c2VyaW5mbz1cInVzZXJpbmZvXCIsdi1iaW5kOnVzZXItYmV0PVwidXNlckJldFwiLHYtYmluZDpiZXRzLnN5bmM9XCJiZXRzXCIsdi1iaW5kOmVycm9yLnN5bmM9XCJlcnJvclwiKVxuICAgICAgICAvLy0gYmV0LW11bHRpcGxlXG4gICAgICAgIG1lc3NhZ2Uodi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIsdi1iaW5kOnVzZXJpbmZvPVwidXNlcmluZm9cIix2LWJpbmQ6YmV0cy5zeW5jPVwiYmV0c1wiLHYtYmluZDplcnJvci5zeW5jPVwiZXJyb3JcIilcbiAgICAgICAgbW9kYWwubW9kYWwodi1pZj1cImVycm9yXCIpXG4gICAgICAgIHRpcC1tb2RhbFxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tICcuL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWUnXG5pbXBvcnQgTWVudUJhciBmcm9tICcuL2NvbXBvbmVudHMvTWVudUJhci52dWUnXG5pbXBvcnQgQmV0QW5kQm9udXMgZnJvbSAnLi9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZSdcbmltcG9ydCBQbGF5UGFuZWwgZnJvbSAnLi9jb21wb25lbnRzL1BsYXlQYW5lbC52dWUnXG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9jb21wb25lbnRzL1N0YXRlLnZ1ZSdcbmltcG9ydCBCZXRNdWx0aXBsZSBmcm9tICcuL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlJ1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9jb21wb25lbnRzL01lc3NhZ2UudnVlJ1xuaW1wb3J0IGdhbWVEYXRhIGZyb20gJy4vZGF0YS9kYXRhJyAvLyAg5Yqg6L295qih5p2/5pWw5o2uXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi9qcy9yZXF1ZXN0LWxpc3QnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFtdLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnNjcmVlblNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgICAgdGhhdC5zY3JlZW5TaXplLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckJldDoge1xuICAgICAgICAgICAgICAgIGJldG1vbmV5OiAxMDAwIC8v6buY6K6k5LiL5rOo6YeR6aKd5Li6MTAwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdhbWVEYXRhOiBnYW1lRGF0YSxcbiAgICAgICAgICAgIGxvdHRlcnludW06IHsgLy/lvIDlpZbnu5PmnpxcbiAgICAgICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAwLFxuICAgICAgICAgICAgICAgIGxvdHRlcnludW1zOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdW50RG93bjogMzAwLCAvLyDlgJLorqHml7bnp5LmlbBcbiAgICAgICAgICAgIGNvdW50TnVtOiAzMDAsIC8v5byA5aWW5pe26Ze06Ze06ZqUIOm7mOiupDPliIbpkp9cbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGJldHM6IFtdLCAvLyDkuIvms6jpm4blkIjvvIzlj6/ku6XljZXmrKHkuIvlpJrms6hcbiAgICAgICAgICAgIG5vdGljZTogcmVxdWlyZSgnLi9kYXRhL25vdGljZScpLFxuICAgICAgICAgICAgdXNlcmluZm86IHJlcXVpcmUoJy4vZGF0YS9zaW5nbGV1c2VyJyksXG4gICAgICAgICAgICBzdGFnZVNpemU6IHsgLy8g5pW05L2T55S75biD5aSn5bCPLOaJgOacieWPmOWMlue7hOS7tuWGjeasoeWfuuehgOS4iuS5mOS7peaUvuWkp+WAjeeOh1xuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDA4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuU2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAvLyDliJ3lp4vljJbor7vlj5bmlbDmja5cblxuICAgICAgICAgICAgLy8g6K+75Y+W5byA5aWW5pWw5o2uXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4ocmVzID0+IHRoaXMubG90dGVyeW51bSA9IHJlcy5kYXRhKVxuICAgICAgICAgICAgdGhpcy5nZXRVc2VySW5mb0J5TmV0KClcbiAgICAgICAgICAgICAgICAvLyDojrflj5blhazlkYrmlbDmja5cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2dldExhc3ROb3RpY2UnKVxuICAgICAgICB9LFxuICAgICAgICBzaG93KCkge30sXG4gICAgICAgIGdldFVzZXJJbmZvQnlOZXQoKSB7IC8v5LuO572R57uc6I635Y+WdXNlcuS/oeaBr1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyQ29kZUZyb21OZXQoUmVxdWVzdExpc3QuZ2V0Q29kZSgpKS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8g6I635Y+W55So5oi35pWw5o2uXG4gICAgICAgICAgICAgICAgdGhhdC51c2VyaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoYXQudXNlcmluZm8sIHJlcy5kYXRhKVxuICAgICAgICAgICAgICAgIHRoYXQuJGVtaXQoJ2dldFVzZXJJbmZvJylcbiAgICAgICAgICAgIH0sIHJlcyA9PiBjb25zb2xlLmVycm9yKHJlcy5kYXRhKSlcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgem9vbVJhdGUoKSB7IC8vIOWIneWni+WMluaUvuWkp+WAjeeOh1xuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnNjcmVlblNpemUud2lkdGggLyB0aGlzLnN0YWdlU2l6ZS53aWR0aFxuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnNjcmVlblNpemUuaGVpZ2h0IC8gdGhpcy5zdGFnZVNpemUuaGVpZ2h0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2NrbW9uZXkoKSB7IC8v6ZSB5a6a6YeR6aKdXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5iZXRzW2ldLmJldG1vbmV5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgICBzaG93TWVzc2FnZShldmVudCkge1xuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCdzaG93TWVzc2FnZScsIGV2ZW50KVxuICAgICAgICB9LFxuICAgICAgICBnZXRVc2VySW5mbyhldmVudCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXR1c2VyaW5mbyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlcmluZm8pKSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXMuZGF0YSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXNlcmluZm8gPSBPYmplY3QuYXNzaWduKHt9LCB0aGF0LnVzZXJpbmZvLCByZXMuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51c2VyQmV0LnVzZXJpbmZvT3BlbmlkID0gcmVzLmRhdGEub3BlbmlkXG4gICAgICAgICAgICAgICAgfSBlbHNlIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBnZXRMYXN0Tm90aWNlKGV2ZW50KSB7XG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRMYXN0Tm90aWNlKCkudGhlbihyZXMgPT4gdGhpcy5ub3RpY2UgPSByZXMuZGF0YSwgcmVzID0+IGNvbnNvbGUuZXJyb3IocmVzKSlcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsYmV0KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ2NhbmNlbEJldCcpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbG9hZGluZm8oZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOinpuWPkemUmeivr++8jOW5tuaJk+W8gOmBrue9qeWxglxuICAgICAgICBlcnJvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dUaXAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnc2hvd1RpcCcsIGV2ZW50KVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICdtb2RhbCc6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cIm1vZGFsXCI+PC9kaXY+J1xuICAgICAgICB9LFxuICAgICAgICAndGlwLW1vZGFsJzogcmVxdWlyZSgnLi9jb21wb25lbnRzL3RpcC1tb2RhbC52dWUnKSxcbiAgICAgICAgJ2JhY2tncm91bmQnOiBCYWNrZ3JvdW5kLFxuICAgICAgICAnbWVudS1iYXInOiBNZW51QmFyLFxuICAgICAgICAnYmV0LWFuZC1ib251cyc6IEJldEFuZEJvbnVzLFxuICAgICAgICAncGxheS1wYW5lbCc6IFBsYXlQYW5lbCxcbiAgICAgICAgJ3N0YXRlJzogU3RhdGUsXG4gICAgICAgICdiZXQtbXVsdGlwbGUnOiBCZXRNdWx0aXBsZSxcbiAgICAgICAgJ21lc3NhZ2UnOiBNZXNzYWdlXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5ib2R5IHtcbiAgICBtYXJnaW46IDA7XG59XG5cbmh0bWwsXG5ib2R5IHtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbi50YWJsZSB7XG4gICAgZGlzcGxheTogdGFibGU7XG59XG5cbmRpdi5tb2RhbCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC42KTtcbiAgICB0b3A6IDBweDtcbiAgICBsZWZ0OiAwO1xuICAgIHotaW5kZXg6IDk5OTtcbn1cblxuLnRhYmxlLWNlbGwge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogQXBwLnZ1ZT80NzFkYjk5ZVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2JhYmVsLXJ1bnRpbWUvNi45LjIvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb3JlICA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKVxuICAsICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7c3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeX0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvYmFiZWwtcnVudGltZS82LjkuMi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY29yZS1qcy8yLjQuMS9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2NvcmUtanMvMi40LjEvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jb3JlLWpzLzIuNC4xL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9CYWNrZ3JvdW5kLnZ1ZVwiKVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNzY1OGQ2ZGUvQmFja2dyb3VuZC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JhY2tncm91bmQudnVlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmFja2dyb3VuZC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG4uYmFja2dyb3VuZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogLTE7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9CRy5wbmdcIikgKyBcIik7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi51cC1iYWNrZ3JvdW5kIHtcXG4gICAgLypwb3NpdGlvbjogYWJzb2x1dGU7Ki9cXG4gICAgei1pbmRleDogLTE7XFxuICAgIGhlaWdodDogODklO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpIHNvbGlkO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmdcIikgKyBcIik7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5idXR0b20tYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDExJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qYmFja2dyb3VuZDogd2hpdGU7Ki9cXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQudnVlP2IyOTA4NWFlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7OztBQU1BO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLFlBQUE7SUFDQSwwQ0FBQTtJQUNBLHVCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLHVCQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsaURBQUE7SUFDQSwwQ0FBQTtJQUNBLHVCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLHVCQUFBO0lBQ0EsWUFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0Esc0JBQUE7SUFDQSx1QkFBQTtJQUNBLDZCQUFBO0NBQ0FcIixcImZpbGVcIjpcIkJhY2tncm91bmQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICBkaXYuYmFja2dyb3VuZFxcbiAgICBcXHRkaXYudXAtYmFja2dyb3VuZFxcbiAgICBcXHRkaXYuYnV0dG9tLWJhY2tncm91bmRcXG48L3RlbXBsYXRlPlxcbjxzdHlsZT5cXG4uYmFja2dyb3VuZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogLTE7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9CRy5wbmcpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYudXAtYmFja2dyb3VuZCB7XFxuICAgIC8qcG9zaXRpb246IGFic29sdXRlOyovXFxuICAgIHotaW5kZXg6IC0xO1xcbiAgICBoZWlnaHQ6IDg5JTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKSBzb2xpZDtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2RvY2sucG5nKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmJ1dHRvbS1iYWNrZ3JvdW5kIHtcXG4gICAgLypwb3NpdGlvbjogYWJzb2x1dGU7Ki9cXG4gICAgei1pbmRleDogLTE7XFxuICAgIGhlaWdodDogMTElO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiB3aGl0ZTsqL1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvQmFja2dyb3VuZC52dWVcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiNGI0YTY2MDliOTg5NjU1YTRkNjdmMjQ1YmQ1N2U0MWQucG5nXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9CRy5wbmdcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFCbENBSUFBQUFERWg2U0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvNVJrTXlSRGs1UmpOR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG81UmtNeVJEbEJNRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPamxHUXpKRU9UbEVNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qbEdRekpFT1RsRk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K3lEYTFJd0FBQUJ4SlJFRlVlTnBpc0Fyc1pHSmdZR0IrLy9FYmlCN0ZBNDhCQWd3QXI3Z0V0T2pIOVFRQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIvZG9jay5wbmdcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRcXFwiPjxkaXYgY2xhc3M9XFxcInVwLWJhY2tncm91bmRcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImJ1dHRvbS1iYWNrZ3JvdW5kXFxcIj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CYWNrZ3JvdW5kLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lbnVCYXIudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9NZW51QmFyLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxNZW51QmFyLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTWVudUJhci52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1hNWZhNTA5OC9NZW51QmFyLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVudUJhci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVudUJhci52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZW51QmFyLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5tZW51IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDUlO1xcbiAgICBwYWRkaW5nOiAxJSAzJSAxJSAxJTtcXG4gICAgYmFja2dyb3VuZDogI2UxNGY1MDtcXG4gICAgei1pbmRleDogMTtcXG59XFxuXFxuZGl2Lm5vdGljZSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDYwJTtcXG4gICAgYm9yZGVyLXJhZGl1czogMS41ZW07XFxuICAgIGJhY2tncm91bmQ6ICNlZWJlYmU7XFxuICAgIGNvbG9yOiAjNzgzYTNmO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5kaXYub3B0aW9uIHtcXG4gICAgd2lkdGg6IDEyJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgLyogYm9yZGVyOi4xNWVtIHNvbGlkICNmY2QxOWU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuNWVtOyovXFxuICAgIC8qYmFja2dyb3VuZDogI2ZmOWU0MDsqL1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2VLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZT81NDJiOTZmYVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTtJQUNBLG1CQUFBO0lBQ0EsV0FBQTtJQUNBLHFCQUFBO0lBQ0Esb0JBQUE7SUFDQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtJQUNBLHFCQUFBO0lBQ0Esb0JBQUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxXQUFBO0lBQ0EsYUFBQTtJQUNBLHNCQUFBO0lBQ0EsYUFBQTtJQUNBOzJCQUNBO0lBQ0Esd0JBQUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiTWVudUJhci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLeiPnOWNlemDqOWIhlxcbiAgICBkaXYubWVudVxcbiAgICAgICAgZGl2Lm5vdGljZVxcbiAgICAgICAgICAgIHRhYmxlXFxuICAgICAgICAgICAgICAgIHRyXFxuICAgICAgICAgICAgICAgICAgICB0ZFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4odi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MjYqem9vbVJhdGUueCsncHgnfVxcXCIsdi1odG1sPSdub3RpY2UudGl0bGUnKVxcbiAgICAgICAgZGl2Lm9wdGlvbihAdG91Y2hlbmQ9XFxcInRyaWdnZXJPcHRpb25cXFwiKVxcbiAgICAgICAgb3B0aW9ucy1kaWFsb2codi1iaW5kOmdhbWUtZGF0YT1cXFwiZ2FtZURhdGFcXFwiLHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuaW1wb3J0IE9wdGlvbnNEaWFsb2cgZnJvbSAnLi9PcHRpb25zRGlhbG9nLnZ1ZSdcXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ2dhbWVEYXRhJywgJ3pvb21SYXRlJywgJ25vdGljZSddLFxcbiAgICByZWFkeSgpIHtcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEubm90aWNlKVxcbiAgICB9LFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBuYW1lOiAnbGl1JyxcXG4gICAgICAgICAgICBpc1Nob3dPcHRpb246IGZhbHNlXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XFxuICAgICAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCd0cmlnZ2VyT3B0aW9uJylcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcG9uZW50czoge1xcbiAgICAgICAgJ29wdGlvbnMtZGlhbG9nJzogT3B0aW9uc0RpYWxvZ1xcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4ubWVudSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiA1JTtcXG4gICAgcGFkZGluZzogMSUgMyUgMSUgMSU7XFxuICAgIGJhY2tncm91bmQ6ICNlMTRmNTA7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbmRpdi5ub3RpY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA2MCU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEuNWVtO1xcbiAgICBiYWNrZ3JvdW5kOiAjZWViZWJlO1xcbiAgICBjb2xvcjogIzc4M2EzZjtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZGl2Lm9wdGlvbiB7XFxuICAgIHdpZHRoOiAxMiU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLypiYWNrZ3JvdW5kOiBibGFjazsqL1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICAgIC8qIGJvcmRlcjouMTVlbSBzb2xpZCAjZmNkMTllO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjVlbTsqL1xcbiAgICAvKmJhY2tncm91bmQ6ICNmZjllNDA7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmcpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL01lbnVCYXIudnVlXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUQwQUFBQTBDQVlBQUFBNWJUQWhBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVNamRDUlVJNVF6TkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNU1qZENSVUk1UkROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pjd016ZzFNVVpHTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamN3TXpnMU1qQXdNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCttcnA1TWdBQUJrSkpSRUZVZU5yc1cybHNWRlVVL3U1MFlMcENOeWlGc3BSQzZWZ3NGYVJvRUl3U2pZZ29tQUlsNGhKYy9nQWEvMmhpaklreDhZY21HcUtvTVdBUWthQWdDQ29xYUF5N3BVRFpXa3BYS0VzRHBRdWRsblpLWjY3bjNEY3puYW1kZWEzTzFKbkJrM3p0ZmUrZXpwM3ZuWHZQY3QrdGtNWHIwWXNNSml4dzRGN0NTTWU5WUpkV3dpVkNNV0U3WVFkeW4rM3NxU1I2SWIyUThCNWhBa0pmS2dtdkY4eGV0YzBiNlFqQ3U0VFgxRlY3SXoyM3E4RE5lcURMQ2toNzhGTTBHQUdqQ1loT0JtS0dBMUdKemg0MjRodEUzc1lYUnJjLzZTWjh2UXhvT2g5NmRyWGQwbUJ0MWI1Ly9EaGdXQlpjdk1qcTdwYk9KMnhSdHkvK0NYUTBJMndrTWg0WWZZL3phaEZaZXl1VFpnZFZSVWhEL1ZtZytUekNUcFRGemR5NlRCalAwM3VSSW55emdhWkVqZTdmeTlTcFFPYWprQWtabWxOb291ZFZ2Z3VpN25qd2ttWmV2TWFqazBiUjFXS2pJeXdCbGpxbTVKdHc5aEpJODBMUGU4T3k2U2tTem02SEtQa21lSWxicmpCcGJpMWcwdFBWemJacnhFRDZ0SEJQd2g3OTNOZFlBWEhsbU11VHlweGxrR05uVVlTUERTeWh6amFJQy9zZ1RtMEU3RjI5NjdUVk8xdDNHK2pIQ05Yc2FuZFkyZ3N5SDlNZmZPSThsNzdNZVFweTR0ekFFMWFwVkl3YVMyWXY5djc5RlQ4bHFVemFwSnAybTJacEw1Q0o0L1hYTytzNDljZk9IdkFaTE1mUDhjN0Jibk05SXJjNExmMHdyUERUNS93cjZ2bzVUTGV1OUFuUldLVlB1Ykd5Vy8vODNnR25LNnAvODgzamI2UjlyV2ZHdVIvMFIxVTZtcjQ0K1NWRStVL2taRm9EejViRzRMSEU2VTA2UERReGVsamExMU84ZkFRbzNRcDVSMzd2L2RTbmROeFNRbkY4clVLd1NiL1d0QW9KRGVYQXBQbmt0Q1k2cG5RRldYZ25FUzRLbVFTdHo1WjJFYjlVU0JWcm9YSlpvU3ArOXQ0aFoybjc3VWk2YjVhV28yWUE1Z1dRU1k0MTNWQ2g1ZDN1VGl5Y3ByZWM4Z3prNUFMUGV5azVBT1BNWmdwVEc4TEwwbXpobm9ROStybnZlcG5tNkp3Rng5UVhLRFY4a0JLL3VNREg2ZXJmdGZEb3JlRDRKeGtaZkZSWUxzbGEySjE3VDMwZU11dUp3Qk5XMlhTc0drdE9lYnEvR1puZEoyUlNwdjcwVnpvTy9mUTVBNTkxVDVpcnc2UGZqcXdQams3MDNTRUdqbmwvQ2c2ZDNGdHdKcWJIK2ZxNWJ2M3FQUU5mY0ZUdTZtL3VyUk9uUzdjQUkzTDFkUnlmSTQ1K3BuMXN4a01ENE1nc0VGVjd5Skd0NjFPKzBmZUNvL1lRUUxrM2J3RjV5OHVWam52QlVmaVJRbWdYSEJ3U2VKczRPeDh5MmV5WTBuUmRzZ1hpNHFFd0xqaHFEd0NFOENnNDVPMVljT0QvZ3NON0dCd3pFNkNVMDJOTmM5NWRlekJNQzQ1cEwwSG1QdWQ1ajEvek1FNnNoemoyZVpnVkhHVGhub1E5K3Judldvbm02RlRhTXdoeXhrcEtEUjhCVEVNQ3k4SktjYnJ5WndxUEg5TXF2ZVhIZ21QeVV2M0J1ZEp5Rmh4NUs3UTNEb0VtekdLS1UyUEphUy82ZHd0WWFxODZmYzhHcGVQUTUxYzZBNTEyYzFYbnp5MWdmeWI4LzNuQllldXlkYWhXeENEZkJVZDlxWDdpb25RYytoVzdCcjdnS1B2ZU93ZUR3VkZpeUM1RHAvVldrN29hRk8xN1BaemFwRDhxNnpoZjZ4eGVEVUdoRE5hV3dMT2xNWGdzY2VSVDc5L2ZHSzJwV2p1YmpUZWFMTFZSTVpHcEdKS21uU2p5OWhRdjdBV29pdUVka2Q3ejhuV2FqaXZYNllRNCtMNUNVRWo4R1BXcnVhR2xPbUplZGtadWVtWmFuanFPZE0zM0ZGWnZNWGdmTENvSmlFNVUrMUdpN29SR3JuUnJjQWZuc2ZjQmtVTlJ0UC8wRHJGOFpFckJKOSs5czhZVU9UZ1JOWDhBZGNYaGwzZW0zZ1drUHdCclIyZmp5dnkzWGpHMFdXNjI3dnYxeUZlcWt6b1FsNm9idmtJS3pJZDVrVEJQUzB0YlM4UmtrMmw0OGVFU1M4NTBzeWxwZUVJbVV1N1VUZ2p5d1pSUWw1R1VIazk2WERYTHo5VDgrTUdiYTMraDVsVW16YjU4OUlFOVIwdHk4OHl4Q2NsRE01Q1FEZ3hOMDQ0ZGRsRkVzM1VoSk41MWlRaGF0NVFCSm1jQjQrNTNiVzlWbjd1NCsrMlhWMzl0dDltWlJLbFlFaGZIcE9jVGxFOWYvdXFpdkZrUDV5MGxqNTRTNm9adWIrdTR1bjkzMGVZdlB2eTIwSG1Mc0ZNZGt5eVl2WXI5K1V5bmNreHNsSEhaaWlkbm1LZGtUSTlQR3BKdU1nMU9GQVorak1FdGxIallLQTQzVWxpcU9YdXlxbWpqbW0yRmJhM3Q3cTg4dVA2dGRaMENKdUk4Rjh3SVg2SENIeWZVS3FEcDdWb1JCRnI1eUF4RHdoV0VZMDdIeEk3TXZaUFBTdDRnSk1CNXZpeTB4VUxnY3lGbEh2N096ZEk5NjJ4ZTUrVEN3U2ZGb3p6TDBLQVZ1OE5aY1Q3Ti85WlEyOXZtMzE4Q0RBQXE5V3lnd2dkRVpnQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmdcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy3oj5zljZXpg6jliIZcbiAgICBkaXYubWVudVxuICAgICAgICBkaXYubm90aWNlXG4gICAgICAgICAgICB0YWJsZVxuICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgIHRkXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuKHYtYmluZDpzdHlsZT1cIntmb250U2l6ZToyNip6b29tUmF0ZS54KydweCd9XCIsdi1odG1sPSdub3RpY2UudGl0bGUnKVxuICAgICAgICBkaXYub3B0aW9uKEB0b3VjaGVuZD1cInRyaWdnZXJPcHRpb25cIilcbiAgICAgICAgb3B0aW9ucy1kaWFsb2codi1iaW5kOmdhbWUtZGF0YT1cImdhbWVEYXRhXCIsdi1iaW5kOnpvb20tcmF0ZT1cInpvb21SYXRlXCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBPcHRpb25zRGlhbG9nIGZyb20gJy4vT3B0aW9uc0RpYWxvZy52dWUnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnZ2FtZURhdGEnLCAnem9vbVJhdGUnLCAnbm90aWNlJ10sXG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEubm90aWNlKVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdsaXUnLFxuICAgICAgICAgICAgaXNTaG93T3B0aW9uOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHRyaWdnZXJPcHRpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRicm9hZGNhc3QoJ3RyaWdnZXJPcHRpb24nKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICdvcHRpb25zLWRpYWxvZyc6IE9wdGlvbnNEaWFsb2dcbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5tZW51IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgaGVpZ2h0OiA1JTtcbiAgICBwYWRkaW5nOiAxJSAzJSAxJSAxJTtcbiAgICBiYWNrZ3JvdW5kOiAjZTE0ZjUwO1xuICAgIHotaW5kZXg6IDE7XG59XG5cbmRpdi5ub3RpY2Uge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogNjAlO1xuICAgIGJvcmRlci1yYWRpdXM6IDEuNWVtO1xuICAgIGJhY2tncm91bmQ6ICNlZWJlYmU7XG4gICAgY29sb3I6ICM3ODNhM2Y7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG5kaXYub3B0aW9uIHtcbiAgICB3aWR0aDogMTIlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXG4gICAgZmxvYXQ6IHJpZ2h0O1xuICAgIC8qIGJvcmRlcjouMTVlbSBzb2xpZCAjZmNkMTllO1xuICAgIGJvcmRlci1yYWRpdXM6IDAuNWVtOyovXG4gICAgLypiYWNrZ3JvdW5kOiAjZmY5ZTQwOyovXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+iPnOWNlS5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogTWVudUJhci52dWU/NTQyYjk2ZmFcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL09wdGlvbnNEaWFsb2cudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9PcHRpb25zRGlhbG9nLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxPcHRpb25zRGlhbG9nLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0zZDI3MTQwNi9PcHRpb25zRGlhbG9nLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL09wdGlvbnNEaWFsb2cudnVlXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vT3B0aW9uc0RpYWxvZy52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9PcHRpb25zRGlhbG9nLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9PcHRpb25zRGlhbG9nLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmRpdi5wb2ludGVyIHtcXG4gICAgaGVpZ2h0OiAwcHg7XFxuICAgIHdpZHRoOiAwcHg7XFxuICAgIGJvcmRlcjogMC41ZW0gc29saWQ7XFxuICAgIG1hcmdpbi1sZWZ0OiAyMCU7XFxuICAgIG1hcmdpbi10b3A6IC0xZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApIHJnYmEoMCwgMCwgMCwgMCkgI2ZlZDA5NSByZ2JhKDAsIDAsIDAsIDApO1xcbn1cXG5cXG5cXG4vKiDlv4XpnIAgKi9cXG5cXG4uZXhwYW5kLXRyYW5zaXRpb24ge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbiAgICAvKmhlaWdodDogMzBweDsqL1xcbiAgICAvKnBhZGRpbmc6IDEwcHg7Ki9cXG4gICAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyovXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcblxcbi8qIC5leHBhbmQtZW50ZXIg5a6a5LmJ6L+b5YWl55qE5byA5aeL54q25oCBICovXFxuXFxuXFxuLyogLmV4cGFuZC1sZWF2ZSDlrprkuYnnprvlvIDnmoTnu5PmnZ/nirbmgIEgKi9cXG5cXG4uZXhwYW5kLWVudGVyLFxcbi5leHBhbmQtbGVhdmUge1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIC8qcGFkZGluZzogMCAxMHB4OyovXFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi5pbm5lci1wb2ludGVyIHtcXG4gICAgaGVpZ2h0OiAwcHg7XFxuICAgIHdpZHRoOiAwcHg7XFxuICAgIGJvcmRlcjogMC41ZW0gc29saWQ7XFxuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKDIwJSArIDBlbSk7XFxuICAgIG1hcmdpbi10b3A6IC0wLjllbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmZhOTU2IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcbmRpdi5vcHRpb24tbGlzdCB7XFxuICAgIC8qd2lkdGg6IDMwJTsqL1xcbiAgICAvKmhlaWdodDogNzAlOyovXFxuICAgIG1hcmdpbjogMTMlIDAgMCA3MCU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZDogI2ZmYTk1NjtcXG4gICAgYm9yZGVyOiAwLjFlbSBzb2xpZCAjZmVkMDk1O1xcbn1cXG5cXG5kaXYub3B0aW9uLWl0ZW0ge1xcbiAgICBwYWRkaW5nOiAuNWVtO1xcbiAgICBib3JkZXItYm90dG9tOiAwLjFlbSBzb2xpZCAjZTg5MzQyO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWU/NTNkZGVhOGVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTtJQUNBLFlBQUE7SUFDQSxXQUFBO0lBQ0Esb0JBQUE7SUFDQSxpQkFBQTtJQUNBLGlCQUFBO0lBQ0EsbUJBQUE7SUFDQSx5RUFBQTtDQUNBOzs7QUFHQSxRQUFBOztBQUVBO0lBQ0EsaUNBQUE7SUFBQSx5QkFBQTtJQUNBLGlCQUFBO0lBQ0Esa0JBQUE7SUFDQSwyQkFBQTtJQUNBLGlCQUFBO0NBQ0E7OztBQUdBLDZCQUFBOzs7QUFHQSw2QkFBQTs7QUFFQTs7SUFFQSxVQUFBO0lBQ0Esb0JBQUE7SUFDQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsNkJBQUE7SUFDQSxtQkFBQTtJQUNBLG1CQUFBO0lBQ0EseUVBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7SUFDQSxnQkFBQTtJQUNBLG9CQUFBO0lBQ0EsbUJBQUE7SUFDQSxvQkFBQTtJQUNBLDRCQUFBO0NBQ0E7O0FBRUE7SUFDQSxjQUFBO0lBQ0EsbUNBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiT3B0aW9uc0RpYWxvZy52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLSDlj7PkuIrkvqfpgInpobnliJfooahcXG4gICAgZGl2Lm9wdGlvbi1saXN0KHYtc2hvdz1cXFwiaXNPcHRpb25TaG93XFxcIix0cmFuc2l0aW9uPVxcXCJleHBhbmRcXFwiLHYtYmluZDpzdHlsZT1cXFwib3B0aW9uU3R5bGVcXFwiKVxcbiAgICAgICAgLy8tIGltZyh2LWJpbmQ6c3JjPVxcXCJtZW51SW1nXFxcIilcXG4gICAgICAgIGRpdi5wb2ludGVyXFxuICAgICAgICBkaXYuaW5uZXItcG9pbnRlclxcbiAgICAgICAgZGl2Lm9wdGlvbi1pdGVtKHYtaHRtbD1cXFwiblxcXCIsdi1mb3I9XFxcIm4gaW4gZ2FtZURhdGEub3B0aW9uc1xcXCIsQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZSgkaW5kZXgpXFxcIix2LWJpbmQ6c3R5bGU9XFxcIml0ZW1TdHlsZVxcXCIpXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5nYW1lRGF0YSlcXG4gICAgICAgIH0sXFxuICAgICAgICBwcm9wczogWydnYW1lRGF0YScsICd6b29tUmF0ZSddLFxcbiAgICAgICAgZGF0YSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBpc09wdGlvblNob3c6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBtZW51SW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZXlsZXlvIAucG5nJylcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgICAgICBvcHRpb25TdHlsZSgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMTIgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGl0ZW1TdHlsZSgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyNiAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBtZXRob2RzOiB7XFxuICAgICAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSBmYWxzZVxcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd01lc3NhZ2UnLCBldmVudClcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZXZlbnRzOiB7XFxuICAgICAgICAgICAgdHJpZ2dlck9wdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvblNob3cgPSAhdGhpcy5pc09wdGlvblNob3dcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG5kaXYucG9pbnRlciB7XFxuICAgIGhlaWdodDogMHB4O1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xcbiAgICBtYXJnaW4tbGVmdDogMjAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMWVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKSByZ2JhKDAsIDAsIDAsIDApICNmZWQwOTUgcmdiYSgwLCAwLCAwLCAwKTtcXG59XFxuXFxuXFxuLyog5b+F6ZyAICovXFxuXFxuLmV4cGFuZC10cmFuc2l0aW9uIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbiAgICAvKmhlaWdodDogMzBweDsqL1xcbiAgICAvKnBhZGRpbmc6IDEwcHg7Ki9cXG4gICAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyovXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcblxcbi8qIC5leHBhbmQtZW50ZXIg5a6a5LmJ6L+b5YWl55qE5byA5aeL54q25oCBICovXFxuXFxuXFxuLyogLmV4cGFuZC1sZWF2ZSDlrprkuYnnprvlvIDnmoTnu5PmnZ/nirbmgIEgKi9cXG5cXG4uZXhwYW5kLWVudGVyLFxcbi5leHBhbmQtbGVhdmUge1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIC8qcGFkZGluZzogMCAxMHB4OyovXFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi5pbm5lci1wb2ludGVyIHtcXG4gICAgaGVpZ2h0OiAwcHg7XFxuICAgIHdpZHRoOiAwcHg7XFxuICAgIGJvcmRlcjogMC41ZW0gc29saWQ7XFxuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKDIwJSArIDBlbSk7XFxuICAgIG1hcmdpbi10b3A6IC0wLjllbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmZhOTU2IHJnYmEoMCwgMCwgMCwgMCk7XFxufVxcblxcbmRpdi5vcHRpb24tbGlzdCB7XFxuICAgIC8qd2lkdGg6IDMwJTsqL1xcbiAgICAvKmhlaWdodDogNzAlOyovXFxuICAgIG1hcmdpbjogMTMlIDAgMCA3MCU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZDogI2ZmYTk1NjtcXG4gICAgYm9yZGVyOiAwLjFlbSBzb2xpZCAjZmVkMDk1O1xcbn1cXG5cXG5kaXYub3B0aW9uLWl0ZW0ge1xcbiAgICBwYWRkaW5nOiAuNWVtO1xcbiAgICBib3JkZXItYm90dG9tOiAwLjFlbSBzb2xpZCAjZTg5MzQyO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICAvLy0g5Y+z5LiK5L6n6YCJ6aG55YiX6KGoXG4gICAgZGl2Lm9wdGlvbi1saXN0KHYtc2hvdz1cImlzT3B0aW9uU2hvd1wiLHRyYW5zaXRpb249XCJleHBhbmRcIix2LWJpbmQ6c3R5bGU9XCJvcHRpb25TdHlsZVwiKVxuICAgICAgICAvLy0gaW1nKHYtYmluZDpzcmM9XCJtZW51SW1nXCIpXG4gICAgICAgIGRpdi5wb2ludGVyXG4gICAgICAgIGRpdi5pbm5lci1wb2ludGVyXG4gICAgICAgIGRpdi5vcHRpb24taXRlbSh2LWh0bWw9XCJuXCIsdi1mb3I9XCJuIGluIGdhbWVEYXRhLm9wdGlvbnNcIixAdG91Y2hlbmQ9XCJzaG93TWVzc2FnZSgkaW5kZXgpXCIsdi1iaW5kOnN0eWxlPVwiaXRlbVN0eWxlXCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICByZWFkeSgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZURhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiBbJ2dhbWVEYXRhJywgJ3pvb21SYXRlJ10sXG4gICAgICAgIGRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzT3B0aW9uU2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVudUltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv6I+c5Y2V5bGV5byALnBuZycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgICAgICBvcHRpb25TdHlsZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDI2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgc2hvd01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uU2hvdyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dNZXNzYWdlJywgZXZlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgdHJpZ2dlck9wdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uU2hvdyA9ICF0aGlzLmlzT3B0aW9uU2hvd1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbmRpdi5wb2ludGVyIHtcbiAgICBoZWlnaHQ6IDBweDtcbiAgICB3aWR0aDogMHB4O1xuICAgIGJvcmRlcjogMC41ZW0gc29saWQ7XG4gICAgbWFyZ2luLWxlZnQ6IDIwJTtcbiAgICBtYXJnaW4tdG9wOiAtMWVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmVkMDk1IHJnYmEoMCwgMCwgMCwgMCk7XG59XG5cblxuLyog5b+F6ZyAICovXG5cbi5leHBhbmQtdHJhbnNpdGlvbiB7XG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xuICAgIC8qaGVpZ2h0OiAzMHB4OyovXG4gICAgLypwYWRkaW5nOiAxMHB4OyovXG4gICAgLypiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyovXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuXG4vKiAuZXhwYW5kLWVudGVyIOWumuS5iei/m+WFpeeahOW8gOWni+eKtuaAgSAqL1xuXG5cbi8qIC5leHBhbmQtbGVhdmUg5a6a5LmJ56a75byA55qE57uT5p2f54q25oCBICovXG5cbi5leHBhbmQtZW50ZXIsXG4uZXhwYW5kLWxlYXZlIHtcbiAgICBoZWlnaHQ6IDA7XG4gICAgLypwYWRkaW5nOiAwIDEwcHg7Ki9cbiAgICBvcGFjaXR5OiAwO1xufVxuXG5kaXYuaW5uZXItcG9pbnRlciB7XG4gICAgaGVpZ2h0OiAwcHg7XG4gICAgd2lkdGg6IDBweDtcbiAgICBib3JkZXI6IDAuNWVtIHNvbGlkO1xuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKDIwJSArIDBlbSk7XG4gICAgbWFyZ2luLXRvcDogLTAuOWVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCkgcmdiYSgwLCAwLCAwLCAwKSAjZmZhOTU2IHJnYmEoMCwgMCwgMCwgMCk7XG59XG5cbmRpdi5vcHRpb24tbGlzdCB7XG4gICAgLyp3aWR0aDogMzAlOyovXG4gICAgLypoZWlnaHQ6IDcwJTsqL1xuICAgIG1hcmdpbjogMTMlIDAgMCA3MCU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGJhY2tncm91bmQ6ICNmZmE5NTY7XG4gICAgYm9yZGVyOiAwLjFlbSBzb2xpZCAjZmVkMDk1O1xufVxuXG5kaXYub3B0aW9uLWl0ZW0ge1xuICAgIHBhZGRpbmc6IC41ZW07XG4gICAgYm9yZGVyLWJvdHRvbTogMC4xZW0gc29saWQgI2U4OTM0Mjtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBPcHRpb25zRGlhbG9nLnZ1ZT81M2RkZWE4ZVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUxRQUFBRmNDQVlBQUFCaHJaUnBBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzVNamRDUlVKQk1ETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNU1qZENSVUpCTVROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2preU4wSkZRamxGTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamt5TjBKRlFqbEdNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtlUGdPdWdBQUtSTkpSRUZVZU5yc25RdHdWZldkeC84ODh5QWhRQklDSklWQUpJWkVuZ0doQ0JTM09naFVwVmhjZDhGUloxdW1MbmFHN2F6VGRiYmFxVHJyT25hNnpDeEtoN1piSEdIYWlrWFVJckxpRm5rSjhncVBBQTBtUEV3d0lUd0NoRHdBeVo3dlAvbmRubnR5enJubnZzSzl5ZmN6YytiZTNIdnVlWDcvdi8vMy8vdi9ULzdkV2c2c1VvUjQ1TitOcFp1eHZCd3JCL1RZakIvNS9kMlQ5NGdFSVdhemtGK094WVBzenZ0RVFoRHpTMjJmVWRBa2pzVmM5WG5yOHJjSS9lOFVOSWxmTVYrcmJWMWlXTlFVTlBFdVppR0dSVTFCaytERUhPT2lwcUJKOEdLT1lWRlQwQ1EwTWNlb3FMM2tvZnNheTJCalNlSDk3dFE4WkN3dkJDVm1xNml6N3haUjl6YVc5eU44ZkJlTjVTdGphUXBGME1PTTVmdkc4ckN4ak9hOTdrSUVLMlo3VWIvZ0t4eVJwOHhZM2pXV0ZjWnkydnBsTjB2WGQ0KzJBL20zdGxLbTFLMmJTdDFzYm4wbG5aZEdJd0JlcTFHcTRVSjQyMGxPVjZwUGxsSkpBeUo3ZkQxNkdlRTMwVkNzenlWZk41Yi9OSllYSDV2eG82L3RCSjFzTEc4YnkxejkxNVVxWS9reS9CTWtKSklrOVZjcXpUQVFmYlBsa3crTlpZRWg2Z1p6b3hBRFRsWnJNZDlzVktweWwxTFZKUlF6aWNHYTVGS3JOcUhSRzQzNFpJNnhyUG5EMXYvdVpoYjB2eGpMZDdXMStISVhoVXhpSDJnVW9vWm1sWnBuTEQ4V3k5SFBlRDFsTEducTdENmw2cXQ1c1VqOGtESklxU0hGZUhmWldISVJvUmRxTVY4N1J6R1QrQU9haFhhaFlhVVdkYjkxNjlhRHZrWWdJZkZJbTNhaDVlNHRMV3A4cTltK3lBdEQ0clNoMktwZFE4dmp1bmZ2M2kxZC8vVjFNeThNaVUvYXRHdG9PYU43dDI3ZGVvaThDWWxMMnJScmFMazdCeWVSVGdVRlRTaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0VUUWtFVENwb1FDcG9RQ2pwb2x2NTZoMTZpU2NsSmI4OVNObDYvcVQ0dXFWU3J0NXdJZVYvWUJvazhjZk1mL0U5V1h3NG9lRGVXL2VBZTErOGh6clhiVHFpeEl6TFY0bG1GS2llamorTzZTYjE3cWcxN1R1dGp1bXZZQURWdWVIcFE1N0orMXltMXY3dzI0SDdDNGVMVlpuWG1mSDNZMnhtYWthSUdwQ1pRMExFbStFQkFtR1ZWbWVwZ1JhMWFzdUpUTlh0aXJucmkyL2xhdkhZOGVWK0IrdG5xM1dyVjV1TUJDNHVWK3FZYmVqOC9mV3UzZXZueHlYNmlodGgvOS9IUm9MYjMzdk56Mm4yMnRmU3JvTGRqeDFQM0Y2cDVVM0lwNk51RjllWSsvTktIbm42SEtJc0ZWbUxOWDhyVXhyMm4xTm1MMTlTTEN5YzVybzlvRG1IaU4vZVB5L0Y4akl0bWpsUXBpYjIwNE94RUhRbHlzMUsxR0VObHkrR3FzSU1FQlIwRFFKalRDZ2VwUCswOHFlN09IK2k2N3ZTaXdlcEt3L1dROW9PbzF5ZXhwMXIrd1NFL1VlTnpyeEhScmJCS0FRMUgwQURIU0VGSEFFUTkrRlEzci96UGMrOVMrVVBTVk5uWjFrZ3lmRkJhUlBZTm00RW9LdDU2NzRsenR1djFUVzc5OTM4NFRydGpuVGh5b0c4N1RvV25wazcvOXgrVjNqYzJmV3BtV2hJRkhRbXVOZDIwcmZMTW56VTB0MllLL3U5Z2F6UXB5T2tmOGVPQW1NT3BldDBFTGQ4ajQrSGsxY1BORE1XamJlaVVnclpXdlZLOVdqMHlvalA4THZpN3NkbXVyWDVwclZzRmhPK1NFbnJZaXNxdHdlZDBUS0hVQ05FQU5VU28xTlUzcTB2MVRSUjBSN0x6V0kxYStWR3BmcjlnK2todFA2eEl3KzJwWlovNFBvTTFFYUZDM012ZVA2VE9uTHVxNW4xelJGUmI5RTZweFdDekpNSFVEb0ZxaUVDRk5UbUJIcnBETUtlM0lHYW5HNGRjNysrM2ZxR3FMampuWlBPeisyblJZM3RvREQwNjdRNDFkVlJXeEk4NUhxdC91eUJCUVVlQldSTnkxUHJQS3RSOTQ3L2hHb1dRT1hoMi90aUFEY0E1eFVOMXBJYXdYMzFubjNybXdURkJwZUs4NERXbEdFNlBLQ3pZR3h1T1JLVldtVHRwV01TdkNRVnRFdUtLSlRNaTVqL2hyNUZ6aG8zNWFQK1oyM3Jqd29ua2FDaEhzaVl3YndzTmRVYm9DQ1BwUERSNDBGVWREUDFURXRYU2VXTmQ4N093R3RHd0c1R0k2RTQrMXd6T1RYNFhLSHZpcFZGcmJrelRjb1FKcXMvVFJtT3RwT0p2ZzRiUUVTSFZIeHAzRWtIUStIUHE1RUMrR0ZZQ3JmYU0xTVNRcWwyM3FHY25MSFBETTFxNDlRUkNpTEJRWVA3VUVhNkYySzZuRTRYaGxiVUhkR041NGIzNU1XODFZbDdRVGlMNnlmZUsxZmk4ZEIxNWNKRmZXTE5IaXhVTk95Y3ZqUVlrMXNINERLOWR6UGdOZkRyMjQ1VCtrdU96NjlBSkoyWG1GYmVNRE5LUUUvSXlkVU1YNTQ2Rzh5TlRoOXRHYkhUMW8zZFV2cXM4ZjAydDNOVDZPd1NLVVZISTczYzVRU01DdzFyZ2RkakFWUFhzYjNmNExJR2Y4QjhhbzM3OG14M2FmdGlOZkVPVXgwMkYzY0JnSTYrMkJyK3B2dFNnZmppNzBESDlKWkU1MnBFNDFEWUdCRC94amt3dFRseWZzcW82MnhGK3FMa1FqZEdHa0xFcytNeXRFTVFxTVRzZUd0RVhRc0dyVytvSS9tN3hBMFd0d2xwL1VGZTE1bXJ6UC82NFQ3OUh0ZW5seHVBMzBvM3QxbEVUTDBDOHp5MFlyOFVKKzNEK2FwTXZDZ3VvdVJDTlVTdUtwVU5OaUVJY1QyS09hVUVIQTZJMi9DU2lDbndqUkNrZVVDS05Wdys0YVgrbHRoSzR5UjJkZ3cxMTBEOHlNNEdpTmNTSkFWQU5UVGZWYStzTzZpR3l3cVBUOHJTMXdIbWpKa1AyS0ZZYXhwMCt5K0htSnpIT0dGVXJoQXpFTzNydExVTjBSMjRiTnhVMytYWmtiMEt4TDhpYnV6VkNjVjRZSDIwZUVqcXRLRnR0TDYzeTFYS0k0cmh1dUdadmZsTG1PaGFjZ3U0Z0lGejRSTndVeVh3RTAvV0w2STZJam1qZmtha3FSRXlJQ3dYSmJKbTg0UGJZR0NMM2ptUFZQdUZpKzZoNVVGaHhmdks1UkhFUk5jYkc3RHBlcmExY3ZFWHFUaUZvVk5YYmoxYjdIb3ZDallNd0lXeGtRUjZZTURUZ2pjSE54L3FJZE1odVJCdXpoNFd3VVBqUXdBMjJJRFZZT2p0d0xUQ1cyenhLRU9lRXhyVTVrK0ZrVFNCcS9CNDFIU0kvamd2anZwbTJpektJWlB2S2EzV08yaHhwUkJqb01aUFVrd2dWcVRRTTJyZDZZNGhBQmpsaEhJZmNkS2N4MlZiY3VxcWR1b3UzSERucmUyOTl6RWtLSktLdlcvNFl4NDFlVFRCemRMWlBsUFdOTjdTWWNTMjhGR1k3djQyTUVSNHZrK3VIekVjODVLTmpWdEM0V1UrL3Z0VnZDS1BrZTZXS05ndGdTc0VnWDFVcXZsRFNVTnNNLzRpYmdwdU15Q01OSHhIdWhTdk52c0pndnZsT1k3S3R1SzFqMTEyTWM5dDg0RXZIbmt1Y0M2cDlQTFBvQld4bmhoRkZ6WTA4ODdVdyszU3YzZGM0Sm5oeXVYN0lrQ0RDeHpxWVNiWjF4cFd5RFRGM2NPamNrRWVCRUlGdzAzQ1RFTGtRUFRDZ2YweHV1cWNJaEh6MDUyWG50TWUycTBMRnUzYVVkOFk1M0ptZFptc0J6QllxRUtoMU1MREt5M0hiUFlEcjlTSFlhRDJFRURIeTU4YStvRW5rYTcyL1ZsMzJpOEtkaGpaQjh5SFpMZ1FpYktjU3NRMzhWMkNFZ2lhRWdpYUVnaWFFZ2lZVU5DRVVOQ0VVTkNFVU5DRVVOS0dnQ2FHZ0NhR2dDYUdnQ2FHZ0NRVk5DQVZOQ0FWTlNHVHhQWUsxcitRd3J3YUpXNHF0enhRV2p4dk5xMEpvT1FpaG9BbWhvQW1ob0FrRlRRZ0ZUUWdGVFFnRlRRZ0ZUU2hvUWlob1FpaG9RaWhvUWlob1FrRVRRa0VUUWtFVFFrRkhsWWRmK2xBdmRtQ0tOTXdnKzZ1TlIvWDdZQW5sTnlRd25OYXREVXlFbVpHYXFISXkrbmhhSC9OaFl3WlpUUDRaN0lTVW1BQnpmM210V2p5cjBQUCtnZ1VUaVo0NVh4LzJkb1ptcEhUWVpLU2RYdEFRbWRmcGdZUGh2ZWZudEx2NXk5WWYxTy9OVXlZN2dlbUNNY1V5T0h2eG11TmMzeEQ3RTkvT2I3ZTkrcVliZXFybW43NjFXNzM4K0dRL1Vkdk45aHJzK1lDdHBWOEZ2UjA3dk00MFMwRjdJRG1ocDI5K2J6TXl0N2JkZDhHc0l5QUNZV0wyNVI4YzBwRVhrN2U3aVJuckNSQ20yekZnem0ycm9MSDlsTVJlV25CMm9vNEV1Vm1wV295aGdpbXB2Y3h6VGtFSFFmNlFORDJCdXAyM0JYYmZCYk9PR2N6OWpVbmFFWGxuM2pXa25jRGdlU0YyZkkvSjR0MUVLS0tmUFRIWHNicEcxT3VUMkZPdlp4WTFQdmNhRVozOFBjQ01zZUhNR2l0enJPTVlLZWc0NVlFSlEzWEVQVlo1cVoxWWwvKzVWRzB2cmRJUi84bjdDdFRlTDJwVmV0K0VkdEVYd2wvemx6TDkvanVUaGdVc1JEVjFqZm85dGhXTFpLWWxVZER4eXRSUldlcjFwNytseFF4ZmJlYWY3aTlRZ3dja3EwZW1EbGZiajFacnU0Q0czWE1MeHZ1SitwVzFCOVNsK2laZDNYdXhFYkFmS0FUQk5peTlBRzhmajdhQmdvNGdpSlJvbUszL3JLS2R6eFp2amNpcW83WmhGeUJnaUZveUg0andDNmFQREtvaEZRMHhnNGtqQjRiODI3cjZabDB3S2VnNEJWRnkwLzVLTFdUY1NGZ0x0eHRxRmJVMEVNZU95SFJzVkRwbFE3ejYvR0RCY2JnMWNMMzRjelRNS2VnNFF5SXlCSXdHbjZTcTNCcGQ0aSt4dm1RNkVKbmRCQlNQMVQ4YTVoUjBuRkY5cWNIbmUyZE55SEcxQU1pTkh6bDlVZTA5Y2M0blVFUmxMNTBrMW55eFU0RnhpdVJlS0R0N1diMng0VWhFZmJndzEyamtTczFFUVVmaHhuaTU4WGJyd0Z1YUl5bHl4VmljVW15VjU2K3BsWnVPdHNzNUl5MDNwU0FyclBSWXBDTjVRL1BOaU5ZRTVtMWRhNHI5N3ZxWUZiU1hHK1BseGptdFl4WjBvSzVkUk40SmVabnFTc04xWFJoR1pQWFZHWkZvWTljREdDakNvM0RKN3dKbFQrVDNidnRCdG9kZDN4SEFmR05DdVJGZTFnbEdVUERVaFVQN3EyZC91ME5iakk0UWRDRGNlZ0oxZC83N3JUMmE4NmVPY0sxRjBCRmt0UklvREdqc25qbDNWZmVpeHJyVkVPSnV0QjA4TFBEU3BSMXBUaHMzRnd3WjBDY21yb1ZicjJKU1FnOWRxOEFtWVR6TTZpMG5IRWY0b1NQSS9CMHNGc1NNM3c0ZG1LcEc1ZlJuaEk0V3RaZGJlOVlLSW5pUmcrMkEyTGozbEY0aVlSdWlCYXdHeEQ3eGprenQvOUZsWDFaVlo5dDRSWU1ZQW41eDRTUWRyU0Z3Zklhc0RUcVNvcFVucDZBTk1ONEM1QTN1RzdGdGV1MkFNSXYrZHRRUW9RRHhvdU1IblQ2YkQzeXB6bDl0MHA4aENwc2J0eWlnVXJDUml2eko5NHBqd2xaMWFrSERia2ltb2Rpb1RpT0ZsdzRJR1hBRS80eGo2SnZjVzBlMFNCSnFGL2pPWXpXdTRzTTJjWDRZZEhXbXRsNjl0dTZnSHBkaXp2SmdHQ3pPQzJMMk1vU1dIam9Dck50WjRZc29IZG55UmpTVEFVZG9ZS0VxeHMySEw0MFVLRERQdlJuYTJPOVgzOW5ubXNKRUF4R2RSNzk0dDBTdkN6RlBLOHIyeS9JZ2lxT3d3bXE4K1VsWjNENVJFemZGRURkY0lnZ2lTa2VLR2NNN3hWTWlXM0JuZHByMm96TElQMXlmS1JFVDUyWWRGT1cxa2V3VXVYY2NxL1pGWTJ3ZndVQnk3dVlvamVPSHFPR2xZVDkySGE5V2l4OG9panZiMFROZXhDeUQ2cEZDNm9qb0xHTTc1S2tQYzdlMitlWkQxT2cxRExZWHpleGhJU3hFeDZVUGpRbjYzQm9zblIweWJ0dmNrd20vaitPYlZqakl0ZURKZWNtNGIwUnpITmYwb3NGeGs3YnJHVTlpaHFpaWZXRVIxUTZkdXFBamxJenRzTXZENHViRFE4TjI0T2JqR0dGTHBoUU1VbU55MDlYNHZIUlg4V3c1Y3RiMzN2cVlFL2FKZlNQNnV1V1BJZDZQOXAvUjcyZU96dllkVjMzakRTMW1pQkZqdklPSnN1SzM3eG8yUUszYWZGelhpbGh3YnZHUWo0NXBRZU9KYWttUEJScjRFdzd3bDlaSGppQXFMMmtySE5PYzRxSHE3ZTNsdWhDWVUzcE9oUUZDUk1ZQjN5K2RON2FkYUZFb3NBMnZ6MU5pT3pPTUtHcHU1TmwxNVNNNGVPMit4akZoRkNCK2c4d1NPbGdRNFJtaHd3QlBmQnl2dk5RaGcySWtvdVZuOXd1NmF4dkMrZUhzUXYxQTdJSHlDNnFpNW9xdThyUFRVMnlQR3dVRVFvWVh0eXNzMkE3U2todjJuQTY0YjZRY1VhRE00bld5TFJDejljSFpRTThkNHZpeFJPc2hoRWpUcmVYQXFoYjlybXlENnFyRXk4Mkt4SG4rdGVxeVh4VHVORmluUnU3S2RBVXh5M2wyS2hIYndQK2NSQ2hvUWlob1FpaG9RaWhvUWtFVFFrRVRRa0VUUWtFVFFrRVRDcG9RQ3BvUUNwb1FDcG9RQ3BwUTBJUlEwSVJRMElSUTBJUlEwSVNDSmlUdThEM3V2Sy9rTUs4R2lWdUtyZi9Hb0hqY2FGNFZRc3RCQ0FWTkNBVk5DQVZOS0doQ0tHaENLR2hDS0doQ0tHaENRUk5DUVJOQ1FSTkNRUk5DUVJNS21oQUttaEFLbXBBdUltak1nSW81cCswK3h6emRMNnpabzkvYmdjbmxzVTQwd0hhdDI4YUU4MTdCT1MzOTlRN2JjNHNsTGw1dDF1ZUYxMWduTHFaUWZXWHRBWFd3b2xaUG9yNzBvVEcrdWF3eE0ycDkwdzM5M1p1ZmxPbjV0cTAzWXUyMkUzb083M2xUY2lOK1hESnZ0bXo3dFhVSDFmYlNLajNwUFNhMUR3VG0zc1ljNDNZVHlxTWdZcjV3TC96ejNMdFUvcEMwcUYzL3JjWjF4N2xpWHZCb1hNY3VKMmlJZU5uN2g3UndmL3liSFdyaHZmbStTZUVmbVRwY2JUN3dwZHE0OTVTYVVwRGxOL1h2OGNvNi9Zb0o2YU5CLzVSRWRhbSt5ZmYzTTk4cFVsY2JyK3RDQkx5STJnbUlHV0wzUWtOeit3S0JpUHF6MWJzOTcrKzk1K2QwQ3NzUkY0SkdSSDV4NFNSZE5hLzVTNW1PMU5NS0Ira0lqUVVDeCtlMWx4djlmbmZvMUFWWEszQm5kcHB2bm04dkVYSHVwR0crZ2dUNnBTUm9RWmVkdmF3akpMYjEzSUx4dWthSmhLakJ6eGROZHB5ZkczWWxrT2hSNkhDY1RsaC9Md1ZoK0tBMHRld0g5MURRMFFSaUdwWFRYeDJydktTZWU5TS8rZ3dkbUtvMjdEbXRGeEhmY1dNOUFIR3QzZVl1Rmk4UnNhVGlncCtnN1NLa1dkUlovWkw4MW9QdzM5aHdwTjN2dHh5dTBndVlPSEpnMklYQURNVHNKc3lIWC9xd1V6VUtlOGJiQWVkazlGRjd2NmdOS0Q0SUcrdkFQMC9JeTdSZFoyaEdpdSs5MjAxSHpiRDhnME5xcEVlZktxS1c2RzhXdnQxeFd6K3pFM1FrSWlmT0EzNTlSdEZnWHp1a3M5RXpIZzhhRFJOcG5DREMyTjFrWkQ3QS9La2pIS3RzTzlIWXJWdFQxMnBsK2lUNlg2NENvN1l3aXhHTjBEUG42MVdESVpwemh2MUJneFdSWDQ0TjJ6WjdWV1JJT3JLeEpZVThOeXVWZ3I1ZFZKNi9waTJHWFZYdkZvblFnRVIwOWlwbWljTFBQRGltM2I3S3Fsb2JsOE1NV3dQUm42cTVxdjgrZS9HYWZnM1UrTUk1b0dZaEZMUmF1ZW1vRmllaXk1UDNGWGdTS0h3MnhDd05KenRtanM3Mmk0cG9aS0poQ1ZGRHVKSUdROVRGL2xFTDRETTd6Mmx1ZUdHN0FGSFEydkFrRkxSTzJiMjl2VnluNVJBSklWVHhwNUs1UUVQSzZyT1JGWEhMQXZSTjdxMW1UY2p4aVEydml4OG9VcSsrczA4MzNGNTVZckwrVEZKL3NCY0E5Z0RXSXpNdFNVZHFXSWFpWWVucTJmbGpQZGtYMHNVRkRhK0hEaFBrbUZkdFB1NFRuNW5XTE1ZSjM5L2lxYTIrV213RnZyZHJ0RTBkbGFVN1JiQ3RQKzA4cVJ0bmt2b2JrNXZ1OCs5V3FpN1V0L3NNeDVxZG51SW5kS2ZVb0RuTEVhaUJTanBKb3hEUkRsSHp3cFgyM2E4UXFGUEd3Q3BtYzRTM0F4MDFFQjFFamJRYmFvYldDTjIrY3lZak5WRy8xdFUzdDlzWGpzTmFjemlsQnIxMm9BQVVFdEpKc2h3UVlVNUcrME0yZDNnNDVWWGRJck4xSC9EcXNEZjREWmc5TWRjMkt5QU5QWE52b1dRVHRKKythNGpmNTliSUsxbU9uM3l2V05jT2JqUzBkWStQakdJWGQyY2dya2ZiU2JZQmZqYVlRdUdsTm9CWEZtQjNuSkRhUWZ5OFJHY1Vna0NaalJObnZVZm1jNWZ0VTRja2ppTTBSR1BPR2lEUDYxUXRPNDJ3TTMrT1RJUlR3ODBzSEd1WHVobllDZ2dZNnlBamdrd0pzaDZQVHNzTGVEN2l2VmQrVktvdGpWdHVXTVNQYm4vVUFPSDRiTEZLRlBSdFp0M09DblhtM0ZYMXkrL2ZvMisrTkxCRWxNajNnc0VEa24wajRheGUxZXhYRVlYdEJJMmhxQkNtZ1BmRmVabTJncFB1YlhTTFEyeXdIOGhsZSttNHdMSElBQ2NNdmpMYklhdGdTMCszMWdCSUlZYmFlQlN2MzVsejRuRWphSWhWT2t0RUxMaEJrbThHNTYrMmV0bVV4RjU2bklZWlNmbWg1MUF3ZDMyYlFZWURJc1A2R0ttSEJpSUVoMVNnbFZGdDZUd01Hd1g0alpkT0lMRW9Vd29HcWJ6QmZiVmZsOHlLWFlOV2ZEb3NUakNOU1BQMWszT2k1WWdCTUg0RFRDOGFyRjh4MEFjM0NJSnc4c0ZXcmpSY0Q1Z2JobmdrQmJoNFZxRks3NXVnaDZlaU1PRTdxMWdSN1VSa2lMYUlzdVpJNytUYmo1eStxRjhoWm13VDBWMHlLOVo5U0NNVHZsd0dYTmtKMWh4NVVWZ2xaMjYrZnRhaHRPYTJBaHVGSFlqa2FTVWlIajF6eVNlSVNOWUNZalZnR3lBUUdaNHExc1A2Wkl3MEFpWGFtc1g3cGJFOWpBcTBHN3FLUWdLSzJ3Wk9vUU1KQmNLNkQzaCtLU3h1dm56SmlrL1ZyemIreldhaEZrUE9ISVZEUDlueldZWCsvTzc4Z1hxY2l6d2xZeDRYQTlCR1FlMkdod1lZb2FQWUdKU1JjeEtGUk9ERnBwRjBrdG9LSlJPQWZTeGJmMUJIZlhTdW1LT2tSRkRVRG1iQlNtNWJRTTc2TzVPRytZNVJSdGRaRzVVUUtmWmpUZ2ZpRlFVSEE2RmtIemdtYVF2Z095ZGZMbzlHT1VWdnNWRFlYN0t4YmJSRGxoczFEdlpsdFRqWWR6ejNjTVpGaE41MXZNYlBicGhUWSthYkxLbXRZTko0WWwvZ3NVWE1kajRXVmtKRWpvaUhhQWd4STNJaWp5emVGR05QM05LS0VKOUVTNGpmRExhUGpoMnc4MWlOTG1EQVdzQ3NZSVFma0hFa1p0QTdDU3VENDN6aTIvbTZzSzFZTWtNZkx6N0hlVGc5ajhrSUhhWEdJQ0lmYmdnR0VPSGlpNmUwNW9mM2w5ZUdsSmJDb0NPSUJqZ05ya2Zrd3I2M0g2M1d0Z0RpaDNmKzErK08weUpCMmcyUGg4RnJvMHBINHhPMUNJNWJJaDUrajhZbGZndnZhcGR0d0g2a3cwWEViSGRNS0JoU21HdHRjdFRZRjU2emxHdjM4dU9UL2NhdHlFTUkrQjZqQnQwNm5KelNveFIwQ0J4cnEwYkZueUtpU0hTR1VQQzNkRTlMRmdCQ1FVSDR4YnNsZnR0eTZ6YjI4cFNJM0hDcHZoSHg1RE94RElqYUVMV2sxN0NldWVxWFRJM2RtQkNJVUI0SWhnak56MDRLaU1JNC82ZVdmZUwzdVJSNHFjSHNDcDMxWEVUVWFDdzNObi90T3hjVVNITjZVQmdZWk0xSFFkdUFHNG9xT3ptaDlWRFJNSUpYaEpnQUJnMkpkNFJnLzJIR0hYNjVWbWxRNGNiS2QrRWVEeHFtZHRGVnZ2djkxaTkwR2cvQ2xlT1VRb09VSWtiNU9SVVlaQ0dHRE9pano5UE9NNk1nSUJKYm54U2ZZZkwzTWhUV1d1anM5Z2RSWTN5TWVWK3dkbVpCNDlxaElBWHFubzhGdXJVY1dOWFNhaVEzS05KNVFMVHZVdU93MjZaRzVuOU82cVIwMVljS0tHaENRUk5DUVJOQ1FSTkNRUk1LbWhBS21oQUttaEFLbWhBS21sRFFoRkRRaEZEUWhGRFFoRkRRaElJbWhJSW1oSUltaElJbWhJSW1GRFFoY1lmdjBlQjlKWWQ1TlVqY1V0ejJid3g4Z2k0ZU41cFhoZEJ5RUVKQkUwSkJFMEpCRXdxYUVBcWFFQXFhRUFxYUVBcWFVTkNFVU5DRVVOQ0VVTkNFVU5DRWdpYUVnaWFFZ2c2TVRCcVB4UXRMZjcxRHI0dHBrcjJ1Ly9CTEg2cVNreGNjMThGM1dBZnpjVWZpZkRCSnZSdlluOXZ4RUgvaWFuWkdUQ2FKaWRZeGJTK21SSGFicWhmelhXTmFaR0NlbmpoYzF1MnMwSys1V2FsaGkvbTVOM2VydXZwbU5UUXp4WGFxWmZDejFidjE2M3ZQendsNVh5aW9vYkxzQi9kUTBORms2VU5qMUk5L3MwT3QvS2hVamM5THQ1MHhGV0xCWE5mZ3lmc0tJamFyS3FLcHpJRzlhdk54MjNVZW5YYUhwem14Y1V4WTk5VjM5cW1mdnJWYnJWZ3lJMnF6djByQlpvU09RVERKK3J4dmpsQy8rL2lvMnJTL1VrL21idVhOVDhyVXBmb210V0Q2U0RWdWVIckU3TTdiMjc4SUtKS1A5cC94UE1rNzFzTXhydDEyUWgvekQyY1hSdlhhQlJQbFlhc282QTVpMW9RY3RmNnpDblhpN0dWYnE3Rng3eWsxZGtTbVdqUnpaTVQyK2FlZEo3V0laMC9NYlNlOGkxZWJkYTJCUXJUbzN1RHNEWTZ4cktwTzVRM3VTd1BjbFFSdDlZSDlVaEpVMVlYNmRwL0RrenI5eHM0UHJ0NXlRdTA5Y2M3dnQvREpzQlJ6SncxVDk0L0wwWVVFVWJSL1NxS3RIMzk3ZTdrVzgxUDNGNnI4SVdraFJUNVltZVVmSEZMREI2V3BGeDZicUdzaTBva0ZIYXdQRks4YkNJalp1bTM1N2JXbW0xck1FSm91SVBQR3R2TzU1aHJCenY1WWdXRGR6aEdGaW1MdVFwWWpsTmErbXg4MFIyMUVkSWpxNTRzbWErOE4zL3owNjF2YlpSeWNDcERzQjZKMXlnNDRmUzRGQiswRDBzVThkRWVCYVB6eTQ1UFZ5azFIdFdBUmhTZmtaZXJ2cWk4MTZNZ004YzRjbmUzM1diREFneU1yZzIxNWlmS2hFcThOUFFvNmdpQS9EQkZEMEhnVndhR3pROFJyOTFrdzJaTmw3eC9TSGh5V0pocTQyUndLbWtRVVpFOVFXQ0taWXZScWN6b2pITXZoRWptajNlV01EQXV5SndDcE8reVRkTEVJSFU0M2JpRDZKdmZXcjBqYmlXY09GRFd6MDFOQ0tpeXZyRDNnbDRuQiswaDFycFNkdmF3YW10MEx4OUNNRkY4MnhjdjZJRm8xU0pjV2RLUzdjWkZkS1AvcWl0cDF2RnI3V0JIWHRLSnNOVzZFOHcyc3ZkeW9YMGNPQ2M2Zkl1b2p4eTJkTk9LNWtjTkc3MmRLVXErd080VGUySEFrNEhYQy9zVDdlMWtmaERPZWhJSU9jREVseldXK01lYVd2TmVMdjYzMEsxK2tSTWNKUkMxcE8wUXVjNDJ3NVhDVlhzeVlQNU1JajF3eWZpY2RNd0pHL29tQTRaa2hYSFBEc3I3cGhzK0NSS0tYRXdWbVVQOWt2OC8ybDljNjV1anQxZ2NvYUxRY1VRYWRIbUJnV2xKWTI1bGVORmd2MHdvSDZkRnZFcVVCcW1GejVMS0xZbmFmWVJ0WTVCak5vTkFzZnFESWRyekhJMU9IYXkrTkpSSk1LY2l5dFFsT2duWmFuNEx1QUNRcVpxUWxoclVkY3dTMTg0eDJrZDdjZXdpQi92TDc5M2pxM2Z1T0ViSFJkZTQwcWc2Zll6UmhNR0NzdDlQUTA2NUlYR1k1MEJHQnlBZ3g1US9wMkJ3ckduUWI5cHpXNzU5NWNJeU94QmpMNFFVSUw5QVFVUlNNWUxxK2YvRnVpWHB0M1VFcU9aNEZ2YSs4dHEyS0hCUlNCaUFja0lsQVlZSjNSM1NIRjRZUGpzUVRMS0d5dmJTS1NvNVhRYU9LbGNIN3FNSkR5UUM4c0daUFNKRVplV1ByUUNUNFh2d05ud2tyY2p1eVBsMnBKN0JUZVdpSUdWV3NETjRQMVR1ZU9YYzE2UDJheDNNOHQyQjhPOStMOGREdzFUVjFqVnJra1g3NkJEYkxha1hrV1VtblhEaFNpOWJPSVl3M2NjSnVmUW82U3I0VlQ2ZGdVTCtJT1ZCYXk2NnhCTHNSVEVTVC9Vb3IzMm0vRUJvZW9VSm5DZEp1R0pKcVRkbUZDZ29RQ3RLTGY5anIzSGgxeUpkTHc5VXJ3YTVQUVFjSm51SGJjYXphenlOYTg4NU9BbGl5NGxQSGRlYWFyQW9pMzFQTFB2SDdQaU0xVWU4Ynp5MmlBS0VBQkhwV0VCRVprUnRqTXlCcWlLT2s0b0o2ZG41NEE0NFd6eXIwMVE1Mm9KQTVGUnptb1dNTVBBU0w1L2lRelVBRDhORnBlUUV6QUtqK2tYVTRYbm5KOW5zTTlUUUxBTnVES0JCVkMzTDY2MXdzSWp1V2lwb3JLcXRma3VkSUMxRWpnczhwSHFvKzNIZEdXNDlBQktvdGNCd3ZMcHdVMHZXenl5djNTZXlwcmpSYzE2OWUxZ2ZXenFSWXBsdkxnVlV0cmZYeGhwZzhRRHZ2U0VnNzJtYVNqZmtzQjhWTWdvSERSd2tGVFFnRlRRZ0ZUUWdGVFNob1FpaG9RaWhvUWlob1FpaG9Ra0VUUWtFVFFrRVRRa0VUUWtFVENwb1FDcG9RQ3BvUUNwb1FDcHBRMElSUTBJUlEwSVJFQ04rL3o5bFhjcGhYZzhRdHhXMy9hTVluNk9KeG8zbFZDQzBISVJRMElSUTBJUlEwb2FBSm9hQUpvYUFKb2FBSm9hQUpCVTBJQlUwSUJVMElCVTBJQlUwb2FFSW9hRUlvYUVJb2FCL3JkNTFTUzMrOXcvYTdYMjA4cXBmRzZ6Y2RmMTl5OG9LcVBIL044ZnV5czVmVjZpMG45TnpqYnJ5MjdxRDZ1S1RTZFY4QTYrQ1lzZCtPQk9lQmZRWTZ2bmlsWnl3ZkhHNzZ0U2JuQ3oramFMRGZYT0FucXkvcjM5dy9Mc2YzR1VTNmNlOHBOWFpFcGtycTNkUHhKdjlzOVc3VlB5VlIvZkw3OTlqT0wzNytjcE5hdSsyRUtxdXFVeTh1bk9SNHZOdExxOVRWeHV0K3gyQUh6dXQzSHg5VlAvbGVjWWRlMHpjMkhOSFg2ZWVMSnF0eHc5TXA2STVrdzU3VCt1STdrWnVWNmhQZnJBazVhdjFuRmZvMzB3b0grY1M3Y3ROUi9icm8zbnpIN2VRUFNWTlAzVitvQmJicy9VUHF1UVhqMjRsLzZxZ3NYU2dPVnRTMkt6VG00d1h6cDQ0SWVHNWJEbGZwMTR5MFJOdnZVUnZzUFhITzAzVjY4cjZDVGluT1RpZG9NSHhRbWxyMmczdmEyUU5FVkdzVUh6b3dWVjFwdUs0MjdhL1VmOWMzM2RBQ2hCQ1Bucm1rRnhRQ3U1cy9iMHF1WGg5UitKVzFCMnhGdlhoV29WcXk0bE8xNWk5bGZvVkdqZ09GYi9iRTNLREVoY0prQjhUc1Zwak5IRGw5MGZNK1padkpDVDBwNk5zSnZPdVo4L1h0YnB4ZEZMZitEVkZqQVlqRVRqZi9rYW5EdGFYQXVuL2FlVkl0bWpuUzcvdWNqRDVxd2ZTUktpV3hsOS9uOEtNUU9TekxFOS9POTNRdU9FWVVWaWVzaGRndWdxUHdvYkJhanpPY2drUkJkeEJiUzcvU2x1Qzk1K2ZZZm0vK1hDSzQzV2R1SU9JdWZXaU1ldkVQZTFWV3Z5VFgzK0ZZN0hqczFmLzF2VWZoUWVRWHBOSGFON20zZnEycmIyN1hrSjA0Y21CQWdackZqSnJFQ3JZWktMby8vTktIRWFrdEtlZ29na3hHM3VDK0tqTXRxVjFqVGZ4dElPREp6VGNOVmJOVEpCWFJPSDNmSjdHbmE4MXhxYjVKTDFiY0JJMXpNWXZacnFHTFFtRUhDaEpxSDlRay9WSVNncjYrVHR1bG9LUEVvUDdKYXBzUnlhMk5NbndXS3FpYW5hS1NSRG12VVV0cURLVDJrQTE1L2VsdmFSc2ptWlpuZjdzallOWm4rUWVIWE1Vc0JjS3VVT0QzRVBTVWdrSHFoN01MTzZYbDZGUWRLOGgwbkRsM1ZaMnF1ZXFYa3NOTm5EdHBXTXdjWitucEN6cEtpcGhCUTNOcnczYm02R3pIMzBITTJsSVl0c2hKekc2VWYzVkZ2NklXWTVZakRzQk5SdlNSbEJqNHY0TlZPdk5ndFNGbXdTTTNHMnlqTEZTUUY0Zk5zTm9VS1lSV20rSmtpMExoN01YV2pxTmhBMU1wNkhqaDc4Wm1xekc1NmVyVmQvYnB2eCtkbHFkZmtTR3hBNUhSYTNvc0VoeXJ2R1FiaWFzdk5laFhwNElYaVN5UlpIb0NXUnN6MDRxeTFiUHp4MUxRSFkxZHE5MUxTeDRwUEhNMnhQb2JMOXR3VzhmYUl5ZlZQdkxoWm82M0NSM3JPblhoVzdNbHdXUkg5cFhYK3Q1N2FSUWlBNE9hSkRXcEZ5TjBSd0p2N05ZOWJzVXFwRUE0WlRDOFpneXNIUmhtNFpwdENHb0pOUGJzc2lGTzJaVmdzaU5Ta0NTNzh2TGprLzA4dkYyaHdYcFRDcklvNkk0azBKaUpjSEh5MHBJeHdFMWZlRysrcCtPd0N0ZHFRL0t6Ky9sbFE1eHFBcWZ2blVESHo2N2oxZnI5TXcrTzBZM0xQKzg1N1pqcGtGNVBGT1o0NjFLUEswRWpHb1pTN1pzSlZneE9BcEc4Tm00NkJGSlQxeGl3UTZUQitCM09BUVhoaFRWN2RGYzZvcVNrRmUvT2owNmVkL3ZSYWwzdzRJZFI4TEEvRE5oQ1d3TmpWSnpPRFdORTJDaU1Fc2hjQlBKOUVKZFQyZ3UvajFUakQ5M2lFbW1SRDhiWUQzUjJCS3Iya2ROZXNXU0dYaCtpL3VsYnU5Vjk0NytoMytQWW85VWRMUVZtM0lqV2FJdUJXdGpueW85S1ZVRk9QNytzaWZuYzRuSEFVMXpsb1F0eStnZGNCMTNOZGt1a2tKNDZSRnJKQjBQVUVBQStSN2UwRzFnZncwOHhKZ1JSVXdwQ3RQTGs2THFYQWlPMkNBVUgxZ1A3eCtoQ0dSdHRQYmQ0SktZanROeGs4Wjc0R3hmL3p1dzBuVDNBcTdXaDVqUmdYc1pQaEdNejN2eWtURmZWdU9Gb1ZFbGtFMUZMcE1ZQUo3ZWVQSW5rR09Ra1kwSmdXYUxCcXMzSGJRc014STE5eXVqQzZVV0RmUjAzaXg4b0NqblhUVUY3YVBEaHlRN2g2ZGUzT2piQ3pLUHFJZ1dFak9Hb0dHc3RIU0wvK3QxeDdUSUVabEhqR0p5R29KcTNhKzRBOGxvUWdnSFhUUnAzZHRkTDdCSDJMZGNOa2R2cXF5bm9DQXNLWXBJR0RhSUtJZ2w2dTZ5ZUU5VyswK0Q2ZFRzclhNVXVFZGhjVmNORHdsTktOWXpSYytoZWR4S2NXZFRCK0hCNDJ2LzQ0ejdIWWF1aFdnMkovazZOTzNTMm9CQ1p3ZlhGdFloVW9hS2diVzQ4SXVQRGJUNVl4aXhEQUdoZ21TODhCdmM3TldTazZuVktwNkdCSmhFWVFzT1FVZmhjN0E5RFNhMEQrdDA4c3ZiV0NUMGMxNWZobnlna0VwRmhZWEFNT0xkd0JZWHpXYmIrb0g2UGM3QmVFMnV0ZzBJRnk0RXgzVGl1elFlK1ZQTytPYUxkSTI0VWRJUWFZSWlNRW8xeG94SFIwSDJMU0doK3ZzOXVmTEg1dTBCaXhzMUhkRVRrUW1OSmJpNHlFVWg5b1Z2YXJlVXZEeUVJdFpjYi9hd1RoQ1NXUkh5NENCY1dadW04c1dwb1JrcllZcGJ6Z1ZCUklNMVJlOWZ4R3QwT2tEU29lY3cyQ3EyMEV4RGRzYUJtUkhha09DOHpMc1FkczRMRzJHWmNXSWpNbXFXQXVQSDVpS3p3UjQzaG1VTzUrVkxWNDhhaG9NQ0RJb3BKSmlJVU1ERHEvbkd0ZzZCUXE4aStFTVd0QXJFV0Zydm5DdDF5OFNDOWI0SXVnR1kvanNDQTZDdGpyN0VOUkdDcmZjSjdkTFpnL012YjI4dDFad3lHdVdLUnRLaGQreUdXNk5aeVlGV0xmbGUySWFZT0RKRm03eGUxbmxOdWlNeHU0eG5rMlVQcjlyQ2ZYN3hib2w1NGJLSnRCRUpVUlhSRzF6RzZyUVBsc3ExZDVZOU91OFBYeUpMR3Jac1B0eDZ6WkI1azIrYnRCV3A3bVBlQjY1T2RucUtqYlRDOXF6dVAxYWlLbWl1NmdNQ1dSTHRuTm1UYVpwS05XVUYzZE9HSjVhaER2QXVhL3ptcHpiK1N6Z0VGVFNob1FpaG9RaWhvUWlob1FrRVRRa0VUUWtFVFFrRVRRa0VUQ3BvUUNwb1FDcG9RQ3BxUWdJSnV1ZFZ5UTcvclJtMlRPS1ZOdTRhV2IzWnZicjdlK2doR3p3UmVHQktmdEduWDBISmQ5N29MVjhyMVg4a0RlV0ZJZkpMYytzOHZvZVh1NWNkUHR6NG1uVHFZRjRiRUo2bEQ5SXVoNVozZDMxcis3cCtibTY1ZlZNbnBTdlVmem90RDRndG8xdEF1Tkd4bytZUHVkUmV2blB4MDQrNjM5SmVaaFVvbDllZEZJdkVCdEpyWitqK3VvV0ZvdWNkZENRbFhEdXdxN1QxNllrR2ZqS3orZDZxMGJ5aDE2NlpTVFhXOFlDUzJJL1BnQ2ZydFh3OVhmUEJmei8vMlhlUHQ1ejJPN0Y3WjhzN3ZOamJzMkx5dnZtajh5RjVhMUgwTWs1MWtXSkJ1UFF4eDMxQ3E1V3RqM1JaZVJITDdRR3F1VjFLclg4NGNwVlMvMXYrbVduYms1SjlmL3BmbGY3ejE5YTFkeHArWDhYODU5QmVQemZqUk9PTmwxRk5MRjB5YU1ldnVmMHpxazVqRnEwaGlsY1pyVFRYYi92ZnozLy9QZjYzOTNQanptTEdVYU4yYkJOM05lTUg4WGFQNnBDVDFYTFJrL3VSUlkvTW05VXZ2T3p3aG9mZUFidDBScmdtNVBiVGNhdm02dWZuNnhib0xWMDRlTzFpK1ovWHI2M1pmcTIrODJTYm1nMkloZklJV0RHRi9vMDNZcWJ5TUpJYTUyaWJrTC8yY3lkK24ydW9XZllsRGpRWC95R3dBMnBPSzR6N0k3ZVVXbklheFhEU1dTbU01MC9hWkgvOHZ3QUM4MWI1SFpmS3Z1d0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/oj5zljZXlsZXlvIAucG5nXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJvcHRpb24tbGlzdFxcXCIgdi1zaG93PVxcXCJpc09wdGlvblNob3dcXFwiIHRyYW5zaXRpb249XFxcImV4cGFuZFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJvcHRpb25TdHlsZVxcXCI+PGRpdiBjbGFzcz1cXFwicG9pbnRlclxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiaW5uZXItcG9pbnRlclxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwib3B0aW9uLWl0ZW1cXFwiIHYtaHRtbD1cXFwiblxcXCIgdi1mb3I9XFxcIm4gaW4gZ2FtZURhdGEub3B0aW9uc1xcXCIgQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZSgkaW5kZXgpXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIml0ZW1TdHlsZVxcXCI+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvT3B0aW9uc0RpYWxvZy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPjxkaXYgY2xhc3M9XFxcIm5vdGljZVxcXCI+PHRhYmxlPjx0cj48dGQ+PHNwYW4gdi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MjYqem9vbVJhdGUueCsncHgnfVxcXCIgdi1odG1sPVxcXCJub3RpY2UudGl0bGVcXFwiPjwvc3Bhbj48L3RkPjwvdHI+PC90YWJsZT48L2Rpdj48ZGl2IGNsYXNzPVxcXCJvcHRpb25cXFwiIEB0b3VjaGVuZD1cXFwidHJpZ2dlck9wdGlvblxcXCI+PC9kaXY+PG9wdGlvbnMtZGlhbG9nIHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIiB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCI+PC9vcHRpb25zLWRpYWxvZz48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZW51QmFyLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vQmV0QW5kQm9udXMudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXEJldEFuZEJvbnVzLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQmV0QW5kQm9udXMudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNzEzOGMxOGUvQmV0QW5kQm9udXMudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmV0QW5kQm9udXMudnVlXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmV0QW5kQm9udXMudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldEFuZEJvbnVzLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuZm9yemVuIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lhrvnu5MucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmJhbGFuY2Uge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S9meminS5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uYm9udXMtYmFyIHtcXG4gICAgaGVpZ2h0OiAyMCU7XFxufVxcblxcbmRpdi5pdGVtLWJhY2sge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG5kaXYuaXRlbS1zaG93IHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5kaXYuaXRlbS1zaG93IGRpdiB7XFxuICAgIC8qaGVpZ2h0OiAzMCU7Ki9cXG59XFxuXFxuZGl2LmJvbnVzLWl0ZW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmJldC1udW0ge1xcbiAgICBtYXJnaW46IDMwJSAwIDAgMDtcXG4gICAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG5kaXYuYmV0LFxcbmRpdi5ib251cyB7XFxuICAgIHdpZHRoOiBjYWxjKDM1JSAtIDFlbSk7XFxuICAgIHBhZGRpbmc6IDAgLjVlbTtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24ge1xcbiAgICB3aWR0aDogY2FsYygzMCUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duLW51bSB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC1zaXplOiAyZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duLWJhY2sge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2NvdW50LWRvd24ucG5nXCIpICsgXCIpIDUwJSA1MCU7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24tc2hvdyB7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBoZWlnaHQ6IDkyJTtcXG4gICAgd2lkdGg6IDkyJTtcXG4gICAgbWFyZ2luOiA0JTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL0JldEFuZEJvbnVzLnZ1ZT8xN2Y1NjhiZlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJHQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxrREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7SUFDQSxXQUFBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtDQUNBOztBQUVBO0lBQ0Esb0JBQUE7SUFDQSx1QkFBQTtDQUNBOztBQUVBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGdCQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBOztJQUVBLHVCQUFBO0lBQ0EsZ0JBQUE7Q0FDQTs7QUFFQTtJQUNBLHVCQUFBO0lBQ0EsZ0JBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsdUJBQUE7SUFDQSxtQkFBQTtJQUNBLGVBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7SUFDQSxvQkFBQTtJQUNBLHVCQUFBO0lBQ0Esa0RBQUE7SUFDQSx5QkFBQTtJQUNBLDZCQUFBO0NBQ0E7O0FBRUE7SUFDQSxlQUFBO0lBQ0EsWUFBQTtJQUNBLFdBQUE7SUFDQSxXQUFBO0NBQ0FcIixcImZpbGVcIjpcIkJldEFuZEJvbnVzLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4gICAgLy8tIOWxleekuueUqOaIt+eahOS4i+azqOmHkeminSDku6Xlj4og5aWW6YeR6YeR6aKdIOW9k+eEtui/mOacieWAkuiuoeaXtlxcbiAgICBkaXYuYm9udXMtYmFyXFxuICAgICAgICBkaXYuYm9udXMtaXRlbS5iZXRcXG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmZvcnplblxcbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93XFxuICAgICAgICAgICAgICAgICAgICBkaXYuYmV0LW51bSh2LWJpbmQ6c3R5bGU9XFxcImJldE51bVxcXCIsdi1odG1sPVxcXCJsb2NrbW9uZXlcXFwiKVxcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uY291bnQtZG93blxcbiAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLWJhY2tcXG4gICAgICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tc2hvd1xcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNvdW50LWRvd24tbnVtKHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjQwKnpvb21SYXRlLngrJ3B4J31cXFwiLHYtaHRtbD1cXFwiY291bnREb3duIHwgdGltZVxcXCIpXFxuICAgICAgICBkaXYuYm9udXMtaXRlbS5ib251c1xcbiAgICAgICAgICAgIGRpdi5pdGVtLWJhY2suYmFsYW5jZVxcbiAgICAgICAgICAgICAgICBkaXYuaXRlbS1zaG93KEB0b3VjaGVuZD1cXFwic2hvd01lc3NhZ2VcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJldC1udW0odi1iaW5kOnN0eWxlPVxcXCJiZXROdW1cXFwiIHYtaHRtbD1cXFwidXNlcmluZm8ubW9uZXktbG9ja21vbmV5XFxcIilcXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uL2pzL3JlcXVlc3QtbGlzdCdcXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ3VzZXJCZXQnLCAnY291bnREb3duJywgJ2NvdW50TnVtJywgJ2JldHMnLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICB0aGlzLmdldENvdW50KHRoaXMuY291bnQodGhpcy5jb3VudERvd24pKVxcbiAgICB9LFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXFxuICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIGJldE51bSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAzICogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICAvL+avj+asoeW8gOWllumDvemHjeaWsOiOt+WPliDlgJLorqHml7ZcXG4gICAgICAgIGdldENvdW50KGZuKSB7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Q291bnQoKS50aGVuKChyZXMpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSByZXMuZGF0YS5jb3VudERvd25cXG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudE51bSA9IHJlcy5kYXRhLmNvdW50TnVtXFxuICAgICAgICAgICAgICAgIHRoYXQudXNlckJldC5pZG51bSA9IHJlcy5kYXRhLmlkbnVtICsgMSAvL+W8gOWlluacn+aVsFxcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoYXQuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdlcnJvcicpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmbiA/IGZuKCkgOiBudWxsXFxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50RG93biA9IDBcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIOS5sOWumuemu+aJi1xcbiAgICAgICAgY3JlYXRlVXNlckJldHMoKSB7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgUmVxdWVzdExpc3QuY3JlYXRlVXNlckJldHMoSlNPTi5zdHJpbmdpZnkodGhpcy5iZXRzKSkudGhlbigocmVzKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLmRhdGEuZXJybXNnICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ3Nob3dUaXAnLCByZXMuZGF0YS5lcnJtc2cpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpXFxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGdldEJvbnVzTnVtKCkgeyAvLyDojrflj5blvIDlpZbnu5PmnpxcXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcXG4gICAgICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c051bSgpLnRoZW4oKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGF0LmxvdHRlcnludW0gPSByZXMuZGF0YVxcbiAgICAgICAgICAgICAgICB0aGF0LmdldENvdW50KHRoYXQuY291bnQpXFxuICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdjYW5jZWxiZXQnKVxcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgncmVsb2FkaW5mbycpXFxuICAgICAgICAgICAgfSwgKHJlcykgPT4ge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcylcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duID0gdGhpcy5jb3VudE51bVxcbiAgICAgICAgfSxcXG4gICAgICAgIHNob3dNZXNzYWdlKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpXFxuICAgICAgICB9LFxcbiAgICAgICAgY291bnQoKSB7XFxuICAgICAgICAgICAgLy8g6Led56a75byA5aWW5pe26Ze0MzDnp5Lml7Yg5Lmw5a6a56a75omLXFxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnREb3duID09PSAzMCAmJiB0aGlzLmJldHMgJiYgdGhpcy5iZXRzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVVc2VyQmV0cygpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIOWAkuiuoeaXtuS4jeaYr+aVsOWtl+aXtuS4jei/m+ihjOWAkuiuoeaXtlxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5jb3VudERvd24pICE9PSAnW29iamVjdCBOdW1iZXJdJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRkaXNwYXRjaCgnc2hvd1RpcCcsICflgJLorqHml7bor7vlj5bplJnor68s6K+35Yi35paw6aG16Z2iJylcXG4gICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY291bnREb3duKVxcbiAgICAgICAgICAgIHRoaXMuY291bnREb3duLS1cXG4gICAgICAgICAgICAgICAgbGV0IHRoYXQgPSB0aGlzXFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuY291bnREb3duID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb3VudCgpXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyDlgJLorqHml7blsI/kuo4wIOaXtiDojrflj5bojrflpZbnu5PmnpxcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2V0Qm9udXNOdW0oKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgMTAwMClcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmZvcnplbiB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDgwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG5kaXYuYmFsYW5jZSB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDgwJTtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5L2Z6aKdLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uYm9udXMtYmFyIHtcXG4gICAgaGVpZ2h0OiAyMCU7XFxufVxcblxcbmRpdi5pdGVtLWJhY2sge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG5kaXYuaXRlbS1zaG93IHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5kaXYuaXRlbS1zaG93IGRpdiB7XFxuICAgIC8qaGVpZ2h0OiAzMCU7Ki9cXG59XFxuXFxuZGl2LmJvbnVzLWl0ZW0ge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LmJldC1udW0ge1xcbiAgICBtYXJnaW46IDMwJSAwIDAgMDtcXG4gICAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG5kaXYuYmV0LFxcbmRpdi5ib251cyB7XFxuICAgIHdpZHRoOiBjYWxjKDM1JSAtIDFlbSk7XFxuICAgIHBhZGRpbmc6IDAgLjVlbTtcXG59XFxuXFxuZGl2LmNvdW50LWRvd24ge1xcbiAgICB3aWR0aDogY2FsYygzMCUgLSAxZW0pO1xcbiAgICBwYWRkaW5nOiAwIC41ZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duLW51bSB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC1zaXplOiAyZW07XFxufVxcblxcbmRpdi5jb3VudC1kb3duLWJhY2sge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGJhY2tncm91bmQ6IHVybCguLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2NvdW50LWRvd24ucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbmRpdi5jb3VudC1kb3duLXNob3cge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgaGVpZ2h0OiA5MiU7XFxuICAgIHdpZHRoOiA5MiU7XFxuICAgIG1hcmdpbjogNCU7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWVcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTklBQUFCekNBWUFBQUR0MlZ3SkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd1JEQTRORFEyUlROR016UXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93UkRBNE5EUTJSak5HTXpReE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1UyUWtORU4wWkNNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rVTJRa05FTjBaRE0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K2pxVGdJQUFBR0xKSlJFRlVlTnJzWFFsd0hGZVovbnA2YnMyTXBKblJaY21TRHpsMkl0bnhDZmhLbk1RbUpFNjRLc0ZBUVlBaXFjMWlvTFlxeXdhV0ttcHJkMW1TYkxHd0xMQXN4NFprZ1hVU1NFaENzb3Z0SEk0UEpmaGNSMHF3TFYreUpWbTM1dERjM2IzdjlSd2FqV1o2eHJKa1p6VC81M3J1MXZUcjY3MzN2Zi83Ly9lNlcxQitmeE55d01qU1J4TnBMVXR6RXI4UkNLVUNQMHNYV1RySzBuTXNQYzlTSkQyRDhOa0JkYW1Ia3ZVQUgyUHBNWmFhcVN3SkpRd2JTMHNTNlZNc2RiTDBNRXZQWm1iVVpmd3R5b3BLb0dlSlJBVENKSEJPL0M3QkVURjlneDVwSmlrbTRSRzlpTCttOGlJUWNrTW40R3VNS3dManl0Y21XYVJnUk5sR0pDSVFDZ1BuQ3VkTWlramNIcjMyYnRSc05Bai93dGNwVWFKVVdHS2MrZDZyM3lnM3A0SU55K2JxUDYzalVUbEZtNFc5WVNmMmUxclE0Vy9DWU5TQm1DSlMxMFNZUFZaR2tPQTJlTkJpNjhMNjhnN1VtWWExSlI1UTExb3Zmb2F0L2x5QS9YclI4eC9PNSsxbVlXdXVIVGhoZnR1L0VmdThOMElRRFJEMU9nZzZyZ29GS24zQ0xJSUNSWlloeFdRb1VoVHJIRy9qM3VvM1lCQmlPZmZ3aFpTWHkvOWkrTU42dG00eTZyRlNpMFEvN3Y0SU9tTUxZWEdZWURTYllUQVpvTlByNHpRU2lFeUUyY0FoUlJWa2NpeUdhRGlLU0NpRU40T3JNTkJkaWUzMXYxZXRWVFl3N3F4Z0N6TW5rc1VnQ3U1Y3gvL2R3RTA0cXl5Q3ZjSUdzODBLZzVHUlNCU2gwd2xFSXNLc0k1TXNzMlNWRUkxWUVQSUhjTTdYakdjSGI4SW5xbDdMdWd2alRsV1NTRVltMGd6Wi9LUGVpQXQvQ3ErQnJjSUJxOE1HUFNPUlFPUWh6RmF3dHEwVGVkSkJOT2loWjBtbkYvSFd5QnBzREI5SG5YRW9tNStranhzbWRXQXBlNVNoYld3WnpBNDdyT1UyMVJLUkJTS1VEcWNFMVlXeENtV1FKVW5sd3NlTnIrYktMbXBHREU0cmkxVTVweWNTRVVyVVF2RzJ6em5BdWFDVlV4K1BWZVNJU09ocllTVTVSeWgxeThRNHdMbWdOVHFrVHpwWjJhQXptcURqWVc1RkthcWJ2M1RoRWdiNzRtTUE4eFkxd2xadXk3bmRYZU5FN2R6YWFUbHYrNkYzY0w3em9ycmUxTnlBMXRVM1pNMzMwbzZkcWZXMXQ2MkJzNnB5U3VlTGhDUFk5ZHpybDdXUDFuWGxBNy91OXFQbjFmWFdGVTNZK3NrUFp0MldDMXZ2WFQvbGMxOUxjQTV3TG1qeFFLOTVBTDArSHAwck1uQ1N2UFRNL2tUbElWVjVwOW83RVE1RmNPUkFCM3E3UjFNTm9xazU5OENieVd6RW90Yjg4M2Y5SGovMjdqd01yeWVVSWtnU2p6NzhzOXpreTJoOG4vdnkzUVVUZTkvT3RyeU5OOXY1THFmenlFVVEvbHY3MForbENES2J3VG5BdVlDOEZpbVhXVXZveEdMRG5LYTYxSHAvNzBCcS9XVDdtVW1OSXQ0Z2NqZEdUclJDaUhUOFlIdUtSQnUzTEoyeWxTbUVzSDZ2WCswc0R1NDdtZnA5NGVKYVdLeW1uUHQxbmVsTFhkOXovN1VMR3orNGFscXRjZTNjcXF6blNyOHUzaWtWcTYrVWp3V2EwcTVZQXd5OEVUdkt6V3Bsbm5pN0M3ZmVQZk5TY3UrdXQ5VjFmdDdWRzFmTzJMbk9uZXBLV2R0MHNxZkxyRnpYK01RUFgxVFhlYmtrai9Id293OFVmRzV1TGJOWmZZNVY2MWRrdFdJYnRxeVpOckplYXpKTldkcXBOQ3pTT0VQandocTBIem12TnByaHdSR1ZYR3MzcjRHbHpKVHF5Ym5sV0xCa251WnhqR1pUM2pJNGZPQjRhbjNqaDFiaFpFZm51SFZzck1QRGowMXNySS8remJqVSs5eFg3cjY4aHBieEJKbWp3b3d0SDkrVTl4cHJHMnZ4OGZ0dXdiTlB2cFpGZHVUR2RVc1hxTlptOXd1SDFQdXNkRG13YnNzSFZMOXphMkx1czd2YWljUDdqK0xTeGJqMTd6cmJOeTQvZHgxVXkxeTlob1lxck5xd29raUpWSUJGVWpENzBMU29RU1VTeHg5K3N4dDNmWHF6U3FiaEFXOHFEeWVSeldGVHBWS1NOSmNyeVhoUG56eFBYWDJGMnFpZStMY1hVNDM4aXc5dG05YjdtdGZjeU1qblZBTU4zTityWXlRMG1ncVRURnlpYnY5bWJlcCtDNEdkRWNZNzZvdkxZSGFmL0I1SGhyd1RwVFRyTERpSmt1V1FqdE1uTHMyYU5qWGxxRjB4ejBubERUb0pIbGlJaE1LcWY1R3NXTjdJdVNWb1Avd09Ybm9xTGxGYVYrYVhTRnB3MVpSajM4NkQ0OWJwOWxVcHN1VU1qUFJQREhRNDJYVnJFWU5iZ2g5OSs3K25wWXkyYmx1ZjF4b21PNFgwc2t3R2FzWmwzVEtVQktZczdmaU9TbkhhSzI1WjFteTREc0ZBT0c1dFdPTThkM0s4eDF6YzJoaS9OMWtwdUxEeVJzVFNlbVJPMU90YUZtS1lFU1d6TVU2SWlqMDEwZDlScFY1RHpkVXBKTG53K3VYM3MrMytyV3E1SHRqOVZzb241R1djZnIyOE05cnkwWnVaNVI5SjFjUDN2dlhrdEpUdmU1VkUrWWxVeE9ERXVmWHVpVzlJT3ZibTI2bjFpMmY3V1NQZWhhRSt6NFJvRS85dGdtOVI3NTZTcnQrNFpXWEJrdXV5TGNtOTYzSnVPMys2ZXdLaHRmSzZhMTE1ei9Yd28vZXJ3d1luTzg2aTdkVkRDUHBET0gweTdnTXR2SzRHR3o3NGdVbjdjQklsT3cvZU1aUUN0S1hkTEh2a0tHbWRja2tVNzJnb3E4N1hLb1BhdVRWNCtMSDdWWi9sRjk5OVdqMkc2c3NzYmxMM001cU5haTlkY0FmQVE4UjV5dHhkbDVzQVhvK3Y0THpjUHl5a2ZoY3RiY1pBM3hEMjdoenZpT29hS3ZEaHo5NmV2Yk1RTk1xdVdOdVRnTW5xcFJTa25ScE4yM2NzRlVsYXVuckoxTzZsd0RJNHRPZElpa1FiTjdmQ1pyZXErL0hscXZWTEN6NWRjajlOditVSEx4WjhQSzI4Vys5Wmk5WTEyak1OWHRvUnQ5QmR6SUpQOEpVdWp1S0ZYLzFSSFNOYWU5dnE4V3ZPTEsvTTlka3M3WlRaeVNPODlVWUhmS21aQnF2VnRETERNVDd6NTNQWXQ3czlMbFVXMTJEOWxqVVR0dk5CeEh4bE1PWWJ3OTdFTVRpV3ZiODF0YzlRL3dpZS9PRWZDcjdtKzc1ODE5WHprUXB3V2RxUGRrMzR1M1ZGWStxMzB5ZmlFaSt6VEhQeHFOaGRwSktNMnZIR25TUVJSNlU3SHRZZUdSeEIyeXVIMVBXYWhpcVVWOWhUZVhqdjZodjE0MVRIbVJUNWt2dHBZYy9MQnlaSW5uTW56aWRrbWtsOUlISzZ3Y21XQzBPWGh2RFNiOXR5ZGd6cHNKZmJMdnRjbk9RMzM4bkwxajhoc0ZNU0tNV29IVzlRNmIxbzhqNThJNzVVajFyaGNzQ2NvZkY1bUR5NXZXbGhQU3BkRlpybjRjUk03N1c1NUVrMlpIN2VsZXVXVHBKVGsrUlRJbitoWmI1LzE4R1VOWGpnb1k5TkpIdmF2cnhqcUsydm5yRHZZOS80ejlRNjM3Zk1adFU4MTVIOXgvUDdVRGZNUjBtWXBGSU1ObkRuT0ltYWVuZnFQbnhwZzVIbGxmWkorN2xxeHNlZlFveFUrZTZmRDRwZURscFdYNjlOcEFLVXdMeEY5U2tpN2ZqNS82QnBRWndzaTFybVQ3WXlRdHhYN09zZW5CQnNVYTEwQVpZa1U5cGxRMU56L2NST0xHMXNqSytySFZsR1BaUldzS0dJd1J0T0VsVnBZZDYrbnZIZlhkWE9DWld1ZFl4YzRMTG12dTNaWDhCa3NoZ1JEa2FtL2Q0V0xHbkNLMzg0RXU4WW1IeE5XZENNQnAxK0g1bUU0TEx2Y3JIMTNyVnFtYW0rSlpPdis5TDh3anUzYldZcExxbC85TzJueGp1Slo5cXcvWnZiVUdZdm05V3FUM3VLVUJGTHUvU0c0NnF1VE4xSDk3bng2SlBUWFlHaHZxRU1INkE2clRmMTVMMS9vOGt3WVo5TVhMclFkM25TcG9BeTUzTHprMS9jekt6dThBU3lHL21UekZta2xHb0pNckQyMXBXWFhiY3UxbWtrNzNWQ3VhVmQ4NTZYMjlKOE1MTks5TGRlUDRKYjc5cFE5UDVSeVFVYlhuNzZsUW1WbWV3TmYvZkxsOUhiSFIrQXJhc3Z4NWgvREo0Ulg4N2o4THlIOS84ZlZxMi9NV2VlanNQdk1tbjJabTVuL1V0MzVyeTJxUVpSenAyTWR4Sm1zNUg1Y1hQRy9idHdSTFVVNlIwQnY3N01mQnc5NXkrcHFXWFY5WVg3blduV3U2OTNhRkk1aEpqTVRYWmd0OTIxVWowdkw1dEQrMCtocHM2Rk9VMjFCUVZ2Wmwrd29VaVJibzBXdDg1TnJTZjlDbzc2ZWRWb2UvVklWaDhnUGNSYmlMeWI2clhsa29wYTRGRkZMZUptZGdUNThsNE9rWElkaS90bE8zNnhlMExudFpRZGx3OHVIMmw3TjNVZHZGenYvTVJ0czFmYWFZd2tvUmpuaHJldWlKT25abzRiUzI1c1R0M0QxbnZIcDdNc2FsbUkzYysva2VFMHoxSHpycjFsUldJZGlaSDczR1hBZ3hQcHg1M1V5Q3JLTkxkUGtvcG1nK2I1VEd4Nzh2Nm1xWnN0cUN5MUFnMk4vUEgxdEh5dHF4YW43dVBtTzlhZy9mQ0pSSDI0VUx6UEdtaHpnYit5ZUc3NEo5YXMzZVIzeE8vRGtpYzhTaUNVQW9MK0FMNGgvVlgyenUzQlFLTzJSU3IycVEwRXdyVDZSL2w4Sk9JS2dYQkZLbGpUSXNsVWRBUkNRVXpTdEVoallVWWxvOHhmRkE2OVRxQ1B1QkJJMldrUlNVdlpTV3lqRklzZlJjL2ZHTTdmUEtrWFNBNFN5QjRWS3UweWd3MHhpU1dXTnhUajM5QVUxSjM1a2l3VmdZSU5XbFRUZUIxWFRGYWdmc2VNTFJtWFZPbkhMWmFPM2hOT21JMDhFcFNwQnhzS2hTci8ySDloaWZOT1VhMlVTTmFLVU9ReUxzYmF0SlJZQmlOSzR0UGxVN0ZJVXhoSDRybWp6S2VLcW1hTFc2aUV0V0pMa1pzdUNnVnFva0xzdzNYT1R0UTVoK0YyZUdHM3h4OU85UG5NR1BTV28yZTRBcWVHRjJGVXFxSENtazdvNHNhQWh3TzQycHIweElTaUZCSnNtTG5JQWIrZ0NMdEE5V0VDZHBYY1VuRkNjVTZKUEJKSVFRc1ZUdDFGckovYmhoc1dEL0dQa1NaK0hXTXAvZ3lSeVc2Q2UwNFFTOUNIV3dQdDZEanB4UDZ1ZFJoUkdxandwaVRWR0hGWTQweXFLYWtnSXpIbEFkbnBuMnZITDVoZmVMb2J4aTJXYXJuNFp3ZExrRmgxL3YvRmZmZjhtYkhGb1JKSDhsK0F2OHNET2NCTWVpeWFxQ2s5ZEZZRGJIUExJZHFyMExMY2g1YkZ6K0JYenkxQmQ5bUhpQm41T25RaFFSaE9IRVhSZWtZdk54ZG0ya2U2VWkwYVRkeFZPRUd3cE5YU0paZXptRnpWdlkvanZnZjVVN3RsaVBuT1kvaFlGMlMvekt4MUdZdzJCMFJqL0ZGNEtSeEJaTWlIZ1hNWG9MTjN3N204RVhwN0F6N3o2Vk40L0NlOTZLLzdBckVsZ3pReUNyYzJoYmRXVFNKcDZMSnJNTmRPdFZxeHhIbGpLUW1yU2tGZFFoTE9obGZ1dWJxZndCZTJlMVFTK1U5M3dITnNBQlpYRXlwdmJJYmdka3d1ZTBHQU11akZ5TWxPOU8zcVJQbHlEMndMV3ZDRkI3MzR4WThleDJEOTUwc3VJS0NTSmVIVHFNdVo5RkhFZkQ1U0VVeE01UVVrSisxeHduSngvMHFYSUZleEVTemE5UmJ1L3lwL1Bzb0YzNG1qOEJ6Mm9XYmQ3VEEwMVFDQklCQ1U0cDhTaVVtcU5oY01lclVRaEhJbm5EZmZoT2o1ZnZUdDN3MGxlZ3oyeFN2eHhlMEQrTWNmL0FtR3h2Zk5lc0tvaWYyblhPV0tWcWI2WUoveUhwL0F3SzlQVG8rbXBQbGVLcmt3VGpKZFlvcVREdGYrczArS0xPT3JIM3FCclMxRThBS3pSRWRHVWJmcHd4Q3J5d0h2MkxnbDBzVVE5WXVRb3dwTUx2NGlGZ3RqSUNPWU53QkRRelhxYnRtS25qMHZRRy90Z0dWdUM3NXl4L1A0OTQ0MVJmZk5YL1VWN0VuQ3BKTUZHcjZNY1BYYm1oYTBIeldYaS9jeGltUkZaSzBESlkxWVFweFlFNGcydzJRemRPK0U0Mk51S01GZWpCenRoYXRsSThRcU80OXh4MXNUUDdlb2grU0xRUkY5Nm1jWFl4NEQ5QzQxQkJyUHdQS0sxUTY0VzlhelkreUZ1Y3FKOGtWdUdIYitFYkg2Mjk5VEpFbGFsQ1JSa3Q4dVNQMHRGRW1EMHBYZ1c0VHk5UzVTNmhXN2s2MVprbXpwQk9QcnlZa2VRdkkzSmUzM3kyZ01kN1R5RjFSV3dOTitCZ2F4QnBibXVWQzgzbmhsOGM4c3FpY09JaFpnRnRYbWgyZ0tJekxXQUgyWVdTdkJ6Q3lhRkcraEhxKzZyLzlDRFR4dm4wWEZtaFc0bytVZ1hoeTlmY2FKb1M0VGlrV1JsVlI4VjFFbUVpWXZTV2JKaUwxZXl5QmwvZXhKQ1RteWlwTG1seFdBSktHU0g3QVdNbjVYZmFQUlh0eXdLUVNFaGhFWmlzSlcwd2d3Z2doeWxKMU1naFNSMlVKQmJJejE0U1lUVEpWOEhDbklmS1FneHJwRkdCMWU4QS9ONnd3aUJEM3pmaU5BR1R1R2YvQVlPK1lRYmxnUnhkUFBYSVRKV1o4ejNwVHFRNFEwY2lSK1RGZkt5V1dLRk5NYjZDcXlCcUZvaWpQdDhIZFM2eEFLSng4U2ZsdU9CaVg2VHpCalpFUzRjd2hDekFTejB3NGxIRUt3bi8xdFlJV3R4Qmlab2hETlRoaXRmZkFjUGdWRkV1Qm9Oa0N4VkNIaUdWYnJSVysyTUlzVmdZVkpPb3ZUQVYrUEFlR0xRekExdXlEN08rRjMxRTNmalJYeEoxQ250UXl1NkFsWm1hWWVUQ2NzOEtpMUVob05RWTZKMEluTWs1TmpDSStNSURCNEhuUFdOYXJTRVFZL1JvNWRoTytzSDNvKzAwSHFSTVZTNWtPVk1iSVo5ZWc3ZUlMNWQwNVkzUlVzdjh6V0daRThJZkN2dFpyZ1E0RHFiV1o2eWh6UVRleExNeE5oMnJWMGxQbENZME9zZnpLb00rV1ZTQWlTMzRlS3BocVlyWGIwN0hrWGtpK2dqcDlGUjJOd3pLdUF0ZDRCT2N5a0JaTjdDck5XL1cwbm9ZUUV1QlkxUUE0RklFZEQ2ckVrbWZXTEVSODdoNThLZWtZMXgyU2V6Tm8zcmI1WEljV1l0YmwwRmpxdmhVazRHeFJHQW9VNVBWeW11VnBiTUh4Y1JtL2JLZFJ2V2d5OTFZREFRQUN4VUpUSk55dVRmZ0w2M2p6TlZJSUR0YXRXc045RGF0M3BKQmxTTkFwOWdCR3dwNGVkWXpuVjIwejRTRUkrSDBuclRhdjBITVMwWWd4T0lCQlRMWk5PMFNIU3c0aGhaU1RSbXhGbTFxV2kxbzdZS010M29nZG1vdzVCWm9FTWpFQVdxOEw4cWw0by9qQ2NpeW9RR1IxU3JSbGlZY2lCTVdhaGZEQUVtR3hrQmk4Z1ZGQzl6WVNQcE9RZTFOSlRDVjFkQkt6TlVBYVlyMlRSWWN3YlEzQmdCSVl5VDF4bEM0eFlpc1FzandIU2FBQUdteDZ1YWxFTkw0dFNHSkhCR0VTOUhvR2VidWlOQTJxVWowK29pbzRwRUVRRkppdkxPNmdnYUo0UE14WDExWlhzV2hhSmgwUVZjbHFuRmFhcUJUaDgwbzdWeXdZQmtYK3R3Z1M5U1lMRTVCa1BrVWRqRXZONXdyRFlqUEIwQitFUFJOVjZzSm9OY0xwTmlERG5LUkxrWTRNQ1pGbUdLQUtoaUE2aUxjSU9GOEtoWTI2WXFoZFN2VTIzc3BPMTRnYjVMQkpKdXhuQmk5MmJzWHJwYjJEUUJSRmdaQW9PaGFFdlV5YzBJY1o4SGNrWFJXOS9CR0ZHSUlmYkFwMG93RHZJOG5vajBPc0ZpQTRGUmxHbkVpbmlrYUdZcmV4WUlUN2dneGQ3dHZDeFhzS01TTHM4RmluM1pEd0tOc3lJbjlUNEVaeHRmd3J6Ry93SVJjMEloY3d3am81QWJ6VkJDc1hnOFVSaHRvdHdWVm9neDFnVlJHVTRxOHp3ZWNQd0QwZFJ4c2dVWStTS2pURzVaNnlFa1ZtaVNwTVA1enJNR0d2NkNJeFVaek1UYk5Bb1Z4cHV2UVl3bHRueHIyY2VVTHM1YTNTUXlUSUZJWjBkb1NHdk9pbTF3bVdFMWFSSHlNT25Cb1VRRFlRUkdBM0RwQk5RV2NXa0lLdlE0S0JYM1VlMHliQkVCOVZqZmYvMEF6QmFiVlRBN3pVZmlTelN6TUc2N0c0OHN2TW92bjdiNjRnTjlrQXVxME5VckFaR2h5SDR4cUF6R0tET0JVcHBhNFg1UmpMem41alBaTFJBS0srR2FGRmdEdlNpdkVyQ0kzL2NCT3Y3N3FiNm1rR0xOUFh2STVHUE5LUHd2djliZUdSWERGOWZ2eGNHL3dVTW9RcUN5OFVmRlZiSGlCQ05RSW5GMURvUVJGWlZCa1lnbXhtQ2tVZnlnaWdQRGNEQkROQWpPemZBdS9aYlZLRFgwRWZTeGZ1NjdQOElWNEZNYS84ZUQrMjVGLzR4SGVhSkF6Q09kVU1XR0lFc0J1aGNGUkRjTGpYeGRmNmJ3cllaQTkxcVhoL2I1NkU5OTdCai9BTVY1TlV3U2hvOG1mYlhjUkV1SDZZTmY0bS9hMStPMVoyL3hPYUdUdFNVRGFoVkVvNENNU0grZkxOZWtXQktQRHZWRnhEdzB4T0xjTmorZWJnM3JLVTZ1bXJTTHArUFJOYm5tc1BkdWhibnNCYVB0dStIKyt3QkxCQTZVR1BzaDhNWWY0dVFOMnhHWDdRYVo1UVdERld1ZzNQdGVyaXAySzY2VGNvVGJORGFrVWgyTmVGcVhjZEtmQjA2dktNNE1qb0lKUnovV0xUZ3RNTlU3b0s1dkpKUE1xSjZ1UllrdXBLdlVSQ3VEY3lPQ2pVUmlzRWU1WnNpSk5NVUlRSWh5UVhRZ0N5Qk1MUEkvNmc1alNNUkNGZjRxRG1GdndtRU5DN2tzVWcwK0VvZ0ZNQ2xLN0pJRkd3Z0VLNXdRSlpleDBVZ1RJT1BSQ0FRMHJYZEZIMGttYVFkZ1pEa2dwYVBSTUtOUUpnRzBGdzdBcUZRWFVlenZ3bUVtWFdTTkMwU2pjY1NDT05jbUhxd2daaEVJS1M0UU1FR0FtR0dvUjFzb0VtckJNSTRGNlljYkNCcFJ5QVU1Q1NSdENNUXBrdmFLV1IxQ0lRQ2pOSlVYeEJKMG81QVNKTjIrWHdrQ2pZUUNOcTRvbUFEZ1VCSU4wc2s3UWlFYXlmdENBUkNJUWFKM3RsQUlCVE9JeHBISWhCbUZIbWZSNkl4SmdJaFFSS0syaEVJTStza2FVbzdFUktWSFlIQVlFUzRBR21YQXhYU0FQeEtHWlVpb2VUaGtJWTB0OGMvZlpuNDlIbG1XaWkvUXlWSUlERE1sLytja3lkNXBkMXlxUTJLRktOU0pKUzJaOFE0c0lKeElhKzBpOGtJNm5Xd1pHNnNSaTl1ak96QmNldHRWSnFFa2dYbkFPZENOc2dLWWltTEZJeGdORFVkS0NOdERqNkZ4a2dIbFNhaEpORVllVmZsUUM1K3FOeEpXQ1JsY0V4MzNtNlM2cklkaUVmdTd2SDlBSzladCtHWWVSTVVtZzVPS0FFSXJLVXZDNytCVzhkMmFFYXYrLzI2MDV4RG5FaXhJejM2QS9PZDBnZHlaUmFaOWRvYytEV1doMS9EY2ROTk9HdG94YWhZQlJraWxUaGgxc0NnaEZFdUQ2RXArZzRqMFY2NHBlNjgrM0R1c0lVa3dINjl5MTBtcno2NGZXU0h6YWpRMTM4SmhBSXhGaEZHMy8vanlrLzErWFVIUlppcWhFQlVzTlNVeVlaVmM2SnJxSGdJaE1Md3hCSHo0eSs4YTNxRHJmWnhJc2xjdmIxeTJqajJ2cm14bXFaS2FUNFZFWUdnalQxbmphOCsrSHZIcjlucUdaWkdkUDNmSE9DZTFBaExGejd6dE9PSkExMkdmVlJNQkVKdXRIVVo5ak91UE1rNWsrQ09KSDV0c3hYL3ZMZU14OEtqa2l6b2RodzNkK2xGakM2cGlzMjFHR0NsWWlNUTRoZ0pDa00vUFdoOTVrdlBPNTVqWERtVnNFWmVsaFNoL3hHWG1xbjYyOVU4Z3VkbXFabWwrWGFUNG41bzQ5aWFUZk1qcmZVT3FZSDk3ZEFKRktZamxBNWtCWkl2TEhpN3ZlTEYxODhhMjcrN3Qrd2crM3VRYlRyTFVpZExmRjBka0JYNnYrTks3Vmo5VDlVR3R1Q1J1NFpFNGh1NVZUSnhQd3IwVGlGQ2FZRlBwT091RDUvNkhXQ0p6MXk5bUVpai9YL2JIMldjVVRQeThIZm16bnkyQTU4dVZNbFNGVXRPbG16Z004bEJGb2xRVXVBa2lyRGtaMm1ZcFlHRVR4VGtCaXM5WTdiSEtIaUdNWlpDaVozTWFTUWlpMFFvUllzVVNmQWhsUGg3RXY1ZmdBRUFWTVczek50Y2JTNEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WGu+e7ky5wbmdcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTklBQUFCekNBWUFBQUR0MlZ3SkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRk5rSkRSRGRHT1ROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBGTmtKRFJEZEdRVE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1UyUWtORU4wWTNNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rVTJRa05FTjBZNE0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzhOd3Y3d0FBRkQxSlJFRlVlTnJzWFhtVUZNZDUvNnE3NTlyZDJaMDlXRUN3TERkQ0xBSVdlQUtoRTFDVWlDZlowck9NN0FCK0w0bHoyZmtyc1VtTS8zV2krQ1ZSOGw3aUhKYWRDRmw2QnN1V2RhQm5DU1RaM0FJSkJFSUN4TEZjNGxoZ2Q1bGxqNW5wN2twOU5UMDlQYk16UGMwd3k3STczMjlmMFhmMVVGVy8vbjdmVjlYVkd2LzFBNUFIZnBHK2JLWEZJdDFoN1NNUXlnWFhSVG9uMG42UlhoWHBOWkhpemhQWTZzdHlxUUhQbWNHVEl2MVFwS2xVbG9ReVJwVklkMXJwYXlJZEYybXRTTC9LUGxISjJsWk5MZ24wS3lJUmdUQUF5SWxmV2h4Um5RYzBjSmdrM1lCbk5SWCtoc3FMUU1nUGhjRjNCRmVZNE1wM0JsaWt2amhmU1NRaUVMd0J1WUtjc1ltRTl1ajl3NG1nMzhmK0JkY3BVYUxrTFFuT1BQZmUzOVVFN1dERDNVM2ExeFdNeW5GM0ZsN2k5YkRidUJ1T21KT2hBeUpnWk1wRUFtRllReFV0dWg0NllZYlNCb3ZVZ3pDYVhYV1hlQUJqVzhhcHE4VHE4d3pDTTlWci8xMzNXampJVnVTN0FBbnptckVVZGhxdEFFd0J4cGlrSkM0SWhKRUNqb1lFbXphdWNCTVdLUi9EbDdSM3dRZDYzbXU2Ky9sYk5YL1c4WVFtMWdOK0RWcmRTUFM4L2pRY2g4bWdLRWdlaTBnbWNvcWxZeFhFS3NLd1pZOUZJSk5MTTRORTRwekJCekFmTHV0MThLZmFSbW10Y2tGd1o1NVlCSkZJSVovS0d2TGQ1elY5R1p4QUVvbU1GVVdWZHhSVVNwSUl5U01YUkNMQ2NPWVN0eU1HK0dkS3VhV0FhUnJReGliQjY4WXllRko5SitlMWdqdWpVa1R5Q3hMNmN2bEhGM2tEN09IelFXR3FJSkVpaVlSTE1BV1pWRVdTaXFYb1RDQU1YeXBaelYrUXlEQkJWY1hTTkdYck5vWEUrOENjRDR2WlBoakRydVR5azdTa1laSWRTN21qREh2NVhHQ3FUNXlzaU13MVlOd2lrNXIyazRoRWhKRkNKaW52aEZWQzhqQnVnS0lwWUJnNklLV1FDNCt6elhuakZKb2JFejZIYVVrU2FVZ21WWkJKbGNJT3JWSlN6akdpRVdHazBDaHBtWVRNWThJYVNSSUphUWVxYU9GR1FuSUJJQytSbUpiT1pDQzZXTDIwUkVnaVRWZ2lKazZYRWc4c0VqbDlJL0tUQ01NNTJKRHlsWmdna3Fva3BaM1FiYnFKOW9aRGwxSHYyanVrWldlV3lWSmhpWVEvcFByUUVnbUxsTFJIa2pRTVdKbzgzSVdOWllUT0s1Mnc2OTI5TjN6ZHRGbVRZVnJMalE5dHZIajJJcXovOXpmczdUWGZmaHpHTkkzSmVTd2Z2dnVQM3l6eldtTzJKbU9RRERhb2FKWEVFaVBXR0FyZ0NVUElPMTllbnFTSmxBZXBBQVBqeWVBQ0JoMHcvSjIwUmtTZTdFYjk2b3ViSVhxdC80YXZQYlR2Tkt4NE9nNE5vK3VncXJvS3FtcXFYTy96UWg2Q09JbnpEVUVxajgySTRPekM0VXhhSlVWSjhvWWJRdVlKbDRZTEM0VmRQa1VSQ1ZMQkJXYkp1WlJmUkNRcTJMQ256QmdEb1lxQTY3VlgyNi9CaFMrNjVQcW1YK3lReXhWUEw0R1dCWGZkOU8veUJ3UFFNcTlacnZmMXh1REUwWXR5dmJvbUNCTW1qNmFLeXhkdmtCMnl5YmFPWFQ1Y01JcHpGUXpEY0wzVVZkckpEbGlBOUVpR1pIaWRTRlFBVDYxKzJKTlVpOGZpOFBwTGI5dU4vRVp4L3lPellmS01pZmIyOXMxNzdienFSdFhDaW1kK3p5YjdpYU5Kc2lPSlV2c0orY21FMWtlNlRPakdjRG5pVyt3clV0clpQaEN6QWdzS0l6MlFoVG9oeDc3eFY0OW5XQUpzeE42c2hoK2VXUFVvZExSMzJQdFEycm1WTDhxK0ZTdVh3SkdQVDhEeHo4NUM1OVVvekY5eXQvU041dHd6RSs2Y08wV2UxK0h3MS9wNll2YjFaOW91d2FZTjZjN0Z4Y3NXZXY2OVpRWEZpZ01BeStTQ0c1RzRHNDg0OGNhVkRBRS9mSEg2QWx3OGQ3a2srWG14RmcyTmRYRDUwa2NRN2VxM3BTSEFRZnY0bVBHaklONGZrNzVYTnZBYTUzNGtJYUdBRDVtU2ZNVkt1d0VVNG1TTmN2cEpna1M1R20xeFJISS9mdXI0R1dGUmRnd0lWbVJqWFBOWXFwaFNCQ0NjWENnMmFwY1VpVTZpa1hPVUM5Tm5UWUxtS2VQeUh0LzBpNTBaZmsxMUpPeGU1bTV3NkhUTTY5N2w5MERINVU3WThQd21hVzJrWEZ1NlFQcGZLYUQwUk11SiszQjVYbGhRNTI4cWVNK3lKQkszbWp2M1ZFWWFsZGpObzFCZ3dkbG9KOTg1VVVpdjRxTm1HTkdiUG5zcWJIOW50L1NQTm0zWURHZE9YckpKOU5UcWg2VFBjL0hjcFl6cmRyMzNvYlJjTGEzTnJxUW5GQWQzYWNjY0NiTFdDVW1uL2pJNjlSOTZQbi83TzNzZ1ZCbk1lM3p4c2dVRm5YOE1Vc3hkUEJzMi9EaHRoYVFzZlBwZW1EWjc2a0JWemdvNEFWU25oUjBsQm9XbEhTOGtNN2p6QlZ1Q0UvbWMrbnc0Y2ZTUzYvSDVTMmE3VnRpeFF5Zmc4ME1uWmQrUWswU0liWnYzd2VuajUyU3dZZHpFc1ZreWhROWN6N1ZOeUNxWGRMa1ZEamJrT1NXRFI0ektPeGN3WEwzaUs0dmRwZDBydSt6MSs1YTNRSTJMajRUNXVaVnpyRThRZC84WmV6dGNFNFRHTVRXU29ESWlaeDI3d3hGc2NNdVBlT1RCaHRqTFFzRUdLc2lpVVJtdWhGbU9rUWhvTWRCS3lVWXVDRE5oYWxNR2tkQkhDdGRVd2FtanB5MlpGaEErMWhUUDk1czRveG5XZkx2ZVFhUXErUnVjUGxGQVNMOVlmNXdxcCtUc3VwbGdBOCtlTzRYZ2hpMXY3SVp1YTd6ZGszLzQ0TURIdmRqMitUVFl1bm0vZmQ2M3ZqZGFrc0VMenArNkFNYytheXQ0WHV1OXM0Rk0wczJhSk82NWZMU0NCWjN0c0pKajZ1cS9kRHNHclRaUGE4cFpYaGdzbUxOd0ttemZja2h1SHpsNERPYmZOOWViVHhhUFowZzdMMFRDc1BmcGsrMXlIWmZOVThkQnk3d0pTZXNWOGxPZGVyVkNSUWNiQ0RlRXMyM25NM3doSkV3K3pKdzd6U2JTbm0yZmVTYVNFMU5taklZbHl4ZlkyK3YvWTVPOVBxWnBOSHozMlQrUzZ6dTM3TEVKanN0cm5kM3cyTXJsVkdHbFUzYnV3WVpja1F0Q0hrc2hmSklQZHh5enQ4YzNqOGxkWGxhWjF0WkhKQkV3U0lDTis5Z254NzM1U280OGNYVDVtUEdOcnVkZFBIdkpKaXdHSnZCZXVEMXp6bFNvYmFBeGRxN2x6QndjNEp5Q0RZT050emErSzErSlNBY0FnakxJZ1B2ZGNPZnNTWFk0Zk11YmU0VHZjd29XTDIzMTNNQXhCSTVFU2NrM0ozRC8xZllPT1BKSm0vMmJudm1UMzRjM2YvNCtYUGppR3J6MzVpNVlzbXkrN0xOeXM1eUVVZ1ViQ0FXUjdiUE1hR25LdVY4MjZFajZwYjFwczRRRmVtVzNMYm53L05iRkxaN3ZpeVE4Y2ZTdG5KSVBTYlRKeWh2eHdDTnpKVUVYUFRRSFhuMXBxMzN0bXI5OFRNcEF3czNCUGRpUUhiR2pRYXM1MFRLdnlWNlAxRlhEZ3Z2bnl2Snk3cGZCQitIa1Y0WXI3RWViUCtnVFZtSTVuR3U3QUYwZDBhVHpML2E1UGZyUWVtVG42MFF3RklCNWkyYkJsZlpPK3p6OFRVblp5TVZ5TWl5NDl6ejA5OFU4M2ErOHBaMno3YnRINzNESzRxYllmMVhrREFQOUlQQlBvR2srVUprcUowSEIrZXlZUWt3aWxBR1A1S3lyWEU3SFpYQURkRDBCNjJLNVA5WVMrUFBlQ1lXRERaaWhDalM4Z1ZDZVZnbGhVckNCUUxpVndZYmNaeGlDaFZyMkNIQUNvUnpBWU9EYkQ4VmFwTzZZRG5HdVFraFRJS2poZEZ3NEFwWVlSU2dQOHlPL1NtR21VMEdMNUtic0RKRkJ2MjVDd2pUQmg3UHRLd3I0TkVaeWtFREt6cXUwczUwc0sra0dGOFF5QmJId0c1cE1Yb3hMc2xHRWtSbG80SmtjS0RyWW9HVHBSVWd2ZFhFRDNTSWJ6ak91S1lKWUNzNWlSTFFxQnRXOTNYRFhtYU13b2Ywc05GenJnSXBZSHhqQytuZUhxaUJhV1ExbkdzZkQ0YWJwY0Uyc0UyNlJqK1RvTnpVNEx6N1k0QlhDVUlFaC9va1p5Zm1UMFVxcFpLMDhFK2pCZzl0aDV0bGp3TEs2RmxUVGdQcnVUcGttWFR3TkQzeXlVNUJwR3Z6dTd2c2dXaEdtd2h0RW9DRkNZeEVUYmsxL3dvQ0VuR20xME9odnQ5bTRQQTdhYytySWhNNGhJYzFXY2s1SmFhM0VVbFdaNi96SjVZYXA1MC9DNDN2ZUJyK2U4UGFRRkhWdzE1blB4WFZ0OEp2V3BYQjR3Z3dxeEZKQlNSb0QzU0lReGdidzIzM295cVMrNk1jSDJ5SVZZblpjL0VBNXBGTDhTclJVU0Nqa2xLb2twNE10Ujh3LzlqRXNPN2h0Z0JXU3hiUmdBY1JXcnNTYWhjRFBmZ2Jhb1VNWng1RjRUd2dDVnZiM3dJZlRXNGtFeGJoQUxCbElTNmtwNHliRERlNCtrdk10d1JLOUlZcy9HSCs0MCtpaHhaS1dTOFdKeTBkK0pjNFF2dEN5QTF0enkxN2hGOFZXclFJZVNFN0FIMXU5R3JTMWEzUG1zMVJJd3U1Z0JSd2x5MVQ0Z2M0c3d2Q2t2Mk55TDZUaFdXL0tEcUZGOGlRRnJmOVZ6Q0pZeW1vcHFlVUlJbGU0SndxUGZmUitYdCtSUnlJMmllUjJkVFh3WUJCWWYzOU81WTE1bmE4ZkM5MFVoQmhBR2hOdXhOb010a1V5clZHd3FlVXRnTFJhdW5VdjNaYXdVZ29xbGlSVVlQZ050a0N0L2NDQjdlQTNFamQyb1Vza0ZQTjY4TUEyZUdQUkg1VGQxK1d4aFVpeW1Fa0xJNWVscTZ4ME1qMWFKRDRNZWxleGdNeVVQYllzbC96Y2hrV3U0VUN3Y0hjWHpEcC9zdVQ1M25XK0RYNHI4cjVlWFZzV2hKRUpnd0hzVnYrT0l1Zis1cFpUbGxyZWpnNmo2WHhTT0h3dlNTNUlrMHhSa3FGNEJZYm1jN2RvamFhZlBpSzdCMG9OekJQei9tajJvbUZwbGVSRFAwVVlKMW5BeFpkaGcwOWVaOXN2Vkd1Rlgrd2JBbWxYRWd0bVZVVE9PdUFPWWxrZklzd2cyaUNRelRRTW1OQitMbk9ucW9KWld6dkFSeHBRRGZYMXdMTjhKS1d6VTBiMVVzQzg5NHB0L1BMODdVYVNsRVZKRWNWV1N6QTBscVY0YVZmczF5aEdxclptVmsrMTB6ODArQUN5T1FuR21HTXdjR29mZCt3djBCajBSQUpHOTZUbmRkQmJXeUcyWmsxR1lDRWZldGV0Ry9nd2lNVWdzSDQ5YVB2MnlXM01HKzh4MkVSS0VVTXVVMDlzazZmZm8rYVpoQ2xJa2hIaTFta3AyVkdRbGFsVUp2NXNxbEdZcG5jcm5DS1VZcjFGN0J4VjFkc1hneW85UFVGSjdLdGY5VVNpdkw5UFhJdDlUU2tpWWQ2SldCeDgva0RCZUpQOURHSE9hdVlaUkhGZVk1T2l0SUd1MjE5dlFtYmI1MFZicEZ4Zm9xQXhQKzdrQTh0dnkwSi9RczlzVTBZSmdySVplWENJeGhKZ2hnWmg2RWc1MXJ1ejI5VEQvNyt3ajVUOUZRTWlVbkgxWXBqUXJXaFFaeVN0VXZEbGw2RWZwVjExY2YwL0xCcUY0RXN2MmR0UnhTZnZBU2E5MzFKU2k1U3R6TWhIR25xYzBZSTJrZFJQUDRYS3RXdUJWMVJrMWw5dExmUisvL3NaK3lyUlI4b0tOckRlM2dGNUU0YUxqMFJ2ODkyVU92bzBVQU56WTFGWFFrQXdCeUg2K29DSjVBYk1tN21wQzhJZytrak1vNCtVNDMwa3dvMUIwVlRZVXpNYXZoNDlXL0lpeE9yRnZQRWVWRCtENUI4V0tGZUZTdW9XbVg2ZkQ2NVZSV0Nici9SajRqRFBhTGhXM29Nd2hOSXVueHhJOWc5Z2h4a0h1NmVBbm5oRkFTZllERlpVd292VlRiRHc2bUVJM2Npb01CZTUxaWVlaFpobklGUWg3OEVwMkZBaVpXZTEvWXpKVC9KTE95VWxEWEtsQWRLT1V0RkpVUlVJVlZaQWI2UWUvalV3T3ErM3licTZaR2VydlIyTjVoejVuYW8zekF2enhMenhIbFRXZzVmeThnUzhocjhwMkZBUytBTUJDRWNpc1BmNldQalBxM0g0Qy8zcVFBTnZtaEI0K1dXSVBmVlU4c1cralJ2emt1aC90SHJZR3hrTGpTSlBmNnB6bDRJTmd4WnNvUEQzYlNQdlZLaXNyb1pJUXdPOHJldHc4Wm9HZjZ0Zmhvb3NtYWZ0MlNOVGZqbkg0RG10QVhaWGo0VUdrUmZtZWJ1TnNTTWZpU3pTNEZvbG53OXE2dXJrSU5ZRG9reS8yUjJBUDlhdndNTzh0NkQ3aWFYL1BxdUFud2dTZFlkcm9HN1VLSm1YUHhWa0lHdDBtMW9rQ24rWEhFejRNY0dLRU5RMmpnSlZVNkhyaWc5K0dBM0E4L0UrZU5pOER2TjRQMHprQ1loWVZxcEx1TEdubUEvMnN5QnNWYXJnc2o4RUZlR3d0RVExOVhVUURJV0FLUlI4SGJ3S0ErOURoRGc5eVc1dDNTaElwZ29weC96QklFUTdPcUduT3dxLzdxK0NWL1NFY0kxTTRLWnBuNnNLOHFtYVQ1d2JnUHB3TllSckkxTE8rZjErSXRFdGp1UVZaNUd5eDltUnRDdnBndzZKb0VZaTBxcjA5ZFNJMUFPeHZuN1FFM0VwL1JDS0lKdm04ME1nRklSUVJhV016aUg1cEUvRTZETTd0MFRhZVpETlF6NzVTWG16aVFsTG8wRklrQ0lneUZFbHJJeXU2NUpFcWY0Z2ZQZEpra21jaCtmYUJDSU1CYnNLQlJ2eUhKVWZHY3NWTlNlVTJqeGhINUJmRFlDd1BUZFZvWVJTa3NhUnpCRXkrUW1CTVBUVUt0SWlwVjhqcGlGQ2hQSUxMR1FNRVNvZ0JNaEhJaEFHM1VlaWZpUUMrYS9wVkxTUFpIMGluY0xmaERMVWRwQXhzc0hreGZ0SUJBTEJrN0x6MENGclpvVUJTZG9SeXNraW1ZNEpJcUhZWUVPK2R6TUloSEt3UGp5NzNaTzBJeEFHWDlybGRhTEtlS1pWQWttN0FiTUlrVVVpRUc1SnNJRVhFSW8wMW81UXJrNlN0L1pQTDdNUUNDV0FKMm5IT2IzMlFpZy9GeW4xUlpMU0JSdUFSallRS05oQXdRWUNZVWlERGRuZlJuTHVJeERLQWFuQnFwNDZaQXM1UnpSb2xVRFM3dWFERFFRQ0FlaFZjd0toTkR3aWFVY2czQXBwNTNIME53VWJDT1VZYkxEZmtLV1JEUVRDb0lLa0hZRlFLbWxIYzM4VENGNjRSZEtPUUJoVUVKRUloSkw1U1BrK3hvd0Q5UnlKZkNSQ09jazQrZWRzL3lUdENJUWhsSFlxR0ZSQ0JJS0FIMkxGUzd0YTR3cDBzWEhKZHpGTURveVJ0Q09VamJaTHl6bVJJa1pIWVdtWDcrMzBxY2FSekxOcFZBT2hYSkRWMWljYngxeG5jWENWZHZPTkQ4U1pKTzhJNVc2ZERNR0YzWVdsblc1Q242WkFLUHRnbzNsUlpMQVQ5cXNQQ1laYS9GTVlCZThJSTk4YTRUVEZMQ252a0FQSWhWd1FwK20yUmVxTFExZk95U0JGZXJUdmx6QlJQMnlGQTVNZkhpT0pSeGpKSkVwOVdBemJmTE4rUkhJZ0h6OGtkeXlMeEsvMEtLZkRBV05zcm53eGN2ZE16NDlnUytncjhIRUFMWk1xTEIyVEh3a215MFFZY1NReVVtUHNESmdiMndxUDlMM2lHcjF1djY2Y3dBdVFTUHErODlyT1NYWEdvbnduWTBhUDltMkExdmhXT09DL0g5cDhMWEFOUm9ISjZJTi9oSkVUV1BBWi9WQnRYb1hteEdjd0o3NGRSaG5uQzE2SzNCRUxZVnJDTStzYktzMEZlNy9WOGZNcVA0OVFxUklJM3RBVFoxMzMvS2p1YTVldUszdFZDSXhpdlFrV2FxdzBmYTEzNkF1cGVBZ0ViL2kvZmFIL2ZmMXdZS3RZdllUQkJ1eXl2Ykx1bmFxM2Y5Zm1mNCtLaDBBb0RPU0s0TXh2a0RzaTlTdnQ2eTZqSjlVcDB0bFZHNnRmMkhuR3Q1MktpVURJajExbmZEc0VWOVlqWnl6dUdLa08yVjdjR2RQWmlTKy9HUG5wY3pzcVh1anNZMWVweUFpRU5KQVQvN2F6NG9VdnZSajVpZURLY1l0SXZUSmUwZjVzdlR5cDhRZU5HSUpyRUdtcVNKUENBZDd3MS9mM0xIeG9VcnhsWExVeFhteFhLd3hVS2s1Q3VjRGtZSFRIV1BTTHFIcnV0MjMrUS8rOHJYS3YyRVlwMXliU2NVdlc2VWtpL1VPOWZXSGozemY2eEFJamQrT3RoQWNyUkFvQVNCSlJWeXlobklBZE80WVZSMERMZ3lydG5KVzYyci9YbmhDY2tTZGkrRHY3WXBSN09GeW9WcVJSSXRXSlZBVTRraHpJSWhIS0NraWl1RWpYUmVvUTZiTGxFL1dod1hLZW1Hc1dJVHloQnlNUjFrVkJCNG5JSWhISzBTTEZMVDcwVzlzRDhQOENEQURzRUlmN3JhQnoxQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUpJQUFBQ1ZDQVlBQUFDemZxTTJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dSREE0TkRRM01qTkdNelF4TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd1JEQTRORFEzTXpOR016UXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pCRU1EZzBORGN3TTBZek5ERXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakJFTURnME5EY3hNMFl6TkRFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtnT05tR3dBQU12eEpSRUZVZU5yc2ZXdTBKVWQxM3E3dTg3cVB1Zk1lUFpCNENnd1J3UTloeDJBckdJTlpnSDRRTElUQnk5aXgxekpSRXVKZ0lGN0pTbXdUNHpnNFRnVEI0TERBQzhjbWdBUUlJd2dSNWlVa1liQXQ4UkJJYVBSK3pFaDNadTdNbmZzNjk1NW43OVR1cmo2bnEycnY2ajczM3BGbVJtcXRVcCs1cDArZlByVy8vdmEzOTY2cVZuak5GZkFFM1BibzlqemRubDVvQjNUYlcyZzEwM2FZejZ6cU5qRHRSS0VkMCszQlFydFR0OFVuV29mV25nQy9jYjl1THpMdHgzVDd4N285WlJQbjJlR2NNN1E5b3RzUGRQdWVidDh5YmVGSklKMVoyNnh1TDlQdGxicTl4RERQWTcwOXhiUlhGdjVHVEhXamJsL1U3YXU2cloxTm5hN09FdGRHcnVxMXV2MlNBVS9qTkwvZW5nSFZOYnA5MXJqSUo0SDBPRzBFbHRmbzl1dTZ2VnkzK2huNk8vcTZmVVczdjlEdGM3cDFuM1J0ajgzMlROMytsVzV2TWdMNVROL29CbmlWYVNUY1A2cmJuK2wyL3hPS2thNWJubjFNTHZRMU85ZGVySGUvYlZ4WWZKWUhDRVBkL2xxMzkraisvZVlwN3RjbkJpUHBIM3FwM3IzTGFKOXQyVkMzRFl4Z0xZbGhRMk55QTJQb1FBUjkvYmUrb3IyQ1JPOHhqZldWNlNoTVgwV1lRRjBoMU5OOUFpMUlZRW9OWVVyYmZqYlNlLzAzdGZWTHBCdmxkZFQwN3ljdDlic2FVRGMvNmRvMkI2Qi9ZZ0QwQzFzOUY0SG1aRktESmF6RGltN3JxZ1pKRklHS0ZFUzBWN1FuOHl2OVdvTkY3Mk9EaHFiS1hpQ2kyUk5kSUF6MGZrUHZseEpNMzB1U0pOMUh3d1NtY1FCenFnODdkZHNURFZKd2JXR2pHK2dtM1Ira28vNlRCdFRmUHdta2FnQTZUKy8rU0xkZlN5MjdpWTFZNU1Td0JzZXhBWXVxQ1YwTm5EaU9VK0RFY1FUTkZFUlJDcDQ0QjVUSzl2U1ZHYWlNNzNlQVJGdVNZTXBycVBlSlppYmFEeldRNk8rbzkzM2RqbWxBSFUzL1BvUm1Nb0E5MklWOXFnZDc0MEhLYnB2WUtLQjRtZTZmdjlMNy82QUJOZjhra0hnQTBiVzhuZTQ2a3d1YVVGUW9iYnc2SE1WV0NoNk5tQlE4eERqVHRUZ0ZVQnhuK3lqS1c4WklCQ0tpSWdKTjlsSlpJQnE1eEJFclljcE1CQ0I2WVlNcGE4TWh0V0cySHd6aGVESUZSL1cvOVI5U1VKMmpPbkFnN21zZk5oR29sTG5CTHRmOTlZZDYvejgwb0FaUEFta01vaGZxM1ljaHl6eFB0QzFyblhNNGFlbHdaMHIvbWpyRU5jMDRHakMxbW1haEd1ME5vRFNBYWxHY01WR3NEQXNSZUtMVVBQUWFjZ0NONmNnUlZ6alNXUG0va3hSUjlESkpYNmNzUmN4RUFFcHlNQTFob01GRWdCb01CckF5Yk1ESndRd2NIUFIxMkxrQkYwUWQyQmtOSi9uWmRLTzlXN2MzNkw3N1RRMm1XNS9RUU5LZFFLSHZIK2oyamttdWhReDVSQnZqSVp5R2R0eUVXck1HRFFKTnZRYjFBb0JxY1MwRlVGU0xSc3hEQUVvZFdMcFhLV295NXJGQjQ3S1J5MHIyMzVJTVRNYmRwWTdQdUwyVW9UU29ra0VHcXI0R0VnR0s5b04rSFk0UG1uQkV2NTRaZE9GcGFoM09qWHVUK0hPNjhiNmwrL0cvNi8zdmFVRDFuM0JBMGovK09YcjNNZDFlV1BVekpGa1BEMXNwZ0FhMVpncWNHZDFTQU5FK0JWQTljMk1wZURKZGxJcHBwVVlhS0FRVXk0azQ4TUw4Y3c2V2xCcG5JekFhdjBsNktXV3BFVk1Ob1pHNk9tcURGRXo5UGdHSzlnMDQySitDZXcyZ0xvZ3BqcXhzdzM5djlOT3ZhRERkL1lRQmt2N0JsRXo4WDdyTlZHVWdBdENET0FQRFJqTUZ6YlJ1alViZEFLaG1YRmtHSHRJK09ZQlMxOFVCUnhWQlVvMERWUEJ3SEx2RC9DVUpmRXRYYWZkS2dLb1RxR29acVByRVR2MFVVTDFlUDJXcCsvdjZadWwxNGVtcW5RS3FJa1A5cEc3ZjBYMzdMeldZUG5wV0E4bTRzcXQwZTB2Vnp4eFA2bkEzN29CZXZaV0Nwa1hnTVFDcTErdXBHMHRiSVp6UHdualhWVTBHbWsza2RzZi9WMk53MFhVUWxyTHJpVkxHaXRQSUx3UFZzSjVBVFVlWURRMm9aa09EcWE5QnBRSFYwNy92dm40VER2VTc4QnkxQ3Z1aVNsNkxic3kvMHYxTW9IcjdZK25xYW84aGlQYWJiTzNQVk0zOTNEbWNoZVhhakFhT1pxQm1JMk1nYWpYYXh5YWt6Nkt2WE9jVUFhUlVGZUFvZ0sxZ0RNVi9GTnlvNVJ6VFY4U2M1THNvd1VtL0EydWFuZlR2ckdsR0dtaEExWHU5bEtGNjNSaCswR3ZDemtFYm5oZXZWYzFKL1J2ZGZrTDMrUzlxTUIwN2E0Q2tmOUNQNk4wWGRIdFdGYnM4ck4zWUE5RWN4Rk1ObUc1b0FLVWdJZ1pxakFBVW1UQitNdkFvVWYrSTRDcERrTEkvaHg2bTBIby92OVRVQTJLbXI1VENORjBSbVJURnNKNEZEbzE2SDdxYWRYdmRIclI3TWZ4OXJ3WFBHSzdBVTZ1NU83cGh2Nm43L2pJTnBydk9lQ0NaRWdjTmxkaFRoWVZ1VCthZ1haK0dwZ1lQdFVZelk2R0djV09UQTBnSndObXFpMU9CditMb2JSeS9FRUJsczFUYUhFRFY5YjdlclVGWDY4QUg5UDVZZngwdWpsWmd1cHlkbm1YQTlNOU9kWW1sZG9wQlJBTzdydFZ0dXV6WVI1TW0zS04yYWhacXdrd3pZeUVDRW9Gb0xLUWRBS1VZcVFvZVZWazlUOEJIL2wrUSs5WU1XRHlveGl5VnZvMDJvR2dmRTVCcTlWRmFvNnZkM1MzZEJqdzdXWWJ6bzlKUkozUURmMUhiNG5JTnBpK2VjVURTRjA1VitxdWhaSkFaM1ZOM0pqdGdvYllqWTZGV1UrL3J1bVhoZmNwQ1RnUldCaUFSUE1vUnhWdHdiVXJRUTJCbEI5QUNsZ2NxaDZYeXZGWVJVS3F1TW9ZYUFZcjZSTE9UWnF5N05UdWRIS3pDODZMVnNsUUIzY2pYYVp1OFFZUHByODhZSUJrUWZiTHMvQjN0eXI2UE82SFRtSUhwcWViWW5XbGRWTk9hS0kvRWlpemt1ekNYZlhqd3FPMFcyZTZIa0FPWktnQ0xBWlZDbHFVeVFPVXVqOXhjbG5uUDNYcGU2cUdiYkxFVHdhMGFVQzlReTlBS3V6cTZvVCtsYlhQRnFRQlRkQXBBOUVyRFJFRVFyV0FOYm9XOTBKL2FBZE16VXpBOTNZSXAzVnBUT3N4dlprbEZsVmJtSThOR2JnWmFtZnBZZmhNclcwWG50Yk1SaU5Ub000VVBGWUMyK2Y4QW5QT055aTNGS3pNM2cxS1dTeDJkWWZ5L2dzdFRZelkyQUNKWDM5UTMzYmpQcHRJK3ZFWDNKZlZweVVhWmg2dU5qVTVmSU9rTC9EbWppWUx1YkNGcHdQZWlmUkJOejZRZE1UMmpPMlJxQ2xvdGNtZDVZVFUySGMrVk1Jb3VqQUVRQzU0UWFCd0FUTlRHY0pIQjVZUEtCUlFVcjhQNXJjcGs1WE0yb2h3YU1UZjEzUXdCU3JkWTl5WDFLZlZ0eVVZSFhLdHQ5WkxUMHJYcEM3dEk3ejVUSnF4VFVWM2JtOTVWQkp4V0szTnBwSWVJdXUxc05KUUF5TTQyS2o1dDdUczJWU1g0VjBHcGpjSjNqV0kxUjNTaktyZzd6TjJmL245K0NHSUJUT2hwS012ZEVhRE1EUmJsUTJEMDY0NSsvY09OZmZDY3dRazRMeXpDeVVhZk1XTys3ajF0Z0dTU2pkZnJ0anQwM0tGa0N1NnY3OGtBTkpXMVZBK1JxSTRqUnd1NXhsZStpUGIwaitzMjJOUTJEN0NKZEpKemJuUWg1b0FMY2ZRSk5FQ3hBVVZBVTVhT1VwWW9aeUk4eU9xSk9UT09Ta0w2djdzNysyRFlQNUdPS2lpSjVzaG1OSVI1NFhFSGtnWlJ3K1NKTGlvRDBRT05QZHFGdFZJQVVWU1dNVkZzUmlsS0VSbkRRZ0VBS1lhcFBQT3J6U1FneTNRMzJ0K0JCV0FWODEwNHpodWhCNmljb1FoUWFpVGNVVG5zbEx2Rk5JOFpXL3BSbVRyai9SdDdBWHVMY0dHMEVicnlpNHp0WGdyWkZLbkhsWkhlWjFBdHV6TnNGVURVMGlGK0l3VlNuaHNLdVRLdlJxWW1BeEFQSGlaQm9MWUFKZ01PS3lHZ0NzRGlRRlZrS1FsUUkzZG4yQWtWNitwSVQ5YTBKVlVyRHo2eU16K2dTU2ZXekhTK0NqSVQyZTVQZGZzWGp5ZVFmcTNzQWhhd0FmZlY5Nllnb3FpTThrU3BPNnZsUXp3RUVDa1ZZS0dLQUZJQ2NLcVVVYW9oU05Cb0dhT2d3MWc1cUtvQ2F1enVjbmVQaktzYmcwblZWS3FsaTdMZ1BoM04xZnNMc0Y4RkNlZk5sQUhYN1M4ZkR5RFJlS0lQaEE1WTF1SG93ZG8rTGF4ekp0THVUSU1vRG9LSWMyVWNDeW1XVFRnQUtaRnhWRUI3cXdwNWJXWG5IYUZROGloZUJoYnlSU29NcUpHR1FpV3lrKzNxeG1BaUVaNHlrN0t2OUNEdWc4YmdHT3hVd1ZHNVpFdGFvMkJUNDVrMkcvNlRMdm80Qk1ZVFViTHhoL0ZlYUJoTmxBdnJ6WU9vR0c2ck1UaEdiS0RHMnFFWWFoZU9HZjA5enpHcDR2dHVLeE5GeWtvdkZNK25sSE9lVVU2cm1KS0FrVGlHd205UlZvYTdtQlpRdHJOMittMzAzWVY4VTY1SHlRWmtDN0pKWUNOYmZndzJPZDE5czBCNnAyNlh5R1VQQlhkRWUwQk5UWTlDL0hKM3BncXBGVlhJQ1FtdWJFSUErVWxOeHRDYmJDNVErZStiQUZDZXRpdmVPRkQ0alRLWXFLOVRNTFZhYWYrVExjZ21KV1hlRnhyYlBpWkFJZ0Q5VHVpQXUzQUhkRnV6b3pBL1k2S29GRVJXNXpwNmFKVG9jMWhJQnBETlBrSGdjQ3dEUWdLU09TNy9YZ2xZM2pWSWdQTFlTVm0vVVhHL09jUk11cytwU3BBeWs3WUYyZVF1bkN1ejcrK0VTR0s3TkJJZC8rY1FtREk5VDlPQldydlMydG1JaVp3UVh3YVJHLzR6SGN6b0lKZjZ3K0tkeTBWSjliaUpTbXlGSVVwajdZUEZaS01SM1lqS2xudTVodUwwVTY2ZFZDNjZpLzhlQys1eFJHY0xjTkpNU0dBeXMxc1drMTB3MytuQmVYSWtGeHNiMHlqTHdhbGlKSnAzSms0Wm9xblBsSEJNUlhVckcwdVVacXczQXlKVkJxSkNNVmY1ZDJSeGtMOS85eGZacUZoU0FabUpXR1p5eWlNV0kvbHM1YnBabHlGRmR2SjBFM016Q2N5VWdha0dqVlpkZTRkc2RBWFppR3dWMkg3TTJQcVV1TGJ6SVp1OEtNWXhCK1BkVUU5clpsa0ZQeDFUSFVkQ2FVSXgxUTlKSi9nZ1VsYjIyM1VmSUx1VG9oNXhRT09ESy9CZkVUUWV1QVJRc1lCeXJybU1pVVZtbHZ1WGJFQmdvdHdkMllac1JMWXFtWnBKdHI3d1ZBQ0pwbEdMTTJBUHd6UjBtck5tVkdNakhkRVl4VGtMUld4SlFsVnhYNnFvZlFwM241SllqYm03bWVob1BISkFPZnFyU2dIWExSRG40SEkrSndVRERJdmExdy9PdFZkamFNK2J3N2d2eUJaWnNUZXJLSkN0RG9mTG92a2t6RzBGRXZuTFh3MjV0TU1ONDlKU0VEWFNTWW5pZEtBcWQxNmhVdS9lMWF5SWRWMllHRjRyWDdnWG1NT3UzMHVEUm9vVmZvZlZ1UE16Z0hJREE1ZEJQVGF0NHZZOHZWZ01BcUlNVERxU2F4R1l0SzNJWmlVdTdvMjYvZFIyQXVrUFE4bVZlNk9kVUd0bUl4dnBRbU5XWEx1aVZqbnFWUUlSZ0QrcDBiNkxsWk5yQ2dHb3lEYktHU3VrUk9ZQmxxbVVNK1pKZ1R1OEpBUW9KYmhvL3ZlT0FhVDhnTVRaZTJNaENucUo4bmoxZEFScVBiVVoyYTRrdEhqWGRnR0pCdSsvUW5yekJEUmdyVFdYdWJObXBvdkcwNFA0eEJtZmJMUTdaeElRaVJFZUF5RGxzb0dYZy9KMWtCTDBFMWpqam14V1ZGQU9xTTMvdmpJbVVueWkxd3c3cVJrWFIvWWkyNTBJNXlESjl2OTBPNEQwcnBEQWZyQzJKNDNPMGtwK0xSc09vaHpoeVliT0FmZm1abTdaVG1iZG1pb0JrR0pHTHpMSnhVRE9pR1VrNVFKTE1kL3BBOHBqSit0MUNFelYzQm8zSm91OEJBMWhycG5CY1dRN3NtR0o4UDZEclFMcHB5R3dVdHE4Rm11RFpqWjFpTVpZMStMeFhIdlBwWG5Ba1RVU0tDV0FxS2daWkJES0FJSUNlTnprSmJEQUVodHd3MzdIQWg0QzE2QWNvL05nOENNNks5SXNGZHljWG9MUmFNdlk2Q1d5SGRsd1BpeThYMkt3c0drZ3ZTMVVCbm1rdml0eloyYjJLd25zYW41YnNRemxqVEx5UUNReG1TdElsUzNVbFJOdU00SjlsTnVSbUlpdHJ6a1piU2JWNEFLS3ZUNG1ndzNXQUQ5L3NKOTM4em5KMVRJOUdwbVVRTU5NUUNWYmxpeGErSTdOQW9rR1BWMHVzcEdhQm14Tm1SbXcyYnd6ZjVoc2lVc3JhZ24zenZMY21WL0FkZTl5TVYwQWZJN0pLc3VBbXJqbTVvTE9MdG9Xd091bElrQzRic1VXYW4wM3h6R3hFakw5WG9KL1pLZTBoTktvcFRZa1c1Sk5BOXRySVRCNE1RU2tLNlgzeVovTzEzZW1jL0ZyV2x5bjZ4QkZrU3l3eTF5YUJ5TGdOUkU0cjB2U0JjckoyZmgxTjg1ZFFUVkdjcUk5NmJ4MnNiWThuTGRjbStYbW1QSlBxQSs1TVZ5ZThNNG5FMlRyS3BCTk1VdzZWMDRLcEVZb2I3U2dwZ0NiVTJaVmtOaHphY3JMcm5JdXpkVkY3bzh1QjFFeE92THlOQXBrQURITVlRdG9LR0VqSitwenMra0tBb0JpOGx6Rm1TK1Z3T1NQaWdERlZReDRPeWpIeGRGNkNtUkxzaW5aTnJEOXFqVE1oQVhTTUVscFRIeHdDeUUzbjByTnN4SC9tNVF3Mkl3YjVhaThXYkYyeEJKaUp6bXhCeDR6dUJsdTRLWVNLWDlLRTBnWmJWQnlOcnNJcmhJVzhobkZkL09jWHZMK3lqbUpVZGNWV0ttVzVRREp0b0Z0djhiR0wxWUdraGIxLzF3NjB3clVvZE9ZTnVzVHhhTXlDSWQyU1dETExzMTFMWXdtY0ZqRWQzRkZRTGxKUzBjb0N4bHF0NWlybU9Lc21CRzNCcVQ1V28vVk5RNllyUGNuNlJ1dlQyWGg3YkZTUFpzdlI3WmREVHlOUThJR0I2UzkrdnBlSnAzb2FEeHJ0RkZ0dEx3TXU0eGVRR0RMTHMyKzYvekZJbXpBMkhleXJZVzhTTTBCa09mT0FPVFNpUXFWUW53MzV3SEtpZURzQ0ZReExwdEx6QUk3YlYxMmNlWENPejlueWtwbURVNnk3WkZZWGxUWVlPTkFLWkFNZGJHUXBDV0lseHB6SmtyTFZzd0FQNEtYQis5d2Q0N2swcFRUbWNYUGUwazVMbHlXMkVBeHcxcUxycXZpTkczRmwxdFlRRUhnMnBROTlsdzV2N000cEEwOHZTUzRPRzVrQUdNUEMxOVJsZzRnMjVLTmgzSXFnQmFhdTd3S0k3MWVPc09pYW9GcTVCbnNPRnRtMkoyUDcvNmt3TXhZZG41YTRFNnp5Z3FjTytOeUxvN0FCY1ZObTFheTI1SVlTWEhUczExQThjS2Z6NDA1eVZqWGxVL1lWeERTU201OVU1bkY2MnZaMkNXeThRbHRhN0dpZ2I1T2NvRTBxejNWcFdKZGpaYmhNMnhVeStmbTg5ZGVUUnRaSDJidU11VzRNWWVod2lCU2pPdmd5eWpLR2ZvQkFDV0xSb0Jkend1Y20wMCtsb0JKdVNCUnRvdVQyYnVhVm1MdmFaVTlCU0ZucGNXYXZFNnN3Y2lzQ0tUZUVNbi9OU1czdHRyY1lSWkF6NWViZ1cxa0k5L3Yrek51blRwY0VFUmNORk15QzhYS2ZvTzhhSVRIU01EUEFnbVZRZ1F3K2ZVMEZ5U0tYZjlwcTZ5VXo5TE5Cc0hGcWEwRDdxMXBzTUlEU1ZQV1pkSW5seFROaksybml6eEZWVVcyRUh1RzJNZ3FLNGgzWStGNHI2UVN5Qmlya25GQ2lrczZ1aE9VM09Lc1BPN0pmeTJCcVZoVWRldHBnb3VyeUVvZ1RCU1ZSRGZaTms0WDg2cW5OZys0dDh0RUlNV1IramtSU1BGMHRnd3hMZkNrb2tvaVc4b2JoZGlJN3d6WHBZR2Q3K0dXQTJUR05MSDVKaVhQQmxFcVVPMlh4b0ZEV1UwUW1Fak1udzNqaWV4QXY0UllTWEo2a3YzU1lTWnhObTZKYkM1dDlkakd5Z2dSeDFhVEE3VklycVdzTm1ZdHQxWkZaUE1qcGFSSUxjeEd2RXNMaUZZb2ZsWjJNWFpHZXJJU2lWMmNMUitOd0tVd2lyOWJPYXhyeFJhbHJBUUJWaEtjQkNPNkxmZldtQTNsa3k1YVdFdk84WURVcXF0TEpmTjNJSVpCdldraXRiaWdqNnE1Tlo1ZC9PZ2pmTmM1UDUxWmZNc09vN2toS3U3b1JEL1JOMUdKQkZRZzRhbVk2TkpObXZycFpzV3Q5VFJ4L3pESFYzQnZJeGRubml4Rk51L0lNODlVczZZdTlZQ2tRU2d1cEw0U05WT0VqaGZDVWhPNU5WOWsrMnpFdlI5aUkxY1hlWFU1YnlRbWs5TnhKaHA2RXluRkhyZEI1NVpndk55Vk9EQk4rYXdLazdCU3RYNkVDZHpiYUhVNHcwcGsrMEQwOW1JUFNOcXR2VUQ2d0ZvOE5WNGtYVWwxM2duZG11RGZnM2ViNkFLWjBRVk93VE0wNHBKZm05Sm5JSC80Q0FBM1QwMHBwbGpxYUNybFhIZlFaWW1zTktuT0RMazMrK2FNRFN1UjdjWE1aQUV6S1NxbTMzb2txa1hxWXVrREc3WFdhRVhWU0VuNnFEeGFrMzR1bDRkbjJhaTBNN253R1VRamM5T1lyQXc0U0ZPMDNSR1dBS0hoc2Q1NEtzVzdJL0Vta2xncGVGTXk3d2Z2OUVKeWNoVEJSYW50WlNDcGl6VjI0aEdRdnZ4YmU4N1JuemxYR252VXJiZlNaRlZhNVkrcjZLTlFibEo1STBoQWxhK2twcUNNalJUYjJRcEtodTB5YkJHZTJ3WitoTVdPTm5DK2p5bkcrb3pKc0ZKSnlZbDNiejdUaVJraDdqN09GejdWald5UHNtczc5M05YN2o0d0F0TDVPK04vSkgxUFI5VkFVZG84aXRoSFZWWFNSeVdhUTc0am1ZNHVwWFkrczhzbUFDRTh4anJBUit3WWNMK21Cb0duRktocXJsM1FobklmbFBXM0tsblFmZ3ltMU9iYTlvUUJhYnRvZiszNUl5Qk4xZFV6UkxlbTZxUG52NFl2Yi9QNmlEMVNRUkFrTWh0eCtTckd6UWpyRHBTdUFlQXFIZUY4eWh0SXh1UjNKRllLZ1UyVnJicTdHWjNFdjg2ZitVc1lrRGFObll0R1FHckU4RXpwd0c2VUFhbjRhUFBLZnEzQ3p3VGdLaTFLY0d0Q2hDTjJvSnQzc2FNMEVNWUdGZGZBOW1wc0NwajVhZnp5UEVyNTJxVEtEYVc4N0Qydm04U1V5MFFXNFNLNDhicmUxQWdEY21JU25wNENLUlhhc1hxNmRHQXZxcG0xbkZWRlZna0o3VWtYQVEwOUQwdjUyR1BDWThYTlFoQW5hU29lUENDQmlsOVJqVjI3a2czTEZZT0o2Zy9mNGVKM1ZlYmlLZ2p1L0xkR1prSWxZVUFVM0xGNkttR0lHSWxVOXo3cHdIN2NHQytRTmVGVEdCVmJHMVJDQ0tvQ0p3aThweGptNGhLZ1hObEFRV0JGdUlEWUJtbEZOZkRLUWR6anZ4UUhHZEc5TVN6RTViUWczTTlCd1MxRWVIbW1tekFRMlBabXVqdGI5VVFFMHBBZTkyUkFKRDVRV0ZXbnpiS2pWSUNCb095OW9Ecmd4bis3b0hhTHQxSW5sM3krckVKZktYUUt2NmUyS0NyS016REtQTVkrU2pFUVNFcnVHd05KeVN2MkoxRzJUR3FrMUtTT2R4TS9TZ0dVTGpFaHB0SEtzNzZjdEpUcWIrQU1MV0VYNU9JbUtpb21OeFBLT2l2aGhsSVFXaW9pdkdqcTloaUszQnBkNHpDZ2tReDJVaUNSUnRvaE1sSmNjeEp2WVhCVThkU2JJcStRcUZRVkh5dnFaY0JadFdXUGNQVHF1SW9OMm9IVmErVS9UbzVRSisyVFNRNVQxV1M1U2RJbWNZaVJVdXhrUUZMQ1lMYVVrVlFNV3d6VXF0UDVSQ2RYQXV1WHJLZGRZakIvUFVxaDZsOEM4TElZU2dVMTRiYmRjWk1iaXluNVljQzFhZkEwMDdTVFNRR0lNMjdIRDBzNWhkdkVtbWdySFMyZFczS21Zaklpd0I1cWk5Y0hFMnVtVTJXV0N0NG9UcjBnL1UvejByVE1TSkZGYzZmNDJyY05NS3J5R1ZSNTFLbFVhZFNqSmd3cVRxVzIyWTRlTFFJb1VWRkliRS9sUUNxOWVxVk9EOWljS3RDRkR4UGlJN1hOMzN1NjlsbzEyNmRRVThNRTFtWGVRamc3TnR6a1ljaS9nZHY4dmFmeEZzS0F4czVHRGlUN21Td1Y3eWM4emNHQmxjOVFjZzc2SDJLNGswck9VLzI2OExUczBaTEgrNlJQcFVnWktVR1VuOEdVREI4blBPQVcraGFydlk4aDVoazlHM3ZVUXNmWkwzR0wxeGY2Q0Q3MitBdGdRR09uTzJLay9oRFdwQU5yT05RMzVGWXZIaWZzVEt4MlRxektEQ2ljRlhsc1lSRWs2TU1KVWJBckNtZkhhdGVKRS96MmJldnI4S0ZrZThLQXRHbnN0SE5Hd3Q0QVYwUWc1V2lrenNQeUg0REJEdDJ1L2tHdjd5czV1Y0xCeUJvVmJUQ2hRenpvZ0doMFBESll3Q0RJd3RlUDIzZS9sY0pZdUs3MDk2T05BV1l6Mk1rZTROWHB3NUlvdEpKQmVsTGNWZ3JGd044eDZHZ3d4QzdvdUN6emIyVHBBKzFqUnRZc3VqVHpIK0w0dGNPSTZKeUgrdzUwcnNlK1BoU2tQVElRZDI4aFBLVmFLOE1TUXBUSXo3YkpzWk15VW1lQUlwRHF3ejdnbGx6K1pDSVVONldac0lMOGRSalRBZ0hZWU1JU0kySEo1NFU3SGlkeFBTV2FDQ2VHREc3dUxmMWVRMk5BQk5JQWwzTkd3cVgxWkY0NnNESHNXVFEzTVRpOFd3b1pYR0NnTTB2ZVF4VHVaZ2RVaGU5SHp5Qm9nOEdLMXR6R0hBYzJZNlBIaHNoQ0hGMkxpVDY2L0QwUGR4NzdiUUowUnM0UUJxUnR0Wk1jellHVUhGOUxIaEVaS2Vtbkowd1FLek9CVEMzTWZWcEJkMGtkaUt3dWNZREszUUFJakhCR3k4MjVqb3o5T3hhTWlKekYwTlljbkZ0RExrNmNnSjJjZmd5clV5dzVGN29SV1hyZUZBUENkbXcxeFU2U0F1bUJFOE5EMG9GVEdvMEpKbG5DQUpNdCsrUlNVY213a0gyVFNhS2Z1K3NkMWlpY0d6MHdZVkVZV014amc2ZHd6TWlkb2NOOHpuZWdEY1ZTS1l4b3NTaUcyQW1yeG9rVHluSERSbVR6cVFBalBYaGkrUEFJU0Y4KzJMMWZPckNwMGFpR2xBSklnc25kc3B1bVNnZGFSNkxRZ1lKN3N6NkRydHRCMzhWNVlBSkdURFBORWVNZ25NOTY3Um1mdTE0VXN1cFNoSW9WYjFXc1RQYm9TY0VrdFgwendFalgvN0I3ejhpMWZlSDI3c0pHSDArSU9xblhTV2tPUzhzRVVnb0FLL0FTQ3JrVnZwUGRxSWJ2ZUdSY0hEcXZIVU03RVpyZmNNeENCYURhSUVMbk5kamlYQUlKU0gyTXJBVGcrNkNzdndPaFA5cEhrYzNKOXRKR21MbitqdTV4b0lHMDlEOUtCeXl0NDRNaUsvWFhBUk1jdFVtOEczSnV5NHVZTVFoTTI3MXgxTzZ5a3VONlhLT093SVQyWnkxQUJjUTJPaUszY0M0V1JJNnV3cUkyRW40UFZ0RThVcG9EL2RBT0o0allVcmMyekd4TnRwYzJnNW0rQmFRakswUFJ2YzMwMXRNSDZ5S0VTZ3BWQlhlRmRLWFgyYnhyOCs5SVI4QXlrUk95ZW1ZY29WZ01GZUlrQkNlYXhaTHZzVjJhbnpPVDlKUGREeWl3VTdrK3FpcTB4OWRFTnAvdXlVQXltT2xhUUxwOWZ2QUQ2UVBUZ3cyTnptU1VtQ3RWUVp2UVNhV2RXU1F1a1pVOEJlUGM4YnlSRVowVTlnaFVCWEFWL2czTzhma3gzUGs5eHJTdURjSnNoTEkrbEYzN3BQcUlQNFpFTnRsOFpyQWhBdW1PK2NIdGhKMFVTT3Z2UFpkQ3NkNG52NzF4bTNSV0VsdFJ2NnNSbW5pdURhdnFwTEtzTS9NK3kwcUlnUWdIbWJ1K29IdGNZenNSbHVYdVNqV0hDeUJ6clp6K2NvQlZCTGdZaVdJSkcwM1FqMVgwVWZFd1RCL3RucVEyRHdodHZPYmJHOThqN0JDRzhxRnZnNi9lcGIxYkI4WEU1TXpHY25yeVZIUlgwa21TeUFUZUhaVXlGL0phaVdYRUlnaWRuRStCVWRBUjNrVndvTWRLUGtPQm83K3dxTGtRdmR5VXI5OFlJZXhwbzgzMEQzTThWcXZqcFNHL0FkTE1obGlDQmNJS1lZYXdrNWRJd1B4ajQrSEY0ZmVsRDg1MjF5QVpKbnlDajhzcFYzRnZXT2F5d3F6azNjM29oUG9GNDJHb3JtYTVMQWpxSTI4VUFLTG55dEJKZHRxZzl2TlBidDZvR2hzeExoQnhrMjdOMFVjRUptM3IyZTZxQ0NTRGxZNExKT0t2alZzZTZ2MkQ5TUVkL1RiZ1lEaEtVazNxM3ZqOHppVCszUzNZMnRySEM3UFJCaE13WUxMMWpqR3p3ejdGaU0xakp1czYwTmFRVnNiY1RqSDRhUW4wSTBFM3FUcUJ6Z1N1SEZUVnJSbjdrcTNKNXRKbXNMSnVzR016MHZ1K3ZuNnJaalhXS1ViNjVOUHJTeHFwdzRLK3FPN2VRUGhKNEdaeEE2ekVIdStWSVJ4allUSHZZNysyQVdXSDhlR0JiV2dYYjVuTU9QK2REc2daQmtHbTFGUE9SaGhnbytwdWJhU1B0STNKMXBGUXlTQ01FRllJTXhZamFiRkVrVnZucnFPRHhmbmw0VUdSbFRhV1lEak1CRGNpVm5KdllkRWRydEQ3SFlLQ2kwTS9HY2k0R09CY25WdGZRd2RZVEI0SjBSNWFZZ01JZ2l6b2c4aDJ6WndnRDZjN1pEYmlxZ1VodDRaRy81S055ZGJTcGpIeVE4SUtZY1pneDVyUFJtRmMrOWFIK3pkTEo1anJyV25LRzdCWmJsODZZVkIwaDFpSnV4dVJkWEZsWUhJRU1QaE1ZYms0UkxaQTYvNW5YYmNMS21TK3kzMHRnQWlCU2FLS3JGek9ScnpJUnZhK3pyZGg2dFlHcWEybDdidUhCbjlIV0RHWUFRNUlhKys3WWYwbUFxWGszbVpYajZmVVo2Y0N0b3VWbU9pRGRYRjgwWlF2VFRqRlU0czFuRElIK0xwSWFqWWp1ZVVWc00rTjRGeGpJRWp3M1BQbSttb3piRVFDbTJ4TE5wYmNHaDMyd1p2Yk54RldKQ0NSTm1wLzY0SGVzY01uaDdkTGFOeTFmbkxzM3FCYVRzbDIxMWdoZ25NeXh1QUxhWFNIVG5oZ0N0WFVrQUVVVjJzTHNKTGovbngzR2FyQnVTRGlpcm51MkNjTXMzZVFqY3BGZHFwOU5EbVFiY25HMHZiSTh2RDJyOTNkbXplTTFQZUFaQktUSko3YU45elQrMm9veTEzZldJT2h5WFJYRXQySUU3RVN1b1ZXSVhTMkVuc3VNMkV4NjF5TXJCaEFGVUNGVUpHUmluemtqQTVBaTRYY2F3Q0dpZXpmdzZVd2l2MkJDQk95VVRXUlRUWWwyMDRIc3RsZnZhdjNGUU9pRFlNWmo1SEExRTFXL3VQblZtL3FCaVlFN0Y0NXFwRTd6T3B2NkkrcWR1S1FjcTNFQ0ZCUlBDTXk0cHR4Y3d3YjJBbERjRndUNzdhNHlqOHlRMHVRQTVESWlyNDc4OFMxNDhvcjlVMkpOa0xKVGlZSlNUWWwyMHFieHNTcXhnWnA2QldERlpDQVJENXZkYkdkck41MmVIQ1RLTG83S3hCMVRmMnRaSkNTcEpVOEFFZ3VEdHh4MXVDTmFtVHpRMTQxM2czVmk4QUJIemJzQ0FDMzh1K0F4d1VRQW5zZEdBQVJNc1ZkanExWmw4YmxqYVQ2dWVmV2hxbE55YmJTcGpGeEkyR0RNRkxVUng2UVRDaEh0TFg2L2h2YjE2T1FIbFg2ejd1V2NsYnlSVGNDVTdTVThrcXNpeFBxWjU0TEtMbzVkRnlhclp0WVFEbnNCamhoaWNRZDdJWThnQ1RoajRVY0Uzb2c4Z3ZQNkNVdE9aY1dpdFFFTmhvbXFTM0pwa3FjbmdSSW1EQWdJb3drSVVZQ2svWmUvdlIzT3cvZWQzeDRpK2plTmhZQk94dFoyVVFhak9WU0tncXpPRHdYQi83UWpCSVdzalBaTGpNSWdBSTNVejFaaVFTZHozUG50VW9wd0tVbG9KU2R4TkdYb1Q1a2IwNStjQktCQ0R1ZDFLYlNwckZ3SzJHQ2hpR1ovQkdXQVlrb2k2YVlySDNrVyt1ZmswNnM5Sy9ac3pRdnN4SldFOTdJRkRhNWlBdFlsOFprakxFb2dNSFJLamFnck1vOUNHV1FRQU1QUEQ3VG9Rc2F0Tk1EYkFiZVRXUnlrWitrdDBvRXRuMlRqdGxvejlLanFVMmxUV1BoT2hQeUw3dHVqUVdTVWVKRVhVdnYvVnI3OXZubDVHQW9GYURXMjJOV3dySmlMdWZpSEczRXpieGd3MlczaHVWb0gyNUlMQU1BMTJYNVpSS2hjZU9VR0VDNk9TYVFrcFJTTnB3ZGNjbE56SVJTZ2MzMVA0R0liQmdLK1FrRGhBWERSdTFpdEJaaXBEeDZTei8wNGI5ZHYwWmtKWDBsKzA4ZUdyRlNzSmlMRlZ5Y1d5b0FZWGdzQ3lhLzJ1NW5zd0g0RVk1MnVGMkprVUFhRENlUEFTK3lrT3lhblNFdjdHQTVlWmF3NTlLSzRIT0tzME10c01sMlpFTVZtSGRpTU5BMm1PaXl5V3Joc3dNVDRpMjkrMHRydHgxZUNnOHZhYXdzWmtsS2E2d1NGNUdGZ0lWZVVpNDRQTmJMRDBrbENtRExJL2F3V2I3YUx6RVJPeHFBT1lZSGtQTStJajlXS2pEaXNoeUVYSTJXcjZtUjdjaUcwcVp0Znp0aHdJQm9KUy9TVmdLU0VWSTBSSUJtbHJUZmQ4UDZKeUV3ZnZ5QVJuVFM2NWx4M1NYQ1c1eWNDRUlpTGp6V09qUVdTQWFVRTNWeElUM0lUTVNuQ3Z6a3BnUWdhVXhVOWQ5WEJpS25uem1CVFI1RTI0eHNGOWhRMi81cXcwYWt4TmRka1YzR1NIbkpoSVRWa2c3Nzd2emgvRUFzNXRMYzhGMG5Ec09ReGlzbEdCYmVKWDViR2t0VTF0bm91cGdTUUZtZ0FvR1JXRkppR0FuNGNvc0VJSHVVNWlaQWhLSGxKZndxZ2l1d2FZWUkyWXBzRnByWGYrZVJ3VGZJOW9hTmxvb2xrY3BBTXNocjU2ejA5cytzWEROSVFKemt0SHR0QVdydDVRenAxbVJLWHlpRzNGb29uR2NUZTU1N1kvSTBES0RZVW9qSE4zenRYOHFJaStkM3h6MjVyQWkrWVBlblMySEYvbkoxa1hPajZwdDhvTFVSMllwc0ptMWs2N2RkdTNKMUVRTVNHNVV4VXA0S0lFcGJ2UEdlM3BFYjd1cCtWaGJlQU9jc1BBQkp0NXVOK2JXRU42K1hLb0dKQytjeFFPTVl5bWE3akFKQ0lSWkthbTNBRjNqZHp6RUFBc0RnTkNZK2FRbk1DaWdob2Uzcm9ySEFUbElia2ExQ1MvcDkvZTd1ZFdUejNQNWN5RjhaU0FWV290bVVxMi82eTZYUG4xeFBIcEpkWEEvMkxEdzRjbkVVeVlYMGtsOU9RVDRWSUhTYWw2L2hzc3hjamdqOGpEWUlPa2o4VHhUbmpLdmtrcFRTTlpmZFhHeC9sUGR2Q2lJZG9aRnQ5bW9iaFZZWUlSdi95djllK3B6SlloOHZZNk1xakpSckpVTGtpWlVPdHQ5MS9kcUhLWThsSGJ4ei9TUk1uenlTWlV0UjBrdlMzZWlLNVRDWXBMdWJUVDRXTTlZc2FJQUZsOWlrQmJrQzQ4QnRBSld3YUlDaHVjSXMzNjkybEViNVByTE5YQ0JuUkxZbEc1T3RqVXRiREdtanlrQXFSSERIS1B6NzRNM3I5M3p6Z2Q3L0RYMkdJb0ZvYlVWTVZGWUdVNkJUUTNxRG5mZ1lHTFF2RCs2WG1TaVVMckRBSXdLb29xN2pJcndKUUZSTVBKSk5TcUkwMExiOVBOblloUHJIUXBIYXBJeVU1NVdXekluYlYvejUwcWVPcnlVUGhNb241eDY3RjdDN2tlWXFlUEV0Z2NsSjJrSFZFRm9DRlBvVEgwT3pRWVNjVVNpMzVNNCtBWGF1SE1vQXFwSzZBSDg4ZUJVUXBlS2F2SU8yQmRra1ZBWWhtMnJiZnRySW1XUEc1b01xQUtrRUpJUElEWFB5eGFYMVpGMHIrdmRyWmQrVlBrTkxCaDZZdndlRy9kNDQ2MTBCVEZaVkd6R3dvbHBBekFLSWJJQVlucCsybWNiTmgvTy9EMlFBU1N6RVpha3RGaTRIVVpxOTFqWWdXOVFEb1Q3WmtteEt0alh1Yk1FTVhzTnRBMUpoaUFuUkhTbjVsVTkvdDNQNDZsczNQaEw2ekZSdkhmYlAzd3NEbWpCUUVVemVHRzkzUmJYUUxKQUtnTExyYThBV1g2dXRrODBKZVFnellCbUFtQklQbTJ3VUU3MCtpS2p2eVFaVGdjVWdhQ05ia2swTE5sN09aNGhzSzVBSzZRQVNZRFNNYnYzTkgxKys2YnVIK2w4S2ZXQjJZeG4yenQ4M0d1ZGREVXpJZ01sbEp5YWtMd0VVVjF2enl5UlFjVHdTOE9VUnIvWldEVUJGNStXN01xNnlId1pSUHY1NjcvejlxUTFDRzltUWJHbTA4RkZqNDk0a3dKZ0lTSVYwd0ZFVEZ2WmUvV2NuLzgvUmxlVHUwT2ZtMm91dzY4ajltYSt1QkNZbm44SzZPa2M3aFFDRi9KSTAzRFNrYW1PUjBCK2I0UUt0NGtSS0tDWTRPUlp5OVpBN0psc0FFZlgxYnQzbmMrMFRRWnVTN2NpR0JqakhqVzNiVlYzYVpoa3BkM0Vrd21nbXdjbmxqYVJ6K1lkUFhxWER4YU9oeisxYVhVakJOQ3dCRTRMZlVXRjJxZ0FvQzFTT2xoR21hay9VZ0ZsVGFZUWhMTDAyRjBBY0N5RXpXMWxtSWdMUmZiQnpkU0ZvUzdJWjJZNXNTTFkwTmwyYXhLVnRHa2lGM05KeDg4V3Izem5VWDdyeUU4dC8zQi9DZWhtWWRwTm1HZzVFTU5sTHczQ3VqcGxEeGdBS1FjZ3llN05wSnhpREJLRVJBVkE2Q3hlODJTb0NnTVFWNFFwbEQ1R0pCckRuMFhzMGlJNkhEYWh0UlRZajI1bkU0N3l4YVg4emdOZ1VrQXBSM0JGekFlM1AzdGFaLzI5ZlhydHFHSWprVWplM2RnTDJINzVMUnhKOVFZRDdBN3FLcmc3ZGdYSG96RXRsSmoyQ0J5cC9HV1EvTnhUQ1RtaEVBSlBVOU9wekxvREFXa25YWWlIa2w3MngrbW9VbmZYVHZ0M1JYZ3phajJ6MDdpK3RYVVUyTTFKbDN0aHlZMUtYdGxWR3lrZFM1a2ltdEVEbnYzeHg3WTczM3REK241UzZDSDJXMWxvNjU5QWRnTjBPQTZhd3EvUG1wb0ZmemZkWXdqVTFWMHZ6NXJCV21yUXQ1SnY4YzdqczU0MFdBSHZRSFRmdm4zc1VSZzRpNmt2cTA1a1NZVTIySVJ2OTE3OVp1d095OGZuSGNzL0NqWHc4NVVCeTlOSWpKdS9RKzkzUHIzN3ZROTlZLzlOUUdZVzJsZzVIejMvNGRvaldsa2RKUzdzMjU3bzZmNTZUOTlRQXp1V0JQNVdJQlVacG9WWXU0SExBQStCZHArL0NYRGZtalFEa1hSbU9SVFgxSWZWbHF5VEVwNCtRYmNoR1Jsd3ZHTnR0U2hjVnQvaWRWMXk4bGMvRDgxOTA3dkRhcnkvU1JSRUs2SW5McmIrNXMzdGt6MHgwNkpLbjFuOVNLUm1zTkw5OGgvYmxmUlZEcnpremV1eWxDanpxWEhsUG9sYk9zNDY1UjRhcVNrL1kzdEpXK3JndGZnbzFzZ1ZYTnlMeldTaTk4ZlFOT0hYeUNKeHo5RjZJUzU2clIweWtRZlMrdDEyN2NrdEI0OUppNjhjMGlIcGIvZmtSYk0rV28vdHdYdVI3eDJkV2JublAxOXFsbW9sUzl2c1hIb1RkV2lCaXI4ZUljRmM3OGU0TzJCVnBIVTNqcmZPQm9tc3FiM0xweElvSlVXSWZmMktsN01ZY0VOR3NIZDFYMUdmVWQ2cmtxVU5rQTdKRkFVU0x4bFlMaythTFRoa2ozZFZ0d090ZXVnYzBLdzNNUmVYTTFMemg3dDR4L1p2dmV2R3o2cGZFa1dxRXp0UHNiY0QwNmdubzFLZGhVRytPT2kvRVR0bGJ3blB1dlNleWh4NXpyaVN1cWtaQWJnQWd2Q2V6RC9ERFFoZ0EwWGlpbW5abEJ4NDVDRk9kMWZJN2ZJanRQL3BpKzAvZWRmM2E3YVp1Um1IK0lhT0xOaTJ1VHhVandTZis4MFg1S0lGNWM2RjB3WU0vL3ZMYXdUZC9iUG1kcTEwOFZuYU8rcUFMNXoxeUoreWN2eCtTL2poRmtHb243ZzcxU2hJU1MzRnJaOHZzVXJtK3hrN25sdkpVUFB1QW00NWdJckkwSUtHbSsyVHV5UDFwSDFGZmxXM1U1N3J2ZjU5c3dJSEkyQXhPS3lBWk1DVUZNRDJjdTdsUGZxZno2R1VmV1B5OXNneDQzb2s3VjQ3Q2VROStEK3JMeDBlelUwTHViaHk0Q1VzYkYwRWxBcXRxblMyY0FTOENSd2FQTzZ3azRNWXdLM1ZRWDFDZjdGbytXdWthcWErcHo2bnZDKzdzWVdPYmRXT3JiZHNVWG5QRmxrNXczZktzOTdjMy92NjlCTkJwM2M3VDdVTGRkdXZXbUd1cCtQcC92ZWROUDM1aC9SV1ZJOE9wT1RoNTRPbVFUTTFBRkdXNGoraFJ2S3ovY1Z5VXF1S290aWk2S3p4dVZCYlFnb3N6czNIU3RhNDMyckQ3MklNd0hWaXFtS3VkdmVvRGl4OWQ2YVFQbzgxQmRJZ0QwV3QycnAyK1FDcUFhVXEzYzNXN1FMZTlCQ2I2emcvOThzNUwzL2pDcWQrSW8xUkxWYkNWZ3RXNWZiQzY5d0pJbWkwYlVDd0FtQmhOYldlSU5obktzTXBUTHd2bEZBS1E2blpnN3NSaDJMRnlQRGg1MFJYVkg3dGw0eU5YZm1MNVp2TUZlWkg5Y0o1d2RKbm90QWVTQVpNeVlOcHZ3RVQ3Rm4zdjYzNjhkZDVWbDgrOVpkOXM5SXpLWnRGb1dKbmJEMnQ3bm1JQml0SUd2aWd2QVk0cUVlS2JCVTJRbVBpSCt1VVRKVklHMGdDYVhYd0U1bFlXU3FPeDRrYUQwbWc4MGFlL20yYXIwU1FiRndyUkdhdUp6Z2dnRmNEVU5JejBGTjBPVUhLYkNJVmMzYlZ2M24zRmk1L1J1RXhqSVo0RVVPMlozYkM2NTN6b1QrM1FnRktqSEpUTVVoT0NSdmxIVjNtUVl5bHdIUGJKRjdtcWI2ekNqc1ZIWWFaOWNpSUEwWmorYno3USs4TGxIenI1S2VQSzhyVWJqcGxrSXpGU1Z4TFdad3lRQ29BaXQ3Ykw2Q1pxTzNTcjBYdFhYanI5ek45OTFleHY3cDZPbmpicDkzZWJNN0M2Y3o5c2FLYUNXczFucWNyWVVWdG1veXFIRk5rSEJnT1kwc3l6WTNrQm10MzJ4TjlLc3oxb29QNEhiMTdQbjJ4RmtWbGV0a29yK1JwQXdUelJHUWNrQTZiWUFPaGNBNmJkdVc2YWFhajQ0NysrNjlVdi9aSG1hMnRSNnY0bTJoTE5ST3N6dTJCOXh6N296bXE4eG5FR3BqeGJQakd3dGlmVG5RTm5GT0xURXhuWGxtQjY5VGhNdCtWRjBVTWJUVjZrT1lhLy9CZExYMmozVWhiSzlSQ0Y5eFNsVVdpM3FrRlVXdlk0STRIa2lQQjlCa3o3VElTWHVyYWZlV1pqMTN1dm1IdkR4ZWZWTHQyc3laTW9oZzBkN1hVMHNEcXp1MkZZYjJxWHAyRVVGVXN0aFhMTVpvbUplYXFsdGZSTWtqMkZNZTUzb2JWMkVsb2FPRk02K29xU1RaZTFrS2JPLzl0UHJWejl0L2YzOGhYVmh5YmxrZy9yT2M2SjZyTU9TQVhkVkRldTdoelQ1bkoyb21QZThwS1ppMzdycGRPdnYyQlgvUHl0L3NoK3JRbmRxVm5kZGtDdk5RdURoc1p0TFI0SmRLVzRLRThKbWtSNG1IRmVudEdNVSt1dVE2T3pCazJ0ZTVvYmE1V1NoMlViclFwQ2kzbTgvOGIydlFVWUV3dXRHQWFpbHM3UG55VFJlRVlEeVhGMU0wYUlrN3ZiWS80OUV0Ny83dVV6ejczeTBwblhuN2N6ZXU1MmVwNitacWwrZlNvdHgxQWoxa3BxZFJqR2RjQ29wbHVrUlgyVTd0T09vcENjSGhaTSsyUUE4YkFQMGFDZnNrM050SHAvUTdmdWRsNW11c2pWQjI5dWYvSlB2dEl1TG5pV3IvVzVhTUw2ZEc1K0ZWZDJWZ0twd0U0TncwZ0hUSXBncDBrVGpETHZiLzM1bWVmOHhvdW1MM3ZXdnZpRlNqMm15YURIZkNNNVJXczJmdVJiNjE5NDc5ZmF4V3BBWXNMNmZQTGlNZk82dDlseXgya0RwTzNhcHQ5NkpEYmFhWmNCMHo0anpCdEY1ZkthRjdUTytlMmZuL21GSDcyZzlyUE5tcG83bXdCRWE1dmZkbmp3amZkOHJmM2w2NzdmT2Vxb3NSNk01K0l2R0RlMnNkVnhSTnUxblRaQU1tQlNKaVV3YmR6Y3ZvSzdzd0MxWnlhcXYvUFZzNWU4NG5uTmwxeXdPMzUrTkVFZTZuVGFhSUFqUGJMalMzZDJiM3puLzF2NzltTGJldlpuRHFEY2pSMDNleExYZysycTNKOTFRSElBMVNnQWFxOUpGVXlidjF2RjVoYzhwVDc3dHBmTi9OU0xuMW4vNmZOM3hzL1ZvS3FkNXVBWlBMbzhQUGpOKy90L2Q5VlgyLy93L1VmNnJuOUpESURXVFVoL29nQ2czdWtFb05NYVNBeWdab3pMMjJQMjlPOW1VWlRuMjlQMnhDMGQ4VjM4czgrcS8rZ3o5dFV1bm11cDgwNkgzMExQZ0gzZytPQ09iOXpYdjAxSFhuYzh0RGprRmkwak45V0Y4Y0tmaTJiZlBsMEJkRVlBeVFGVTNURFNuQUVUdFZranl1c2dESW41aVF2cmM3OTBTZXZabHp5MS9wd0xkc1ZQMnpjYlhUamRVTHRQNWZXdTkvRGs4YlhrMENQTHc0ZHVmYWgvOXpYZjd0enpuVU45cVh4UDdOTTNJbm9OeHN2c3JSZ0c2cC9PQURxamdNUm9xS1pocFoybTdUQkN2V1hlRDQ2eklsZjQ4dWMyem4vMmdkcUJwKzZPOXgvWUVlM1g0SnFicnF2WlZoMTBVN05VKzR1VXF0WE1DQVZhWkNGQkhGQnRxOVBIdFU0ZjF0YjFYb05tNWRocXN2RHd5ZUhDUGNjR3g3NXlzUGNvNDZvNDhBd01lRGFNaUY0MnJXMVlhWEFtQU9pTUJKSURxc2k0dlpZQjFRN0RWamxMTlF4VHhRQ1BlN29BamR2cUcrMlRzODhLakovdDBUSHVLemtUN2FHbXpydjBiSWljWXdPY3BtR21IRmpUNXQ4NXFHcm0yT2dVZ2dzTjR3d042K1RnMlRDdUtnZk9obUdlbmpuMmpONXFjSFpzUTJPWURYT1gxdzE0Y3NhYU1xQnFGZGlxQ0twOEh4VkFsZ05ORlFDUzczT3dKQVhRRk1HVHMwN0hnR2NqWnh6VCtnQ1F3Rm0wMWVEczJ4SnpwM2NMYkZVck1GS3RBTEtHdzFZMUIxVEtBUkk2NEJrNHJGTnN4ZmNHWndQclBOR0F4TEhWRU94bmFPUXNWR3hxazR5RWhlOFlGdGpwQ2JYOWZ3RUdBRmpBd013bmdOWEpBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL2NvdW50LWRvd24ucG5nXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XG4gICAgLy8tIOWxleekuueUqOaIt+eahOS4i+azqOmHkeminSDku6Xlj4og5aWW6YeR6YeR6aKdIOW9k+eEtui/mOacieWAkuiuoeaXtlxuICAgIGRpdi5ib251cy1iYXJcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYmV0XG4gICAgICAgICAgICBkaXYuaXRlbS1iYWNrLmZvcnplblxuICAgICAgICAgICAgICAgIGRpdi5pdGVtLXNob3dcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJldC1udW0odi1iaW5kOnN0eWxlPVwiYmV0TnVtXCIsdi1odG1sPVwibG9ja21vbmV5XCIpXG4gICAgICAgIGRpdi5ib251cy1pdGVtLmNvdW50LWRvd25cbiAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLWJhY2tcbiAgICAgICAgICAgICAgICBkaXYuY291bnQtZG93bi1zaG93XG4gICAgICAgICAgICAgICAgICAgIGRpdi5jb3VudC1kb3duLW51bSh2LWJpbmQ6c3R5bGU9XCJ7Zm9udFNpemU6NDAqem9vbVJhdGUueCsncHgnfVwiLHYtaHRtbD1cImNvdW50RG93biB8IHRpbWVcIilcbiAgICAgICAgZGl2LmJvbnVzLWl0ZW0uYm9udXNcbiAgICAgICAgICAgIGRpdi5pdGVtLWJhY2suYmFsYW5jZVxuICAgICAgICAgICAgICAgIGRpdi5pdGVtLXNob3coQHRvdWNoZW5kPVwic2hvd01lc3NhZ2VcIilcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJldC1udW0odi1iaW5kOnN0eWxlPVwiYmV0TnVtXCIgdi1odG1sPVwidXNlcmluZm8ubW9uZXktbG9ja21vbmV5XCIpXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBSZXF1ZXN0TGlzdCBmcm9tICcuLi9qcy9yZXF1ZXN0LWxpc3QnXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nLCAndXNlckJldCcsICdjb3VudERvd24nLCAnY291bnROdW0nLCAnYmV0cycsICdsb2NrbW9uZXknLCAnbG90dGVyeW51bSddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICB0aGlzLmdldENvdW50KHRoaXMuY291bnQodGhpcy5jb3VudERvd24pKVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGJldE51bSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAzICogMzQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLy/mr4/mrKHlvIDlpZbpg73ph43mlrDojrflj5Yg5YCS6K6h5pe2XG4gICAgICAgIGdldENvdW50KGZuKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgICAgIFJlcXVlc3RMaXN0LmdldENvdW50KCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhhdC5jb3VudERvd24gPSByZXMuZGF0YS5jb3VudERvd25cbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50TnVtID0gcmVzLmRhdGEuY291bnROdW1cbiAgICAgICAgICAgICAgICB0aGF0LnVzZXJCZXQuaWRudW0gPSByZXMuZGF0YS5pZG51bSArIDEgLy/lvIDlpZbmnJ/mlbBcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoYXQuY291bnREb3duKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC4kZGlzcGF0Y2goJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuID8gZm4oKSA6IG51bGxcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0LmNvdW50RG93biA9IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOS5sOWumuemu+aJi1xuICAgICAgICBjcmVhdGVVc2VyQmV0cygpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuY3JlYXRlVXNlckJldHMoSlNPTi5zdHJpbmdpZnkodGhpcy5iZXRzKSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuZGF0YS5lcnJtc2cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGRpc3BhdGNoKCdzaG93VGlwJywgcmVzLmRhdGEuZXJybXNnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSlcbiAgICAgICAgICAgIH0sIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGdldEJvbnVzTnVtKCkgeyAvLyDojrflj5blvIDlpZbnu5PmnpxcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAgICAgUmVxdWVzdExpc3QuZ2V0Qm9udXNOdW0oKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0LmxvdHRlcnludW0gPSByZXMuZGF0YVxuICAgICAgICAgICAgICAgIHRoYXQuZ2V0Q291bnQodGhhdC5jb3VudClcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgnY2FuY2VsYmV0JylcbiAgICAgICAgICAgICAgICB0aGF0LiRkaXNwYXRjaCgncmVsb2FkaW5mbycpXG4gICAgICAgICAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5jb3VudERvd24gPSB0aGlzLmNvdW50TnVtXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dNZXNzYWdlKCkge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ3Nob3dNZXNzYWdlJywgNSlcbiAgICAgICAgfSxcbiAgICAgICAgY291bnQoKSB7XG4gICAgICAgICAgICAvLyDot53nprvlvIDlpZbml7bpl7QzMOenkuaXtiDkubDlrprnprvmiYtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50RG93biA9PT0gMzAgJiYgdGhpcy5iZXRzICYmIHRoaXMuYmV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVVc2VyQmV0cygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlgJLorqHml7bkuI3mmK/mlbDlrZfml7bkuI3ov5vooYzlgJLorqHml7ZcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5jb3VudERvd24pICE9PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93VGlwJywgJ+WAkuiuoeaXtuivu+WPlumUmeivryzor7fliLfmlrDpobXpnaInKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb3VudERvd24pXG4gICAgICAgICAgICB0aGlzLmNvdW50RG93bi0tXG4gICAgICAgICAgICAgICAgbGV0IHRoYXQgPSB0aGlzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvdW50RG93biA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb3VudCgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YCS6K6h5pe25bCP5LqOMCDml7Yg6I635Y+W6I635aWW57uT5p6cXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2V0Qm9udXNOdW0oKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbmltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuZm9yemVuIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDgwJTtcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Ya757uTLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuZGl2LmJhbGFuY2Uge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogODAlO1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kvZnpop0ucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xufVxuXG4uYm9udXMtYmFyIHtcbiAgICBoZWlnaHQ6IDIwJTtcbn1cblxuZGl2Lml0ZW0tYmFjayB7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuXG5kaXYuaXRlbS1zaG93IHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbmRpdi5pdGVtLXNob3cgZGl2IHtcbiAgICAvKmhlaWdodDogMzAlOyovXG59XG5cbmRpdi5ib251cy1pdGVtIHtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbmRpdi5iZXQtbnVtIHtcbiAgICBtYXJnaW46IDMwJSAwIDAgMDtcbiAgICBjb2xvcjogd2hpdGU7XG59XG5cbmRpdi5iZXQsXG5kaXYuYm9udXMge1xuICAgIHdpZHRoOiBjYWxjKDM1JSAtIDFlbSk7XG4gICAgcGFkZGluZzogMCAuNWVtO1xufVxuXG5kaXYuY291bnQtZG93biB7XG4gICAgd2lkdGg6IGNhbGMoMzAlIC0gMWVtKTtcbiAgICBwYWRkaW5nOiAwIC41ZW07XG59XG5cbmRpdi5jb3VudC1kb3duLW51bSB7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDJlbTtcbn1cblxuZGl2LmNvdW50LWRvd24tYmFjayB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi9jb3VudC1kb3duLnBuZykgNTAlIDUwJTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cblxuZGl2LmNvdW50LWRvd24tc2hvdyB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgaGVpZ2h0OiA5MiU7XG4gICAgd2lkdGg6IDkyJTtcbiAgICBtYXJnaW46IDQlO1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEJldEFuZEJvbnVzLnZ1ZT8xN2Y1NjhiZlxuICoqLyIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgVnVlUmVzb3VyY2UgZnJvbSAndnVlLXJlc291cmNlJ1xyXG5WdWUudXNlKFZ1ZVJlc291cmNlKVxyXG4gICAgLy8g6I635Y+W5byA5aWW6K6w5b2VXHJcbm1vZHVsZS5leHBvcnRzLmdldEJvbnVzUmVjb3JkID0gKCkgPT4gVnVlLmh0dHAuZ2V0KCdnZXRCb251c1JlY29yZCcpXHJcbiAgICAvLyDojrflj5bkuLvphY3nva7kv6Hmga9cclxubW9kdWxlLmV4cG9ydHMuZ2V0TWFpbkNvbmZpZyA9ICgpID0+IFZ1ZS5odHRwLmdldCgnZ2V0TWFpbkNvbmZpZycsIHsgcGFyYW1zOiB7IHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSB9IH0pXHJcbiAgICAvL+avj+asoeW8gOWllumDvemHjeaWsOiOt+WPliDlgJLorqHml7ZcclxubW9kdWxlLmV4cG9ydHMuZ2V0Q291bnQgPSAoKSA9PiBWdWUuaHR0cC5nZXQoJ2dldENvdW50JylcclxuICAgIC8vIOiOt+WPluW8gOWllue7k+aenFxyXG5tb2R1bGUuZXhwb3J0cy5nZXRCb251c051bSA9IChwYXJhbXMpID0+IFZ1ZS5odHRwLmdldCgnZ2V0Qm9udXNOdW0nLCBwYXJhbXMpXHJcbiAgICAvLyDkubDlrprnprvmiYtcclxubW9kdWxlLmV4cG9ydHMuY3JlYXRlVXNlckJldHMgPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5wb3N0KCdjcmVhdGVVc2VyQmV0cycsIHBhcmFtcylcclxuXHJcbm1vZHVsZS5leHBvcnRzLmdldHVzZXJDb2RlRnJvbU5ldCA9IChjb2RlKSA9PiBWdWUuaHR0cC5nZXQoJ2dldFVzZXJDb2RlJywgeyBwYXJhbXM6IHsgY29kZTogY29kZSB9IH0pXHJcbiAgICAvLyDojrflj5bnlKjmiLfkv6Hmga9cclxubW9kdWxlLmV4cG9ydHMuZ2V0dXNlcmluZm8gPSAodXNlcmluZm8pID0+IFZ1ZS5odHRwLnBvc3QoJ2dldHVzZXJpbmZvJywgdXNlcmluZm8pXHJcbiAgICAvLyDojrflj5blhazlkYrkv6Hmga9cclxubW9kdWxlLmV4cG9ydHMuZ2V0TGFzdE5vdGljZSA9ICgpID0+IFZ1ZS5odHRwLmdldCgnZ2V0TGFzdE5vdGljZScpXHJcbiAgICAvLyDojrflj5blvq7kv6HnlKjmiLdjb2RlIOeUqOadpeWQjuWPsOiOt+WPlueUqOaIt29wZW5pZFxyXG5tb2R1bGUuZXhwb3J0cy5nZXRDb2RlID0gZnVuY3Rpb24oKSB7IC8vIOiOt+WPlueUqOaIt2NvZGXlgLxcclxuICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihefCYpXCIgKyAnY29kZScgKyBcIj0oW14mXSopKCZ8JClcIiwgXCJpXCIpO1xyXG4gICAgICAgIHZhciByID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkubWF0Y2gocmVnKTtcclxuICAgICAgICBpZiAociAhPSBudWxsKSByZXR1cm4gdW5lc2NhcGUoclsyXSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKioqKuWQjuWPsOeuoeeQhueUqCoqKi9cclxubW9kdWxlLmV4cG9ydHMudXBkYXRldXNlcmluZm8gPSAocGFyYW1zKSA9PiBWdWUuaHR0cC5wb3N0KCd1cGRhdGV1c2VyaW5mbycsIHBhcmFtcylcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvcmVxdWVzdC1saXN0LmpzXG4gKiovIiwiLyohXG4gKiB2dWUtcmVzb3VyY2UgdjAuOS4zXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJlc291cmNlXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb21pc2VzL0ErIHBvbHlmaWxsIHYxLjEuNCAoaHR0cHM6Ly9naXRodWIuY29tL2JyYW1zdGVpbi9wcm9taXMpXG4gKi9cblxudmFyIFJFU09MVkVEID0gMDtcbnZhciBSRUpFQ1RFRCA9IDE7XG52YXIgUEVORElORyA9IDI7XG5cbmZ1bmN0aW9uIFByb21pc2UkMihleGVjdXRvcikge1xuXG4gICAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XG4gICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlJDIucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChyKTtcbiAgICB9KTtcbn07XG5cblByb21pc2UkMi5yZXNvbHZlID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoeCk7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDIuYWxsID0gZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGl0ZXJhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0geDtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBQcm9taXNlJDIucmVzb2x2ZShpdGVyYWJsZVtpXSkudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuUHJvbWlzZSQyLnJhY2UgPSBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDIoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBQcm9taXNlJDIucmVzb2x2ZShpdGVyYWJsZVtpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG52YXIgcCQxID0gUHJvbWlzZSQyLnByb3RvdHlwZTtcblxucCQxLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgICBpZiAoeCA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHggJiYgeFsndGhlbiddO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGVuLmNhbGwoeCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2Uuc3RhdGUgPSBSRVNPTFZFRDtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHg7XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfVxufTtcblxucCQxLnJlamVjdCA9IGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgICBpZiAocmVhc29uID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVKRUNURUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSByZWFzb247XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfVxufTtcblxucCQxLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9taXNlLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgICAgICB3aGlsZSAocHJvbWlzZS5kZWZlcnJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBwcm9taXNlLmRlZmVycmVkLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZWQgPSBkZWZlcnJlZFswXSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWplY3RlZCA9IGRlZmVycmVkWzFdLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gZGVmZXJyZWRbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCA9IGRlZmVycmVkWzNdO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQuY2FsbCh1bmRlZmluZWQsIHByb21pc2UudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlamVjdGVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChwcm9taXNlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxucCQxLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb21pc2UuZGVmZXJyZWQucHVzaChbb25SZXNvbHZlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgIHByb21pc2Uubm90aWZ5KCk7XG4gICAgfSk7XG59O1xuXG5wJDEuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbn07XG5cbnZhciBQcm9taXNlT2JqID0gd2luZG93LlByb21pc2UgfHwgUHJvbWlzZSQyO1xuXG5mdW5jdGlvbiBQcm9taXNlJDEoZXhlY3V0b3IsIGNvbnRleHQpIHtcblxuICAgIGlmIChleGVjdXRvciBpbnN0YW5jZW9mIFByb21pc2VPYmopIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gZXhlY3V0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2VPYmooZXhlY3V0b3IuYmluZChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUHJvbWlzZSQxLmFsbCA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmouYWxsKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG5Qcm9taXNlJDEucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKFByb21pc2VPYmoucmVzb2x2ZSh2YWx1ZSksIGNvbnRleHQpO1xufTtcblxuUHJvbWlzZSQxLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShQcm9taXNlT2JqLnJlamVjdChyZWFzb24pLCBjb250ZXh0KTtcbn07XG5cblByb21pc2UkMS5yYWNlID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoUHJvbWlzZU9iai5yYWNlKGl0ZXJhYmxlKSwgY29udGV4dCk7XG59O1xuXG52YXIgcCA9IFByb21pc2UkMS5wcm90b3R5cGU7XG5cbnAuYmluZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnAudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cbiAgICBpZiAoZnVsZmlsbGVkICYmIGZ1bGZpbGxlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICBmdWxmaWxsZWQgPSBmdWxmaWxsZWQuYmluZCh0aGlzLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMSh0aGlzLnByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKSwgdGhpcy5jb250ZXh0KTtcbn07XG5cbnAuY2F0Y2ggPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMSh0aGlzLnByb21pc2UuY2F0Y2gocmVqZWN0ZWQpLCB0aGlzLmNvbnRleHQpO1xufTtcblxucC5maW5hbGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZU9iai5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbn07XG5cbnZhciBkZWJ1ZyA9IGZhbHNlO1xudmFyIHV0aWwgPSB7fTtcbnZhciBhcnJheSA9IFtdO1xuZnVuY3Rpb24gVXRpbCAoVnVlKSB7XG4gICAgdXRpbCA9IFZ1ZS51dGlsO1xuICAgIGRlYnVnID0gVnVlLmNvbmZpZy5kZWJ1ZyB8fCAhVnVlLmNvbmZpZy5zaWxlbnQ7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tWdWVSZXNvdXJjZSB3YXJuXTogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGNiLCBjdHgpIHtcbiAgICByZXR1cm4gdXRpbC5uZXh0VGljayhjYiwgY3R4KTtcbn1cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRGF0YShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cblxuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucyhmbiwgb2JqLCBvcHRzKSB7XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzLmNhbGwob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2UoZm4uYmluZCh7ICR2bTogb2JqLCAkb3B0aW9uczogb3B0cyB9KSwgZm4sIHsgJG9wdGlvbnM6IG9wdHMgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvcikge1xuXG4gICAgdmFyIGksIGtleTtcblxuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtpXSwgb2JqW2ldLCBpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwob2JqW2tleV0sIG9ialtrZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgX2Fzc2lnbjtcblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcblxuICAgIHZhciBhcmdzID0gYXJyYXkuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IGFycmF5LnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByb290IChvcHRpb25zLCBuZXh0KSB7XG5cbiAgICB2YXIgdXJsID0gbmV4dChvcHRpb25zKTtcblxuICAgIGlmIChpc1N0cmluZyhvcHRpb25zLnJvb3QpICYmICF1cmwubWF0Y2goL14oaHR0cHM/Oik/XFwvLykpIHtcbiAgICAgICAgdXJsID0gb3B0aW9ucy5yb290ICsgJy8nICsgdXJsO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5IChvcHRpb25zLCBuZXh0KSB7XG5cbiAgICB2YXIgdXJsUGFyYW1zID0gT2JqZWN0LmtleXMoVXJsLm9wdGlvbnMucGFyYW1zKSxcbiAgICAgICAgcXVlcnkgPSB7fSxcbiAgICAgICAgdXJsID0gbmV4dChvcHRpb25zKTtcblxuICAgIGVhY2gob3B0aW9ucy5wYXJhbXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh1cmxQYXJhbXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBxdWVyeSA9IFVybC5wYXJhbXMocXVlcnkpO1xuXG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PSAtMSA/ICc/JyA6ICcmJykgKyBxdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFVSTCBUZW1wbGF0ZSB2Mi4wLjYgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vdXJsLXRlbXBsYXRlKVxuICovXG5cbmZ1bmN0aW9uIGV4cGFuZCh1cmwsIHBhcmFtcywgdmFyaWFibGVzKSB7XG5cbiAgICB2YXIgdG1wbCA9IHBhcnNlKHVybCksXG4gICAgICAgIGV4cGFuZGVkID0gdG1wbC5leHBhbmQocGFyYW1zKTtcblxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyaWFibGVzLnB1c2guYXBwbHkodmFyaWFibGVzLCB0bXBsLnZhcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUpIHtcblxuICAgIHZhciBvcGVyYXRvcnMgPSBbJysnLCAnIycsICcuJywgJy8nLCAnOycsICc/JywgJyYnXSxcbiAgICAgICAgdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiB2YXJpYWJsZXMsXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csIGZ1bmN0aW9uIChfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gZXhwcmVzc2lvbi5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godG1wWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yICYmIG9wZXJhdG9yICE9PSAnKycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICcsJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSAnJic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiAnJykgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlUmVzZXJ2ZWQobGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIGtleSwgbW9kaWZpZXIpIHtcblxuICAgIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgJiYgbW9kaWZpZXIgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHBhcnNlSW50KG1vZGlmaWVyLCAxMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5maWx0ZXIoaXNEZWZpbmVkKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdG1wLmpvaW4oJywnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJzsnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnICYmIChvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPycpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNLZXlPcGVyYXRvcihvcGVyYXRvcikge1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gJzsnIHx8IG9wZXJhdG9yID09PSAnJicgfHwgb3BlcmF0b3IgPT09ICc/Jztcbn1cblxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcblxuICAgIHZhbHVlID0gb3BlcmF0b3IgPT09ICcrJyB8fCBvcGVyYXRvciA9PT0gJyMnID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9KS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUgKG9wdGlvbnMpIHtcblxuICAgIHZhciB2YXJpYWJsZXMgPSBbXSxcbiAgICAgICAgdXJsID0gZXhwYW5kKG9wdGlvbnMudXJsLCBvcHRpb25zLnBhcmFtcywgdmFyaWFibGVzKTtcblxuICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlcnZpY2UgZm9yIFVSTCB0ZW1wbGF0aW5nLlxuICovXG5cbnZhciBpZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbnZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuZnVuY3Rpb24gVXJsKHVybCwgcGFyYW1zKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMgfHwge30sXG4gICAgICAgIG9wdGlvbnMgPSB1cmwsXG4gICAgICAgIHRyYW5zZm9ybTtcblxuICAgIGlmIChpc1N0cmluZyh1cmwpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVybDogdXJsLCBwYXJhbXM6IHBhcmFtcyB9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZSh7fSwgVXJsLm9wdGlvbnMsIHNlbGYuJG9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgVXJsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB0cmFuc2Zvcm0gPSBmYWN0b3J5KGhhbmRsZXIsIHRyYW5zZm9ybSwgc2VsZi4kdm0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybShvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBVcmwgb3B0aW9ucy5cbiAqL1xuXG5Vcmwub3B0aW9ucyA9IHtcbiAgICB1cmw6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcGFyYW1zOiB7fVxufTtcblxuLyoqXG4gKiBVcmwgdHJhbnNmb3Jtcy5cbiAqL1xuXG5VcmwudHJhbnNmb3JtcyA9IFt0ZW1wbGF0ZSwgcXVlcnksIHJvb3RdO1xuXG4vKipcbiAqIEVuY29kZXMgYSBVcmwgcGFyYW1ldGVyIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuVXJsLnBhcmFtcyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgcGFyYW1zLmFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB1c2goZXNjYXBlKGtleSkgKyAnPScgKyBlc2NhcGUodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgc2VyaWFsaXplKHBhcmFtcywgb2JqKTtcblxuICAgIHJldHVybiBwYXJhbXMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIFVSTCBhbmQgcmV0dXJuIGl0cyBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqL1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiAodXJsKSB7XG5cbiAgICBpZiAoaWUpIHtcbiAgICAgICAgZWwuaHJlZiA9IHVybDtcbiAgICAgICAgdXJsID0gZWwuaHJlZjtcbiAgICB9XG5cbiAgICBlbC5ocmVmID0gdXJsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogZWwuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IGVsLnByb3RvY29sID8gZWwucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgcG9ydDogZWwucG9ydCxcbiAgICAgICAgaG9zdDogZWwuaG9zdCxcbiAgICAgICAgaG9zdG5hbWU6IGVsLmhvc3RuYW1lLFxuICAgICAgICBwYXRobmFtZTogZWwucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycgPyBlbC5wYXRobmFtZSA6ICcvJyArIGVsLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2g6IGVsLnNlYXJjaCA/IGVsLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IGVsLmhhc2ggPyBlbC5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJydcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZmFjdG9yeShoYW5kbGVyLCBuZXh0LCB2bSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHZtLCBvcHRpb25zLCBuZXh0KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHNjb3BlKSB7XG5cbiAgICB2YXIgYXJyYXkgPSBpc0FycmF5KG9iaiksXG4gICAgICAgIHBsYWluID0gaXNQbGFpbk9iamVjdChvYmopLFxuICAgICAgICBoYXNoO1xuXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgICAgaGFzaCA9IGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIGtleSA9IHNjb3BlICsgJ1snICsgKHBsYWluIHx8IGhhc2ggPyBrZXkgOiAnJykgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjb3BlICYmIGFycmF5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYWRkKHZhbHVlLm5hbWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNoKSB7XG4gICAgICAgICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24geGRyQ2xpZW50IChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgeGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCksXG4gICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uZFdpdGgoeGRyLnJlc3BvbnNlVGV4dCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogeGRyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4ZHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geGRyLmFib3J0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuICAgICAgICB4ZHIudGltZW91dCA9IDA7XG4gICAgICAgIHhkci5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub25lcnJvciA9IGhhbmRsZXI7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufVxuXG52YXIgT1JJR0lOX1VSTCA9IFVybC5wYXJzZShsb2NhdGlvbi5ocmVmKTtcbnZhciBTVVBQT1JUU19DT1JTID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbmZ1bmN0aW9uIGNvcnMgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIGlmICghaXNCb29sZWFuKHJlcXVlc3QuY3Jvc3NPcmlnaW4pICYmIGNyb3NzT3JpZ2luKHJlcXVlc3QpKSB7XG4gICAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmNyb3NzT3JpZ2luKSB7XG5cbiAgICAgICAgaWYgKCFTVVBQT1JUU19DT1JTKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNsaWVudCA9IHhkckNsaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0LmVtdWxhdGVIVFRQO1xuICAgIH1cblxuICAgIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gY3Jvc3NPcmlnaW4ocmVxdWVzdCkge1xuXG4gICAgdmFyIHJlcXVlc3RVcmwgPSBVcmwucGFyc2UoVXJsKHJlcXVlc3QpKTtcblxuICAgIHJldHVybiByZXF1ZXN0VXJsLnByb3RvY29sICE9PSBPUklHSU5fVVJMLnByb3RvY29sIHx8IHJlcXVlc3RVcmwuaG9zdCAhPT0gT1JJR0lOX1VSTC5ob3N0O1xufVxuXG5mdW5jdGlvbiBib2R5IChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSlNPTiAmJiBpc1BsYWluT2JqZWN0KHJlcXVlc3QuYm9keSkpIHtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gVXJsLnBhcmFtcyhyZXF1ZXN0LmJvZHkpO1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9ybURhdGEocmVxdWVzdC5ib2R5KSkge1xuICAgICAgICBkZWxldGUgcmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuYm9keSk7XG4gICAgfVxuXG4gICAgbmV4dChmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcblxuICAgICAgICBpZiAoaXNTdHJpbmcoY29udGVudFR5cGUpICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCkge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGpzb25wQ2xpZW50IChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgbmFtZSA9IHJlcXVlc3QuanNvbnAgfHwgJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJ19qc29ucCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiksXG4gICAgICAgICAgICBib2R5ID0gbnVsbCxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBzY3JpcHQ7XG5cbiAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyAmJiBib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gNDA0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uZFdpdGgoYm9keSwgeyBzdGF0dXM6IHN0YXR1cyB9KSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tdO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QucGFyYW1zW25hbWVdID0gY2FsbGJhY2s7XG5cbiAgICAgICAgd2luZG93W2NhbGxiYWNrXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuc3JjID0gcmVxdWVzdC5nZXRVcmwoKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gaGFuZGxlcjtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGpzb25wIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT0gJ0pTT05QJykge1xuICAgICAgICByZXF1ZXN0LmNsaWVudCA9IGpzb25wQ2xpZW50O1xuICAgIH1cblxuICAgIG5leHQoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYmVmb3JlIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LmJlZm9yZSkpIHtcbiAgICAgICAgcmVxdWVzdC5iZWZvcmUuY2FsbCh0aGlzLCByZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbi8qKlxuICogSFRUUCBtZXRob2Qgb3ZlcnJpZGUgSW50ZXJjZXB0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWV0aG9kIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSFRUUCAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnXSA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9ICdQT1NUJztcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGhlYWRlciAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgcmVxdWVzdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJlcXVlc3QuaGVhZGVycyA9IGFzc2lnbih7fSwgSHR0cC5oZWFkZXJzLmNvbW1vbiwgIXJlcXVlc3QuY3Jvc3NPcmlnaW4gPyBIdHRwLmhlYWRlcnMuY3VzdG9tIDoge30sIEh0dHAuaGVhZGVyc1tyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpXSwgcmVxdWVzdC5oZWFkZXJzKTtcblxuICAgIG5leHQoKTtcbn1cblxuLyoqXG4gKiBUaW1lb3V0IEludGVyY2VwdG9yLlxuICovXG5cbmZ1bmN0aW9uIHRpbWVvdXQgKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHZhciB0aW1lb3V0O1xuXG4gICAgaWYgKHJlcXVlc3QudGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH0sIHJlcXVlc3QudGltZW91dCk7XG4gICAgfVxuXG4gICAgbmV4dChmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHhockNsaWVudCAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbmRXaXRoKCdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMsIC8vIElFOSBzdGF0dXMgYnVnXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHRyaW0oeGhyLnN0YXR1c1RleHQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHIuYWJvcnQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgIHhoci50aW1lb3V0ID0gMDtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhoci5vbmVycm9yID0gaGFuZGxlcjtcblxuICAgICAgICBpZiAocmVxdWVzdC5wcm9ncmVzcykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXihQT1NUfFBVVCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcmVxdWVzdC5wcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKHJlcXVlc3QuaGVhZGVycyB8fCB7fSwgZnVuY3Rpb24gKHZhbHVlLCBoZWFkZXIpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB4aHIuc2VuZChyZXF1ZXN0LmdldEJvZHkoKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhzdHIpIHtcblxuICAgIHZhciBoZWFkZXJzID0ge30sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpO1xuXG4gICAgZWFjaCh0cmltKHN0cikuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAocm93KSB7XG5cbiAgICAgICAgaSA9IHJvdy5pbmRleE9mKCc6Jyk7XG4gICAgICAgIG5hbWUgPSB0cmltKHJvdy5zbGljZSgwLCBpKSk7XG4gICAgICAgIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaSArIDEpKTtcblxuICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSkge1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyc1tuYW1lXSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG5mdW5jdGlvbiBDbGllbnQgKGNvbnRleHQpIHtcblxuICAgIHZhciByZXFIYW5kbGVycyA9IFtzZW5kUmVxdWVzdF0sXG4gICAgICAgIHJlc0hhbmRsZXJzID0gW10sXG4gICAgICAgIGhhbmRsZXI7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENsaWVudChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gcmVxSGFuZGxlcnMucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVxdWVzdCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBpbnRlcmNlcHRvciBvZiB0eXBlICcgKyB0eXBlb2YgaGFuZGxlciArICcsIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBuZXh0KHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXNwb25zZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXNIYW5kbGVycy51bnNoaWZ0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3BvbnNlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc0hhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gd2hlbihyZXNwb25zZSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChjb250ZXh0LCByZXNwb25zZSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hlbihyZXNwb25zZSwgcmVzb2x2ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBDbGllbnQudXNlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmVxSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn1cblxuZnVuY3Rpb24gc2VuZFJlcXVlc3QocmVxdWVzdCwgcmVzb2x2ZSkge1xuXG4gICAgdmFyIGNsaWVudCA9IHJlcXVlc3QuY2xpZW50IHx8IHhockNsaWVudDtcblxuICAgIHJlc29sdmUoY2xpZW50KHJlcXVlc3QpKTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbi8qKlxuICogSFRUUCBSZXNwb25zZS5cbiAqL1xuXG52YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keSwgX3JlZikge1xuICAgICAgICB2YXIgdXJsID0gX3JlZi51cmw7XG4gICAgICAgIHZhciBoZWFkZXJzID0gX3JlZi5oZWFkZXJzO1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZi5zdGF0dXM7XG4gICAgICAgIHZhciBzdGF0dXNUZXh0ID0gX3JlZi5zdGF0dXNUZXh0O1xuICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zZSk7XG5cblxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXMgfHwgMDtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCAnJztcbiAgICAgICAgdGhpcy5vayA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICAgIH1cblxuICAgIFJlc3BvbnNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICB9O1xuXG4gICAgUmVzcG9uc2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiBibG9iKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3RoaXMuYm9keV0pO1xuICAgIH07XG5cbiAgICBSZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNwb25zZTtcbn0oKTtcblxudmFyIFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3QpO1xuXG5cbiAgICAgICAgdGhpcy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG5cbiAgICAgICAgYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldFVybCA9IGZ1bmN0aW9uIGdldFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFVybCh0aGlzKTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZ2V0Qm9keSA9IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHk7XG4gICAgfTtcblxuICAgIFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbmRXaXRoID0gZnVuY3Rpb24gcmVzcG9uZFdpdGgoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdGhpcy5nZXRVcmwoKSB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXF1ZXN0O1xufSgpO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIHNlbmRpbmcgbmV0d29yayByZXF1ZXN0cy5cbiAqL1xuXG52YXIgQ1VTVE9NX0hFQURFUlMgPSB7ICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9O1xudmFyIENPTU1PTl9IRUFERVJTID0geyAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicgfTtcbnZhciBKU09OX0NPTlRFTlRfVFlQRSA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnIH07XG5cbmZ1bmN0aW9uIEh0dHAob3B0aW9ucykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICBjbGllbnQgPSBDbGllbnQoc2VsZi4kdm0pO1xuXG4gICAgZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgc2VsZi4kb3B0aW9ucywgSHR0cC5vcHRpb25zKTtcblxuICAgIEh0dHAuaW50ZXJjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgY2xpZW50LnVzZShoYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjbGllbnQobmV3IFJlcXVlc3Qob3B0aW9ucykpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gcmVzcG9uc2UgOiBQcm9taXNlJDEucmVqZWN0KHJlc3BvbnNlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZWplY3QocmVzcG9uc2UpO1xuICAgIH0pO1xufVxuXG5IdHRwLm9wdGlvbnMgPSB7fTtcblxuSHR0cC5oZWFkZXJzID0ge1xuICAgIHB1dDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcG9zdDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcGF0Y2g6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGRlbGV0ZTogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgY3VzdG9tOiBDVVNUT01fSEVBREVSUyxcbiAgICBjb21tb246IENPTU1PTl9IRUFERVJTXG59O1xuXG5IdHRwLmludGVyY2VwdG9ycyA9IFtiZWZvcmUsIHRpbWVvdXQsIG1ldGhvZCwgYm9keSwganNvbnAsIGhlYWRlciwgY29yc107XG5cblsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBIdHRwW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdXJsLCBtZXRob2Q6IG1ldGhvZCB9KSk7XG4gICAgfTtcbn0pO1xuXG5bJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBIdHRwW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zIHx8IHt9LCB7IHVybDogdXJsLCBtZXRob2Q6IG1ldGhvZCwgYm9keTogYm9keSB9KSk7XG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBSZXNvdXJjZSh1cmwsIHBhcmFtcywgYWN0aW9ucywgb3B0aW9ucykge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LFxuICAgICAgICByZXNvdXJjZSA9IHt9O1xuXG4gICAgYWN0aW9ucyA9IGFzc2lnbih7fSwgUmVzb3VyY2UuYWN0aW9ucywgYWN0aW9ucyk7XG5cbiAgICBlYWNoKGFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24sIG5hbWUpIHtcblxuICAgICAgICBhY3Rpb24gPSBtZXJnZSh7IHVybDogdXJsLCBwYXJhbXM6IHBhcmFtcyB8fCB7fSB9LCBvcHRpb25zLCBhY3Rpb24pO1xuXG4gICAgICAgIHJlc291cmNlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChzZWxmLiRodHRwIHx8IEh0dHApKG9wdHMoYWN0aW9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNvdXJjZTtcbn1cblxuZnVuY3Rpb24gb3B0cyhhY3Rpb24sIGFyZ3MpIHtcblxuICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCBhY3Rpb24pLFxuICAgICAgICBwYXJhbXMgPSB7fSxcbiAgICAgICAgYm9keTtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcblxuICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICBib2R5ID0gYXJnc1sxXTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuXG4gICAgICAgICAgICBpZiAoL14oUE9TVHxQVVR8UEFUQ0gpJC9pLnRlc3Qob3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHVwIHRvIDQgYXJndW1lbnRzIFtwYXJhbXMsIGJvZHldLCBnb3QgJyArIGFyZ3MubGVuZ3RoICsgJyBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgb3B0aW9ucy5wYXJhbXMgPSBhc3NpZ24oe30sIG9wdGlvbnMucGFyYW1zLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cblJlc291cmNlLmFjdGlvbnMgPSB7XG5cbiAgICBnZXQ6IHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgIHNhdmU6IHsgbWV0aG9kOiAnUE9TVCcgfSxcbiAgICBxdWVyeTogeyBtZXRob2Q6ICdHRVQnIH0sXG4gICAgdXBkYXRlOiB7IG1ldGhvZDogJ1BVVCcgfSxcbiAgICByZW1vdmU6IHsgbWV0aG9kOiAnREVMRVRFJyB9LFxuICAgIGRlbGV0ZTogeyBtZXRob2Q6ICdERUxFVEUnIH1cblxufTtcblxuZnVuY3Rpb24gcGx1Z2luKFZ1ZSkge1xuXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwoVnVlKTtcblxuICAgIFZ1ZS51cmwgPSBVcmw7XG4gICAgVnVlLmh0dHAgPSBIdHRwO1xuICAgIFZ1ZS5yZXNvdXJjZSA9IFJlc291cmNlO1xuICAgIFZ1ZS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVnVlLnByb3RvdHlwZSwge1xuXG4gICAgICAgICR1cmw6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS51cmwsIHRoaXMsIHRoaXMuJG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAkaHR0cDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMoVnVlLmh0dHAsIHRoaXMsIHRoaXMuJG9wdGlvbnMuaHR0cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJHJlc291cmNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVnVlLnJlc291cmNlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJHByb21pc2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVnVlLlByb21pc2UoZXhlY3V0b3IsIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICB3aW5kb3cuVnVlLnVzZShwbHVnaW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtcmVzb3VyY2UvMC45LjMvdnVlLXJlc291cmNlL2Rpc3QvdnVlLXJlc291cmNlLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJib251cy1iYXJcXFwiPjxkaXYgY2xhc3M9XFxcImJvbnVzLWl0ZW0gYmV0XFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLWJhY2sgZm9yemVuXFxcIj48ZGl2IGNsYXNzPVxcXCJpdGVtLXNob3dcXFwiPjxkaXYgY2xhc3M9XFxcImJldC1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwiYmV0TnVtXFxcIiB2LWh0bWw9XFxcImxvY2ttb25leVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtaXRlbSBjb3VudC1kb3duXFxcIj48ZGl2IGNsYXNzPVxcXCJjb3VudC1kb3duLWJhY2tcXFwiPjxkaXYgY2xhc3M9XFxcImNvdW50LWRvd24tc2hvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY291bnQtZG93bi1udW1cXFwiIHYtYmluZDpzdHlsZT1cXFwie2ZvbnRTaXplOjQwKnpvb21SYXRlLngrJ3B4J31cXFwiIHYtaHRtbD1cXFwiY291bnREb3duIHwgdGltZVxcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYm9udXMtaXRlbSBib251c1xcXCI+PGRpdiBjbGFzcz1cXFwiaXRlbS1iYWNrIGJhbGFuY2VcXFwiPjxkaXYgY2xhc3M9XFxcIml0ZW0tc2hvd1xcXCIgQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCI+PGRpdiBjbGFzcz1cXFwiYmV0LW51bVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJiZXROdW1cXFwiIHYtaHRtbD1cXFwidXNlcmluZm8ubW9uZXktbG9ja21vbmV5XFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRBbmRCb251cy52dWVcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9QbGF5UGFuZWwudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXFBsYXlQYW5lbC52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi01ZmViZDBiMC9QbGF5UGFuZWwudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUGxheVBhbmVsLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1BsYXlQYW5lbC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvUGxheVBhbmVsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi5wbGF5cGFuZWwge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nKSA1MCUgNTAlOyovXFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgaGVpZ2h0OiA1MCU7XFxufVxcblxcbmltZy5jaGlwIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LnRhYmxlLXBhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNTAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qZGlzcGxheTogbm9uZTsqL1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgLjMpO1xcbn1cXG5cXG5kaXYuc2luZ2xlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuZG91YmxlIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAyNTUsIDI1NSwgLjYpO1xcbiAgICBtYXJnaW46IDMlIDAlIDAlIDg2JTtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuYmlnIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDFlbTtcXG59XFxuXFxuZGl2LnNtYWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYubnVtIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XFxufVxcblxcbmRpdi5ib251ZG51bSB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlP2RmYzI0MDRhXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErTkE7SUFDQSxzREFBQTtJQUNBLHlCQUFBO0lBQ0EsNkJBQUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxXQUFBO0lBQ0EsWUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLG1CQUFBO0lBQ0Esa0JBQUE7SUFDQSxnQ0FBQTtDQUNBOztBQUVBO0lBQ0Esa0NBQUE7SUFDQSxnQ0FBQTtDQUNBOztBQUVBO0lBQ0Esa0NBQUE7SUFDQSxxQkFBQTtJQUNBLCtCQUFBO0NBQ0E7O0FBRUE7SUFDQSw2QkFBQTtDQUNBOztBQUVBO0lBQ0EsNEJBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0lBQ0Esa0NBQUE7Q0FDQTs7QUFFQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJQbGF5UGFuZWwudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g5Li75ri45oiP5Yy6XFxuICAgIGRpdi5wbGF5cGFuZWxcXG4gICAgICAgIGRpdi50YWJsZS1wYW5lbCh2LWVsOnBhbmVsLHYtYmluZDpzdHlsZT1cXFwie3dpZHRoOmltZ1NpemUud2lkdGgqem9vbVJhdGUueCsncHgnLGhlaWdodDppbWdTaXplLmhlaWdodCp6b29tUmF0ZS55KydweCd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnNpbmdsZSh2LWJpbmQ6c3R5bGU9XFxcInNpbmdsZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnc2luZ2xlJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzaW5nbGUnIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uZG91YmxlKHYtYmluZDpzdHlsZT1cXFwiZG91YmxlXFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KCdkb3VibGUnKVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ2RvdWJsZScgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS56ZXJvKHYtYmluZDpzdHlsZT1cXFwiemVyb1xcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgwKVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMCBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLm9uZSh2LWJpbmQ6c3R5bGU9XFxcIm9uZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgxKVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMSBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnR3byh2LWJpbmQ6c3R5bGU9XFxcInR3b1xcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgyKVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMiBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLnRocmVlKHYtYmluZDpzdHlsZT1cXFwidGhyZWVcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoMylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDMgaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5mb3VyKHYtYmluZDpzdHlsZT1cXFwiZm91clxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg0KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNCBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmZpdmUodi1iaW5kOnN0eWxlPVxcXCJmaXZlXFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDUpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA1IGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uc2l4KHYtYmluZDpzdHlsZT1cXFwic2l4XFxcIixAdG91Y2hlbmQ9XFxcImRvYmV0KDYpXFxcIilcXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA2IGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uc2V2ZW4odi1iaW5kOnN0eWxlPVxcXCJzZXZlblxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg3KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmVpZ2h0KHYtYmluZDpzdHlsZT1cXFwiZWlnaHRcXFwiLEB0b3VjaGVuZD1cXFwiZG9iZXQoOClcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDggaW4gJ2JldG51bSdcXFwiLHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIpXFxuICAgICAgICAgICAgZGl2Lm51bS5uaW5lKHYtYmluZDpzdHlsZT1cXFwibmluZVxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCg5KVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOSBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmJpZyh2LWJpbmQ6c3R5bGU9XFxcImJpZ1xcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnYmlnJylcXFwiKVxcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdiaWcnIGluICdiZXRudW0nXFxcIix2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIix2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiKVxcbiAgICAgICAgICAgIGRpdi5udW0uc21hbGwodi1iaW5kOnN0eWxlPVxcXCJzbWFsbFxcXCIsQHRvdWNoZW5kPVxcXCJkb2JldCgnc21hbGwnKVxcXCIpXFxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ3NtYWxsJyBpbiAnYmV0bnVtJ1xcXCIsdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIilcXG4gICAgICAgICAgICBkaXYubnVtLmZvcm11bGEodi1iaW5kOnN0eWxlPVxcXCJmb3JtdWxhXFxcIix2LWh0bWw9XFxcImJvbnVzTnVtXFxcIikgXFxuICAgICAgICAgICAgZGl2Lm51bS5ib251ZG51bSh2LWJpbmQ6c3R5bGU9XFxcImJvbnVkbnVtXFxcIilcXG4gICAgICAgICAgICAgICAgdGFibGVcXG4gICAgICAgICAgICAgICAgICAgIHRyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGQodi1odG1sPVxcXCJ1c2VyQmV0LmJldG51bVxcXCIpXFxuICAgICAgICBpbWcodi1iaW5kOnNyYz1cXFwidGFibGVQYW5lbEltZ1xcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7d2lkdGg6aW1nU2l6ZS53aWR0aCp6b29tUmF0ZS54KydweCcsaGVpZ2h0OmltZ1NpemUuaGVpZ2h0Knpvb21SYXRlLnkrJ3B4J31cXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJywgJ2JldHMnLCAndXNlckJldCcsICdjb3VudERvd24nLCAnY291bnROdW0nLCAnbG9ja21vbmV5JywgJ2xvdHRlcnludW0nXSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdGFibGVQYW5lbEltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZycpLFxcbiAgICAgICAgICAgIGNoaXBJbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iLzVY562556CBLeaLt+i0nS5wbmcnKSxcXG4gICAgICAgICAgICBpbWdTaXplOiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NDAsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTI4XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgICAgLy8gVE9ETyDph43mlrDorr7lrprkuK3lpZbop4TliJlcXG4gICAgICAgIGJvbnVzTnVtKCkge1xcbiAgICAgICAgICAgIHZhciBudW1zID0gdGhpcy5sb3R0ZXJ5bnVtLmxvdHRlcnludW1zLnNwbGl0KCcsJylcXG4gICAgICAgICAgICB2YXIgc3VtID0gcGFyc2VJbnQobnVtc1swXSkgKyBwYXJzZUludChudW1zW251bXMubGVuZ3RoIC0gMV0pXFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bXNbMF0pICsgJysnICsgcGFyc2VJbnQobnVtc1tudW1zLmxlbmd0aCAtIDFdKSArICc9JyArIChNYXRoLmZsb29yKHN1bSAvIDEwKSA/IE1hdGguZmxvb3Ioc3VtIC8gMTApIDogJycpICsgJygnICsgc3VtICUgMTAgKyAnKSdcXG4gICAgICAgIH0sXFxuICAgICAgICBzaW5nbGUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBkb3VibGUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA1NDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHplcm8oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAxNzQgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAwKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgb25lKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMSkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHR3bygpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB0aHJlZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDMpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBmb3VyKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogNCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGZpdmUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDApICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBzaXgoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBzZXZlbigpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMikgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGVpZ2h0KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbmluZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogNCkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGJpZygpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA0MjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBzbWFsbCgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA0MjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA1NDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGZvcm11bGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIxMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNDIgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBUT0RPIOmBjeWOhuS4iuacn+S4i+azqOiusOW9le+8jOiuoeeul+etm+mAieaYr+WQpuacieS4reWlluWPt+eggVxcbiAgICAgICAgYm9udWRudW0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDY4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2OCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyOTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBiZXQoZXZlbnQpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGVpZ2h0JyArIGV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQpXFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dpZHRoJyArIGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aClcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudClcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyDnlKjmiLfkuIvms6hcXG4gICAgICAgIGRvYmV0KG51bSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJpbmZvLm1vbmV5IC0gdGhpcy51c2VyQmV0LmJldG1vbmV5IC0gdGhpcy5sb2NrbW9uZXkgPCAwKSByZXR1cm5cXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudERvd24gPCAxMCkgcmV0dXJuIC8vIOWAkuiuoeaXtuWwj+S6jjEw56eS5pe256aB5q2i5LiL5rOoXFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW0pID09PSAnW29iamVjdCBOdW1iZXJdJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdOVU1CRVInXFxuICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW0pID09PSAnW29iamVjdCBTdHJpbmddJykge1xcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdTSU5HTEVfT1JfRE9VQkxFJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdTSU5HTEVfT1JfRE9VQkxFJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlnJzpcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdCSUdfT1JfU01BTEwnXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRudW0gPSBudW1cXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuYmV0cy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudXNlckJldCkpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGV2ZW50czoge1xcbiAgICAgICAgY2FuY2VsQmV0KGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5iZXRzID0gW11cXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLnBsYXlwYW5lbCB7XFxuICAgIC8qYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmcpIDUwJSA1MCU7Ki9cXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBoZWlnaHQ6IDUwJTtcXG59XFxuXFxuaW1nLmNoaXAge1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBoZWlnaHQ6IDUwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG5kaXYudGFibGUtcGFuZWwge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiA1MCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgLypkaXNwbGF5OiBub25lOyovXFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAuMyk7XFxufVxcblxcbmRpdi5zaW5nbGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5kb3VibGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XFxuICAgIG1hcmdpbjogMyUgMCUgMCUgODYlO1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5iaWcge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMWVtO1xcbn1cXG5cXG5kaXYuc21hbGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxZW07XFxufVxcblxcbmRpdi5udW0ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcXG59XFxuXFxuZGl2LmJvbnVkbnVtIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aYvuekui3nuqIucG5nKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9QbGF5UGFuZWwudnVlXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUVnQUFBQkpDQVlBQUFDZXNXRGlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEZSVUU1UlRrNE56TkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRlJVRTVSVGs0T0ROR05VUXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tWRlFUbEZPVGcxTTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1ZGUVRsRk9UZzJNMFkxUkRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtVdjJISUFBQUJEeEpSRUZVZU5yc25MR09GREVNaHVQTTZCREZGYlJYOHdSMHh5dndLRHdQajhKclVDTkVUVWQxQlRwcEp5R1p0WFAvZURQTDVJVEFJRWZLSnV6TUxjbVgzNDUzRlE5OStKeERLZXVMbDIxNWYvK1dZbm01Y1JTNzVTYVdsMXZuc0Z0dUs2QVh6bUczdkpoNzcvNTQ5enBNUkd1ZFM0M2NqOUNuY2wva2xyaTFWS3BUelRtdmJlSjJLVzNpS3YwVDkydDkrZkhyeGVkMEFRbVlLY1krSklIRGZZRmtDbENGVXNhVXVGOWgxREVMbk1od3lzVkFLZTEremk2Z0NtZG1LRmdSRktvbkdnTWtxbW1nUkRXOG9BdmZ0NDY2ekRYdlFPb0NRakJ6VDBVTVptSW8wYUtKTVpReTBMTmllSnlpSHVJYUNwZzF4aW5YOGxGQVVVd00vQkNxQnhXRWNLeVlXVlVOUWtMVGFxb0JrTkl1SXlZV0ZaeWVpVVZsWG1SSVBXSm1Bb2ZBcEJaMWIrWTVMeU1LbWpvN2wvZ21rV3NFY3lOTGdMaldzWW5QRVgrNXNLK1JleVlHbEhiVXZ3c29ka3hLNENDNENLWmxBVktHNzAwWjRaeHRyem5rU1p3NTdNcER1MWhVN1VXL1kySldkckxFdmlacFFBeEpOcGZNL1FUdkhRSkVvQ0pDdGZTcUNoUXRLRWpNaGhpU1ZwZFV3cGd1NXpFVGswbGoxTnlEWXpHYXh2Z244RmF2QVNWUWo0aGdURUhnVzVvcHlmdlMxMXU5QVVpck1pQTRqQXhKbkhabVZVbE10TUtCWGU0WUlOaVZOaERBNU1qbzl6R1NiUjYzZUZaN2hzVVZlTVJ3YUZSQkJFNDRkUHdMUWlGRHdXSVdOVEFrVXY2Rk9yNldydmlnZUdoVlFGRVhnYUd4U0pwMnhoYlZISTZPZFg2T2hMdXRrV2hhZGlkUmtwaFZmdWJZWXZEaWdCeVFBM0pBRHNnQk9TQUg1TVVCT1NBSDVJQWNrQU55UUE3SWl3TnlRQTdJQVRrZ0IrU0FISkFEY2dRT3lBRTVJQWZrZ1A3Wk1udytLSGZhOWZ3Tm4rYXlrTnZaVWhGMnh2emJGU1I1VjNoQ3RQMkhmQTBIWmdZT2pDMnBPUndkNjd5bkVzbXh5bkJVTFhmdXdhTzJaQVVTTGlwQTZzMWhuYU82NTllQWVPTHRBK1JJYlhnNlJpdW5TVGRIYlkwY0F3NHEwN0F0TnRla3IxOVoyRjBGU2FaZXdKU2k4SFFJTXZGQThLZ3RYVm1KdjZXZ3hFbDBNcWVrM1FSY1B3eW8wWllFTkVncDJ1UTlkSTdhbWxBUXVnbUJwS3Jrc0tMQ3hoUWtlWjdjM3h5aFZmZUtwNDlHZHJHV3pJSXE2a0ZTd0E0REV0VmdleFlNTytTd3pjbkNuY0pVT3BSU2tPU3NMcW92N1pDSkpmV0hhNlplVFVhTHNUbkJIRG81V1ZaOFVNL0VlQTRKVXNGUlVVT0FGbGFESkhwSXV1S2FqTWFtMUJKRHhDVVpBdFF6c1VXMUd0U1lpZFUvREdHVHc3RG1ZaWsvSlE2OG1hQ3hTQm9oTFFyU1NmMTdTRUVubWJRQ0ZPQnJ4UVIrcXFVOEdsS1JMTndpRGptRTdoTVhUcU1LYWs4a1dHbWxjOURJUUJLa1oyTDhZL3JCQXFBZ1ZOS2lJRTBqSmtic2tMTnlmSnRjSzBoR00vbG9DZ2g0RXpqc0N4V1Z1UzZqZ01RaEI2V2U5bkFUTUsxcitWWldvdWtqRHpjNWJHTDRGSlRNTzlqeW4vN2VNOEhHNHorWStTK0tEdWlQRndxdjd1OUsrNmJVTzhleEtkOUsvVlNkOUdPcDM1M0hSYWxNSGl1Z2gxSy9CSC9ZbXk1Vk9BOC9CUmdBM1YyTXRsV25SK3NBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mmL7npLot57qiLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDkuLvmuLjmiI/ljLpcbiAgICBkaXYucGxheXBhbmVsXG4gICAgICAgIGRpdi50YWJsZS1wYW5lbCh2LWVsOnBhbmVsLHYtYmluZDpzdHlsZT1cInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5zaW5nbGUodi1iaW5kOnN0eWxlPVwic2luZ2xlXCIsQHRvdWNoZW5kPVwiZG9iZXQoJ3NpbmdsZScpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ3NpbmdsZScgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uZG91YmxlKHYtYmluZDpzdHlsZT1cImRvdWJsZVwiLEB0b3VjaGVuZD1cImRvYmV0KCdkb3VibGUnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdkb3VibGUnIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnplcm8odi1iaW5kOnN0eWxlPVwiemVyb1wiLEB0b3VjaGVuZD1cImRvYmV0KDApXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMCBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5vbmUodi1iaW5kOnN0eWxlPVwib25lXCIsQHRvdWNoZW5kPVwiZG9iZXQoMSlcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSAxIGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnR3byh2LWJpbmQ6c3R5bGU9XCJ0d29cIixAdG91Y2hlbmQ9XCJkb2JldCgyKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDIgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0udGhyZWUodi1iaW5kOnN0eWxlPVwidGhyZWVcIixAdG91Y2hlbmQ9XCJkb2JldCgzKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDMgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uZm91cih2LWJpbmQ6c3R5bGU9XCJmb3VyXCIsQHRvdWNoZW5kPVwiZG9iZXQoNClcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA0IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmZpdmUodi1iaW5kOnN0eWxlPVwiZml2ZVwiLEB0b3VjaGVuZD1cImRvYmV0KDUpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNSBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5zaXgodi1iaW5kOnN0eWxlPVwic2l4XCIsQHRvdWNoZW5kPVwiZG9iZXQoNilcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA2IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLnNldmVuKHYtYmluZDpzdHlsZT1cInNldmVuXCIsQHRvdWNoZW5kPVwiZG9iZXQoNylcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA3IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLmVpZ2h0KHYtYmluZDpzdHlsZT1cImVpZ2h0XCIsQHRvdWNoZW5kPVwiZG9iZXQoOClcIilcbiAgICAgICAgICAgICAgICBpbWcuY2hpcCh2LWZvcj1cIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA4IGluICdiZXRudW0nXCIsdi1iaW5kOnNyYz1cImNoaXBJbWdcIix2LWJpbmQ6c3R5bGU9XCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XCIpXG4gICAgICAgICAgICBkaXYubnVtLm5pbmUodi1iaW5kOnN0eWxlPVwibmluZVwiLEB0b3VjaGVuZD1cImRvYmV0KDkpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOSBpbiAnYmV0bnVtJ1wiLHYtYmluZDpzcmM9XCJjaGlwSW1nXCIsdi1iaW5kOnN0eWxlPVwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVwiKVxuICAgICAgICAgICAgZGl2Lm51bS5iaWcodi1iaW5kOnN0eWxlPVwiYmlnXCIsQHRvdWNoZW5kPVwiZG9iZXQoJ2JpZycpXCIpXG4gICAgICAgICAgICAgICAgaW1nLmNoaXAodi1mb3I9XCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ2JpZycgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uc21hbGwodi1iaW5kOnN0eWxlPVwic21hbGxcIixAdG91Y2hlbmQ9XCJkb2JldCgnc21hbGwnKVwiKVxuICAgICAgICAgICAgICAgIGltZy5jaGlwKHYtZm9yPVwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzbWFsbCcgaW4gJ2JldG51bSdcIix2LWJpbmQ6c3JjPVwiY2hpcEltZ1wiLHYtYmluZDpzdHlsZT1cInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cIilcbiAgICAgICAgICAgIGRpdi5udW0uZm9ybXVsYSh2LWJpbmQ6c3R5bGU9XCJmb3JtdWxhXCIsdi1odG1sPVwiYm9udXNOdW1cIikgXG4gICAgICAgICAgICBkaXYubnVtLmJvbnVkbnVtKHYtYmluZDpzdHlsZT1cImJvbnVkbnVtXCIpXG4gICAgICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgdHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkKHYtaHRtbD1cInVzZXJCZXQuYmV0bnVtXCIpXG4gICAgICAgIGltZyh2LWJpbmQ6c3JjPVwidGFibGVQYW5lbEltZ1wiLHYtYmluZDpzdHlsZT1cInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nLCAnYmV0cycsICd1c2VyQmV0JywgJ2NvdW50RG93bicsICdjb3VudE51bScsICdsb2NrbW9uZXknLCAnbG90dGVyeW51bSddLFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJsZVBhbmVsSW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/kuLvmk43kvZwucG5nJyksXG4gICAgICAgICAgICBjaGlwSW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nJyksXG4gICAgICAgICAgICBpbWdTaXplOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUyOFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICAvLyBUT0RPIOmHjeaWsOiuvuWumuS4reWlluinhOWImVxuICAgICAgICBib251c051bSgpIHtcbiAgICAgICAgICAgIHZhciBudW1zID0gdGhpcy5sb3R0ZXJ5bnVtLmxvdHRlcnludW1zLnNwbGl0KCcsJylcbiAgICAgICAgICAgIHZhciBzdW0gPSBwYXJzZUludChudW1zWzBdKSArIHBhcnNlSW50KG51bXNbbnVtcy5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1zWzBdKSArICcrJyArIHBhcnNlSW50KG51bXNbbnVtcy5sZW5ndGggLSAxXSkgKyAnPScgKyAoTWF0aC5mbG9vcihzdW0gLyAxMCkgPyBNYXRoLmZsb29yKHN1bSAvIDEwKSA6ICcnKSArICcoJyArIHN1bSAlIDEwICsgJyknXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDgzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDgzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA1NDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHplcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDApICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDEpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0d28oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aHJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTc0ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMykgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZvdXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE3NCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXZlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDApICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICgxNzQgKyAxMjApICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgKDE4ICsgMTIwICogMSkgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoMTc0ICsgMTIwKSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgxOCArIDEyMCAqIDIpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiAzKSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbmluZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEyMCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogKDE3NCArIDEyMCkgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAoMTggKyAxMjAgKiA0KSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmlnKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogODMgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogODMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogNDI1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgOCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc21hbGwoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA0MjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA1NDggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm11bGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAyMTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiA4MyAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjIwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPIOmBjeWOhuS4iuacn+S4i+azqOiusOW9le+8jOiuoeeul+etm+mAieaYr+WQpuacieS4reWlluWPt+eggVxuICAgICAgICBib251ZG51bSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDY4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiA0MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2OCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBiZXQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIZWlnaHQnICsgZXZlbnQudGFyZ2V0Lm9mZnNldEhlaWdodClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXaWR0aCcgKyBldmVudC50YXJnZXQub2Zmc2V0V2lkdGgpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgLy8g55So5oi35LiL5rOoXG4gICAgICAgIGRvYmV0KG51bSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlcmluZm8ubW9uZXkgLSB0aGlzLnVzZXJCZXQuYmV0bW9uZXkgLSB0aGlzLmxvY2ttb25leSA8IDApIHJldHVyblxuICAgICAgICAgICAgaWYgKHRoaXMuY291bnREb3duIDwgMTApIHJldHVybiAvLyDlgJLorqHml7blsI/kuo4xMOenkuaXtuemgeatouS4i+azqFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW0pID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ05VTUJFUidcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChudW0pID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQudHlwZSA9ICdTSU5HTEVfT1JfRE9VQkxFJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckJldC50eXBlID0gJ1NJTkdMRV9PUl9ET1VCTEUnXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJCZXQuYmV0bnVtID0gbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiaWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LnR5cGUgPSAnQklHX09SX1NNQUxMJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG51bSA9IG51bVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iZXRzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgdGhpcy51c2VyQmV0KSlcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIGNhbmNlbEJldChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5iZXRzID0gW11cbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuLnBsYXlwYW5lbCB7XG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5Li75pON5L2cLnBuZykgNTAlIDUwJTsqL1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGhlaWdodDogNTAlO1xufVxuXG5pbWcuY2hpcCB7XG4gICAgd2lkdGg6IDUwJTtcbiAgICBoZWlnaHQ6IDUwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG5cbmRpdi50YWJsZS1wYW5lbCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA1MCU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIC8qZGlzcGxheTogbm9uZTsqL1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAuMyk7XG59XG5cbmRpdi5zaW5nbGUge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMWVtO1xufVxuXG5kaXYuZG91YmxlIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAuNik7XG4gICAgbWFyZ2luOiAzJSAwJSAwJSA4NiU7XG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMWVtO1xufVxuXG5kaXYuYmlnIHtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMWVtO1xufVxuXG5kaXYuc21hbGwge1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDFlbTtcbn1cblxuZGl2Lm51bSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIC42KTtcbn1cblxuZGl2LmJvbnVkbnVtIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pi+56S6Lee6oi5wbmcpIDUwJSA1MCU7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogUGxheVBhbmVsLnZ1ZT9kZmMyNDA0YVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQW9BQUFBSVFDQVlBQUFBUnE5OWdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEZSVUU1UlRrNE16TkdOVVF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRlJVRTVSVGs0TkROR05VUXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tWRlFUbEZPVGd4TTBZMVJERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1ZGUVRsRk9UZ3lNMFkxUkRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt2Y2xoSlFBQVhTTkpSRUZVZU5yczNYbVVIT1Y5Ny8rbmVoWnB0STUyTkVLSTBVaENFZ0lFd2tKZ3pDSWpnc0VtQVhPSWJjRFlOK2NlSEFkd0VvN2pEZnNQWDhkSjdLUGNYd0FuNXBkalk0TEJ1VnhzeDJBd05tWVRBZ25GWXdraEpMUnJ0SXpRT2pQU2pHYnQ3dHZmcDZwNnVudDZxZXExdXVyOTRqU2oyWHVxYS9uVXMzd2ZRMDI2dkVZcEZWSW1Rd0VBQU1DUG90YmJpQkVMZ0dOaS82aTFRaUFCRUFBQXdMOEJNQko3REVrQW5CYjdSNzBWQW12WU5nQUFBTDRVbHZBWGV3eElBR3lKL1VOYUFVY1JBQUVBQUh3ZEFQdGpqek8xVnZpYkVIczBLTE1WRUFBQUFQNGpyWCs5eWdwOG82endKMEd3am0wREFBRGdTNFBXMjM1NzNGK3RGZjdxMlRZQUFBQytwYk9mOFlQM28xRzJCUUFBUUxCU29Qcko3OTVtU3dBQUFBVEE1NjYvTEY0QUdnQUFBQUZCQUFRQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNpUjJteWZ2UE9LODloQ3hVemJOVFZzQkFBQU1vaUU2dGdJUmZUVDE5L0pMd0NLNy95ZlY5aUNSZkt0ejZ4U3E1Ly9BeHNDQUlBMC91WVRsNnZ2dnJLSERWRUVYMTg1Tit2bjZRSUdBQUFJR0FJZ0FBQUFBUkFBQUFBRVFBQUFBQkFBQVFBQVFBQUVBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUlBQUNBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FHWXpaMXk5dW0vNU9hNi81OG5QTEZNUFh0MmkvdzBBQUFDbGFyMytCRythTzFsOVprV3p1bUpoa3hvN3VrNDl1L1VEMWRZOTRPaDc3NzJ5UmExYU9rYy83ci9wSXJYKy9jTnF3KzZqNnFYM2o2aTNqM1R6NmdNQWdLSzRZKzQ0TldsMGpabzlzUzdwNHdlNkJ0VWpXN3NJZ0U1SnE5M0tKYlBVa2psVFI0UzZMNys0TGVmM1M0dmZiVmZNUy9yWWlvVXo5ZVArbTVUNnhPcmZFUUlCQUVEY2pVME5Pc1RaZG5ZT3FBMG5CekorN2RWenhxcGxzOGVxSlUxanMvN2NleTZmcnI3eW00UHFoZlplQW1BMjB1b25MWFpwTi9peU9ZNENvQVJGYVRGTTUvRlh0aEgrQUFBSXNPV1Q2OVdxYzhlcUQ4MGVwMXFtamxiVHhxZlBESHVQOTZsSDNqcXFudHhqNW9aN0YwOVVkMXd5UlRYSHZzY3ArZGsvdnIxWi9ZK245M29tQkhweURPRHplMDZxdlVmU041ZE9temhHdHc1bWM5bU1jU05hLzJ3OWZZUHFrYlc3MmZNQkFBaWdiMXd5U2YzKzlqbnEyYy9PVS9kZE5WT3RhQjZmTWZ3SkNYcXJiejVIZjUrUUxsNDM0Uy9SUDMzc2JNOXNCODlPQW5udUQvc3lmdTR2UHJvNDY2U08rejk2WHNiV3Z4Kzl2Tlh4R0VJQUFPQWZjeHBxMVA5WU1UMW5sMjA2RWhhbDFmRG4yMC9sL2ZzbGFOcEJrZ0NZd1JPdEIzUnJYVG9TN3I2MmFtSGF6MG5ybjB6NlNPZFkxeG4xbmRkcC9RTUFJSWphZXNOcTNaN1RlWC8vL2N1bjZqR0JXOXA3OHY0WjE4NmJRQURNK2lKMUQ2aG4zdG8xNHVNU0NtVU0zeis4OUg1eXFoOVhyKzVhY3BaYU1HMmMvcnpNK0pYQWwraG5hM2V5OXdNQUVHQy8yWkYvQzk3bGM4ZnJ0Ni91eXY5bjVOdDlYR3llTGdNamt6MnVPcjlKTmMrWXFOL2YwblpjN1dqdlZFMlR4NmpIN2w2aFA1NnBxemVkUmJNYTlmaEJ5c0FBQUJCTU1wbmpxNmNIczQ3N3kyUnN2VGxEK0tmYlR1bXVaUHY5WTdHZnQzYjNLYlYyZjQ5YWU3aFh0elR1L3VKNThjK24reGtFUUl2TS9KMDhwbDZ0MlhjeVBrWlBDajhmNlRnVEQ0QlNFaWExTEl3Ynd6VUJ6VEQ1Mk9zNzFCTmJQdUJvQUFBZ1FDU3MzYkowU3Z6OW5nR3phL2hRMTREYWZLUlBYWG5PMktUUHA3SzdraSthTlZiOTU4Ymo2dS8vMkRIaWEyVDJjRDVqRFFNWEFCLzQySko0dUpNWndIYm9LeFg1WGFzL08xVjllTjB1OVlWZmJ1Wm9BQUFnSUI3YjNLRURuclRjcFF0d0Y4N0kzVTM3MEliamFzUEo5b3lmbnpFKy9XVFZRc1lQK2k0QXlzU054SmE5VW9lL1JMZGVQaytOYjZoVGR6elZ5aEVCQUVBQXlFU09oOWNjVHR0eUo4NmIzcEF6dkdVcUVDMWt0bkNtTHVidS9vZ250b0VuSm9GOC9vcTVGZjM5MGkzOC9Sc1djVVFBQUJBUW1jS2ZoRGVwRFpqT3pxTjl6bkxOaFpsTHZXdy82bzFDMEo1b0Fmekk0cWFpL0p5WE5yV3A5cFBKTTMrWHRVelRFMFZ5dFNwSzRXZ25LNHdBQUFELyt1UjVtY3Uwdk9jZ0FFcXR3ZXNYTjJiOGZDRjFCSDBWQUdYeWg2enVrWTJVYzltMDk1amFkcWhUZmVMU2N6T0dPZm44eURwL1pxaVRidWFIN3J3czQvZEtTSlJKSnc5djJNL2VEd0JBQUVsNHUrM2k5Sk0vWktMSUkxdTdjdjZNT3hkTnlEalRWOFljWnVzNkRsUUF2R2JCakl5Zmt4YTlwOWJ2MVV2RDJhU1VTNllRTjdFaDgrb2dVdmJsL3ArK3JaNTc0UHFNWDNQTzVMSHMvUUFBQkNEb0Nabk5tK2lMU3lkbERHKy8yOXJwNk9kS2VaaE1YdGphNFpsdFVQRUFLRjIwbWRobFcrTHB1MjlRbmVrZnpQcXp2bitEVWwyOUE2cnRSSS9hY2F3N3FkNmYvRnRDWmFhVlFzNXJhdVNvQUFEQTU2U1ZUb0xhajljZmpZOEZsTEYvZDErV09iekp6T0Zjc2dWSWFVSDgxMDBFd0RnM00zNmxtelpiNGVmVU9vSC82NWsvakNqNG5EcEdNTkc0aGpxT0NnQUFmTzVEczhmcG9DYnIrMzdxNHFtNkZFeTJKZHArLzM1bnpxN2JYQUh5bVkwblJyUTRCam9BdWxuSnc2M09NeU5mck0wSE85anpBUUFJc01SWnZsS3VSWUpnSnRKeUp6WC9iUGN1bnFpdW16OUIvZmVCYnIwaWlCM3EvdVhHczdQK0RDKzEvbFU4QU1yYXZRQUFBT1VpQWM2TmR3K2RTV3I5VzNIT1dCMGc1U0hCY2YzZTA2cTdQNXgxalYrdnRmNVZQQURtSWl1Q3JIbXZmY1E0UWFmTHdhVmI1dTNDc3lleDl3TUFFRkFTNEZ4OWZTem9mZkRYaTNYUSs3TmZIZERMdjZWK1BodVorZnVWZGNjOXR4MHFHZ0Fsb0szTzhua1pIeWdCY09VUDFpUjkvT2ozYnMzNFBZKy9zazN0UDltVGRrYXZGSHVXZW4rWmRQY09jbVFBQU9CanFRSE9LU25nZkdOVFE4WVZQckw1dDJ0bXFGUDlZYjNPY0VkZldMM1FYdmxpMEJWdkFaUWFmOW5xQU42OTBneHQwaHJZdXZ1WS9wak1CczQyZGxERy9zbmp3YXRiZEdtWXBzbGoxTkxtYVRuckRXNXY3K1RJQUFEQXgvN3gxY1BxcTlmT2RCM2tEblFOcXF2bnVBK1A4bnRrM2VGVUR6eTdYejI1cHp1NEFmQ0YxallkOHJLUnNKYzZ3emRiWU15SGhNcEgxdTdteUFBQXdNY2tkSFgwSFZRL3ZyM1oxZmR0K0tCWDNYSEpsS0krajBxcStGckFzdnlhdE81VjJqLy8raDNWMWozQWtRRUFnSTlKc2VadnJwenA2bnZzRlR6VzdENmwvMTJvTGUwOUZkOE9JUys4R0xjLytvYmEwbGE1QVpJUFBmOE9TOEFCQUJBQVAvckUyVmxuN080OVBuSzkzOTNXeDJReXg4ZWYycVBMdWhSaXA0TTFoVXZORTdPQXBlVk5KbnJJbUwxUFh6ay81MWk5WXBIUXVmbzNXNUtXbWdNQUFQN1ZlcUJITFdsS1A1YlBudWtyN3BnN1RsMDRZN1NhTUtwR0hUdzEzRVA0TDljM1pWenR3Nm5Fbnhmb0FHajd6dXU3OVVQcUEzNTQvblMxb0tuUmNja1hKMlNjbnoyWjVKbU5CMGFzRWdJQUFQeE5XdkZtVGF4WDF5MU1YdjVWV3Y2KzlMdjIrUHN5Umk5MW5ONVBiMmpLV3ZaRldnYS85ZUloSFJ6UG05NmdXcWFPVGp2WlpPTUh0QUNtSmVWaEVtdjRYVFpqbkZvd2Jaeis5NXdwWS9YTTNteVRQYVFVakxEWEJCWnI5cDFrakI4QUFGQjN2dGl1L210VVRUek1TWEQ3WDY4Y3pscXNXVm9FVTBOaktnbC82WUtqZk8razBUVnE5a1F6REZJR3hpRnBxZnVnWjBCZGRlNWtLOUJsSHp5WldqaGE2Z21tS3hzalFWRW1vUUFBZ0dDUjFyNy8vT1FjTlgxQ25icnZ2L2JuREdVUzZ1NDkzcGR4L09EamJ4L05PTE8zMGpOK1BSOEFwVkN6T0srcFVZMXJxTk9oVGNLYlc4WHNOZ1lBQVA0anJYMmYrbm1iK2tUek9NY3RjdkwxRWhwVFErRHYzKy8wNUdvZlZSTUFwZVd1bk9GTkNrUURBT0FyMFdqQzIyanNqZm5XTUdxVUNvWFlQaWtoOEpHdFhhNisva3N2SEZRLysxUnpmQ0tJakIyVUx1VnFFK2c5WWVha3NlejlBSURxRndtclNGKzNDdmQwcXNpWlU3RkhsNHIweHQ3Mm5sYlIyTWVqZlQwcUdoN1FRUkNGa1hxQTBtVXM0d1lsL0VtcllEWHlWQXZnNFk0ZXVtOEJBSEFwS3NFdUdsV0c5Wjc4dzdEZUd3NkpFYk5WMEREWVlBV1NMdU5KTHg1U2F3LzNacDA0UWdCMHFQM2ttYUw4SEZsZldKYVl5MmJ6d1E1MThneXpnZ0VBMWM4d1FzcW9xVldKbWM5SUNvaVMvY0lxR2duSHZvNXU0R0x3NHNTT3FnMkF3bDRScEx0M1VHMXY3OVQvVGl6bklxRk5DamZmdC93YzljM2JMazM3TTQ1MG5tRjJMd0FnU0FsUXFWZ0FOS0tSV1BETDBNMGJpYWhvZUVpcFVDMnRnUEJXQURSRG03UGcxaGtMZ25aWTNCRUxpcWRqZ2RFT2lqdU9VZUFaQUJDb0JPZ2dJeHE2QlREMnY5ZzdOV3d5QW1CMVNpMFdEUUFBTXNmRGFDd0FHcEdvYmdXVUxtTmFBWU9OZ1FBQUFBUXBDVWFHRkxPQlFRQUVBTUEzNlM1enREUHNyNGpJWkpBSW00c0FDQUFBL0pEL2NyYnJHVlp4R0drRmpOSUtTQUFFQUFEVm53QWRUZ1pSNFNGZEZnWUVRQUFBNEljTW1PdlQwZ29vTTRIcEJpWUFBZ0FBbjZlL3BDODE5RmhBWFJJR0JFQUFBRkRGK2M4SU9mc3krWWQwQTBmb0JpWUFBZ0NBS2c2QXNVdDZUWjNEcnpYTUZVTUlnQVJBQUFEZ2l5VG9NQU5hM2NDRVFBSWdBQUFJU0VUVUFkQmFIeGdFUUFBQUVLQWdLQk5CcUFsSUFBUUFBTlViNmFMbTZENW5YNjBYQ1k0U0FBbUFBQUNnaXZPZjQyb3dpVFVCb3hHNmdRbUFBQUNneWxPZ0M5TDZKK01BUFZJVHNDWms4QklTQVAxalZGMHRHd0VBNEwyNHFMdUJJNTRJZ09GWUdHMGN6ZldTQU9nakU4ZU5VWU5ocHRvREFEd1UvcXdFS0tNRzlXemdDbzhGN0Rvem9GcW1qT0dGSVFENlIwdlRGSFdxZDZDNi93ZzlVTmhhUDVLNlVRRGd6VWhuNUhscDk4RFNjSHVQblZJWE5ZMDNXeVZSVXJTemx1TndqTzNKRnpjM3FiYllqdTM1akRjMEdEc0pERmw1ejc0VGpDcHpTbGwwT0FqSzMxVmJGN3VGcUluOWZTSDlGZ0JROFF1T1VqV3g4M0hVZVpnejR2ZjRFYjAwbkZIQjgvbVcvUitvUzg2ZHFpNlpOVUcxSGp6RjYwa0FyRzdMejV1anBveHZVTTl2MnV2ZEp5bkZRSWY2elFEbzhLUVJIWXpvazAzVWlJVkFPZUZJRUl3OWpCcDJLd0NvWUFvMGc2Q2IzbHc5R3pocXJnMHNOL2tWYW9JNzJkV3QzdGwvUWwwM2Y0bzZjV1pRN1R2Wnk4dFpJblFCbDFoTDAxUjEzZEo1c1IzNm1EcCsyb003c3R6eERRMm95RUN2ZnFzclNFbUlDNFZVS09PalJyODFyQk9HQ2cvR3dtQXNQTXJQc0IreGp3RUFLblJxajdyTGYxWnMxTjNBMFFvUDhWbno3bTUxc0tOSC9mbEZaNmxMejU1QWQzQ0owRlJUcXZ1djJCNTc2WUp6MUtwWStEdlVjVnE5dHZXQTU4NE9VdmRKdC9oSldJdTliOWloVHQ4OTVqNVY2THRGKzY0eGZzYUo2RENvNU9mV0RzVWU5Ulh0VGdDQUFGNkI4dm9PZlQ2M2w0YXJZRTlPT1BZY2ZyWHVQZldSQzFyVXFnVlRkSGZ3eHZiVGFzK0pNNnFqZDBoRktGcE5BUFNhdXJwYU5XbmNHRDNoUThiOFNiZnZ1d2VPcTFkajRTOGM4Y2dPSzJGTnVuaUhCdUxkdlRyMFdlSFBuQTNtT09YRzN4cnk1eG1KUVRCcUJrRzVrNVFRS0NjVGd3Wm53SXVrOWQrYzJHV1k0M3JscGkzRThWclYrVThudXJ4YUw0YkhEMWJ3bkMwaDhMVjNkcXAzOWg1V0Y1eDdsbG9XQzRFZm5UZFpoV2dPTEU4QUROWFVxRzk5WmhWYnlZWEJjRVNkNnUzWEV6NWt6SitudW4xMWQrK2dOZEVqckkvenhPQ1h6MzJqa2ZDUHFObDJxUDhmTmF5bGhhUTdRYnFFWXdIUTBLMkJ0WXIyZk1CYjRVK08wWGo1ajloRlB4cXl4dlhHamxjZEJqbG1xelFGNXZNZGhqa1pKRHlrejltVjFuR3FXNjNadkV1dDRRVjE3WUdiTHMwL0FJclZ6LytCcmVpbkUvMWd2M21RaHd5ejVTL1A0SmNyREpveFVGZVdHZzZlMHNKUVV4K2ZQUXlnMHZlRTRZUnpRc2dLZ1ZFOWhsZVA0NVViTmdtQ2NnUEh6WnV2dzEvaXR4b1JjeDlRSGdpQUtCMjZnSU1rRWpGYjZLVFZ6eHJuVjZyVHVXSC9UM2NQaDNSSkdmMFk3RFBMRE5TUE1pOG9BQ3A0VGdpUE9DZklUZHZ3dUY0SmlFUG1NbUVTQm5RUURLblNuVG5naFJBb0RRTlJxd2VIbTNVQ0lQeHdPcEJ1SFJuYjRXYWNYeEZPUVZHN3BkRWVHeWl0Qy8wUmEyeGdIV09OZ0lxZEZHVDhyeEVmTWhZL2FvMlVTVjdTaWkvZHhITFRWc2VZWHIvSFJuTXlTRlQzM0JqMUJFQy80Z2dPMk1tK25PRXY4WVJpV0hlVk1vQlhsNUN4TGlpUndUNVdGUUVxZHJHM1p2MW5PRjdOaDFrV1NyZjhSYzB4dlpHQlBrK3NHNHNjNS90Q1Q5eXlLQUN2TXdFUUtFb1F0R2NjMjVOUGRBM0NQbDJTQmtDNXJ3QWhGYzNTa21mRTd4dXRtemY3QmxLTzIvNHo1cktROEdiNEs2Q1YxcDdNcDFGeWhRQUk3Z2lMSFFUdHd0S0cxQ09VRUJnbUJBTGxQUmhEam9aZ0pONjgyY2V0dEE1RituczRicjE5eTEzUXQrdnVZRzdPQ1lEd3l3bkJRNmNtdTN0Smp6Y0pzNElJVUExbkVPdTREUm5XVUk2K1dBaVUxa0M2Q2owbnF2SXJCWmowRTF3c0R3b0NJTHg4dCsreGdkdUp0UWp0Y1lHNktDMkFNaDJFTmE3T0MwYlNjUnN5Nndickx1RmV4dlA2TE96cndLOG43dkc2RWdCUjVhOTJTRVZyNjdPTythbllpY1llRnlnbkcra09sbFZFQUpSZVRhMHUvSnpmY1dza2R3bkxEUnhkaHQ2Nnd5N3crL1dQa09vUlR0c1NwYldRY1lOVmdUSXdnUXVCVXRnMVlqYnJLKzhjcEhiWGtoNlBGTEhXRTVaNlpMV2pLRDRMbEpwVjl5K2ZsWUNpMXZyaElSVXhDMHRMUzJEOWFMUEVFNm8vUStyOE54aTdTYWcxeS8rTTNIbk1jN1pNQ0pMeDNOYVNna24xSW10WVVZWUFDRytjNjBOMU9nUWFZUmQzZFpVS2diRUxrMUUzbWhNSFVOSWJ3eHByL2Rkb1hzZHRWRThZa0F0K3hGejVSOHJFMUVVOXNaUVk4YTNBOEtlR2EwRW1oVDc1bUlTKzhKQTVkbHUzL0tuNE5TVWFUbGhwUUZhaE1xeTV4YlcxVnYxWDZnc1NBRkdCYzRLaG9qV3hFM09rVHgvWW5qdGRXYk1OSTNLQ2tmR0FFZ0xyUjFONEZpalpnU2ZIbGp6Q0JSeTMxcytKV01zL1NvMVBmUU0zaXUxYnFaTnBNZGY0MUVzRDFwZ3JoRWlnazhDbnl3QkZWWHdsK0ZCeVhVa3pEMXJMQzFvbGc2SUQ0VmdZSE5EN2l1d2JabEZ4YnZBSmdDanJDVDhxemZJZTZ3b2VibEdJdHllWWQ1ZHl2aUFFQWlWakxmNVdVR2F3MXhsWFVZWnkrQ1VCMmo5QnVuWjE3Y2RvTkQ0cjJJZ3ZMaEN5WHQ2RVZyK29mV05nRFMrd1dnZWo4VUFvNWI4aWV2eXBVVnRQRUNRQW9xeENkYkdETDZKTHNIZzVCTW96aTBnSUhBeVpJUkJBMFc4STlmamd5R0RCQS9nWnlsRkJNZ1pUaHpPcjg3WlloYnAxbFFZMVhBNUdyeDF0ZlR3aDlCbnBrbVBTSjQzNE90T0d2VDY4akMrVWExQnRuVGxrZ0s1aEFpREtjZEkzOUt4Z05kUnZoVUR2M2I5R3JaVUhkR3VnZEFmTCszUXBBVVUvRjVqMVhJcDM3Q2FGUUt1MGt6NTJhY1V2RHVsbXQ4ZHgyK3VzeXd4c0NYM0djUENTbWRyRnVVZVE4QllhZm9YVGhiNXMrMFBpdmhZUGxWWUl0SWI3U0JBMDdEWGl1VmtnQUtMMGQvNHl1MHRPSm9ZSHArNG5oa0JEdWcwU3h4VnhnZ0NLRkNhaWVqQi9NWHNDMG83bmxRL1ZON0M5bmI4dzhaZkVISE1YVGg1VEo2OVovTHh0ZGVISGczeFUxMmtzMm10cG5ZdWRoajZuUDg5OHZzTUJWc1lJcXRvSTUzZ0NJTXJDQ29ERnZnQVVPd1RxVmtBNVNVaVhrbTRKckZkZVd0MEU4RVVRTE9KRmQ4UlFqaUZ6SW9GUlc4ZXhtMm43NjdkbVNSMWx0ZkRwaityd0YwbjZXbk1NbnJXdDdiQ1hGTktLdTQyTC9Zb045eEliVnFkMXlHb050TWFPMG1KTUFFU3BFNWJNQ3E0elR5Z2VMZUlhdjVBa3RpYll0YVVBRk9VOFVJb1dsNHl0K0RMOEpPZ3RQSFo1Rlh0aWhaUlVzWU5nWkNocFBLYVJ1SzNzbGpQRFNBcFJwUTVzcFQ2L0cxYTNzSG1qUHpBOGRqUkVDQ1FBb29SSG9Ea3IyT3dLam5qNkpHRzNCT283WWdJZ1VKUWdVc3IxWHBPTzNVaGlpWmo2QUxYd1JPTmRzMUc3ZkVvNGJOWFFpOGE3ZHUwTlpwWlZDWTFvSlV2NGdxb0tlVTcyRVpXd24raUo1THJjVEZTRlpOZ0FJWkFBaUJLU01GV2ttWUFsdjFQVWJRa0FpcE5OU3I5OFYvellqVThNQ1VBM256MWV6eDVqcWNlNWhkTzM3aGtKM2JqS0dGbFdSZmtyOE9VK3h5dXp4eWQyUFlvT0d1YllVY1lFRWdCUnVrTnZ1QlhRZTZWaGtwNHA1d0dnS2kvdVNSTkQ3Qkl4ZnF2eEtlVlk1SzB1Y1JJWkhyOFhUWmlvWVhmajJ0c2t6WW5OQ1BCK01yekVvTlNDSGRMRGZoZzJRQUJFU1krOGtEa2VVTmVRQ252MzVCQy91d1pRS09tRzFFTS95bkJ4VFpvWUlrRlF4dk5LVjJjMUY0dU96MksxSm0xWU01N05pWFVKNC9lUzZ1Y2xCejVpVGJxYkJiM1JKRkdyaUYxVXZJNWFzQVJBbEU1SVptTFZtQmNFUWhiZ2I3cExNbHpXQUpMVXdpTTl3dnJpYmxSZkM0ODFkbEszVUVuWUN3L0VvMXhTSzE5OC9KNy94dTZWWTJleEIvM29ZQjJxTlZjTkFRRVFKVHJpWWdlWmRGMTR0aXRZcjF6QUJCQ2c0QXd6WkxYK0pVNDRLRnNJdEMvdXl1d09sdWVnZXlDOEgveWt0VStQWXd5SEU1WkdDeVcxN3RIS1Y3eWJoZmdFb29GZVpZd2VSMWN3QVJDbERGamU3UXFPM1F2S2laYTdRS0RBSUdPTlQ2dlF4VFRwNHE1Ynl6dytEdEJldWt6Q3FpNlpaYmZ3aGF3cU90YjZ1N1R5bFdRLzBST0lySm5VYkYwQ0lFcEpkd1hYV3V0SmVxY1ZVTVlOS2VrcUFsRFlzU1NGbVdYU1YxS0prUXBkM0pXSHcxL1VYTTVPYnkvcmZHam8wR2NrcllkTEpDbnRmaEsvVWRFRnk5a21CRUNVOXBDcnFUWHZ0WFRKQm84OEo5M05RazBvb0dEMjJEOVBYRXc5T05URVhxTldhdlZaUFNHR1ZhN0ZTQ2ljVFJZcGI4TUUzYjhFUUpRcGNFV3Q4WFplNkFxV2xnSzlkakdBd280bFhZQTQ3SzFycVpjbW5VbXIzMkQvOEJyR3l1emlIYkVDQjhwNE9aS2hQL1UwQUJBQVViNDdycHJZZWJuT3FnOVl5Uk8wT1RtRnlSOUE0ZUZHU1YwMU9aN0xQUG1qT2piUGtJb09tT1A4Q0g0ZWVVM2tPaVRqMG1rQUlBQ2l6R29rZE1YdXZDcllGU3hqLzZKTS9BQUtQNWJzc1d4ZWF2N1RLeEY1b0dWSHp6VHQwMTIrb1lUZ1o5MkNvcHo3cWQ3Mk5XWWpCSlVmQ0lDb0ZLdnIxUmlzeUZyQjhhNWZtdjZCUW84bWEreWZOWkhCUStlWWlrZXNxQlFjN3RYRFhXajFxMkRvMDcwOU5XWTFDdjNXQS9zR0FSREJ6b0N4UzBhdDJRcFk5cTVnM2ZYTDdnb1VmSUVkSERBRG9PY0cwa2U5c1czQ1ExYjRDM2x3WnUvSWhZR2o2VDVudFp4SnI0a09zekxlczJwQ1g0M1Y4c2RrRHdJZ3ZFVkNXRTFFcjNGWnJnSGI4YkVmbkF5QXdvNGxXYTFDeHY1SmJQQmE2MStGVy9mMU1tNng4MXJJTStIUE1FdGVqZGd1aGhvNWRkdlFSYldUZ3FEdVRqZmlheEo3THU1YkxYem1jNjJSOW1oQ0h3RVFucitJaE9yTUJkejFPcGNsRG9GMC9RTEZPbkoxK0ROcjJIbnNJbXZPdEtqc3hUKytta2Q1YS9vbGoyMUxyQ0J0VldDSWJ4TWplWHM1ZllZVmJsaU4yczlmL3kwMUtYOWJLSDZlQndFUTFVQkNtYlRJU2RkQ0tWc0I3ZkJIMXk5UWNQZ3p1MzZIdkRtdUxlb2kwSlFzZzFvQnRNamhMNW80ZnMzdTJrd0llbEdqSnQ1YVY3SndYYzR3YS85U1F5WFZiR1VTQndFUXZnbUJJVE9jUlFaTEZnS2o5bkowM0IwQ2hSMUw0YkN1YVJleWxpdnpWT2svT3lSVitqalhYYi9GU1Z4SnJWNEpyWHVWR2R0bWxPUm5qbmpOOVB1MUNYKzd3ZVFOQWlCOHkxb3JXSldnSzVoWnYwQ3hEcVpJZk55ZmQ5ZmE5VUFBdExvbERmdHNKczlIaHJyb0c5eG96dk9WN3Q2MHYwK1BhVk0rWGJWSWVvQnFySUw4cVFHUTh6VUJFTUZnZHdYckF0R1I0azBLMFNmUVFndCtSb2ZQMmQ1WjZ3b29lL2lUbGovZDlXc3RvZVhKSThFTExVWHlIR3JycmRPR0VRK0E2YXNlSkxTQVdTRXZhcmYwZVMwRUZUbFlteTIyRE0waEFBSzZtN2JlWENjekdyWkNZTFNBYm1HejVTKy9ybDhyOU1sRlQxb2w3ZWRRVXh1N09hOGhCQ0pnNGM5YXh6YjJzQXNhZS9NSXNGYjQ4VUFYc0hSaGpvdzdPVUtmNTF1OWlyMWRwZGRud0ZxVGx4WS9BaUNDTFdUV20xTFJXcXZMSkdLV1ZOQ3o2dHlFUVVPdjlLRURwZE9MZ2Z4cytYM3liL21kVXNVL0VndC80YkIxOHJZdWVxRWE4aCtDbGY4aVlUM3hJNzZhaFdmemllR05GVUF5aEoxNGQ3Q2VyRkdydXorcjdXUVMxZWZCYUxGK21HNVJqc3FpQUhYMTNGZ1RBSUhoR1hSUlZhTmIzWFFZbEl1UUJESzd4SUlkMnRLRlAwZjEvdXhXdnFoNWFoNGFOQmUxdHdOZy9LbFlkK2xXUU5Sdm1Vd0MxeGU3aEJzTWV5eFk0djRyWThhc21uRm1sNkh5eG41bWovdUxId3VzWnBIM2VTMTJUakpuc0pad3BtNnBBM2I4ZHJnNG0wVC9zTUYrZmM0MldKNlRBQWlrQzRUUm1wQTVXVVMzREliTmxrRTdxQ1dla3VMaEw1VGhJaHkxZ21SVUJ6NVp5OVJJR05zWHY4aFpZNG5pbnpPaUtxSmJRbnBqZS9zb3VvTGhuTFFtRC9Yck1YVFJhRFJoS0duQy9oT3FpWGNMR2xhTk15TitFMk5VWnZ5cEhDTXk3aytLLzNwNTNKOTFCb2dxRDg4VU5ReHJzbHRWMzhVa3BMYmk1RC9kL2Eyc0JRSGlTN1dCQUFoa09KRW1EUnpXTlFUREtsNFFOTEUrbE4zQ0lpMHYwc0lud1U4V3JrOVlnemdVR2k0Z2FxUzhUYjVSTmN3dTZmQ1FMb1VoSjNQZGJVRTlLbVM5WmtaVXBMOG52bVJheGk1VVBkd2hhbDFtelpib2FNaHFrZGF0ZzJaTHRDRkxLTVp2U2tvWUN2VzRQek8weWpGaVZFUExYMDB0QWFMa04rT3F1SVVhREhOd2pUNC82ekhXZFd4bUFpRGdrQzZUVUpOMElkVXRMdkVKSEpHazdsc2pQdmc2ZStCTG56MGxMRWFHQjhYTGpNallCZG04S0hQaHdjZ1FGZW5yMGZ0ZUtHTUxtbmxGMVcwcjBXaThuU1hlWmF3L0ZvN1BLTld0aUhJN0lqY2dWcGtRUFRrcE1SQVdJUmpxL1h2QURuK2g2bWpyWmlKQmVVSmdzWCthWWZhdzZIMU96dEUxbE8waUFBTE9MbFhteFZLNlo2UG1FbFhSZU9pekxwdFdPRXZ1eG5KWHFWOWZwZzByQkZvMXZYVElIT3pUUVRNMHFvR1RGdExzTjFHcjVTL2JtckFKQlcvVjhQaFdNeFRHSTZFVkJpMHlmQ0h4S0RETUdiRDJQbTYya01kK3Q1NFY2KzdDclZ0all2dTFFVExpeTVsVlJmampKcXowNTlwU3ZYelNzNk43VjRiaTR3RjFheUE5TEFSQVlBUUpmTEllcVE1aVVUMmJMUFVlMVVqVHZWdklQZXp3R3VuMldDT3JsU2IydXlPOTNXWnJZUDFvWGh0WVFhcGZ0OHpwSU9XMlhjVklYc3RWL3orMWhUQWxGSm9YVVB1OWZuTWlsZFdsWnRnQlNZNkYycnFNUjRFZUZ6dllxejhicXFKSkgyYnRQQUpnNlRhd09XWmFKdU1WZXpNYjFnMk1QbDlIek1vUFpoQ1VzYWZtOG5hRVFRSWdBbnZ5c2JyQzVLUXdORGc4aGsrL1RXakp5OUt0VzBqd1MzdXh0bVpyR3RHUWZtNVJlOHhVN09RVkdqV0cxZ2dVUEdNOFl5aE12SmxKQ0lWRzJsQTRhTFVtRHErUVlkODR4YnZhckJZWGZkRWQ2Tk0veCt1VFBwSTJzOTRRVENBbzVYNGM2VDlqaHI5UWFTYmF4TS9iSWV0OGFwLzNoeUxtall4TTFwUDlWWVkrTUZ1WUFJZ3NGNTAwNGFmcS9nd1p2MmZOOU5VemZ1MnUzc1J1WFQwNFhnMi9uOUxIVnVvdEVMOXp0U3Y5eTkxcjdJSXJnLzdORUVpWGNOQ1B4VkpjTGcyM29kQXdrbHNOdzBQVzA0dkVmMkxVWHE1TW1lSFBxS3B5THdiaHIwVDdyMTBBWEUrZUM1VjJuMGc4bnhyUjRYR3gwZmh3bXdHekVVQnVXR3JybURCQ0FFVHlBV3N1MTZSUDhES0d3ZzVKTmJYZVBrbnFNWHRxZUphdURITlBuTUNoVXNieHBiVDZsU3Z3WmIwWUo5eTlSbUxQWFFiLzZ4Qkl0MFZnNmRobGxIay96QmdLemY4bGppdE1yRWtZalIxM2hyVVBWMTM0bzN4SThjWDJoOGhnbjFrQ1NKOTNqYkxVZ1RSUzkyRTdETXIxd2JDRzNBelpYY1FENWxqQjJqcHV0Z21BaUljcGEvV01hTUxkdlQyV0luN0MxQWQxQlUrY2RyZXVMczlpdGZCWjRTL3hSSkJwSEYrbEFsL091OWZZZjNveEUxMys0NHdlRThpZGFuQWpZQ2tIenJzTGhmWXFEaW8raGlFcEZLcVVZUlRWY3JxVC80d3FMYXpzeVExcXQvb05XcVdMVlB5bW9Oem5YUHQzbWEyQ3Nxc2FPZ1RHV3dYRFpta3ZlYjY2a1VQR1lIUERUUUFNOUFVbmRqSzBhOXRGRSs3dTVaR1Fxc3dMVTZqT0hOTmhGNTR0OFhxVWVqeFN4T3gyMHQwS2RtQ05SdVAxb014cmtPSDV3SmZ4aEdWWTI5ZXFOeGdkNkZXcUxwcDE0RDE4U282blNMU2lJVEJqSUV3TmhWVnlqR1U2NTlFQ1dJeDc4dkJ3NFc5VnZsWS94L3R0dk15UmtWQ0pJV28rYjJsRWtGNGpYWmFMRmtFQ1lGQWpZR0xKaWZpZ2NQdGVXUTNYeEZQbUxNWGhRR2pPcERNU1d3bmx6aS9mT3lxN2pwazlqcytheEJHL0dObzErZFJ3dDI3OEhGNUZvUy9qQ1NzVUdoNFhPTkJuL24yMXRBUUc2NndZZTcySElna3IxbmgwWDYzeUcxN3ZydjliUmVGUHovN3UxK2RvK3hwaWx3QXl2TGkvMnNIVTdoNjJLekxvSVZDRFp2a2pYVXFHYUVJQURFejZzMCtLdzkwNXcwdUtHc2tEd3RYd0FOdDRuVEU1Q1lRVEQ3Q1F1V2k1a2RCZGJLOVpxc2MzaFpJQ24xbC9UNWIxQ1NmOU85NnRteml1bzBwYitkeTlGTmJpOU5aU1lEcm8wa1VSb09NeFpKWW5pUjBIUmpUSzlpaCtiSWt2bjRjODZYSmE1anJvc3RKUnZMdlg0ME1CMG5ZUDJ5SFFYcTFKZXB4b0VTUUFCaW9CR2xudThPMUFtUEIrK2pJUzFzazFQZ05YbWVOc3JKbTIwWkRWY2hkZnExU1pzN1BDWWF0TE56TDhkT3pRYVArK2xPZHArUHZWU0FpQllmTWtTM2RWc0VoTGhCNE9NTVMyS0hyOHM4Y3pjenpsRlo3bFJsMVA5QmlLTDFPWXZXQzVkNFBnaUxKYytrKzBDdlhMaWswMWRjblhLeEFBZlJ3N25IODJNUlFtemhoVTBUUmR4MUh6UGV0YXBnTmYvSHdTMWQrb0kxNG9GQTk2aHFGS1ZvK3Zxa0tnWGVrK1JMZEVzQTdIa0Y3ajFHd0ZqTEE5aW5xelM0dDZYcXliMGZoRUQzdm1kNVZOQUVwM3JrMHVJMk1NcndNdjE2cmFzTmtpeUUwNEFSRFpRcUUxT0R6ZGJNSGhPaExKUzFQcEdsR2grUGVVc3g1ZmRZVEFrTmt0THQwU2xLMElGajBlU1ZwY0J1Z0tMcEtvZGJHbmE4L2RWaHZSNmxjbFhiNnVyMlgyK01YRVF2M1dHRWNabTJ1dTM4NitRd0JFN2xDWXBvU0Uvbi9TeFN3WTNib0ZOVmhJOTdrMU8xalB2RVp3THIzUzhxdHZBQkltUXFIQVk0b0x1T1A5ejVvbGE3YjZEZm1tMVMvWE5TeXhVUC93K3UzOTV2dDFvOWlIQ0lCKzIrdU5raDFNSTA0cVBweThVZHBBTGY4M0J5bkhaMXNqTU1lbFhwZFh1b0lUNmwyaWdQTWMzYjhPa3A4MWx0dkhyWDZPcmx2eGxhS3N5Z3d5V3poMkxJYnFHd2lCQkVCZjN2dVU3K0NDdTVmRnJGdkFCZ3pjNnkremdpVUVEbHJqQVFtQkJRVkFMdHpaUmF3WnNWTHVLeG9PUkt0ZjFtdVZQYVRKWHJGcGFGQkZZbTladHJOd2JEM3YzZlBBazYrT3dmQy9JS3VwVmRIYXVsZ1FwQVU0WDlMekVHVWNiWTd3RjlZckVVVUh6dWlialpBc0VCRFE4RGN5Q0pxem5mV0NDZGF5bmZZQ0JTQUFBbVdJNXJUK0JQZHNHUXVCTmZXRXdFS09wQkNkVHVuVHNibVVteGxxaHN5Q3pxRlFGYTd4WE5yenNOa0Rib1pBQ2NpUnZ1N2g4bVVnQUZiOUhUS2JvUnBTSUFKN3hxeFIwZHBSWmtzV25KL2I3SU9JTHJ1Ukl1YjY0MUZaZ3p5MnBTVGNoRUswK21VOEZTZXNjNnpMU012eXBNelN6d3UzWXdRTU9EM3JsSGpOWlZUTHZoQ0toY0I2cGNLRzJWckR4Y2Z4RFM0U040Z1pYdUt6V3hNbWVyQ2xIRnd1NDZzMURWQ25sUUJZN1h0MGpSa3d3alJuZTVKTUFxRDdDcWtoTUZKcjFvaWtZSFRPN2FWcVdGTTdUbHI5OUF6ZlFiTnJNMlFFWm9adlVVT2dYYWRWeXVYVXNMb01BYkJxOTJacmZFelUyNHZRQi9KR1hicjk1TFdoQlFPcGx5RFpOd3hqK0xqVmc5SlpRemo5K1kxdTgzaXJuOVQxa3htK1N0SHFWK0FoYUhVRVU2R0JBRmpsNUdJU3RRclBjZ0h4eE5sRkJ2ekx3SC9kM1FDazNVMUNaa3VFYnNXUG1KY2pIUWJ0Rzdsb29BTmhWRzhScnN4NktiZkJBWE5sR2FYaXBWMW85U3NvLzVINkNJQitDb0cxK203R2tJR3RxT3lGUzBwLzZJWElDWDl3Y2pVeTlGQU9IZldzTURpOE0wV0d2MGJDb0l3ZERFcEx2L3pOQVIrZnBkZTFsYnArRWF2Vno3Q0xPaE5mQ3I5bWhzejlpeDZheWdUQS8rK3oxN0lsQVFBQXl1Q3YvK05WYndSQThUOGYvZ1d2aUkvOSszMjNxbnQrdnBVTjRXT1Bmbkl4eHpISE1UaU9VUVhIY1RIUXR3VUFBQkF3QkVBQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQUFCRUFBQUFBQ0lBQUFBQWlBU0hUVDNNbjZBUUFBVUsxcTJRVHBYVFpqbkZvK1o3STZaL0pZdGF4bG1tcWVNVkdOSFYyWDlEVTlmWU5xNzVFdXRhTzlVNzEzcUZOdGFEdXAzajdTemNZREFBQUV3R29oTFh1ZnVPaHNkZkZjTS9EbElvRnd5WnlwK25HcjlURUpoQnYzSEZQUHZYTlFQYi9uSkJzVkFBQVFBTDFtenJoNmRlK1ZMZXJHWlhQVXRJbGpDdjU1RWh6bGNldmw4M1FZZk80UCs5UVRyUWRVVy9jQWV4c0FwRHNQTjlTb0x5NmRsUFByTmgvcEcvR3hKL2ZRNitMMWEreGpkNjlRcmJ1UHFjMEhPOVFUV3o1Z294QUF2Ukg4YnJ0aTNvaXUzV0tSSUhqL1RSZXB2L2pvWXZYTVc3dlVJMnQzRXdTQlBNaVFqSCs0N1pLa2o4a0ZKWjM5SjN0VTU1bVJ4eGtYSHUrNmNtYUR1dnV5NlhsOTcrcVU5N2UwOThUL3ZmTm9uenJWSDA0S2p6czdCOVNHazV5SHkrWG14V2ZGZThyRXQvc0cxYnY3anF2dDdaM3F0UjFIc3ZhVTNiWGtMRFZueWxnMXNhRmVuZGZVcU1ZMTFPbnJkYTRldWkxdHgrUC9QdHpSbzlwUG5qSDNnVmdBM1hHc202RmFRUTZBRDE3ZG9rTlpxWUpmS3ZrOWQ2OWNwRnNaZi9qU1Z2WHdodjNzZVlBTEM2YU5pMTlBYktudnV3MEtxUmNLMGQwN3FDOU1pZVNpa1dqTnZwUGN5QlhaaFROR0YrMW5MV2thbS9iZnFYb0d3bXJ2Y1RNVXRoN29pWWZFanI2d2VxRzlseGVsU002ZjFUamllcmhpNFV6OWtPdWlqS1YvNi8xMnRlMlFlZHd0aW4zOXZKbU5qb1poWmR3SEVzNE5tYzRUNjk4L3JJLzFaelllQ0d3Z0RGUUF0SnVpM1Y0NGlrVzZtTDk1MjZWcTFaSlo2cjZuVzdtSUFFNER3dG1UU3ZKejA1MEw1TUxrUnFiV2hseXRHeGgyM3ZTR3N2L09zZlUxOFlDWUxpamFBZkdEVTRQcVVOY0E0VEJQTXFZK1Z3UEpxcVZ6OUtPY0VrUG9TNXZhMUZQcjl3YnVlQTFNQUpRSkhvOTg3c05sYS9YTHRlTzk4S1dWNnU5K3RvRUxCT0JBMCtReG5uMXVtVm9iVWxzT2tWbkwxTkdlZTA1MlFGelNOUEp6RWd5UG5CNVVmL2FyQTd4NE9SVFNrbGN1ZGdEOXhicGQ2aDllZWo4d2pUT0JxQU1vWGI2UGZlRWFUNFEvbTdRR1NpQ2xwaUNRMjh4Slk5a0lQalp0ZkYxVlBkL21XR0JkMFR5ZUZ5NEhHY05YVFdUeTV0UDNmQ1F3MTJYZkIwQUpmeklSdzRza2tCSUNBWCswSXFRNmVZWWhIazdjTVhkY1ZUN3Z4TWttU0s5VVF6ZEtmYTRKeW5YWjExM0E4Z0lXR3Y1NkVtWXNKYzR1YkJ4VHI0dEV5OHlrQzg2ZG1uZnJvaDBDMVUvZXBEc1lTRVBHN25xcDlkNHBqbWVISVdIRzZLcDgzakxER05uSjliRWEyZGZsNHo5NDFkY1RSSHdiQU9XaW9ZTlZIbzUxblZGdmJHMTNWY3paTGlMOWtjVk5ydXNKeXM3MnJWc3VWbHNlZllPSklVQ0txODZsaGR6UFprMnNyOHJuYlplWFFXYlNPRkt0NUxyODBKMlhxY3RXdit6YjE4ZTNYY0F5MjlkdHE0RUV2NGVlZjBlZC8vY3ZxaS84Y3JPck8zajVXdmtlK1Y3NUdmS3ozSkJtNSsvZWZBRm5EQ0JGTlhZalNjOEJuUEhpQkJBbjBoV2x4akNwM1ZtTkxmZXAxK1h2MzdESXQ2K1JMMXNBNVFWelcrcmw4VmUycVMrL3VLMG92Lzg3cisvV0Qza2VNc1hjS1ptRmROZm1ReFNzQlJLTWI2aStpNGlzQWdSbkhubnJxRHEzc1U1TkdGV1Q5SEY1Zi83MDVIQ1lyYTVmdWJFQ1NYYkw1MHd1K1RHMjYzQ25PdDA3cUNkdmxJcGN3LzFhSzlCM0FWQzZmbVYxRDZla3BhNVU1VmdrVUVvdHNPOTllcm5qYnVHdi91blNXQUI4a2JNSFlEbDRza2VYWjFpUU1wNW9SdU9Zb2l6ZmlPb01Vc3NuMTZ2NWpXYjM4YVRSTldyMlJQTkdRYnFVejVwZy9sdG02MG81bDJJN2Rwb1czbHhrakh3cDNXNE5tYnB2K1RucVZnZGZMNjN5K2JaSTNuYnhiUFYya1JxSUNJQWxKTXU3T1gyUjVRN2k5aEtQdTVOZ3VlVmZYdEZUeTUzTVpKUUxtc3hjbGhaRUFNclZzWkJhZHNKZVJpclJzcFpwSlErU3NxSUlTa3VXYzNPenBKczkyOWh1YlV4c1lYVGJzcmo3T04yL3VhUWVaMDZ2eVU2dWs3S0toMzNkWGpIUDJlKzU5eWR2NnJjUGZHeUo2eDVDV2NYcnl3UkFiM1BUK2ljdGY3ZVhhZEtGL0E3NVhWTDgyY21GNXROWHppY0FBbmx3Tm54aVc4N3pTT3JFazlSeGlQYTZwRGE1YUNYZWVLWXVKNGZLYzlMU2VHTlRnMjVOdEdjbTI2MkpNOGJYSjlVcTNINlUxVUJ5Y1ZxNlNWYlNlV1hMSWZWRTZ3SDF0VlVMSFgzZmh0MUg0LzllMnB3N0FFcnJuOTNMOS93UDFyZ3VEeWZYYlpubzZiZVovYjRLZ0c1YS82VGJ0NXd6YnVWM3llK1VndFJPZGpaYUFZSEtrR04xUkpCa1hHNGcyTXU4WlFxTGRyZnoyc01Fd0d5Y1RnQ1JKZGp1ZUtvMS9uNnVaZVBpTjNxdEIrSy94MG1qaXF3MW5NaSt0cm9KZ2Rjc21PRzdBT2lyV2NEU1RPdUVUUGlveEFzcHYxTit0eE1ybDh6aUxBSUFIaUpkemhJTzIzb3BBWlBOZ21uT2ludmI2MmJiWWM1dDkrK3FoVE1jL1o1dGgwYTJ5RXNJZEhvOUZ0VmEwekFRQVZDYVo1M2NDVWpYYnlYNzh1VjNPeWtSSTJNVTVJQUFBS0NhT0MzZGxMaGV0dE13bDlqOXUyaVdzMUQyMHZ0SENyb2VpeG1UL0RmaHpEY0JVSW93Ty9HenRUc3IvbHlkUGdlWmVRUUFRRFZwbXV3c0xLM1pOOXdUdDd4bHVxUHZzYnQveGJ5WnVRT2dCTHhzSlZ5Y1hvK3JjVG5Ld0FSQUoyTUhaQ0NvRjhiVnlYTndVaWcybjFsVUFBQlUwc3hKem1aVko0N0RkN0pxaU13U3RyOUhKbXM1Q1dXYjloN0xlVDEyeW0rOWNyNllCT0owUjBnZENGcEo4bHlrOEhNMmJxZXFvMFQ3VjBPTnVuSm1ROWF2eVhjOTA2K3NPODRHQnVBclRxN0hNdnZYSmtPNG5Fd2EyYmhuT013NVhTSXkzZmkvZE1IU3lYT1dzWTErS2dqdGl3QjQ4K0t6SEgzZCtsM0hQUE9jNWJua0NvQkM2cHF4TWtoeGdsdHFTRHR2ZW9NYU55cTVFYnpjS3cwUUFJSEMyS1ZiUkdKQmFOdXkyZW1QYWJmSCtnUFA3bWYxRDRmY0ZseStlTGF6TVlQdkpZUTVwK01NTng3b3lQazFSenJPK0xLTE54QUIwR25GOFljMzdQZk1jNWJuOHMzYkxzMzVkWG9uSndDT0NIV1pLdituMXVzQ1VIM3NjaXVKeDNuaURWc2xsb1NURzBnQ1lHN1NtdWRFNis3aEJobW5rem1lM1RwOExYUXlLemV4L2w4MlVyZHp4Y0taZ2JzZSt5SUFPdGtSRXB1YnZVS2VVNjV1WGo5T1BTK0VoTC9WTjUvanE5WUx1L1lZRUdUL2RzME1kZjNpeHBJczNZYnltVHltM3ZYM09Kbk1rVGorVDkvc081aVZ5NXJjMmZsaUVvaVRIV0dIQnl2ek8zbE9mcHg2WG9pZG5RTysrbnZzcmlzZzZHUlpOaStIUDJtQlJHNnkvS0piVHJwZkU4Zi9PZjJleEZaRytEUUFPdGtSVG50d2JVNG56eW1JNHhLeWNiUDJaeldRZFVrQnhHN3VqbnA3ZmQzVThjSklMM1h0N1V6c0dvRFNaZXlrS3NiQmt6M3hmNmV1K1oxSlYrK0FxK2NTTkxWQitVTzkrQUlIZGFjcjFMSFRnNzRaNXljTDBnTlE2bFMvdDFmWGFKNDZtaGVwQkdTTTN2UGZlazZYV0pGaTBESWVVTHFFVXhzL25Fem1TTlYyb29jTlRBQ0VueHc1UGNCRUQ4Qm5EblFOZXZyNU1UYXh0S1M4U21LSkZTbnZKaFUrWkpLbjFNUk5uTXdobFRIV2ZQdlh1aFNNVE15UXo2Y2JUMDhGRFFLZzVzWFpPMDZuc1NOWmQzL0VOMytMTGxGQktSaEFkZlI1ZjMxZEptM2w1blFWa0Z4a3dzZHc1WTV0YVQrdkE1NitycHVmbCs3a2F4Yk0wSk1ueHpYUVNCQ0lBT2hrTm0yeGRzcGlHdTlnQi9YaTdPVksyMzYwVjYxb0hzK0dBSHhrN1dIdkJ5c21iZVhtZEJXUVV0RGR5UTdLdnNEa2kxR3RoenR5OS9NN21XWmViazZXcjNQeXQ2RjZTZDFDQUVxMTlYcS9CVERmRlg4QUwvSkZDMkQ3eVRNNXYwWUdsTXFZZ3NRNlFwWGtkUGs2SjM5YjBHdytVdHJaZ2pMSlJNWVpwbW85MEZQUjV3WDQzZDdqZlFWTnR0alMzcFAxbUpXSkp2czYwNDgxbEJKVGZxc3lVQW5kdllOc0JBSmdHUU9CdzltME1xRFVLNnVCT0YyKzdyVWRSOWhMWGVvWkNPc0xTYWFMUUdKUWszRkhqT2tCdkhQc1pqcVdwVXlNUFZQWVBvWTVmcjNINmFvYStkUUxMSldnanNmM1JRQ1VnYUNySFh6ZGlublRQQk1BNWJua1BCazZYTVltYUdTczBPTnZIK1ZDQVBqTVA2ODlxc2ZaeVRGZURWM0N5Si9UNWQ5QUFNeHAvZnVIYzk1MXJGbzZSODE1OXQyS2R3Tkw5Njg4bDF6ZTNjY0VrSFRrd3ZBVlpzNEN2c05OWEhBc2JaN21tZWNpWldTQ3lEZWx6YmM3WE9ydDNpdGJLdjVjblQ2SERidVBjcFlBQUZRTnAwT3lwazBjb3g2OHV2TFhZMm1ReVZWRnhPM2ZSZ0FzczJjMkhuRDBkYmRkTVUrLzRKWGMyZVE1NUNMZHYwKzBIbEFBQUZTTE5mdWNEMXY2aTQ4dXJ1ajFXTnkxYkhaSi9qWUNZQmxKQlhIcEJzNWw3T2c2OWQyYkw2alk4NVRmTGM4aGw3ZmViL2ZNakdVQXptL3daSjNTeEFjUUpITGRPdGJsckhxRlhBdWZ2dWNqZWhtNFNoMnZuNzV5dnFPdmxiL0piOWRrWDYwRThuODM3SFUwKzBqRzM5MjM2MWpaSjRUY3Qvd2NSMlAveEZQcjkzSW1BVXBNVmc2WVBHWmtDMFM2V1lIcFZoZHcwblcwWS9YdmtwYTRncmN0bjF5djVqYzZiNVdpZk14SW0vWWVjM3l0azNKby8vbFgxNnBuM3RxbEhsbTd1NndoNitIYmwrbXVhS2QvazkvNEtnREtiT0N2eGxLNmt4ZjBiejkra2RwenZMdHNzMnpsUWlPLzB3bFovWVBadndneWFSRllNRzI0VmFBeEZ0SmtUZEJzc2kzL0pCY1pKeTN2cFNCL0J3R3crT1kwMUtnclp6YkUzeiszc1U1TkdEVzhVb2Y4ZS83MGtUVUZwZmg2TWRjU2w5cUQxejNkeGd1U1lQMHU1d0ZReUxGNTk4cEZlbmpVYnplMnFUZDNIaTNwT3I3U01uL3ZuNXp2cUJhdmJkdWhUdCs5VHI1YkMvZ2ZmN1ZKcmY3c0ZZNTJ1RWMrOTJHbGZ2Sm15Y09XaEQvNVhVNHZRSSs5dm9NekNBTHR0b3RuNnd1Q0h6U09ZYlVYdDRFdWNjV044NlkzcUhHanpORktVaVI2YkQzTHNYbWQ5SzU5WWRWaXg2MXJpZGZsV3krZnB4K3JyY2FRSGUyZDZuVHZZSHdDaG96RGM5TktLTjI4VjUwN1diZnF5L0tyc2dLWG0rQm44K09ZZk44RlFMbHIrTHlEdFlFVFErREZMMjlWMzNsOWQwbWVqOHh5a29HdVRzUGZTNXZhU25ybkExU0QvU2Y5c3dSaXJwYkxvUHJHSlpQVXRmTW1WSDJvSzJUbEVqOTdvYld0NEpzNHVZN251cGJ2UGRLbEowMm0rOTVpa2ZrRmZoeVRYK3ZISGU5cnoveFJqeWx3RXJya2ErNi82U0sxdkdXNnV1L3AxcUs5eUhMWEllTUxuSXhKdE1sTy9QVm4zK1hNZ2NEclBNT1lLcitUTHRvbFRkVWZqbW1SVEUvRzg5MjRiSTdyVmtEWEFUeVAxankzWkg2Qkg0WDgrRWZKZUpzZnZielYxZmRJVUh2dDcvNUVmZitHUlFYTlNKTHZsWjhoUDh0TitCUC8vT3QzbVBrTHhKejBVUUFNYXBIWlhQeTBkclowWHlPWlhNdGtTRmExazI1b3YvYksxZnAxNTVNdVhWbHFKcCtCcVBLUUpsOHB4UHpTKzBkeUR1Q1cwTGRxNFF6ZGl1ZzI5TmtlZjJXYlo1YXBBeXFOU1ZDb0pqSjJzVzBQRTMxU1NYQ2E4L3c3dXBldEdrbXZuUFFvK2xXdG4zZStPNTVxVmE5TUdwdlhXQUFKY3ZLNC95YXovcy91dzEwalZodVJXWWN0TXljVzNNUXQ0LzYrL09JMnpoYUFENVdqaTZvYXlYcS84RDk3ZkgwMWhrRHBTZlR6RFA1YXYrOThuMzk4dlM0MFdjaEpXQUtlUFBKdDNjc1YvaVNvQWtpMnhlRmtMcStyVlBrWnI1TTF2ZjFDWmkwL1NRdGcxaERZMVR1WTE4emdTbm5vK1hkS05qblVLMEorMy9Ga0hNSmxxMS9XUWN0cmZyRnVGK0VQQ0lCS3JYVGdkVDBEWVRaQ1FNZ1FweHYvNVJVOTNDbmRyRjJ2a0I2L0IvN2pMZCtIUDFFYmxKMVBndGIzVDU3eFJHMHgyZmwvVk1MU000QWZITzdvOFd3TG9MUk9KckpybGRta2pFM2lUR1lLUWFlMzkzaWZMMllDejVwSXJVY25wRUZHaGp2SkRHRlpnN2VRY2ZPbHVDNVhZalVTQW1DWnlJNzMybzRqNmx1M1hGeXhjVGx5NFpCQnBWd1FnT3phVDU0cDZQdmxUdjVJWi9xZmtScllNZ1UzNGJid0xMeExWdTFJWitmUlBuV3EzMWxyNUlHdVFkWFJsL3kxcWU4amR4RFVEU0N4aDVSTXUzbnhXZXI4V1kxcVFWTmpXVy82cEliZ3JzT2RldVdTSUU3Q3JBM2FIeXl6QzU5Zi9iSXUwQ3lMUUpkclBJSmNqSDc0MGxabStnSU9QYlB4UUx6NmZ6b1VUSzkrclFkNlhMVUFTb3VoM1czOHdhbEJkYWhySUdNd2swa21maHBuNk9jd2FGNFhoNitOOWxLUWlXdHlGMUpPS2ZHR3p6Nm5jUDRJWUFDMHlkMkhQRW9kQk9VTzQ3ay83S083RjNCSldzbHBLZmMvdTFVdU1kQWxoamttVndUNDJFOEthVlRLSUFDV0tBaktlcjJmV2RHc2xqWlBLemdNU212ZkcxdmIxWFB2SEtTZUdRQms4SlYxeDVWYWQ1d05BUkFBSzBkM0RWdGhUY0xnTlF0bTZEcC9GNXc3TldjWmg4UTZnVExHa05BSEFBQUlnRlVjQm9VTVVyM3EzTWxKNHhHNmVnZFUyNGtlQm9nREFBQUNvQjlKd05NRFJoazBDZ0FBZkNERUpnQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFBQUFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQUVBQUJBQUJBQUFRQUFBQUJFQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCRUFBQUFBUkFBQUFBRUFBQkFBQlFYTFY1ZjJjMHFxS1JvZGhiTmlJQUFFQWdBbUEwRWxiUi9sNUZBZ1FBQUFoSUFKUVdRSVB3QndBQUVKd0FhQmlHVWlHR0VBSUFBQVFtQU1ZU29Ca0NBUUFBVUZVS2FNSXpFdjRQQUFBQS93ZEFraDhBQUVEQUFpQUpFQUFBb0NvVk5BWXdtaEFELy8yK1c5bWFQdmZvSnhlekVYeU80NWpqR0J6SElBQTZTWUhLcmdONHo4KzNzalY5ZnRING53Ly9nZzNoODRzR3h6SEhNYXIvT1A3QkczdllFRDcyVngrWlc1U2ZVM0FkRnlvQkFnQUFWSmNDQXlEakFBRUFBSUlWQU1sL0FBQUFBUXVBQUFBQUNGb0FwQWtRQUFDZzJoUTJDN2kyVHFrd0lSQUFBQ0E0QVRCVXE2SUd2Y2dBQUFEVnBQRDBSZ0FFQUFBSVdBQUVBQUFBQVJBQUFBQUVRQUFBQUJBQUFRQUFRQUFFQUFBQUFSQUFBQUFFUUFBQUFCQUFBUUFBUUFBRUFBQUFBUkFBQUFBRVFBQUFBQUlnQUFBQUNJQUFBQUFnQUFJQUFJQUFDQUFBQUFJZ0FBQUFDSUFBQUFBZ0FBSUFBSUFBQ0FBQUFBSWdBQUFBQ0lBQUFBQWdBQUlBQUlBQUNBQUFBQUlnQUFCQWtOV3lDVXBuVGtPTnVuSm1RMTdmMjlFWFZpKzA5N0lSQVFDQmRzOEZqZXB3OTVCNnMvMk1PdEVmWVlNUUFBdXpmSEs5bXQ5WW4vU3hDMmVNSHZGMUUwYlZxUG5UUjZmOUdjMVRSNnV4OVRVbGVYNWIybnZVQzArM3NZZFdLcnlQcTFkWG5UdFpQYkhsQXpaR2xicXhxWUdiS0tES3RVeW9VNSs4WUxMKzk3Mnh4NEhPZnJYMVNKLzZvSHRRclQvY3EzYWZHbVFqRVFCTjM3aGtranA3UXYySTBMYWthU3l2Tm5LNmFlNWs5WmtWemVxS2hVMzYvVFg3ZnF2YXVnZllNRlhvbno1MnRucDRWRWl0MjNOYXJkL2ZveDdaMnNWR0Fhck1kWE9TcjkyekcwZnBoN2c3OWpqUk02VDJkL1NyUGJISE16dE8wVUlZNUFCNDdid0p2Z2g3TThiWHMzZVcwWU5YdDZoUFhIcXVhcDR4TWVuamR5MmJyYjd6K200MlVKVzVkL0ZFTlcxOG5Ya0JXZGlvSDM5enpWbUVRYURLTEorZC9YbytaV3l0Zmx4ODlsajErN1llQW1DUUErRE9vMzIrQ0lEMnhRdWxjOW1NY2VyelY4eFZmM0x4SERWMmRQcnQvZWtyNXhNQXE3SFZZUDZFRVIrVDRScDJHTHpuOHVscTdlNVQ2cmtkcCtnbURxajdscCtqOWh6dlZzL3ZPY25HOENqcC9yVmIrM0xaZUxDSDd1Q2dCOEJUL1dGZVZXUWxyWDBybDh4U1MrWk16UjNFSjQ3UlgwOElyS0lXZzhuMWFrWHorSnczV0xjc25hSWZ4MDRQcW84L3RVZTE5WEx1Q0lydjM3QkkzYjF5a2VycGl3V0duN3hKQ1BUcWpkd2M1NDA1bTQ5d0krY1daV0E4N0k2NTQ5Z0lKYkJvVnFPajhHZVRWa0JVajArZU44SFYxKzgrM2tmNEM1QW5QN05NaHo4aExmK1BmTzdEZXV3dlBIZ3pOOXQ1QUh4eFh6Y2JMT2dCY1BPUlBsNVZaRDlSYkQ3azZ1dnRWa0JVaHhzWFQzTDE5Yi9mZVlxTkZnQXlzLy90Qno2cVZpMmRrL1J4Q1lIZnV1VmkvWGw0aDl2dVg4YitFUUI5WmRMb0dqWkNDVWhwbDJOZFoxeDlqN1FDY29Hb2d2RFgxT0JxL0t4MC96SWh4UCtraGUrRkw2MGNNY25MSmg5LzdPNFZiQ2dQb2Z1WEFPamF6azcvbE95WVBaR0pJS1h5czdVN1hYMjl0QUorYmRWQ05wekhmV0tCdSs3ZkY3WjJzTkU4ckJnM1hUTFpRN3A1NVJqT1JvYUZTUGN3dk1GTjkrL0tsdkhxZ1dWVGRNRm9lZHpjUEU1ZDI5VEFSc3pCZDVOQU5wd3Nid0I4L08yajFoMUk3cTVuQ2FmbGZuNUlUeVoxU0t0ZXJvdENvbHN2bjZlZWUrY2dBOFk5N01vV2R3SHc1OXZwL3ZXeWgyOWZwaTQ0ZDZyYWU2Ukx0ZTQrcHZhZjdGSFBidjNBY1cxT2U3S0hVOUk5L09DaFRpWjlWWkFFdHdWVFJqbnUvaFdKdFFFVGZVMGwxd21VTWpITUZQWnhBQlN5aW9idGc5aUxmYWhyK0dRaHM0VDNkUTd2QUtsTHJ2M1Q1VlBWM1pkTmQvUjcxdTg5cmI2eTdqaDdVWldTVnNEN2I3ckkxZmZJV0tGcjNtc2Y4ZkdteVdQVXpFbnV5Zys5c3VVUUY1b2ljdHY5SzhkdktXL0k3TldHWklVaENacmMvTGtqclg4ckZzN1UvNWJXT1h2aTFqZGpEeG5Dc1dudk1kVis4b3phZkxBajdZbzlkeTA1eTFYNHM4azVZZU9CRG03MHltREtxSkQ2Y05NWU5YL3lLSFh1cEhwMTN2VGl0OW9sMWdtVUZVVWtFTDYyNXhSaDBLOEI4TG9DbGxDN3lrVUx3bjhmWU5hUmwwbWR2d1hUekpuVWM2YU1WUk1iNnZNT2F6WVpLNVJwSEpGYjBxS0I0bkhiL1Z2bzhXdXY5UzFqZFdXNGhyMXNwQlJ4VHcyaTBrTkFBSFJIaXJCbklpMzNpWk01VnNjZW4vL2hhMG1oVFVMaGhhOXN5eXNFZnUvVHk5V1dmM21GVllCS0dQZ3VqUVV5Q1dabGZ3NngzeWxCVUI1cll6ZUJUNzdYR2RnZ1dNc3VtWHpITHV2N092WFRiWFFmVmV6aUVMdTdUd3gxeTFxbTZiY3lvNjlZQWEzVUpJaWllSmFlN1R6VTl3eUUxZC8vTWZ2NFAybFJsSEIzYnFNWjd1eUFKd1dsM1p3bkJCTzY4amdmdDB4My9ucjJEYVp0c2Z2eWk5djBjWlk2OHpjWENaalMvWHp6ajlmeFFoUkladlBLaEk0bE14cEswc0pYaUN1Yngrdkh6OTg5cVI1OXQ1TUFHR1J1Nm9kSjl4RzF3eXJuODFjdmNGWEx6NHZ5YllWRTRUZHZlNC8zNlRxYjBqMHI3SEFuU3JHU0VCTzYzRW5zL25YaXR4c3o5L3JjOFZTcmVudG1vK3NiUS9uOU1vWlFRaVRjdXlOMlBaWEpHVzdHOGxYczJuL0JaRFZqWEozNjlycGc5Y29RQUJPNDZmN2RmcFJwNTBDbDJhMTBkcEJ6U2tMZTZwc0o0RjZWcmZzM0habWNsYzN0ajc2aFh2dTdQOG00NUdNbXQxMHhUNzIyNHdqakFmUFFNbmxVVllRL203UUUzdE05R0tpV1FBS2dmY2ZaNEs1YjUwRFhZTnFWT3BqcFd4NDcyanVydmdXdzJwOS9xWDNqa2tucTJubkpOMlhweHRkVkE2OTFmWG1kbSs1Zm1SQ1NLNkRKV0w1dlBmM2ZhdlZucjNEMVBPd2kwYyt2ZnBrWHhhVWozZFUzcms1YUFvTTBPWVFBYUxsemtic0I1QTllUHl2N1NlbjBvRjVpU2dhYXY3U3ZoMUJZWktkN21jcnZkeCthUGE0azNiR1ZNRzRVTmZjZDM0eTc3UDU5WTJ1N282L0xkMUtJZEIzVEZaekhUZnFKL3FwODNuZWMzeGlZcm1ET1NzcGNjL2ZqTHBlUHlrVmFLV1JCK3Z1dW1xbWUvZXc4OVY5L09wdTFmWXRJNm9INUFXdVFadWFuWVJiU2NnbG5pdDM5bTBoQzNKWTI5Nlc3SkRSeXJMcnphbnQxSHIvTHpnN08wSkJBdGdES3VLR3I1NHhWeTJhUExWc0xnNFJCZVh5K3ZVZDkvZmVIYVJFc1VPY1pmMnkveVdNSUJrRlFqZDNXbFZMczd0OVVuMzk4ZlY3akFla0tkdTlBWjM5SnhnRktMYjlQLzJyL2lJL0xqT056eHRXcThhTnExTXpZMjdtVFJ1bjZmMjQwMUlYVXNxbWpWT3Z4ZnQrL1BvRUpnQkw2cEU2WXJCUlF5Wk94Qk02ZmZhcFovWGo5MFp4bEtKRFpqbVArcU1Fb3BXeVFucFBWZGVBdnBlcitUWlR2ZUVDNmd0MXI2eGdvU1FEY2xxRjNRTWJ1cFk3Zms5cURmM1hKRkQzSnc2a0o5Y0hvSFBWMUFQUks2RXNsZGNTa2ExZ1FBdlB6OWhIdkJVQnBqVGpTZVlZWEIybkpFSkFuOTFBOFBodTMzYjl2N2p5YTErK1I4WUFmWHJkTEwrL29oblFGTXl2WU9TY1RRV1NveDVZanZhN3FCRzc2d0huMzhvbitpQjdUOTZ1engrcldQUVFnQVA3KzlqbWVIMEF1SVhEakIzMUpTOUhCWGVCeXM1WnZLbGxmVkFySTJsSlg1cEJ4aHFsZHpkTHk2TVh3NlVkckQxZjNjU0cxQnFYZ2RPdUJIbC84UGVYZ3R2aHp1aVhnblBxSGw5NVhIMW5jNVBvYzhzREhscWpuZjdDR0Y4dUJkQk5CZWdjanF2VmdqdzV4YjdhZjBRRk4vR3BobzZPZktkLy83TjdTbm9OUERVUUlnTlZNMWdCZTB1VDk1L2xQSHp0YnZmZlVIb3BLNTNOMzJaa2NBQk1EWFdLWWs3VkNFKy84VVIycTRaaXcxeDIzUTU1MFcxTUtLbjhYbk91OE5OSmI3N2NYdG45MUQ2aS8rOWtHOWRnWHJuSDFmVksraWE1Z1p6WmJBVkRHQW02TkhSdXZ0WFduSFZzblkrNmN0czY5ZjhUOWpaUjBBenY5K1RLK01BamovM3dkQUovYTNLR3VjM2hIVVVuU05mM0ZwWlBVVjlZZDUyemgwdXJmYk5GdjZZN3hMMmxGYzd2c1dqRi90N1RnZGZkSDRqT1M3WEdKZE9VVzMzM0x6M0UxTVdQOXJzSkxkY2k1NC9FOFNzTklnZWhIMXU1bXJlQmNZU3AyN1B6bHJ3L2tyS3QzNlV6bmRUSTM1eEVBYnpqWGVRV09iUUZhNU1HM0FWQzZWYVVXWHpYTXZydnQ0aW5xWHpkMTBBcVl4OGtiL2lZQnJKamtuSERrdEhuUmxsNkNRMTNtdjZXd2UwZGZtSEJYUVN2bVRYTytYL1FOcW9jMzdDL0s3NVdXdkt2T2IzSzFWSndFMWUvZWZJRmVaZzdaT1NtcXZIeTI4K0ZhTCs1emYzeGVPTU41d0hRenZwQUE2R0ZyZDU5U3R5eWQ0dm5uS1pOQ3BCQTFFMEtLNzdJWjQ4bzJacStjdnlzb3NnM2xrTzVYYVIyVTQ4ZUptLzlqRjEyekhyYTAyWGtBTExUN045VWp2MzNQOWF6Z1ZVdm5xSnZXNytWR3RFRFNQZXQwcHJDMHhOdGpCdDFZNkRBQWxtTjhJUUd3VEo3YlVid0FLQzBSNi9hY2pyY1kyRjFCc2c2cHZkQzcxQlYwYzBGS0pLc2VLQUpnVVVuaDFrYys5MkYxdE91TSt2WXZONWIwUlAza1o1YnBDOEpMbTlyVTE1OTlsNjZoSW5sb3czSDFtOWh4TEJNbzByV1F1NW5zUmZqejlySHFaakxHdGtQRlhhODEzMW5CVEFncG5KdnUyUzE1ZFA5ZTI5UlEwdkdGQkVDUEttWTNzSVMvTzEvTWNkZHBqZU83ZC9GRWRjY2xVMXlOWFdxcDBEZ252NUo2WXQvNzlITGRWZE04ZXFJZTZQMkwyQWxlWnY0Vk81elo0Yzl1RlpnM3M3SGtnVE1vSkxRVkk3akplRDU0MXpVTFpyZ0xiSzBIaXY0Yzhwa1ZMQk5DSHJ5NlJYM245ZDI4aUhseTB6MHI2L1M2ZGNsTTU2L241b0FGUU44WHhaRnU0R0pZdjkvNWp2ZkkxaTcxcVorM3Vicm9zRkpBY1QxOXowZEduTWpsN3Y2Rkw2MVVkeTA1cTJnaE16SDgyV1Fza2JROEZ1djNJTXNGMkdIclg3SEhFcUs0WkF5ZTQzUHgrNGRMMHNJdVAvT0hMMjExL1gyZnZuSytQaGNnUDA2N1oyVjJycFB4aEtrV3ozRGV1TEwrTUFIUVY2UWJPQjFwR1hUMWMxeU9DNUR1cWw5dnBVdTNFaVNVWlJyUUxhRlF4dnI4OEpZTEN6cHB5L2RLeUV3TmZ6WnBlWlRmSTYwRHFMenUvZ2did2FOazdLeWJDUmpiMnp0TDlseGtZb25idFlMbG5ITHZsUnpuK1hEVFBmdUhnKzViLzl5TUw1UlNOZmtFVEFLZ2gwazNzTjBTSjYwQXY5eDBRZzhHZjhGRk9KUEI1dm5NMFAzcHRsTWM0V1VtZ1N0VEtFc2tyWUd5SHFpVW5zZzMvRG01YU4xLzAwV0V3QktaMCtCOHJPMzJveFJoOXFwVkM5MTEvejZ6OFVCSm44L1hudm1qNisrUnNqQzBBcnJucG52Mmo0ZmRyN0xrWm56aDFnQXVQUm1JZFZHa0plN2hOWWRWeTc5dVYzLzUyaEU5cG1pWmkybm5kcEZYdHlqclVsNHlrRndDbDFQU1N2Zk4yeTdWTFJCdWZvZDBJN3Rwc1NBRWxzYVZMbXFId2J2Y3JQNGh4ZDVMUGROZWZyN1VCblJEemlWZlc3V1FGOU1scDkyek1qdjMxVHhXekdxWjdId2Q0bndDSmdHd0NraDVsZFFTSzI2V2lYdTlyWWNqMWVQc1NSOXV5WW5lelFYbFc3ZGNuTmZ5YzRSQUlEMDNxMzlzM0hPc0xNOUppanpMVXBOdVNLK0NtNXZKb0hQVFBadnY3TnhGMDUzZkpMNGF3Q1ZaQTdreXNpeks3cFNNRlN6SFdyMXV4eVFpMmNPM0wzTWR6R1F3dWR2bG5HNS85QTNYWTRRSWdVQjZNbEhLemVvZmIrNDhXcGJubGUrRUVMZmQyVUhtcG50MmM1N0x2MDBaNjZ6UVNWQ0hpQVF5QUY3b1lsYlFPNGZ5Yi8xekV6VHQxUW5nbnF6THVXTGhUSGVCTzNaM2Y5L1Q3cXY0eTRWaDVRL1c2SHAvK1laQTZVWkdlVTBZVmNORzhLQVB6M2ZlL1N1cmY1UnpMVzgzRTBMa3VUMzAvRHVVZzNIQlRmZHNQck56UDl6a3ZFRmd5eEVDWUdCYzFUTEI4ZGNXc2k2Z0ZJbDJhdWRSNnBUbFE3cGNaQUMyVy8vNHEwMEZsWktRSmFEY2poT3lTWWtZdW9yS2EvNTA2bXg2MGNWem5hLys4ZTYrOHErWC90anJPeHlGdjN0LzhpYmh6NlZsWnpzYmhwWHY3TnlaNDV5WE9UN2NQVVFBREFLWk9laW1RSE1oTTNuUGQzSFJPZFhQaEpGOFBIVG5aYTY2a0lRRXQySzBKRWozc2R6MXV5WFBWNTQzc3diTHA1bEM2OTQ3RjhmMmZ6ZVRxVGJzUGxyMjV5am5pV3l0L1RJcDVacnYvWmFpNzI3RDM5UlJqc3UvNURzN2Q0bUxBdE9uQTNyOURWd0EvRVN6ODVZWEtSOVR5RXplcFdjN24yaXkrUWd0Z0c1SjE2K2JDNGg5d25ZNzdpOGJ1ZXZQSndUSzg1YkY1SkcvblozT1czQmxlVVpab1FmZWNkZXkyYTYrL3FYM2oxVG1KdlBsN2VtZlR5d1l5cGhnbG4xMDcxSVhNL2p6blowN2Rhenpob0hOSi9xemZsN0dFeElBZmNCTnE5eW1nL21QLzNQYjB2amtubTdPQ2k3SU9McTdWeTV5L1gyeVJGdXg1UnNDcFY1aFBuVUlZWEs3Ukp3c3oxZ09jdXhMMlB6cERVMnV4Z0VIemFKWmphNXUzRXBkL2lXVGRHVmg1SDBaQmtMNHk0L1Qxcmw4eTcvbzBEYldlUmR3cHZHQ0V2enV1YUJSZlc3SkpGKytEclZCMi9IY3RNcXQzWjkvQUx4emtmTnhocXhUNnA2VVkzRkxUdHFsNnFxeHgvKzRxVU1vL3ZiakY2a05iU2NyZG5HcmRuTHNPTDNSa3ErVFVKWnpUVytYWVUvcUVjckVzbGtUNi9XYTNvblA1MURYQURkM21jN0Z6YzdILzVXci9Fc21VaGJHSG12OHo3OStSMDhRUWY3T2MxaWU1ZjB5VGM3NDAwVVQxWHNuekxHR0xSUHExUGxUUnFtbFp6WG9jWXJTVlMzakVBbUFWYTZjclhJZm11Mzh6dDl1YWJ5eHFTRnA0b2gwY2JsdDVRaUNmTHArWmRadk1idCtpeFVDWlR6Z1A5eDJpWjVaRFBmazJIRnpURiszc0ZHdGkzMzlrMzg4b2Rmc2RzSStMczl0ck5PemlTWG9uUlc3U01qdmxhN2xiSFRCK1hYSGVhRlNTQXUrbTdKTjVTci9rb20wOUQzejFpNzEybzRqalBjcjBNM05wUzMva2crcFIvaHZINStkOWZQU0duakNaMHRLQmlvQXVoMy9KOTAzOWtrLzllNWxYSVl4QVU0dUNxbHVXVHBGUDFJOS92WlJ0WUdMeDRnTFJ6NWR2ekxydHh3a0JFNXNxSGYxSEpmTW1hci9MaTRzN3IxM3RFL2Q0dko3NUJoOThQcFo2bSt1T1VzZjV6SURYeVpoMmNGT0IvUDZtcUpNSEpreG5vays2Vnl6d0YyOXZIS1dmOG1rMURlUVFURy94T1ZmU2tYcUZqNjUzVi9MdS9vdUFDNmZYSy9tTjVvbjNkVHc1bWI1TnpuNXI3NjVzdU96enB2T1VsZXBIdmpZRXRmZkk0TzF5M2tCa1F0RjArUXhqdFlrRmpKK2tQQ1hIMm5Ga3lEbjlxYkxEbm15SXBDYlZZSGNtamErVHZjOHNDeGt5cm10eWZuNFB5bllEdjl3dXZ4YnZ1VmZFci9mNlVvalRyaXBXMGdBcklCL3VueXF1dnV5NmI3NWU4YU5DaWtNazY1ZmFTMXpRMnAwZmYzWmQ4ditYR1dBK05zekc3TjJWY3R6KzlITFc2a2ZWcUJuTnA3dzlIRXZZd1RiR0FlWXhNM3liOXZiTzlsZ1BpSGo2NXlHc3EwRlZzYVE3eTltQUZ6a3d3WVpYeVVNdjlYU28vc29tUXpFZHRzYUlPTjJLalZUVDBwRVNNakxGUDRvSGxzYy83cXBRL1VNZVBmWWQ3UHlVQkM0WGY1Tnh0M0JIMWE0S1AreTgyUmhFeS8rYTJkeHUydGxWbkhMaERwZnZSNitDb0Q3T3YyMW5xNTBIMkdZQkxtYmY3eE96K2JORkt3U0Zidm1YejdQVjBKZXB2Qkh0MitSdG5OdldQM3Yxejd3N1BPVHNZVklKamR5TWpFckYva2FqaFAvY05PTit1emV3bHJOcGZ2NHQ5dTdpdnI4cjVzejFsZXZSeTI3SktxTmhEcHBGWkJTTU5tNldCLzU3WHNWZjY1eThaTEFhazhLa1ZCSzhkamlrN0dBVXVNejNXU3FpbC8wV0lVa2lZekh0Y2ZreXBLSXkrZE1WdWZQYWxRTG1ocEhEUEhZdFBjWUc4eEhuSGFqYmo5YW5Na2ZxMXRQcUxIMUlYVmw4L2lpL0x5NWsvdzFEdEJYQVZES3RxejIyUUVqTTVHcEk1WStXRDIvK21YMXcxc3VWTGRlUGk5dEM0TVhaZzdhZ1ZVR3ZjK1lOSWJ3VjBKLytkb1JOWDUwalM3MTRpVXNRNWVaMUw4MGEyQU8xOVdUR2ZFeVMxZ21VcTNmUlFEMEMraytkVnFjZVVzUnk3OThlOTB4ZFUvM29QcmtCWk1ML2xsSGUveTFaakF0Z0tocVgvamxabDBqN0t0L3VqU3BydGpmUC8rdXA1N25mVSszNnJlRXY5S1NJcy8zN3UvSmUyWndzYTNmZTdwb3JSbUJ1cm1qMjlkMzNJei8rME9SeTc4OCttNm4rbjFiajdyai9NWjRjV2NuWkNVU0tVWXQ5UWhmM05kTkhVQ3ZjN015UURXUUFlUzBBR1luTFgxcjlyMmlIcjU5bVZxeGNLWXUrK0sxbFRVSWZ1VWozY0hQN2UxV1gxdzZTZDEyOFpTeUJVRTU5K3lPUFdUMUQxbmJtK01XR0NZMTlDUkVYVGhsbEZvUWU4aHljT2xLblVub2FqMWUvSlUzWkV5Z3RBWXFkVXhkMjlTZ24wTTYzUU1SMVg1NlVPM3ZIaXFvREEwQnNBTEtNUnR3UzN2NkplSzZZM2NIVHU3MlpiYXkwd2tyYmhhOER6Sjdnc2lEVjdlb0oxb1BzRUdDdmovMGh0VlgxaDNYRDFtWFY4WUh5aktRaGQ0Y1NzaVRjNHhkUEZxQ1hrZGZXTDNRVGlzZmtJdTBvTW5hdm5wOTMzZk44ajUyR0pQeGRRdGpvYkFjeTcvRm4wUEErUzRBZG1kcG9yVlAzcmJXQThsQmJuTkszU0ZPN05XSHNpcElwWmQ4UzFqMlRjYlZpbXpsV1ZKdjBtak5BOG9UeHFaUS81WUFtSy8vLzcrUHEvLzdiZ2NCRGtCYWRwZ2oxQUhlNDdkeGRnVEFNaUx3QVFBQVpFZGJLd0FBQUFFUUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUVBQUJBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBQUFFUUFBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQUVRQUFBQUJFQUFBQUFRQUFFQUFFQUFCQUFBUUhXb0xkWVBldlNUaTltYVB2ZnY5OTNLUnZBNWptT09ZMVMvdi9ySVhEWUN5aE1BLy9vL1hxM092ejQ4cEl6d2dES2lrWUovVk5RSUtSV3FVZEdhZXFVTWd6MExBQUQ0T3dCV3JacGFGZFZCc0xBUUdJMEZQeFdxaTRXL1d2WW9BQUJBQVBSK0NJeUZ0MmpzRVpZb0dIVVgvS1NsejZoUjBWcHA5V000SlFBQUlBQldDY1BzdG8xR2xSRUpPd3lCaGhuK3BBV3hwazYvRHdBQVFBQ3NxZ3hvV0VGTzhsOUVHZEZzcllHeHJ3MkZ6SzhQc2ZrQUFBQUJzSHJKQkk3WXd3Z1B4VExnVUVJUVRNcCtzYSt4V3YzbzhnVUFBQVJBZjlBVE9lUWhJVkIzQ1Z2Snp6RGY2Z2tmaEQ4QUFFQUE5Q0ZwNmFPTEZ3QUErREhtc0FrQUFBQUlnQUFBQVBDeG5IMmNEOXgwS1Z2SmhYQWtvcnJPREtpOXg3clV1d2VPcXhPbmU5a29BQUNndWdMZ2QxNDd3Rlp5dWpGRGhtcHNxRlV0azBhcHBVMVQxQ1hOTTlTNys0K3BWN2NlVUVQaENCc0lBQUNIcG94dlVFdk9ucXpPblRwQlRXeW9WelVoT2kzZGlJVERoUVZBT0RjVWlhcmpQWVA2c2VGUWR5d0VUbERYejV1dUdzZU9Wci9Zc0VPRkkxRTJFZ0FBV2RTRURIWE5vdG5xd25PbXFHTmRQYXAxeHdHMTY0TVRxcXVuajhZVUZ4Nzg4NVVFd0VxUUVvSWJENTFTSFdjRzFhY3VtaDdibWM5Ukw3L1h4b1lCQUNCTCtMdjFRL05WVStNWTlXTHJEdFc2NjFEc2VrcmpTU25RbmxwaSt6cDYxZTkzZGFnTG0yZm81bXdBQUpEZU5ZdG54OExmV1BXejF6ZXBQK3c4U1BnakFGYTMxa09uMVBFelliWGtuT2xzREFBQTBwQkdrb3ZPbWFaKzk4ZnRhdStSRGpZSUFiRDZ5UTNNcHZiVHFubjZKRFlHQUFCcFhEQjdxanArcWtlMTdtNW5ZeEFBL1dQM2lUTnE0cGhSYkFnQUFOSm9ualpSYll5RlA3cDlDWUMrMHRrM3BFSWhndzBCQUVBYTBraXlzLzBZRzRJQTZDOW1DUmdDSUFBQTZjZ000TTd1UGpZRUFSQUFBQVNKcktZRkFpQUFBQUFJZ0FBQUFDQUFBZ0FBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQVJBQUFBQUVBQUJBQUJBQUFRQUFBQUJFQUFBQUFSQUFBQUFFQUFCQUFCQUFBUUFBQUFCMEkyZjN0Q2tibXhxNEZVRUFBQWxkZG1NY2I3NmUycXI5WWwvNDVKSjZycUZqZnB4N1BTZ1dydjdsSHB1eHluMVFuc3ZleWtBQUNpS20rWk9WdCs2NVdJMWZlSVlkZTlQM2xUUDd6bEpBS3lrankrZUZQLzN0UEYxNnBhbFUvVEREb1AvK1BaeDFkWWJaczhGQUFCNStmNE5pOVJ0Vjh4VFkwZlg2ZmNsQ0c1NTlBM1YxajFROVg5YlZYWUJTN2R2ODlUUmFUOG5ZZkRLbGdtRVB3QUFrSmM1NCtyVkszOTFsYnA3NWFKNCtCUE5NeWFxNzk1OGdTLyt4cW9NZ0orNWNGTFd6Nyt3dFlPOUZ3QUE1T1dGTDYxVVMrWk1UZnU1VlV2bnFQdVduME1BTEhzcWI2alI0LzR5NlJrSXEzL2RSQUFFQUFENStkbmFuVmsvLzdjZnYwaTNFbGF6cWhzRCtNV2wyVnYvM2oxMFJsMDVzMEhkMlZpbkpveXF5Zm56RG5RTnFrZTJkckczQXdBQTdUdXY3MWFMWmpYcTFyNTBwRnY0YTZzV3FpLzhjak1CTUYvTEo5ZXIrWTFtaXI1d3h2QzRQZ2x2ODZjUHZ6KzJ2aWJqdUw5RUs1ckg2NGRUVzlwN0NJQUFBQ0RKMTU5OVYxMnhzQ2xwREdDaVd5K2ZweDU3YTQ5NiswZzNBVEFmMzcxdXBsclNOTFppdjErQ0pRQUFRQ0taNmZ2UHYzNUhmZk8yU3pOK3pmMGZQVS9kOFZUcmlJOUw5N0E5V1VTQ3BCZG5EUWQrSlJBbnJZb0FBQ0I0SHQ2d1gyMXBPNTd4ODlKQ21Eb1dVTjUvK3A2UDZPNWplY2kvdlRoZXNPSUJjT2ZSUHZZd0FBQlFWazVYOW5qczlSMFpQeWZkdy9kZTJSSi9YNHBHeXd4aUtSZGprMzk3TVFSV1BBQ2U2cTk4dmI0NzVvN2pTQUFBSUVBZXV2TXlkZlI3dCtwNmZ6Kzg1VUpkMmlWZEtIeGl5d2RaV3dGdlhHWk9GSkh2ZitSekgxYlRKbzRaOFRWMkNDUUFlaXdBQWdDQTRKQ2daN2ZTU2IwL21kQWhZLzJlZStCNnZmcEhxbXl0Z0JMNDdscHlsbG94YjFyR0NTTjJDSHp5TThzOHN3MHFQZ2xrWCtkZ3dUL2o5KzkzcWtOZEl3ZFliajdpckh0NVorY0FSd01BQUFHeGF1R01qSi9iZjdKbnhNZWtGZkNyWFdmU3R1NkpHeTZjcFNlRFBLbFV4dEl4eXZyYzkwK2VVVjkrY1JzQlVNTFg0MjhmVFJ2YTVITWJUZzZvZFhmT3pUaFpRd28vMy9saU8zc3pBQUJ3UkdyOFpTSVRQOUtSNHREMzMzUlIyczh0Ylo2bTN6b0pnYks4M09hREhUcFVCam9BU3NEYnNDNUwzM3FXZFgvRk14dFBzQ2NEQUFESDdNQ1dLdHRZdnlkYUQyUU1nTkl5S04zS1VoTlFRdUN6byt2VmlvVXpNLzZzYjkvK0liVm0zMjhyV2g3RzgyVmdjcTM3Ky9QdHA5aVRBUUNBSXhMVU1uWGx0dTQrbHZIN0pLenRQWko1NFlnRjA0WW5rTnozZEd2V3I1V3hnby9kdmFLaTI4SFRBVkRXL2IxOGJ1WlZQV1RzbjdRZ0FnQUFPSkZ0L0o5MHpXYXpjVS9tZ0hqaDJaT1N3dUw5UDMxYjlmU2xuK2NnSDEvOW15MEV3RXhrM2Q5c0szWDhaZ2V0ZndBQXdMbXpKMmRlZlN6WHVMelR2Wmtucm81dlNKNEJMTjNCc3BKSUtta1ovTlFQWGxYUDd6bEpBTXpreHNXWnUzK1BuUjVVVCs3cFprOEdBQUNPTFdoS1B3RWsyL2cvVzdZV3duUS9WeWFVL0dMZHJ2ajdMMjFxVTdjLytvWW4xZyt1OWVvTEpNV1pwNDNQWEUvblB6Y2VaeThHQUFDdVNOMi9kSGEwZDViazkzM2hsNXZWeFhPbnFUWHZ0WHVpL0l2bkErREhGa3pJK3ZsUFhUeFZuVDJoWGoyMnVZTnhnQUFBSUtkc3k3OGRURlAvTDVWMEVhL080L2RLcTE4bFoveFdUUUJjUHJsZVhiZXdNZXZYU092Z0xVdW42TWZlNDMxcXplNVRla1l3WVJBQUFLU1RPRk0zVmR1Sm5vSitkcWFXUmYyenU3MlhUVHdaQUQ5NTNnUlhYeTkxQXVWeDkyWFQ5ZGpBdGJFdytON1JQdlhJMWk3MmRnQUFvQ1hPMUUxVjZjTE1CRUNWZmZKSEx2R1d3ZGkvSDd4K2x0clMzcU4yeHNLZ0JNSU5IL1RTUWdnQVFFQTFUVTVmL3k5YnpUNENZSm5jdTNoaTFza2ZiaTFwR3FzZnQxanZ5OUp4MG1Vc29mQlVmMWd2UGRmUkYxWXZ0UGR5WkFBQTRHTVB2YnhkYlR2VXFVdkJ5TVNNNWhrVHpXelFOMGdBckxRL1c5SlkwcDh2ZFFYdFVHaVRidU1YZnJTVEl3TUFBQitUOGl1cEpWanVXbktXNCs5LzhPcVdqSjg3MW5XR0FKZ3ZtZnlSR014R2JOeFlVQnN6S3BTMU9IUSszam5VdzFFQkFFQUFwWTc5Ky80Tmk5VCtrejJxODR3NVpHek5Qck5nODEzTFpxdS8rT2ppakQvblNDY0JNRytmejdIdXI5VCsrL3MvZHFodlhESkpYVHR2UXRhdzZNYWhMc1lGQWdBQXBaYTFURk4zcjF6ayt2c09kMVJYWTVKbkFxQ3MrM3Y5NHN6ZHZ6SjJUOEtma0xmeWtCWkRtVEY4VmNzRVBRczRYNiszMFFJSUFBRHlKMk1MQ1lCNXVIUFJoS3hkdTcvYk9uTER5b3plRGV1T0t4VjdTSUNVbjdGb2VvTzZmTzU0VjkzRVRBQUJBQUNpZGZleHJEWDkwcEZKSkUrMEhpQUE1dVBqT1VxL1BMZmpWTmJQdC9YYUxZUm1LK0dOVFEzcTRyTkc2MERZWXRVSlRFZkt4QUFBQU9Ucm1iZDJlYkxZcytjRG9IVGxadXZDbGJJdGJsdnA1T3ZON3hsZXVGbEM0ZHpHZWpWN1lwMDZMeFlNeDQwS3FkWURCRUFBQUdEYWY5SmRMbmhwVTV1bjF2aXRxZ0FvWGJtWFBicGRkK0YrYVBZNHRhSjVmTkxuWlptM1l0Q0JrTzVlQUFDUWdUMzdOeGNwKy9MRGw3YXFoemZzcjhxLzB6TmR3UEV1M0RTVE8yU05Yd0FBZ0ZLVHNpK1B2MksyNk1tTTRGUTcyanZWZTRjNnF6YjRlUzRBSmtxYzNDRmhrT1hiQUFCQU9jaFl2dUV1M1cyKy9UdERYbitDaEQ4QUFJQ0FCVUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBQkVBQUFBQVFBQUVBQUFpQUFBQUFJQUFDQUFDQUFBZ0FBQUFDSUFBQUFBaUFBQUFBSUFBQ0FBQ0FBQWdBQUFBQ0lBQUFBQWlBQUFBQUlBQUNBQUNBQUFnQUFBQUNJQUFBQUFpQUFBQUFCRUFBQUFBUUFBRUFBRUFBQkFBQUFBRVFBQUFBMWFZMjF4ZDhmZVZjdGxJUlBYRFRwV3dFQUFEU2VQRFBWN0lSdkJBQS8rT05yV3doQUFBQW42RUxHQUFBZ0FBSUFBQUFBaUFBQUFBSWdBQUFBQ0FBQWdBQWdBQUlBQUFBQWlBQUFBQUlnQUFBQUNBQUFnQUFnQUFJQUFDQVlqQis4SDQweW1ZQUFBQUlVQUJVa3k2L0xQWjJVdXd4TnZhb1o1TUFBQUQ0MGtEczBSTjdkTlRHL2hlT1BZWmlqMEcyQ3dBQWdHOE5XcGt2TEFHd1AvYm90VDVSeTdZQkFBRHdwU0VyOC9WTEYzQkw3QjlqWW85UnNVY04yd1lBQU1DWHBOZFhHdjdPU0FDY3BzeXhmN1VFUUFBQUFGOEhRR2tGSEpBQU9NWUtmMUlTeG1EYkFBQUErSkpVZm9sSUNKUUFXS09HNndFU0FBRUFBUHdiQUVYay93a3dBQ1FtU21NTmZPUXVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+S4u+aTjeS9nC5wbmdcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ1FBQUFBbENBWUFBQUFxWEVzOUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvNVJrTXlSRGs1TnpOR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG81UmtNeVJEazVPRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPamt5TjBKRlFrRTJNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qbEdRekpFT1RrMk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0VWd2NHUUFBRGV0SlJFRlVlTnFjV0dsd1hOV1pQVy90ZlZGM1N5MjNKRy95Smk5WVhuRU1qZ05NSUVPd0lXUnFvR3FXS2dmYjQxQ1ZlQUtrWnFveXFjR1pNS2xValJNOGdja1VXVWorSkFYWUNUQXNKc1pPakcyQ2pZMHNlWkdFWk8ydHJmZlh5OXZmbSs4OXRhZHdoZ0JKeTdlNjNkSzc5OXp6ZmQvNXpyMk1zRFdHUCtYMTd6LzdaMzVZR2Q1NVgvd0w2emFITjkraW1tcUhsL1VHR0RDUUxka0lDSUhlbzduWHo3MmFmL1ZzaDcvam1NaUlPYzNVb05uYWpSUFpjMjhIZG4vL2hxLzVUd3JrOFo4OHNucGFuOWx6c1hMeEM5MXlkOXZOMFMySUJDTFFxaHBVVzZYNWJTU0VCRmdQdS9WaTdlTFdDN1VMRGtBcHhzVitsUlNTejBiNHlGdUtwVUMzZFRqZy85aUwrVGlHdnZ2c041aFJkZlRKRVcza3F4VzdBcGlBV2xYQjBjOVAxdjRVN2JGMlFIRm1vdUVCVGt5ZXdHTlhIMFdNajRIeE1iQjRDejc0MGNhMy9xTGQzLzRZeDNCVFZiTUt4bVkrbENHT2EvUDlVVEFIZnZybzVwNXF6N0VoWStnZTB6VEIxd1R3SmdjLzYwZFpLT09NZGdZZXhnT1RNVEd0VCtPMTNLdDRPdk1VUkU2RTMvYUROVmh3R2dlTGZwOWhNbXNLV3VHaEVCTWFpZkxSSzlkRGVQTGxkejRaUTQvKzk1NHZ2bEo0NWJETjJWaGtMNEt1R3VCRURueUlnMlJMWUdzc01hWEJ0bTJreEJSTTI4UU1nZkp6ZnBjcHphOGh6SWVCS24ydWFmQjZ2WmpsWnBIVGN0Z2UzdjZ2bmNIT2I1V01FaDdmL2IyUFo0akE3THdpWC9uMS9jbjcwWUpXdkYvb1J5UVJRWkV2d2k0QlM5Vmw0TE04aEtLQXVKYkFmTFlOQ1NzQnNlS0JWdEFSVnNKWXlDMUVSU2tqSTJZUWk4YVFMK2FSNGxONHNQVkJUQ2dUdCtXMGZMbkYwL0w3Mzd4MDhxT1QrcDhPUGR6eVF2NjVseDV0ZXd4N0Z1OEZLRzN1WlhaaW9EQ0FEZHBHZU10ZXNKUXc2eExyMEJKdXdZTFFBc1I5Y1RkUmkxb1JZK1V4cEtVMHhuSmphTktTYUF3MW9sZTVDaWtzNFdEYlFXeEtiWVpVTHVHK3kvY2RETUIvaVpZODlsR0FtR0VNdmNIUWtqUFZHVWhWQ2YxcUh3cUZBdFlXT3hFMGc1Z1huNGZOTk9tZEMrOEVCSHJDb0FyV2JUZDBMTTlpaTdnRnNJQzN4OTdHcVlsVEdKc2R3eXBsRFM3NHorT2NkZzRybFpXNGtMOEExVkJvN3ZkZit0b1RlNUxmLzhhUHloK2FRdy8vNEcvMzkyZzlUL29OUDBxVkVwTEpKQ1pLRTFoVldnM0JFTkE1dnhQNzF1OXpLNm9rbFdoZHExN0NiSDBHeXkxL3A0S2l3YWdMK01pVkkzaTk3M1VFeFNCT2UwNmhyYWtWMlprY1BJSUhsdC9HRXI3OXVaL3QvOVdEL3krSE5tNWZLNWhMdE9PYXBmR1FnVUE0Z0JGNUJCM1ZsUWdZQVd4YnZBMjdOdXhDclZKRFdaYkFzQXd0M1FETDlMcjFidE93TEM5czFnZVcxU0NyRmJjUTFzMWZoNmduaXE2cExqY2Z1N1Z1Tk1VYXdjb3NXSTZoaktpc3Z1ZXpkejUvOXRqRjdBMkEvdktyMi9kUDJ1blBDNnJnaXFnWk1wR1VtaEV0UjlIWnVoYTdOdTZDVkpTZ21USVlyZ0dtNXFkZDlzSWZlZ05lNFZYNi9CWTh2bXRnTEJ1YXVwREM1NmN3bHFISUtsYTByRUJCTG1Ba000S1V0eFZUNGlSRVF3UmpNRkI0R2FUMDBaN2Y5UC82ZzRDNHhYZWsvclBLVkZPOFFkWGpFNUdUY2xpcUxVUEVHOEZETisyR2FJbFFES3BoTGdhREZna0Zmd2hlK1RhczJSZWh6L2JBeUhWVEFSd0hiNzhCVHpBRHBiS1dRa2JwWUZjSnZFWEp2QWxYaTFlUnpXZVFOYk1JTjRScEhzTmwyckt0K2F2YU9uN1lkL0dhNmdaLzlSY1hMK3MxZXplVWFrV1lCa214eDBLYjNZWkNLWS8xODlhanNhRVJKYVZFRC90SVV6aUVmRStBTFIxQWRaQWpGdjRDWXZRdWVCdnVKT1kraTlwNEFuYithZnFiUjJEVWF2UmRrRFlpdStXekpySEd6YS8xdmcwb0drV3dOZ3VEd2pxRW9lZzF1Lzl6MXhsaXZyempvUWMrdmVUV3UxVlp4NkE4QU5tVzBjbXRRNXlQWTJ2TFZsZjRuRWt0SmdxZitCTHB6Uk9valhXaVlmVWRFSnBqWUhVU0FsYUFrR3lDdDNFSjVCRmlXWHdUWENBT3hkd0NqbEdvRW9GR1h3SVRsVFJtcTdOSVcyblUyQnBzQ3ZIZHpYZGpFN3RsK3MzZnZmV0d3eEMzOTlON051MUxmaGsvNy93NS9tN1IzMk5hbXNGc2NSYU5nVWFzYkZnSlNhTWtkbHFFcG9QWERrT2Y5aUE4bjBMQzZ6QW5Tc1RTTkd4bUducGFJaG1vSWpSL0JkU0pKSVh3QlpqcUpJRU5vV2JVaU9rbUpBSUpET1dIWU9vbW90NG9EblVjd29INTM4SS9iTjI3amJBSURpREIwczJ0cy9Lc205eGZYL1IxZkNyMEtWd3VYRUxFRTBiQUY0QnUwZmE0RU8zbUN0U1pickJNT3l4VlFyWC9QR3h1R0pXaHk2Z085NEVWUnlHUHZnY2xOd25CdnhTUUJpRUtsNml0aUhQTmw3TEJML2dSRmFNd0xBTmZhZnNLTmlZM29hQVVVSlFLVFU2NU9vQkVsdVdhSFQzSktCbGFHTGd0ZWh1eWFwYWFwTWVkeUJFOVIycHNKUTFrcmdHRWoyVjE2SVVzakV3dnRZc3l0R3dSVnFFUHl1d01oY2lBYlJLYnhTeFlaWnFhYjkzL1dKalRMZnEzekxjTUcwTWJLYzhNQWtkL3l3a0JoeHhIcVVtK2JHSE9NOW51ZzA0bjl2QmV5RTR5V25VRlpXd1k5bndZZVhvdkVVdmtiYWh3b1kxSXhEUG41a0p0b0FiT1F4b2pqVU9lR25kOEN0UllHRUtjcGlFMXY3NjVzbDZHei9hNU1ucmRxN0VzSXpycDR3RGlMTXQyR29BbjZVMjZyZUMxN0d0WTFiQUtFb1VsWDhtRFozZ0tVUWxzd3hvWWdZMHdwMDVCS2hFY2djeFp4UVRuaUNRdHh0Sml2RGVORXJIRW1wT1F3d3VnUis2QVI1Y3BXbk9MbHlrZlRRcFhqOVNEODlKNTdKeTNFMXlKY3l6TUhDNW44NEZRb0pnTUpWR2pIWDI3OTkvUXIvZGhVV3dScHNwVDZDMzBJaUpHWUpvcWZDUlpjdE4rVUcra2tFaFFpaWJVZkJXR2JybE0xdWl6WE5ESUZXb2dsWUNjM0E4L01XVFF4aHhiTXA0ZnB3ckxZR2w4R1pVM2kvKzY5alJPanAxRTNCdEhKQnhScnBkOVVQTlY3eGp3dkwvZ3liRkRPRFoxekhXQlRtTlZ5b3BiRlowdG5kUXVLclJyRFd4cUE3S1pQS3dycCtEeHl1Q0NEV1JqS1o5SU1zUmdrRmdxUXA2b29yVHdyeEhjZGhDQ1ZvSnVhSWlINHpnK2VoeW54OC9RTXl5c2dJVjhJVWZSZUIyVFRCcGRYVjJaRTZmTy9OZ0I1RHM5OGR1YkxrVjdOZ2pOUEJyMEdHa1lqeWxqR3N1OXk1R3B6R0pGcEFQSlFEUEtGRFl2OVI5KzhiMG9hRDVJNlY1VU14UWVXWU9sNkZRcE5iSWdCSERsdzRoLzdrY0ljQ29CTGNGUGpkV3lUQndaT0VMbFgwVzMyWTJ3R0NMOTlTTFVFTVM1OURuODhvWG56ck1GN3hFSGtDY2NEa2JuSlp0MkpPY25vZGQwVnlQOFlTOUtORmxBQzJLOE5vN3RDN2RUbUd6SWlvU0F3Q0J5MCswdzJ2NEdGVEpuZHFRTlp1TjZLSzEvaGREdGg1RGE5Z0E4cER0cXBVQlpLcmdHN1pudVp6Q1lIVVROVjBQRlQ3cEdqdE8yTFFUakFXakRPcFJyeG1HMWFKNTJBSEZheFZKNG43VXozQndLK2FKZWFCVU5JZ2xoanMwaGlCQTBZbUJZR3NhMmhkdW9Wd2tvT3dsU3F5SWFhMERUVGJmQTI3RUR3VlU3a1ZxN0RaRlFHSG9wQTExVHFPbjZFSS9HOFdMZmkzaG4vQjJZZ29sTGRvL2JBWnlXNFFtUjJLb21KdCtiMGdyWGF0OHhWWHZNYlIyVVN6NldSNUQzc2x0aWk4aFNHSmJiK0JST0FSMXAwRUxXVTZQL244K2N4OGFtalVpRUU1UVhCckZWaGtuOWlsV3BaMUZCR05VS05LVkNNaUNnS2R4RWsvcndUTTh6T0ROMkJpWnI0b1IrSElKSGdGcW01dXdKVWYvekl0T2J3ZlNsMlRjclU4Wmh3cEZ4QURsS3c2c2xzOEFJK2ozZWlOY2ZhQTRpVjg3aDd0am5zVy9GUHB3c25vUkdpU2xYYTdpVXYrUUs2RHovUEtTaUtRU0ZJSVV3NEk2Z2gvajBFNk82aHFPalIvSHk4TXU0UEhNWkJtK2d5KzdDUDY3NEdyNlUraExTdFVta1NSNnNvbzN4c3hNb0Rxbi9ZbXIySU9FbzhuVmRxampvcWxQR2Y2VGZtL3lPMVdBajFoakhOMWQ4RTN5Y0orMG9ZOC9GUGJqTGY1ZDdpcGdZbU1CQWRvQVNQVW5KR1FiUHpqbGg1K1JSMDJ1dS9lM1A5MU16dG1CNkRQeGVld2VMSW91d083VWJpQURqNWdSTzlKK0FlRlpFWlVaOVZxdVl3L1M0NUV4eDNRK1pqaDdwVlV2akJEdG1WTFRsM2hZdndvRXdSRm5FODBQUHUrcXQrbFhRb1JHdG9WWVUxUUxlblhrWEU2VEt2YmsrOU9YN01GZ2NkTU5hb3FNSmFSdklEaVBuelNIcFNVS1NKTWhrN2xUNk9adzVqS0V6UTZpT3lOMkZRZlVIdExZREtPODBsdzk2YXNlTExxQ3hQTEhjOTNpZzFiY3VjVXNDL29BZmxYd0ZZU3RFZVdCQjlJc29tYVF0T3ZVZml5ZFJOTnhUS3Brc1NDU1dBVStBU0NRYWVRWXhvY0d0V3R1Z3BrUWtWb05rYXcwZGhmTUYyTU1ZbjdwU2ZvVFdHNkJ4clI2bEc4NWw1dHdaZ2c2b09lT3FJR0toa3BWYnhLQ0laQ3BKbHBTQlNZbHRhcWJiaHh3NzRlVE1ydlpkMk5HeUE3YzAzWUlHZndPNnlsMTB1dVVSdGtNd0ZNTk5DREVrSUJDbkEyU0JhRGlYSTBlZ2pPYXZLUWNzMDNhWUdYRTZ5dlhyaHo4OEtPcjF3VG1nZUdwaThreDFoVWtsNmlVNThDWDg0TWl4VlBXS0MreGd4L2R3NzRKN3NWaFlqSFpmTzI1TjNrcTZGY0RScWFNSWVZTmtaVDN3TlZBVHBkYmlWTlBFK1FsVVorUzNjMzNxZHduTUtLMHpSQ05YSitORFQ2NE9TcFdHYy9CbWxJSXh4ckRzcUZ5c3BpcVpTdFJwRDQ0anlBazU3RjI2Ri9lbjdrZTZsSWFrU3lqcEpSaWFnWnZqTjJPRUc4RlZwUmRjaFVOaHRFQmxQWTNzKzdtTVVyU2VLdzZxdjZTNTAzVXdtVG9CSDNrZDQ0UXRXMGV0bGRPcVdrN2pVbFRCN2JXc3ZKVVBjRXZ6UWg3TkR6U1Rlamw2d2JzZWgySElpbGkwanhCNUhYa1pubnJ6S2FTc0ZHbU9Oa0Y5K1Z4aFVQbWZlaVU1WU1ZY1p0cHVqV3JqcDR1ZjZIN0lxR2U5ZzU0eUZQT0t3OG9yOVA3YjREeXhRemIxSmUvMlhGaittZmJiWXJLaUJFUkI4RGlBRE1QUTg2Vjg3WGRuM3lycGczWi8yYU1OUytOS0Z6MVhxODgzVFdPS1JvbkFHSC9PL1pEcktPR3FCeHBwSk9xZmZmWHYrZnJOMEFkdm9LdzZ1ODVtNURvcjJYcDRIRG9VL0ovdCt6TXVyRDRBekpHRklJMHczTUFnTUhkRjVZSmk2NkNzT3J0YW5kbHlIVkM1RHNUOHVJV1lQL0dPa2EwREVPZXM3dzFncmhlRlhRZWwxNEhwSDhYSUg3NytWNEFCQUFtSDEzRldjZDJUQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi81WOetueeggS3mi7fotJ0ucG5nXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJwbGF5cGFuZWxcXFwiPjxkaXYgY2xhc3M9XFxcInRhYmxlLXBhbmVsXFxcIiB2LWVsOnBhbmVsPVxcXCJ2LWVsOnBhbmVsXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCI+PGRpdiBjbGFzcz1cXFwibnVtIHNpbmdsZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJzaW5nbGVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NpbmdsZScpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdzaW5nbGUnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gZG91YmxlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImRvdWJsZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCgnZG91YmxlJylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ2RvdWJsZScgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSB6ZXJvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInplcm9cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMClcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMCBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIG9uZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJvbmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHR3b1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ0d29cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoMilcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgMiBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIHRocmVlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInRocmVlXFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDMpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDMgaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBmb3VyXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvdXJcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNClcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNCBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGZpdmVcXFwiIHYtYmluZDpzdHlsZT1cXFwiZml2ZVxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg1KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA1IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc2l4XFxcIiB2LWJpbmQ6c3R5bGU9XFxcInNpeFxcXCIgQHRvdWNoZW5kPVxcXCJkb2JldCg2KVxcXCI+PGltZyBjbGFzcz1cXFwiY2hpcFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0c3xmaWx0ZXJCeSA2IGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc2V2ZW5cXFwiIHYtYmluZDpzdHlsZT1cXFwic2V2ZW5cXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoNylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgNyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGVpZ2h0XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImVpZ2h0XFxcIiBAdG91Y2hlbmQ9XFxcImRvYmV0KDgpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5IDggaW4gJ2JldG51bSdcXFwiIHYtYmluZDpzcmM9XFxcImNoaXBJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwie21hcmdpbjogKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSAwIDAgJyArIChNYXRoLnJhbmRvbSgpICogNTApICsgJyUnfVxcXCIvPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBuaW5lXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm5pbmVcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoOSlcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgOSBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGJpZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJiaWdcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ2JpZycpXFxcIj48aW1nIGNsYXNzPVxcXCJjaGlwXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBiZXRzfGZpbHRlckJ5ICdiaWcnIGluICdiZXRudW0nXFxcIiB2LWJpbmQ6c3JjPVxcXCJjaGlwSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInttYXJnaW46IChNYXRoLnJhbmRvbSgpICogNTApICsgJyUgMCAwICcgKyAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclJ31cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJudW0gc21hbGxcXFwiIHYtYmluZDpzdHlsZT1cXFwic21hbGxcXFwiIEB0b3VjaGVuZD1cXFwiZG9iZXQoJ3NtYWxsJylcXFwiPjxpbWcgY2xhc3M9XFxcImNoaXBcXFwiIHYtZm9yPVxcXCJpdGVtIGluIGJldHN8ZmlsdGVyQnkgJ3NtYWxsJyBpbiAnYmV0bnVtJ1xcXCIgdi1iaW5kOnNyYz1cXFwiY2hpcEltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7bWFyZ2luOiAoTWF0aC5yYW5kb20oKSAqIDUwKSArICclIDAgMCAnICsgKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAnJSd9XFxcIi8+PC9kaXY+PGRpdiBjbGFzcz1cXFwibnVtIGZvcm11bGFcXFwiIHYtYmluZDpzdHlsZT1cXFwiZm9ybXVsYVxcXCIgdi1odG1sPVxcXCJib251c051bVxcXCI+IDwvZGl2PjxkaXYgY2xhc3M9XFxcIm51bSBib251ZG51bVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJib251ZG51bVxcXCI+PHRhYmxlPjx0cj48dGQgdi1odG1sPVxcXCJ1c2VyQmV0LmJldG51bVxcXCI+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PC9kaXY+PGltZyB2LWJpbmQ6c3JjPVxcXCJ0YWJsZVBhbmVsSW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcInt3aWR0aDppbWdTaXplLndpZHRoKnpvb21SYXRlLngrJ3B4JyxoZWlnaHQ6aW1nU2l6ZS5oZWlnaHQqem9vbVJhdGUueSsncHgnfVxcXCIvPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1BsYXlQYW5lbC52dWVcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxTdGF0ZS52dWU6IG5hbWVkIGV4cG9ydHMgaW4gKi52dWUgZmlsZXMgYXJlIGlnbm9yZWQuXCIpfVxuX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIXZ1ZS1odG1sLWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTBjZTc0MTkxL1N0YXRlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1N0YXRlLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9TdGF0ZS52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvU3RhdGUudnVlXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLnN0YXRlIHtcXG4gICAgaGVpZ2h0OiAxNyU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBib3R0b206IDFlbTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG50YWJsZSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmRpdi5zdGF0ZS1pdGVtIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMy4zMzMzJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYubW9uZXktc3RhdGUge1xcbiAgICBwYWRkaW5nOiAwIDFlbTtcXG59XFxuXFxuZGl2LnBvcnRyYWl0IHtcXG4gICAgcGFkZGluZzogMDtcXG59XFxuXFxuZGl2LnBvcnRyYWl0LWltZyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9hc3NldHMvdGguanBnXCIpICsgXCIpIDUwJSA1MCUgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbmRpdi5wb2x5Z29uIHtcXG4gICAgLypjbGlwLXBhdGg6IHBvbHlnb24oNTAlIDAsIDEwMCUgMjclLCAxMDAlIDczJSwgNTAlIDEwMCUsIDAlIDczJSwgMCAyNyUpOyovXFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIC8qICAgIGJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/lpLTlg48xLnBuZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICBtYXJnaW46IGF1dG87XFxufVxcblxcbmRpdi5idXR0b24udW5kbyB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+aSpOmUgC5wbmdcIikgKyBcIikgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZ1wiKSArIFwiKSA1MCUgNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGhlaWdodDogNDAlO1xcbiAgICBwYWRkaW5nOiA1JTtcXG59XFxuXFxuZGl2LmJ1dHRvbiBzcGFuIHtcXG4gICAgLypmb250LXNpemU6IDEuNXJlbTsqL1xcbn1cXG5cXG5cXG4vKmRpdi5zdGFycy1idXR0b257XFxuICAgIHBhZGRpbmc6IC44ZW07XFxufSovXFxuXFxuLm1vbmV5LWljb24ge1xcbiAgICAvKmJhY2tncm91bmQ6IHVybCguLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nKSA1MCUgNTAlOyovXFxuICAgIC8qYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXFxuICAgIC8qYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsqL1xcbn1cXG5cXG5zcGFuLm1vbmV5LWljb24ge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXFxuLm1vbmV5LW51bSB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgLXdlYmtpdC11c2VyLW1vZGlmeTogcmVhZC13cml0ZS1wbGFpbnRleHQtb25seTtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZT80NmE5MWY2OFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNGQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsWUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0lBQ0EsYUFBQTtDQUNBOztBQUVBO0lBQ0EsZUFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSw0REFBQTtJQUNBLHlCQUFBO0NBQ0E7O0FBRUE7SUFDQSwyRUFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0E7K0JBQ0E7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxrREFBQTtJQUNBLDZCQUFBO0lBQ0EseUJBQUE7Q0FDQTs7QUFFQTtJQUNBLGtEQUFBO0lBQ0EseUJBQUE7SUFDQSw2QkFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxzQkFBQTtDQUNBOzs7QUFHQTs7R0FFQTs7QUFFQTtJQUNBLG9EQUFBO0lBQ0EsNkJBQUE7SUFDQSxpQ0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGlCQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsK0NBQUE7SUFDQSxpQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJTdGF0ZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuICAgIC8vLSDnirbmgIHljLog77yM5bGV56S655So5oi355qE5LiA5Lqb54q25oCBXFxuICAgIGRpdi5zdGF0ZVxcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0ubW9uZXkudGFibGVcXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICB0YWJsZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLm1vbmV5LW51bShjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiLEBrZXl1cD1cXFwiY2hlY2tEYXRhXFxcIixAYmx1cj1cXFwiY2hhbmdlRGF0YVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVxcXCIsdi1odG1sPVxcXCJ1c2VyQmV0LmJldG1vbmV5XFxcIilcXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLnBvcnRyYWl0XFxuICAgICAgICAgICAgZGl2LnBvbHlnb24oQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCIsdi1iaW5kOnN0eWxlPVxcXCJoZWFkc3R5bGVcXFwiKVxcbiAgICAgICAgICAgICAgICBzdmcoeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIix2ZXJzaW9uPVxcXCIxLjFcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGgrJ3B4J1xcXCIsdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0KydweCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgZGVmc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4oaWQ9XFxcImltYWdlXFxcIix4PVxcXCIwXFxcIix5PVxcXCIwXFxcIixwYXR0ZXJuVW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIix2LWJpbmQ6d2lkdGg9XFxcImhlYWRzaXplLndpZHRoXFxcIix2LWJpbmQ6aGVpZ2h0PVxcXCJoZWFkc2l6ZS5oZWlnaHRcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSh2LWVsOmltYWdlLHg9XFxcIjBcXFwiLHk9XFxcIjBcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uKHYtYmluZDpwb2ludHM9XFxcImhlYWRib3JkZXJcXFwiLGZpbGw9XFxcInVybCgjaW1hZ2UpXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIGltYWdlKHg9XFxcIjBcXFwiLHk9XFxcIjBcXFwiLHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGhcXFwiLHYtYmluZDpoZWlnaHQ9XFxcImhlYWRzaXplLmhlaWdodFxcXCIsdi1iaW5kOnhsaW5rOmhyZWY9XFxcImhlYWRib3JkZXJpbWdcXFwiKVxcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0uc3RhcnMudGFibGVcXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBkaXYuYnV0dG9uLnVuZG8oQGNsaWNrPVxcXCJjYW5jZWxiZXRcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJCZXQnLCAndXNlcmluZm8nXSxcXG4gICAgcmVhZHkoKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnpvb21SYXRlKVxcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4kZWxzLmltYWdlKVxcbiAgICB9LFxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBoZWFkem9vbTogMS4yLFxcbiAgICAgICAgICAgIGhlYWRib3JkZXJpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nJylcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgd2F0Y2g6IHtcXG4gICAgICAgICd1c2VyaW5mby5oZWFkaW1ndXJsJzogZnVuY3Rpb24obmV3dmFsKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxzLmltYWdlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ3hsaW5rOmhyZWYnLCBuZXd2YWwpXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBoZWFkc2l6ZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTQyICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGhlYWRib3JkZXIoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDcwICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE1ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMjggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDcxICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDE0NiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgNDggKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XFxuICAgICAgICB9LFxcbiAgICAgICAgaGVhZHN0eWxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCAnICsgKDY0MCAvIDMgKiB0aGlzLnpvb21SYXRlLnggLSB0aGlzLmhlYWRzaXplLndpZHRoKSAvIDIgKyAncHgnIC8vXFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm06ICdzY2FsZSgnICsgdGhpcy5oZWFkc2l6ZS53aWR0aCAvICg2NDAgLyAzICogdGhpcy56b29tUmF0ZS54KSArICcpJ1xcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnLCcgKyB0aGlzLmhlYWRzaXplLmhlaWdodCAvICgxMDA4ICogMC4xNykgKyAnKSdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIHNob3dNZXNzYWdlKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpIC8vIDXku6Pooajog4zmma/mlbDnu4TnmoTmnIDlkI7kuIDkuKrvvIzljbPmmL7npLrlhYXlgLznmoTog4zmma9cXG4gICAgICAgIH0sXFxuICAgICAgICBjYW5jZWxiZXQoKSB7XFxuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXFxuICAgICAgICB9LFxcbiAgICAgICAgY2hlY2tEYXRhKGV2ZW50KSB7XFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coL1xcXFxkKy8udGVzdChldmVudC50YXJnZXQuaW5uZXJIVE1MKSlcXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTC5yZXBsYWNlKC9cXFxcRCsvZywgJycpXFxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQuaW5uZXJIVE1MKSB7XFxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG1vbmV5ID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LmlubmVySFRNTClcXG4gICAgICAgIH0sXFxuICAgICAgICBjaGFuZ2VEYXRhKGV2ZW50KSB7XFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxcXEQrL2csICcnKVxcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gMSAvL+acgOWwj+WAvOS4uiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5zdGF0ZSB7XFxuICAgIGhlaWdodDogMTclO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYm90dG9tOiAxZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxudGFibGUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5kaXYuc3RhdGUtaXRlbSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICB3aWR0aDogMzMuMzMzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2Lm1vbmV5LXN0YXRlIHtcXG4gICAgcGFkZGluZzogMCAxZW07XFxufVxcblxcbmRpdi5wb3J0cmFpdCB7XFxuICAgIHBhZGRpbmc6IDA7XFxufVxcblxcbmRpdi5wb3J0cmFpdC1pbWcge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL3RoLmpwZykgNTAlIDUwJSBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuZGl2LnBvbHlnb24ge1xcbiAgICAvKmNsaXAtcGF0aDogcG9seWdvbig1MCUgMCwgMTAwJSAyNyUsIDEwMCUgNzMlLCA1MCUgMTAwJSwgMCUgNzMlLCAwIDI3JSk7Ki9cXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgLyogICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nKSA1MCUgNTAlIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXFxuICAgIG1hcmdpbjogYXV0bztcXG59XFxuXFxuZGl2LmJ1dHRvbi51bmRvIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5pKk6ZSALnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG5kaXYuYnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZykgNTAlIDUwJTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBoZWlnaHQ6IDQwJTtcXG4gICAgcGFkZGluZzogNSU7XFxufVxcblxcbmRpdi5idXR0b24gc3BhbiB7XFxuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cXG59XFxuXFxuXFxuLypkaXYuc3RhcnMtYnV0dG9ue1xcbiAgICBwYWRkaW5nOiAuOGVtO1xcbn0qL1xcblxcbi5tb25leS1pY29uIHtcXG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xcbiAgICAvKmJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xcbiAgICAvKmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7Ki9cXG59XFxuXFxuc3Bhbi5tb25leS1pY29uIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcblxcbi5tb25leS1udW0ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9TdGF0ZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFZQUJnQUFELzJ3QkRBQW9IQndrSEJnb0pDQWtMQ3dvTUR4a1FEdzRPRHg0V0Z4SVpKQ0FtSlNNZ0l5SW9MVGt3S0NvMkt5SWpNa1F5TmpzOVFFQkFKakJHUzBVK1Nqay9RRDMvMndCREFRc0xDdzhORHgwUUVCMDlLU01wUFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMy93QUFSQ0FFc0FTd0RBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEMXhqVGQxRFVsQUM1b3pTVWxBRHMwWnB0RkFEczBacHRGQURzMFpwdEZBRHMwWnBNVVlvQVhOR2FiUlFBN05HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TkdhVEZHS0FGelJta3hSaWdCYzBacE1VWW9BWE5HYWJSUUE3TkdhYlJRQTdOR2FiUlFBN05HYWJSUUE3TlBEVkhpbkNnQkRTVXBwdEFDMFVVVUFGRkZGQUJSUlJRQVlvSHBSMHJLOFI2N0Y0ZjB0N2s0YVp2a2hUUDNtUDlCUUJYOFNlS3JQdzdHRmNHYThZWlNBSEhIcVQyRllPai9FeUtXUVI2cmJpQWsvNjZMSlVlbVIxRmVmM1YxTmUzY2x6ZFNOSk5JY3M3ZFRVV0txeE56M3lHYUs1aFdhQ1JaSW5HNVhVNUJGU1lyeHJ3MTRudXZEMTBBcE1sbzUvZVFFL3FQUTE2N1kzc09vMlVWMWJTQjRwQmtNT1B3STdHazBOTXNVVVVVaGhSUlJRQVVVVVVBRkZGRkFDMGxGWTNpYnhKQjRjc1BNYkVsekprUXhaKzhmVSt3b0FzNnRyZGxvc0FtdloxUlQ5eEJ5em4yRmNWUDhBRStmN2NqVzlnaTJnT0dEdDg3RDF6MEZjWnFPbzNPcTN6M1Y3TTAwckhxZUFCNkFkaFZjQ3FTSmJQY3RIMWkwMXl5VzVzNUF3Nk1wKzhoOUNLdkUxNGxvR3VUNkJxYVhjT1RHZUpZK3pyWHM5bmN4WDFwRmRXN0I0cFZES3c5RFNhR21UVVVVVWhoUlJSUUFVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQlJSUlFBQVpOZVdlTGJxZnhINHdUVDdUSldKL0lqeDAzZnhOL24wcjBqVWI2UFQ3S2VaeUEwY0R5cVBvUDhTSzRENGJXWnU5WXZOUmx5endyZ0UvMzM2L29EK2ROQ1oyVVhoWFRVMFJkS2UzV1NFTHl4NFptL3ZaOWE4eDhUZUc3anc3ZEFNeGx0SkQrNW14d2ZZK2hyMGZVdkVRdFpkWXQxSUV0bFppVlQ2c2M4ZitnMVBaMmNHdGVFclNHOFVTUlMyNmJpZXVjZFI3NW9UQm84WTRJcm92Qi9pZDlCdmpGY3NUWVRrZVozOHR1ekQrdFp1dTZMTm9XcHZhVDVJKzlISUJ3NjlqV2QzR2M0OXFyY2s5L1ZsWlF5RU1yRElJUFVVdGVmZUFmRlFWVjBlL2ZIOE50STMvQUtBZjZWNkNEeDcxTFJhWVVVWW9wQUZGRkZBQjBvb3FPV1dPQ0o1Wm5DUm9DV1pqZ0FDZ0N0cStxd2FOcDgxNWRFZVhHdkNqcTVQUUN2R05VMVc0MWkva3U3cGp2YzhKMlFEb0FQU3RMeGQ0a2Z4RGZnUkVyWXdraUZmWDFZL1dzRE5Va1EyTGdIdml1ajhMZUVKdkVFbm5UTzBGaUR0OHpIelNIdUYveHJQOFBhTExyMnNRMmNaS3huNXBYL3VvT3RlcGFxOGVrcG8wVnNCSENMeElsUmVnVXF3b2JCSXdQRW5nS3pYUnpMcENOSFBicnVLRnR4bEhmOGFiOE10WDh5M3VOTGtiT3crYkZuMEo1SDU4L2pYWldOL0ZmaWRveU5zTXp4TjdsVFhuVFFEd3Y4U292TEcyM2xrQkhwc2ZqOUNhVzR6MCtpbzRKa21qM0kyNEJpcFB1RGcveXFXa1VKUlJSUUFVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQlJSUlFCd1B4SXYzdHJtMmhVbmJQYXlSa2ZWbFAvc3RYZmhuRUY4UDNNdVJtUzRJL0lBVmxmRk9QL1M5TmsvaE1jaTVIcmtmNDBuaGJXLzdIOElDNXdXaWcxQUxPbzY3SFhyK0I1L0NuMEo2bUo0c3U1VThXYXNGY2dTZnVtSHFNRC9DdlF2QXQydDM0VHRCbjVvdDBSSDBQK0dLODQ4V01rbmlpOWxoY1NSU3NzaU92UWdnR3QzNGNhdUxYVVp0T20rVkxyRHhFLzN3T240aitWTmdqcmZGbWdKcitrdWlBZmE0c3ZDM2ZQOEFkL0d2SFNyS1NyZ3F3NElQVUd2ZmhnL1N2S2ZpRnBhYWY0aDgrTVlqdkY4ekE2Qmh3MytQNDBrd2FPV3hqbm5QWGc0TmVnZUdmaUVrY0sydXRNK1VHRXVBTTdoL3REcm4zcnorazZWVFFrejFLNStKZWxSc1JCQmRURDFDQlIrdFo3L0ZGYy91dExKLzNwc2Z5RmVmVW5XbFlMbmZINHB6ZjlBeVAvditmOEtraitLUzUvZTZXNEhxazJmNWl2UHNVWW9zRnoxTzErSldrU245OGx6QmdkU203K1ZjbDRxOFl6ZUlHK3oyNnREWUwvQWZ2U0hzVy93cm1NWnBhTEJjS1E4ZldscmE4S2FJMnVhNUZFNC8wYUkrWk1lMjBkdnhQRk1EdnZBT2lmMlpvYTNVeVl1YnZEblBWVS9oSDlmeHFoOFJkVCt4UzZTa2ZMeHltNHg5T245YTdaaWtTWkpWSTFHU1NjQUFWNHg0cTFrYTVyczl4SGtRTCs3aC93QjBkL3hPVFVvWjNIdzFsYWJSN3d5RWxqZE14SjdrZ0dxSHhPdC9LbjAyL2o2cXhqNDlRZHdxTHdycVEwVHdSYzNBdzA5eGNtSzNUdTBoQUEvQVZyZkVHM1AvQUFpRVJjNWFHV1BKUGM0d2FPb2RDejRFdkd2ZEFhVno4eHVaU1FmYzUvclhTNXJrdmh3b0hoY2tuQmU0Y2dmUUN1c3BNcEMwVVVVQUZGRkZBQlJSUlFBVTRVMm5DZ0JEVGFjYWJRQXRGRkZBQlJSUlFBWm81N2RjVVpwT2xBSGxYaXU3OCtPNHNKeisvd0JQdlhLWi9pamZuOUQraEZVdkRVd3VMUFZOSWRnRGV3bG9jLzhBUFJPVkgxUE5iSHhLMG93YXBGcUtBK1ZjRFkrT3pqL0VZL0t1TWpkb1pGa2pZcXlFTXJEcUNPaHFpQnF0bkJKSjQ5ZWxiK2l5V09wSkRZM3R4OWl2SURtenZWNkE5UWovQUk5RFdGSko1c3J1UU1zY25IclRQeXBnZTcyVFhLV0NIVVBKRXFqNTVJMitSLzhBYTU2WnJ6WHgvcmx2cTJwUVFXYkxKRmFncVpGNURNZXVENlZ5NXVaekVJbW5sTVk2SnZPQitHYWpQTkpJYllVVVVVeVFvb29vQUtLS0tBQ2lpaWdBR004NXg3VjNQZy94Um91amFjTGFkSm9wNUczU3pGUXdZOXVuSUErbGNOUm1nWjdMcUYvbzJyYVJJODJwUm14QTNUQ09UYVdIOTA5L3c3MTVQcTk3RGY2akpOYlFKQmFqNUlZbEdOcURwK1BlcU9Ncmc5YVh0ajBwSkEyZEY0U2pOL3E5c2JxWUpZNmFHdUdMY0l2T2YxYkg1VjFuaVRVbDFqd0JlWGlwdGdlVlJCdTZzb1lEZCtKelhuMmwydDFxVThlbVdwZi9BRWx4a0Rwa2R6N0FacjBmeHJicFllQjQ3QzJRa2VaRkRHcWprNFBZZmhReG96L0FVNWx1YlcxUW55cksyZVNVanA1a2pkUHdVVjNaR1RXRjRQMEgrd2RJMnkvOGZVNTh5YkhPUFJmd3JlcE1ZVVVVVWhoUlJSUUFVVVVVQUZPRk5wd29BUTAybkdtMEFMUlJSUUFVVVVVQUZIV2w2VlQxRzV1b0xmRmhhbTR1VzRWV08xUWZWajZlMUFGUHhOTHBTNk5ORnJFcUpES01BZnhrOWlvN212R0pOZ2RoRXpOR0Q4cFpjRWpzY1YwZmlUVFpZYnQ1OWQxZU9XK2ZrVzhJM2xmUWRnb3JtdWhJeFZJaGhSUlJURUZGRkZBQlJTVXRBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBU1c5elBaeXJOYlRQRkt2M1hSaUNLN1BSZmlEdmxnVFhZQk9Jam1PNGpUbERqR1N2Yzg5UlhFVWd3RGtnbjZVV0hjOTdzN3kxdjdkWjdTWkpZV0dReUhJcVUxNUg0YjFHQ3l1ZzFwcUV1bTNEa0JsbkhtUVMrell3UjlhOVdzNUpwN2RYbWlWSkNPZGpoMWIzVTl4VXRGSms5RkZGSVlVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQ1ovS3VMOFErTEx1NGFheDhPeHlTZVdDSjd4UjhxWTZnSG9QclhZWE1jVWx2SXM1eEVWTzRrNEdQYytsZVZlSy9GSTFJL3dCbmFXb2cwdUk0Q29Ob2xJN2tEdDZDbWhNNXR5enlNWkczT1NTV0p5U2ZyVFR4UjFvcWlBb29vb0FuMCt4bjFLOWp0YlZBMHNod29MQWZxYTYrMitGOTg2ZjZUZXdSUDNWVkw0L2xYUGFQb1VtcVlkWnhDRk9jaUo1Ry9KUWNWM0dudytKcktIRm5xVUdvb28vMU56RzhiWTlpdy9yU1kwWmMzd3R2RkdZdFNoWStqSXdIOWE1N1d2QzJwNkNpeVhrYUdKamdTSTJWejZIdUs3VWZFTmJLYzIrdGFWY1djeS9lQ25jUHFBY2NWc3czMmwrTWRIdXJhMms4MUdYYTRaU3JJVHlEZys0Rks3SFpIakZCNHFXNnQzczdtVzNtR0pZbktOOVFhaXFpUmFDYVFjMVowK3drMVBVWUxPQVprbWNLUFlkeitBb0Fsc05FMUxWRkxXTmxOT29PQ3lyeCtmU3RBK0N0ZkF6L0FHYy8vZmEvNDE2MXAxaERwbGpEYVd5aFlvbDJyNytwL0dwcHBvcmFNeVR6SkhHT3J1UUIrWnFibFdQRWJydy9xOWtoZTUwNjVSUjNNWkkvU3FCNDZqQjlEWHMwMS9hYTBoZ3N0WG5qWG96V3Fubi9BSUZqajhEWFBhaDhNWXBVZVN6MUdiem01LzBnQWhqN2tkS2R3c2VkQ2lyV282YmRhUmZ2YVhzUmpsWHNPUVIySVBjVkhhUXhYRTRTYTRTM1VnL082RmdEMkhITk1rZ0F6UzA1MVdPUXFySTRCNFpTU0RXdGRXVnZjMkl2YkxTNzYyajVIbUJ2TmlKSFh0bGYxb0FxYWJlVzFwTHR2YktLN3QzUHpLY3E0LzNXSFN2VVBDY1ZxbHNzdWo2aEpOcHJjRzJuNWFCdlFIdDlPaHJ5SUhQcDYxM1hnM3lMbVlYT2t5ZlpOU2pYOS9hRnYzVnlucU0vZFA4QUkwbU5IbzFHYVJjOVQzOVRTNHFTd29vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BS0tLS0FNYnhOYkc5MDU0cDd3MnVucUM5MUlvK2QxSFJSOWZXdkg3MldDYTVKczRQSXQxT0kwems0OVdQY212US9pRE5kWGtSc0xSVDluZ2orMFhrbWNLQi9BdWZVbnQ5SzgwNmNZQXhWSWxoUjF4MnpVdHRISExNQk5PSUU3dHRMSDhBT3RkUHBkNTRYMDVjeXRkWExqcUpiVkNHUHB6azB4SEppclduV0UycWFoRFoyMjN6cFNRdTQ0RkdvWDdhaGV2UDVVTUFKK1dPSkFxb1BUaWpTNzV0TTFhMXZGR1RESUhJOVIzL1NnUjZWcHR6cjNodlMwZ3ZOTlM5Z2hYQWtzM0c4RDNYdjhBV3M2NytLSTRGanB4SjdtYVRINkN1MysycTFpdDFhSjlvalpSSW9qUExLZlFkL3BYanV2SlpRZUlwSmJWdk10SkpQTjh2QlZsNXl5RlR5RG5OU2lpN3JmakQvaEliVHliN1RvUk1uTWN5TWNvZng2ajJxcDRUMWg5RzhRUVM1SXQ1RDVVd0o0Mm52OEFnY0d0RlBETnRIZXJxQXU5UG4wZkpsUG1UYlcyOWRwVWM3cTVac2IyMmphck1jRDBIYW1JNlB4L1ovWi9GYzdnREU2SktNZTR3ZjVWeldLMy9FMTZOU3RkR3V5ZjNwdFRGSi92S3hGWU5OQUZkdjhBREd3V1cvdXI0ai9VSUVRbis4M1g5Qit0Y1JYcVB3MGlWUERrcmdnczl3MmZiQUZKZ2plMTNXcmZRZE1rdkxqNW1HRmpqQndYWTlCWGsxeDRnbDFQVlZ1OWFWN3FGRGtXNnZ0UWVnSG9QV3UxK0lVa1VTd1NNcG5uUkNZMGIvVnhaUEx0Nms4QUQ2MXhtaWFYYjYzSGMyNXVvWUw3Y0pJVE1jTElPZHk1N2RxRU5uU3hmRXVTMFNPTnRGV0tIYU5pcTVYSTlnUmpGYkZuNHh1OWNqS2FMcE1yeWpobnVIQ3hSbjNQZjZWeSt0NlcxaG90cHBrMTJ1b2F2TE12bFJ4dVdFS1l4dEI2OGsxNkRvR2tyb3VqVzFpQ3BralhNaEhkenl4L09reG84eDhYNlhyRnBlTGVhMUpGSTl4a0swYmZLTWZ3NDdBVmhXMXcxcmN4VFJIRWtiQjFQdURtdTMrS0Y2cjNsbFpnZ3RFaGxiSFl0d1A1Vnd1TS9kNjFTSk43eElSY3V0eWx6cDF5cmNzMXNubHVNOW1YdjlSbW5lR0xneHBjQ1c2MWEzdGxIeXZaRWtLM2ZjdjBxOXFPMXZET25UYWxvNE1SZ0FqdjdlVEVpbnR2R01mbitkWlBoclU3alJ0V1M3aVdkNEVPMmZ5MUp5aDlmNTBnSTlZaWdrbmE1dEw5YnNINys2THlwQi92TDBQMUZhL2d1eFRVUktiT1Q3UHJGbXdtZ2NuNVpVUEJWaDZkdnhxL3F1bytITmZqSlM3V0dYcXJYVnR0NS8zMTVINDVyQTBhNWw4TitKYmE0bEk4c1B0WmtZTWpSdHdTR0hCSGY4S0FQWTBkbmlSbVhZeEFKWCs3N1U2anJ6a0VIb1JSMXFTd29vb29BS0tLS0FDbkNtMDRVQUlhYlRqVGFBRm9vb29BVVVob3pta0hYR2NVQWNSOFM5UkVHbndhZEhnTmN2NXNtUDdxOU0vVS93QXE4NFVGaUZVRmlUZ0FESk5iSGkzVS93QzEvRVZ6TXJaaVErVkgvdXJ4L1BOVk5LMG02MU9ZbUJsaGlqLzFrOHJiWTR4N3Q2KzFVaUdibWthTHBscXF5NjVjV3NUbjV2SmtsM0VEM1JlZnpQNFZUOFU2bFpYTjBsdHBNY0VkbkNvK2FLUGI1cmR5ZStQU3V2MHp3dHBXa2FQTHFFY1oxRzRTTXRHOGtad3pkZ2lucnozcno3VTdKN0c4TU55NGU3NnpxdklqWTg3Yyt2cjZVSUdNMDdUcnJWTDJPMXM0V2ttYy9kSFFlNVBZVk5ybWt5YUhxa3RsTklKSkVWV0pVWUJ5TThlMWRSNFRsZUNaTk4wVUo5cm1HKyt2bVhjSVZIOEtnOWNmeitsYlBqcnc0ZFIwbU84dFEwbDFhRDVzL2VrVHY5VDMvT2k0V09aOEkrTEw3UjR6YlBiVFhkaUR5cUtTMFdmUStudFhhU1dXZ2VNRTNQQXhsQSsrVWFLUWZqMy9BRnJ5aXp2cm14bVdlMHVKSVpGNk5HMkRYVldQanpVWEFXLzFVeG9PdmwyYXV4L0hJRkRRN214SjhMN0JuTFJhaGN4ajBLSzFVZFYrR3JXMWxKUFkzclR5UnJ1TWNxQWJnT3VDS3ZXZmpmejVCYWFQWlh1b1hMOVh1SEFIMU9PZ0g0VlA0azhaSnBPbW0waXVJcmpWSFRhNWlIeXhFOWZ5N0NscUdoNWdYTElFM1pWU2NEMHpTVVk0R2NaOWFLb2tLNzc0WWFpRmt2dFBiK0lDWkJuMDRQOEFTdUJHTndKR1I2VnZhS3gwVFY5UDFhSXM5azhubHRKL2R6d3lONkVaejdpaGpSM1hpZlFyanhIcVZwYUxMNUZyR2htbWxBeVNlaWorZjBxQWZEVFJ0Z0RTM3BPT2YzZzUvU3VxbmZBMlFtTnAyVW1KVzZQam5GWThIaWVPL3RuRmlrWnY0bS9lMk03N0pPT29CUEJQcDIrbFRjb20wand2cEdobnpMTzN4T1JqenBHM1BqMlBiOEtwNjc0ejAvU0luamhJdTcwOExGSHlBZjhBYVA4QWsxU3V2R3R1c2hqRTgxaGNyOSsydmJVbGZ6SElyTm4rSkQyNElYVHJHWmgwZEhZRDlRRFJZRGl0UXVMcTh2SmJxOERtYVk3eVdHTS9UMnFiUmRHdU5jMUdPMXRWUFBMeWRvMTdrbXJEUmF0NHIxWjdsTGFTZDVXNUtqQ0tCMEdlZ0ZlbStHTkJrMFN3Mnp0RUpYSHpKQ3VGWDhlckgzUDRVMnlVZzFEUnJpTFRGaTBpUlQ1Y1FqTnJQODBNeWdkUFZUNzVyekhUTlhrOFArSVB0TUVieFJveFNTQmlTZHZkVDlQNlY2WnFHdXplSDcrTmRTSG1hZGNOdGl1d09Zai9BSFhBNmowSXJsUGlGbzhTNmhhYXJDeUxCZUhaSklPVkRkbTQ5Ui9La2huVGExcEdoYWpZcmRUV01ycElnY1Qyc2Z6QUhuSngvZ2E4L3dCUjhQUnJFODJqWDhlb1d5WkxvcHhMRVBkUDZpdlFQQmNseGI2SkpZM2lONTlrK3phdk81RDh5a0h1TUhpcWVyNmRvbmlPY2kydW83TFdFUERIOTNJVDZNcHhuNjBKaFkwdkJ1cS8ycjRidDNadDAwUDdtVDErWG9meXhXN1huSGd1ZTUwTHhUYzZScUtlVzF3TzU0M2prRWV4R2E5SHlEeUtHTkJSUlJTR0ZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZZM2l6VmhvL2grNW5WZ0pYSGxSZjd6RHIrSFd0azRBOS9TdksvaURyaWFqcW9zb1d6RGFmTHgwTWgrOStYU21rSnM1VGtrS3ZKUFQzTmQ3NGQwZTAwMW9FMVF0ZTZpUnZpc0l2bUVIKzA0NkErNTZWeWVnNmJkNnJxMFZ2cDV4S1BtTW5hTWYzai9uclhwdG0yZytEN013TmV3ck1lWlpHYmRKSWZmR1QrRk5zU1JyYWplalR0S3VieVZRREJDWk1kZWNjQ3ZESkpXbmxlUmlXZVJpekU5U1RYcUhpclYwMUR3WmV5MjhOd0laQ2lyTEpIczh6TEQ3bzZuOHE4MHY3VTJONDF1VDg2QUNUMllqSkg0ZEtFRFBRUEJ6V25ocndoTnExOFF2MmhpZjlwZ09GVWZVNU5kUG9NOTVmV1gyNitYeXpjRGRGQUR4R25iUHFTT1RYQVJLZkVHczZMb2d5YlN6aFF5QWRDY2JtSi9sWGErSXRZYXdGcnB0amdYMTZ3aWlBNlJMMEwvZ09sSmpSbjYvNEJzTlZsYTRzM0ZuY3R5eFVaUno5TzM0VndPcStISmRKbGVPYTlzWGRmNFVtTzc4c1Y3RDVzTmxHSU0vSkRENWpNVDkxUjNQMTUvV3FGMUJaYWxvc1Z4cTFwRE1aUUdDdXZJTEg1UUQxN2loTVRSNDJ0eE5IRzBVY3JvamZlVkhJRGZYMXFJRDg2NmJ4cjRaaThQM3NMV3U3N05jQTdWSnpzWWRSbnVPYTVycFZDQ2lpaWdRZ3gzNlZ1YUxPdGlEOXBCbTBpOC9jWFFYckVleDltQjVCN2lzVEZhZWszRGFlNW5taDgvVFp6NUYwblVFZjBZZFFmYWdaNjROUGE3MFNHMm1tSmtFYTdMaEQ4d0krNjRQcjBOZVRlSWJxN20xRjR0VGhRWDhEYkhuUWJUSUIwSkhROFl3YTlPOE0rYmFXcDB5U1VUUlFLSkxTZi9ucEEzM2Z4QjRQNFZ5L3hOMG5aTGJhbWk0My91WnNlbzVVL2xrVktHY2hhUlNhcE1zVnhxTWNKWDdyWFR0dC9QQnJxTkk4QlhVc3kzRUdzV1cxRHk4SUV1UDZWTDRVOEJ3MzFsSHFHcU01aWwrYU9CVGdrZGlUNytsZWdXdHBCWXdMQmF3eHhSSjkxVVhBRkRZSkVXbldMMkZ2NVUxMVBkTnhscFFvSDRBQVlwdW92ZVc4Um1zWWxuS0RMUUU0TGp2dFBadnIxcTNJQ1VieThlWmo1ZDNUUHZWRFN0WmgxVXpRYlRGZVc1SzNGdTUrWkQvVWVob0tLNlQ2ZjR3MEthR0ppVWRTam93dzhMZHNqc1FhNEtLZWQvQytxNkJmOHk2Y1JMQ1QxQVZzTVAxeitOYkhpVnBmQ0hpbURXYklFVzE1a1R4TDBZajd3L0VjajNyTDhibExYWDQ5UXRTRERxTnBuSTc1WEIvcFFpV2RiNEMxRDdmNGFpMzRNMXNmSlk5eW8rN244RFdqcTJsYVY0Z1ZvTHNSeVN4RGhsWUNXTSszZitsY1I4UGRadE5KUytUVWJsTGRaQWpSbVRJREhuT0s2TFdMYncvNHFWVERxVUVkNm5FYzhNZ0REMlBxS0dNNVB4UnBPcmFDOXRKTk05MWJ3T1BzMTIzM28rY2hXNy9oWG8yaTZwRnJPazI5N0VRUE5YNWxIOExkeCtkY0xjM1BpTHczYnZiYXREL2FlbHlmS3hmNTFaZlp4eUQ5YXJlRC9FZHZvbXF5V3BrYit5N2xzcVpPc1RkaWY1SDg2SHFKSHFXS0tGWUZRVk9RUmtFZEtEelNLQ2lpaWdBcHdwdE9GQUNHbTA0MDJnQmFLS0tBT2U4VTZ0ZjJkbTBPbDJOelBjU2phSlVqSldNZXVlNXJ5cDlNMUJDVExaWFdUMXpDMytGZTdNQ3lGUWNaSFVkcTVMVzlLOFZwdWJTOVplYU0vd0RMTnRzYmo4Y1lQNlUweVdqZ2JiKzJyYXdlMnRZTHFDR1E1bFpJeXJQNlpiMDlxZ3NOVGwwaTRMeFcxcTh3UERUeGJ5djY0cTNxVmw0a2tmR3BRYWpLQWVqYm1INmNWVmpqT25zSk5RMHQ1RkorVlppNkEvbGpOVUk2N3c5ZjYzNHkxT0ZMMTFPbTI4aXlTaFl3cXN5OHF2NTl2YXVOMVNRemFyZU94NWFlUS84QWp4cjBYd25xZXNhb3NaZ3NMUFQ5TGo0RHFoeS9zb3orcHJnUEVOcWJMeEJmUUhCMnpNd0tuSXdUa2Z6cEliT20rR2NZKzM2aGVTRWZ1WVJsajJCT1QvS3BQQzEwL2lQNGdUNmpKbmJFak5HcDZLdjNWL1Ftc1RSYjhXUGhUWEFyWWxtTVVJOWNIZG45QWExUGg1SXR0RnJWMTNodGdSK3AvcFF3UnNlSU5SM2VINzJWVHpxTjRMU0xCLzVacWR2SDVOK2RhSGlXNUVlbytIOU9IQ3kzYXN3SG9nNEg1L3lya2ZFRTVnc3ZDOW9UOXlOYmhoN3N3LzhBcjFwZUxMM2I4Uk5JVS9kaE1mOEE0ODFJQ3Q4VDdzdnFWblpqcEZFWkQ5V09QNUN1SUZkUDhSR0o4V3lqKzVHZy9TdVh6VFFoVFNmV2w2NC9yV3JwMzJlMjVrMU5JR1BhSzI4MS93QXlNVXhHWWtjai9jamR2OTFTYTF2RDkybGpxSGthakUzMkM3QWhuVjFLakI2TjlRZWMxMU5oZVpBQ2FyNGxjZjhBVE96QVgrVmRCYXpGeUZrMUM2ZE9teStzUUFmeHdLVngySWZDeVNhYk5kNkpjbmZMWW5mYnlIK09GK242MWM4WVdJdi9BQXZmSi9HcWVhdjFYbitsVFhkc1YxWFRyOUJsaHV0NU52QUtNTWo4bUEvT3JWM0lxcWtVZ0dMaGpDTStwVS80VWlpdm9ENThNNmUvL1RxaC93REhhc1EzZjJqVFV1bFVrTkdKTUtNbnBuZ1ZsNmRjL3dCbTJlaDJFbldXM2RUbnR0VElwZkJ0dzF4NFZ0SEo1WGNvL0JqUUJyUTNNVnhiSmN3eUswTEx1VndlQ1BXdUw4Y1J6NkxxMWw0aXNEdGZjSXBjY2gvVFBxQ09LbXRMNCtHUEdNdWwzQi80bDJvTjVzTzdwR3pkUVBZbkkvS285V0pPbmF4NGV1U1dhQ0g3VlpNVDFqQnp0LzREeVBwUWdaWThYU3hhOTRDVy9nR1VVcE1QVWM0WWZxUitGY0xmM1p1dkRXbElUODl0SkxFTTlkdkREK2RiSGgrL2FUd0xyMWl4NWlqRXFBK2pIbjlSK3RjOXBWcytwNmxhV0NaL2ZUQUVEdDB5ZnlGTkVucGxucE9temVEdE1zOVdWRkJnQlZ5Y01oUFBEZHV0Y0Q0azhKM25oK2JjeStmWnNmM2M0L2syT2hydC9GT3NhcDRjZU9TT0czdk5KbEhsK1hLbUNoeDkwa2R2VGl1WnU5YmtodEd2OUF1bmlzeTJ5NHNKZ0pGaEo2WUJ6OHBvUXpuYmJWdFFzQVJhMzA4SVA4S3VjZmwwcTlhYVJxL2lPWVBEYWw4OVpTZ2pYNms0R2FzYWQ0cGVCeDVPaTZaTEt4NnBiSE9menJ1dEp1UEUycTdYdjBnMHkxSDhLUjVsWWVneVRqOGFHSkYvdzNvMXhvV21MYjNWN0xjdHhnZndSK3k5NjJLYUJoUVBTbHFTd29vb29BS2NLYlRoUUFocHRPTk5vQVdpaWlnQUZRM2YybnlHTm9ZQkwvRDUyZHY2Vk5TWXpRQnhPcUh4MCs0UXJickdlOXF5NS9Oam11Zmk4TGVKN204RTg5ajUwMmM3N3VVTVAxTmVyOWV0VnRUbit5NlZkempySEE3RDZoVGluY1ZqeUc4MXZYTDY0Rms5OUs1RCtVRWhZS2hPY0FER09LdCtKb05Hc2JLMXNMTnpMcU52a1hFcWNxeFBMQW51UWVsYzRra2tiN2xabGNjN2gxelRhb2trRGtSdEhuNVdJSkhxUjAvblhRZUdadkowUHhHdmMyWUkvUEg5YTVzbXREU3JrUXc2bEd4NG5zcEV4NzhFZnlvQXYrTUpmK0p4YlJyOTJDemhVRC9nSVA4QVdrOFhYLzJueEY5cmovNTVRdXBIcnRCL25WTFhwdk8xZVIxUC9MT05meVJSV2V6dEpqY2M0QUhQb09CUUIwSGpXNEY5ck1WNm4zTG0xaWtINWMvcURYUFZMSmNQTERGRzV5SWxLcjdESk9QMU5SazBBVDJjdHRGSUh1clo3bFY2SUpOZ1AxT00vbFcvYStPSmRPQVhUOUkwMjJYMmpMTitlYzF6Sk5Cb3NGenRZL2locVFQNzJ5dFhIK3p1WCt0YStuL0U2eW5ZQyt0NTdmSndYWDk0ditOZVo1cHA2MHJCYzkvamRKNGtsUWhrY0JrUHFPeHJuL0Z0NTlqbTBWYzh2cUNIOEJ4L1d0YlJUL3hJN0F0L3o3Ui95cmcvR2VwQzk4YVdGbkd3OHUxZEEzcHZMQW44aGlraWkvNHgxWVdIaTdUQmtCTFdHUm14NnNDUDZDdGp3Q2hYd2RaaHY0aTdjKzdHdUhsdHBQRzNqTzUrejdoQVpPWkQwU0plTS9VNDQrdGVxVzF2QnA5cEZid0tJNFlsQ3FNOUJRd1J4L3hOc2ZNMDZ6dmxHSGdsOHZJNjRZWi9tUDFySTEvVUd2TkcwVFhGL3dCZUZlMW5BL2k0d1FmcnorZGRqNDBnVzQ4SlgrZXFLSEgxQkZlYlc4NWw4RzM5dXg0Z3U0cFY5dHdLbitWQ0V6UHNMdzJsdGZSS1R0dUlQTC84ZUIvcFhTK0NyVmROdW9OUnZsYUpMMHRiV3MvWkg5U1Bmb0RYSDg5UWNWMHRwcUQzdmdPL3NwWEpheGtqbWhQY0F0akEvSCtkTVNOclY5WU9vNlpjUjNhcXNpdWJLOVFkRmNaTWNvSDFHUHhya2ZEay9rZUlMTU1xUEZKS3Nja2JESWRTUU9SK3RHcWFpMXhxTjVLcDR1MVhlby92WVUvekZiTmxwT2RUOExUUnJqN1dvWno3b3g1L0lDZ0QxR0cwdHJjSHlJSW9zLzNFQy95cVhyUWZRMEFWSllVVVVVQUZGRkZBQlRoVGFjS0FFTk5weHB0QUMwVVVVQUZGRkZBQldiNGpWbThOYWtGNm0zZitWYU5SM1VIMnF6bmdKNGxqWkQrSXhRQjR4cXRpYkhTOUlEY1NYRVRYRG42bkFINUFmbldWWGIvRU93S1htalFSanJDSUZJOVFRQi9PdVkxMnpYVDljdTdSUHVReWJCK0FGV2lHVUtVSEJwS0tCRHBaREpJWFBmSDhxYUtLVEZBQzBVVVVBRkZGRkFBS0QwSjlxS2tnZEk3aU41a0x4cXdabEJ4a0R0UUI2N3FPc3hlR2ZDMXM4bTB6K1FpUXg5MmZhUDBIZXZLYlMxdmRhMVJZNE4wdDFNNVl0bnZuSkpQYXJza3VxZU1OWUdGTXM3OEtvNFNKZjZDdlR2RGZocTI4UFdtRUt5M1VnL2V6WTViMkhvS25ZcmNsOFA2QmIrSHRPRnZFQTByY3pTa2N1MytBN1V6eFZjTlorSEx1NWorL0Rza0gxRHFhMURNbVpQbTVqR1c5aFdENDdtQ2VEN3c4ZlBzVWZpd29ReTM0Z2xXYndscUVvKzdKYWxoOUN1UlhrTnRONWVtMzBYL1BUeXYwYk5laTZyZUJQaGZHN0g1cGJXT01mVTRGZVhrOFlCNE5OQ1luYXJOcmRlUmFYY1FiL1hvRXg5R0IvcFZjQ2w4bHpFWlFoWkE0VEkvdll6aW1TWDdyU2pCb2VuWHlaSnVua1EvN3lrWS9UK1Zlc1dHaHJiUmFOdUEzV0VESitMS00vd0JhcDIzaG5kcDNoKzNtVWJMRW1hVmY3ekVjRDh6K2xkSWFsc3BJS0tLS1JRVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQmgrSmROKzNTNlZPRnliVzlSbS8zU2VmMXhYQ2VQTlAyZU1TUU1DODh0Z2ZjNFUveXIxY2pqdFhLK085TE4xWVdtb3hydWxzWlZaZ092bGtqUDVVMHhOSGxrOExXOXhMQytROGJsU0Q3SEZSbXVtOGU2YjlnOFJ2Y0tQM0Y0UE5Wc2NaL2lINTgvalhNNXpWRWkwVVVVQ0VOYm1pNlpaM1doYXZlM3UvL1JVWHk5aDUzazhEOGF4RFczcGJodExoc2MvOGZPcFJnajFWUVA4QUdnWS9VL0IycGFaYXdUemVTNnpsVlZVYjV0emRGMjl6Vk81OE9hdlpsQmM2Zk5HWkhDSU1mZVk5QUs5RG1rR3FmRWFPM1A4QXFOTGdNZ1hzWkQvK3Y5S2ZZeUhYUEcxeGNNU2JUU1Y4bU1aNE1wKzgzNGRLVngyUFBoNFUxMXp4cFZ6K0s0clQwMzRlNnZkekw5c1JMUzN6OHpPd1ppUFlEK3RlaVdlcUxxR3MzMXRBY3dXUUNNMzk2UTlSK0FINjFva1k0Rks0V0tPajZKWTZGWmlHemlWQVI4N25sblB1ZjZWZUhXczdXTG94aTB0RS93QmZkekJBQjFDajVuUDVEOWEwdXZJNDdVaWpDTjEveE5OZmlKNGd0WXpuL2dEVnpmajdVTjNoYlNiY25MM0twSzR6MlZQOFRRK28rWmFlTWIxVG56cEV0WXo2bmxmNjF6ZmlPK1RWTmJpakQvNlBicEhiS2UyRjRZL25tcVNKYk5meGRkbTM4TWFIcFA4QUdJRm1rSHB4d1AxTmNiakZYOWExTnRYMVdhNjVFYllTTmZSRjRVVXVpYUxkNjdmcGEyb3dPc2toKzZpOXlmNkNtaEZSYmFaclNXNUVaOG1JcXJQMnllZyt0ZWdhQjRVWVcra1IzTWVBck5mVGc5MklBalgrdGEwbmhpMi80bG1seFJrV0ZtMzJpY25ySy9SUWZVbmtuNlYwbzY1L0twYkdrSFNpaWtBelNLRm9vb29BS0tLS0FDaWlpZ0Fwd3B0T0ZBQ0dtMDQwMmdCYUtLS0FDaWlpZ0Fvb29vQUthNkxJakk2aGxZRlNEM0I2aW5VVUFZbmlidzlIcm1oRzFqQUU4UHpXNVBZZ1l4bjBOY1BCNGNmVy9DL21Xc1JqMVhUM2FDYUk5WkFPUngvZXdmeHhYcWRWRnNJNHRSa3ZZZmtlVkFzd0hSOGRDZmNldE5NVFI0VVF5a3E2a01EZ2dqRkZlbmVNdkJvMUpXMUhURTIzZ0daSWw2Uy8vWmZ6cnpFZ2htVmdRUWNFRVlxa3lXZ3ExcDkxOW12N09SdnV4VHJJZnpHYXEwaDRGQWowcnc1Y0FlTHZGRnkzSlRMQSt3Si93cGZDdDcvWm5nUysxUmptWjVKWmNudTNRVnkzaDNVMkUyc05LMzd5NXNaUHhZRC9BUFhWd1htUGhXWWgxRjRJejlNN3FUUlZ6cHZoeEczL0FBajgxdzUzUFBjT3pNZXA2VjFwNDVKQUE1Sk5jMThQUi94U0Z2OEE5ZEpQNTB6eDVyTDJPa3JaVzJmdFY4ZkxVRHFGNHlmeDZmalM2ajZDNkJPK3YrSUw3V0NNMnNIK2kybWVoSFYySDFyVThSNnF1ajZKZFhURUJ3dTJQM2M4RC9IOEtrMFRURTBqUnJXeVRHNkpNdDdzUmsvcm12T1BIdmlFYXZxUXRMWi85RXRTUmxlanYzUDRkUHpvQXpMcTVNSGhhenNneE1sek05M0w2NCs2bjhpYXlNbk83UE5PZVY1Q0RJMlNBRkhzQjByUzBIdy9lZUlidnliVmRzU2tlWk1SOHFEK3A5cW9rajBYUmJ2WHIxYmUwajkza1AzWXg2azE3Qm9taTJ1aGFlbHJiTHgxZVE5WkQ2bW5hUG8xcG9kaXRyWnBoUnk3SDd6bjFKcTlVdGxKQmdaSnBhU2lrTUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNuQ20wNFVBSWFiVGpUYUFGb29vb0FLS0tLQUNpaWlnQW9vb29BS0tLS0FBMXlIakR3WU5VVjczVFVDWHdHWGpIQW0vd2IrZGRlRG1qNjBiQnVlQU1yUnVVa1VxNmtobFlZSU5OTmVyK0x2QjBldW8xM1pLRXYxSFR0TVBRKy92K2RlV1RReTI4elEzQ0dPVkRoa1lZSU5XbVEwTmprYUo5NkVoc0VaOWp3YXR3MzIzUjdxeEorU1NhT1ZQcU1nL29mMHFuMW9vRWVxL0RlVGQ0V0EvNTV6dVB6d2Y2MWpXODMvQ1RmRXNTTWQxdlpFN1IySVRwK2JHby9BZXFmWTlFMXhUOTZDUHoxNS8yU1A1Z1V6d0pjUjZUbzJyNnpjY2xBc2FnOVdicmo4U1JVbEc1NCs4VE5wZHAvWjlrK0x1NFg1bVU4eHA2L1U4MTVhT0J6MTlhc1h0N0xxTjdMZFhEbDVwV0xNZjZmU3VpOEplRFp0Y2RicThEeFdBUFhvWmZZZTN2VDJFVS9ESGhTNjhRM0liSmhza09KSmNkZjlsZlUxNjNwK24yMm1XU1d0bkVzY1NEZ2RjbjFQcWFrZ2dpdFlFZ3Q0MWppakcxVlVZQUZTQ2syVWtGRkZGSVlVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJUaFRhY0tBRU5OcHhwdEFDMFVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFDdWI4VytFWXRlZ056YkJZOVFRY09la2cvdW4raHJwS1BvYU5nUEFwb1pMYVo0TGhESE1odzZNTUVHbVpyMW54ajRVajEyRDdUYXFGMUNNWkgvVFZSL0NmZjBOZVRNalJ1VWtVcTZraGxJd1FhcE1ob3QyTisxbDlwQ2dsYmlGb1hIcUQzL0E0cVdmVUdHZ1dtbklTRUVqenk0L2lZOEwrUUg2MW4xMDNnN3d3ZGZ1VFBjNVd4aEkzZjlORy91ait0TUN4NE44R0hWMlM5MUJDdGtwK1ZEd1pqL1JmNTE2Z2lMR29TTlFpS0FGVlJnQUR0UXFySEdzY1lDb29BVlZHQUJTaXBiTFNGb29vcEFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZPRk5wd29BUTAybkdtMEFMUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQW5zUlhBZkVMdzJ1dzYxWkpoc2dYQ2p1T2dmOEFvYTlBRk1saFNhSjRaUUdpZFNyS1IxQjdVMDdBMGVHNlRwaytzYXBCWlc0TytVOG4rNk81L0N2YmRQc0lOTXNJYlMyakNSUktGSHY2bjg2NWZ3VjRiYlJyN1U1WmVTc3hnaFlqK0FjNS9ISS9LdXdvYkVrRkZGRklZVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZPRk5wd29BVEZKaW40b3hRQXlpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEyaW5Zb3hRQTJpbllveFFBMmluWW94UUEwREZMUzBVQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOb3AyS01VQU5vcDJLTVVBTm9wMktNVUFOSXAxTFJRQi85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL3RoLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFMUUFBQUJUQ0FZQUFBQTJqQzBJQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBDTmtOQk5rSkNPRE5HTXpNeE1VVTJPVVZFTkVSQ01UQkRNakExUVRRMlJTSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZOa0pEUkRkR01qTkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rSTJRMEUyUWtJMk0wWXpNekV4UlRZNVJVUTBSRUl4TUVNeU1EVkJORFpGSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tJMlEwRTJRa0kzTTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrMFkxbExRQUFIZjlKUkVGVWVOcnNuUWw4Vk5YVndNOTdiL1l0ZThoT2dFQklTSUtBaUlDeXFWaDNySHVyVmR0aTdWZC9WVnYxOTMxRmEyMjE3cldmV2orcnJWbzNCTkZpcmJ1eUNzZ21rQUFTSUdSUFNDYmJKSm5KYk8rOTc1NDdrMG5lTXBNRWczWGl1M0IrTTNsejU3N2wvdSs1NTV5N0RDT3VYUUFuTVNVUW1VdmtWQ0xUaUV3Z2trMGtrWWdOdERTV1V5K1JMaUpOUkk0Uk9VQmtGNUZ0UkZ5amRSTG1PcWZrYngySW8zNGpPVVN1SXZKOUluT0ljRnJkZmllVExTekl3Mm1EanZORXRoTjVtOGliUk9wRzg2UTZHRDJpVWRYZlNlUThEV0l0eFVqSXhyeXdQRXprQXlLUEVkazRHb1d6bzFER0lpS2J3aGQwb1FhemxrWUlOekt6SWN6UW9xK3RvY1VUVjlDWmdnaVBzUXo4WUtpTWRjNGc3RG5taDhOTkFhaHI0Nkd4UFFoZGJnRThQbEdyMGpHWUxFWUdFcTBzWktmb0lDK1ZneWxaZXBneDBRQjVhYnBZWHp1VHlIckMxT3VFcVR2SSsrWVRzcW1GdDg4WThaZDRBYTdrV0hndTdQU3BwcXJqUWZqM3pqNVlYK0dGNDEyOFZzdGFnb3hFRGhhWG11Q0NVODFRa0JrVGJoZGg3Q2JDMk9vaFRZenIyMGNHOUgxSG40Mjh2N2ZnWmdOcFFYOGlMZWdYYW5sUjIyK3I5TUdMbi9WQ1JXMGdjdHhnVG9DVXJGSklUQzhFYTJJMldPemo2REZPWndTVzAyczFQWWFTd0FlQUQvckEzK2NDVDA4THVMc2FvYXUxRXRxYkt1aXgvbFE2WGc4M0xMSEJ2S2xHWUpnb1pZbndGOExhcjQxWGJmZjFIL090bWpNRTBHL0ZCdnAzWWFCL1YzQ3puUUM3bHB4OGlWcStRNDBCZUd4dE4reXZDNEdzTjlraGUvSml5SnkwQUJMU0p1R3B0TnIrVGljUlhNNHFhSzdhQkkxSDFrUEEyME9QbHVUcDRZNWxEcGlhcmE3WUNIT2JDWFBMakZkdjc2QkF2eUVEK2dZRjBQTmpYc2E5UjU2Rit5YmZuRVlLL3BBVVBGUCt1VDhvd2pNZjlNTHFMUjVzVVdDMEpFRis2VExJTFZwS05MQkpxMGN0S1UxV29zRWJEMzhHeC9hK0JUNVBCeEF0REpmUHM4QXQ1OXZBb0dQVW9DNG43SjF0dkhxSDAvZkdhVEtnTzZSQTgwTUFqWFl5QVhVRE9la3A4Zy9xaVlOMzkydGRjS1FwQ0F6THdmaVNpMkRTakt1QTAyc2dhMmtZWUFlOFVMVm5GZFR1ZnhkRWdZZkpXVHE0LzRlSmtKdktxWmtmK3dpREMwRTJLTU1wZ0Y0ekw5WTVEY1E0LzRnWTU0cHdDcG9XZDd6a2dtNlBBSmFFVENoYmNnZllVeVpxdGFTbEVhZWU5bXFvV1A4RXNiZnJ3V0ZoNGJFYkVxZ3BvaEtNMkVCWVBCY05nd2pRTjNaSzhuRDNYcGtiSzVyeE5Dbmdjdm54YlpWK3VKUEE3UGFKa0RiK05KaHg3ajFnc3FWck5hT2xFMG9HY3lKa0VYL0wzZFVBblcwTjhNbGVIMHdoTnJWY1V4TU5uVStZVENPdjcvVWYrLzA3WG1rZUdwcFFrVDZmY0RYSGlEZkxqeCtvODhPS1YxM2dEWWlRUFhVcGxKMTFGK2owRnExV3RQUzFFcHFwWldmZFNabEN0cEF4WkUzT0h6SkoyTHdtY2t5V0dQN051WXFESFc0eE44bkNWQkJEWEJKbmJtam5ZZmt6WGVBaVprYk8xSE9oY041TldrMW9hZFJUNWRibm9PSFFSOFQ4WU9ENW55Y3BORFhoMk5YbEVjdVNyRXdkOStNdWFjUDQ3UlU1a2dPNm43aVkrNWFaWGlHbVJ0bmc0NEdnQ0xlLzFBTk5uUUtrNXMyR29qTnZBUzBVcDZXVGtaSnpaa0J2UncxMHRqZEJlVzBRenA5aEFGWTZTY05Fekk0QzQzTFhHL0x2S3VaeXREL3RPTnVnZzR2a3g1LzUwRU9qR2RhRWJDaGVjR3NzYTBVVFRiNldJRnZJR0xLR3pDRjdDcnViTU5yeHRHT3BDdEJZUWtpSWRtYk5ldmpENEdNb2xZMEJlR3U3bDRibWloYmNCaXhuSkNjV05kSGtwQWt5aHF3aGM4Z2VNaWpuMHFTSCsrUkttUjJjcCs0eCsxa0dEdVlNUGlZS0FJLy95d01DZWMwdXVnQ3NpZU0xTGFMSk55TElXazdSaFpTOVA3M3JvU3dPWmhOWnJYN0VkcmJFWkJiRG5xSitlUS9yK292dFRybmp1SzB5QUFjYmdtQXdKMEZlNldVZ2l0b01PUzE5Y3ltMzlQdlFjbXdUSEtqdnBPSGl1WVhTK0hTeWxjN00reFRIWGlRMjlJZS9zdVNZOVl4aW5zWXJtMEp4dnR5U1M3V2hiQzE5OCtFOHdseGU2ZmZwKzVjM2VSV2ZJN1BJYmtSRDk4Znlpak9aSHpFZ2NvTVhzRlMxOExDL2ptaG5veDNHVFZxa2FXY3QvVWRTK3NTRlVMZHZOUnlvNjRHanpVRW95QmdJNHpHRWVXU1h2TDJmYW1oRVZIOVRyOTVoWmk0UlpXYjNSL3VJSWM0d2tEcmhUR0tjR3pTN1RwUC9pQ0I3eUNDeWlFektPVVYyRWVQSVNPR2pWeGpTelRweHByeWtUeXRDUStacDQ4L1FQRzlOL3FPU09qNDBpVzdkL29DQ2VHUVhHUTZaSElUeEpWUFpCUXdqU3NJZjFhMEN0SFdMb0RjNXdKSTAvanRsYnBRV0RReVFlanhCcUtwMUsvTFlyRHFZa0dlVkhITzJlZUc0MDZmWkNDY2hXWlB5YVdEQzJkMEo5ZTA4NUtZTTRFb1VONHNNazdjcmRZYWZlYmlqZnpUUGtpLytycWdMTFp0eXBFOGpNSStORWNFTHpzNkVzeGRtUzQ2OStQb1JLUC9LTldoWVZZUWJyNWs4MExEcnV1SEo1eXNWbzZLblRrK0NpNzgzWG5Mczc2OVZRbk9yZDlnanFMY3VMNVErODRPZHNHNUw2NGp2YTdUSytYWW5ockJZREcyMVcyQnZOUUU2V1RvbW1HQm1acE9YMWJpd1MyL1NpOVBrK3Zkd00wK3J4WlpjQUdOQk40dWlBSUlRVkJ3UENnSDRKUUdDR1pSdmNNcE10OEF2ZjBvK0Q2OFRldmZqQmpoUzB3T1Q4cVhhdWJPckQzYnVPdzRHZ3hsWVptaWdKK1NaSUQvUExqbTJkV2N6Q09UOERLTmNqRjgycU5kd0QrbzFlSEpQOG5JT1YzVkd5bGt5UHgwczVnRW5hc00ySi9TNmczR3FwU2RDT3dINmFBdVB3NERTc1hDOVdJUXM0MUdEVWNma3lhbXRhd3RWck5HV0NhSVFuMGlYRlNkQVhyWTFEQ29QRTJVUWhyUjJEbVJsMktPV1lUSVIwMks4WXlCTVpCUWhMWW1GYVZOVHBlWkdlemRjZkU0V2VhSW05R0pDejdEUkRlVUgxVFlKRWlFNVFRbHR3UVFycENhYkNJZ0RBUGIxQmVIVHpTMndlUDQ0eVhYY3VtSUgxVnArdnpLVUZRaDZJUmdNQXNkeXNHRHVPRWhNTUVZK2UrZkRlbURaK054cHdtakxvSy8xeUtZTVNjb3dIUkVuVkJ0WU1VMmVvZFVWQnRxYUhwZjJNMTV6YnBZSnpsbVVIVE5mVm9aalJPVm1aeHBnOGtSbHc1Z3lhUnlWd2VuajlYV3dkMzluUkx2M0o5U3F5WW5LVmMrbnpWUmVhM1d0Q3o0ZzVkUTJkRWlBTGltMFFzVWhOd1FDZnNWM2NLR3F3QWZCYW1Fa01CK3RiZ04vd0FkR2d3bmljV0taMFJwNnZzMmRnbUxxcUlHRjlINE5yZU00MFM1SHRyc3ZaRzF6eGdTSVIzK1FGM2lpcGZ5alh1NTVaeGNNT3krZUg2K0RZM1V5NEFRb0xFZ2VWaGxvSm5sOWZYRGtXQXNzbXA4Zk9UNTNkaHJWNUJXVnZTcjZYNlRyT3hmUFM1YzFEaWNFQ2V3RzBSeWZneXlFUldTU1dIZjBIaVdmY1lCYVJxZWpnekVNbU9RYXVzOGZhc1A5RTVIaURtaWlvWGgrZUVDdlhyc0ZsaXdvSmQyOVZGdi8vdEUzSlg4WEZlYkNGUmVmUG9KcjhOUHJZQWVaRUU4L05HZEU5eUdRQnNFVENMLzRzZ0dXWHpmdzNaS2lkQ3BQLzYxSHphS0J2ejZtM0lTenhka2RtcDhUcHhFclpCR1o5UHBCWVhJUWhzMlVaWWpNdUl2ZWRjZGpFZ1FCZXR4ZU9IU2tNVFREaXFUVTFBUUZ0SFVOVGxqMTdoNDQvZFFwQURLbHVXRjdQYVFsMjJEVmM3RVhNaHc2WEsvaWxMUDAvSGdkL2MrUUY2STdZN3YzSG9XcW11UFNJa2daUGg5SHpZTmV0d2oxalcyUW15MjEzWU1xalZidTJQYW5MeXRhU1ptMk1SS0NWYjBIMmhjeXNXNHdmdStkZ2JjL09BSXZyTnBNN0VZdnZmOWJiamdEcmx3bVhlWCt5dXF0TUx0c0V1VGxwQ2xLV0xmbVZ6SFA0T256d2I4LzJnVlB2YlJaWVNjYjlDWklkR1JBRXBIK1orano5VVV0Ni8zUHl1R3pyZFdTY3RDcHMxdFRJTkUrampxYjZ6WWZnZ3VXbGtrYVpTRGdVekczZ2xCNXREa0V0aGdhVC90azQwR29iL1pDa2owQnhnTFBVWmhsZE5GaGoyOE5qVUFiOUdhd1daS3AzWWkyS01zcVZ4SXZtbDhNWCt4cUhIYXBhSjc4K1lYMUlYVkFUQWtFRjgvQmtjN3VsT0owY05oQ1RoaEdFbngrUGRUVWk1Rm5pTmRSZVFSRGMxSk43V3pyZ2EyN25RUzJjZElJQklIYmFMQ1FzdlcwakRmZk93eC9YN1dGbWpGb1E1cU5kakFaYlhEbkxVb04vVi8vc3pyVWtPbDFNbUF4SnhCSE5KdHEvVEdob2FQY2dpN2FwLzJhSW03dExWSnhGcU9EUW8wVmpBNGF4eGtVK2ViUG1ReGY3RzRhZmpNaDVWNjRlRHA5WllnKzhQcFlPRnJqcDQ3Zml0dlBBck5wd0FIYy81VVRubnora09RWjN2cmJ0ZUR1YzBrYW5vbEFpOXJjYWttVTJOdFlCM2dlMU5Ubm5aTUZaU1V6aWZVVURKY25odUxWS2pIdlJmT25RbWxSN2tDOTBuSTRVcllPSHYzTGdiZ0dlcUFIRTZNREhlc0doVGpXMExodm5pRzhkeDdMZU1GbU5VZU5KQXdub1luQkVjZmtON2RMVjZqZCsvQk9BaU1yZ1JuVHdVb25qWEwweDZXeGg3anVzdE5JUG1iUVZZYXVVOGVacUNhV2g5TThmVUg0WUYwam1NMDZtRHd4ZFZqWG1VTHNmaFRWeUF2UHgyMGNlamlXZys1RXZ4aVBEMkRXOUJ6Vnp6REcrK1k3MnduWXNhTWloNCsxd1JkN091RzhzMHNKbEFQbXk1eVp5YVRoSzNkWTNiYjdHREVQVEFRZ1hkZ20xc09jV1JPZ1lFTHlzSys3cXJvTC92VnhOU2xuZE9hSW9CbUNac3hZVGJxaFBMK3hNaWNwTzhNRXlVbktBUkVFT1RjckVhNjRaSGpodEllZi9BUjI3NjJHTTA2ZkVqbTIrTXc4YUdqc2trVlAycUM2dmhzUzdPYklNd3hGUElTUlJXdUl2WTJESjd3d09zUFZBV0o2R2NiQ1BpcGlUSk5EcmNNZVN4cGFoTkxpbENoYTF3bDYzZkFyR00yR1BSVjFFcUJSVzArZUpJMlNIRGpVU0NNVGFCTVBPSVYrdW9mYmlLNGNCNGg0djJvbHZmSFB6ZkRFMzlaSC9lNUxUOXdJUlZOeUZUMVZYTnZRUXloYUhRd1I1aGdMUU9QZ1JOSGtKTlhQT05hZ0NMa04xVGplVzFjTlA3bldCeGF6TVdxdXZmdWJpRjBjS3J2L0dhS0dycTVEdXpxMGdqa3RKUUZTVTZSeDhiYjJibkMydXlMVlY5ZlFGZExzcW82dkRzekU4Vlc3ZmpvNUNSalYraHpEY2VnWUprY2t5aEgvdDQ1aHJpbVQwcUpvWE4ySTdoSHo2blZtMkxYbkdDeVlWeFExMytjN1d5RFJrU21iZXN2QUU4OXZoeDUzTzRYNnRwOHNoS3N2bGU3UC9lbW1jdmp6M3plR25FVnliUmlIUmxGdGpNUkJUVW5NVVkzZStBTjlFV2RVZnYxeFhhZjlqVmNjY1pTRGlXaVZlRStGa3l4Z051dUgzZG8zZkY0QjZ6OC9RTi9mOTk5WEs4SkdPcDJSYU9ER3FFRHYzbnVNYUdjakRaVkpueDhMUm1LL2lwWlFHSkZsZEtwYTEycEtwREN6YkNnL3JRdVZPbG8wdnhDbVQ4dFhuVzZLVG1wT3BsM0ZoQkhHUkoxR1kxWTN0SzBTN3lwYWhMTGk1Qkg1RmlWRjR5RWpQU2xLcDBZZUdqRlQzbHRYQXorOVR0M3NPRmJiUnFGblFEcUlnYkZxaXprSlRFWTdjYzU4cXBvVmp5WFlNeUxtU3FnSFVUYzVVcEt0VkVZS3dsaXdvVThneWpFMlRBN1VSbE9ucEk3SUZFTzdWbTdiRG00QTZCaWlJN2x6VHhVc25GZXN5UFBaNW1vQ3I1VStRK256WTJIbFg3OFg4M292dTJnbWxmNTB0TG9MN241dzI2Z0dCOGFHQ1IxRFE0c3huRUpCaU8rN3QxckVxUFp6YkhjNHVvWmpnQU05WjRLOUZRMEtvTkdwcTJub2d3U2JRL0hzaEJNSXZZV2lITHhxQlZJSHNpMzZyd3lQejB0WDlDQTRVQmJ2ZFJxTDJhaHpPZUo5NkxzL25UbzkrUVJhZW14elc2U21nUjYyN2pvT3QvNU0rdkdPM1ZVMFhNY01DdGYxSjErZ2IrUTlqQmdrOXJaUHRmbysyYkFQSG45K3ZYbzBnL3g3NVg5dmdLTENQQlVOUFFhR3ZzVVJteHhqb1ZjU1lFS2VZOFRmTzFoWkIvdjIxOUQzMTF5MlFEM0NRTXlPN2w0bFNDWEZlY1IrcnFFT25iSzM0MC9vSHFKOUQrMXJLN0hKV1ZicEN1R3FGYlVveHhpcTNCaFJqakZxY3N5WmtRUm5uRDUreE41eXE5TUZoNDYwcUtvQnVocUVQQk9jL0RTck5GUHhlVjVPQ3VUbk9LQzVSVlI4SDc4My82TEh3ZU1ObVFsMzNYd1dhVEFMSlhsV3ZyVVJIbm4yczRnVGFiT2tFa2xSclVDV09LY09LenFReWdnT2h1MFlZRlhyOHp0cGNrQ2NSem53dWllTXQ0SFpiQmp4ZHhlZFVVb2xtbWFna1FMeWRsWlpwbXFXaFhPellPVS82eFUrT1RZQ2c5NGE3dllGeVdMWWdTNlZBNVBCVGtOeE9Ja0lZOTVNRkUxN3hTV3pxSHlYb2h4RE9UOVJUWTZoaGhpLy9kRU5ua2hBY3F5MnZoWEc1NlovUGFjdy9FeHdKQzQvVC8yWG9XZWRrZ212cnFsVnpHckRHWFVPNnpnUXpEemRQb0ZqalNxbWpCRVNIVG1ndzduYlRHZ2tNM1lmT3ZJYmlHZWVtZUdaSExIRFh2R1lnbnhRRWxWb2EzZkIxdTFmS1lFK0FhY3dOTW1JaDhMSjZyLzhsWnVkQ0hZclFJOWIvdXpZeUx3UmpqaDYwVFMwVVdlbGNlekl2WkM4bzBXaE1GWUdWbUNrVG1HY1J6bHdST3pqalVlZy9PQVJxcWwzbFRmQjlWZk9IZjZUaVdHNzRUTXBuZW9BU3d4elpzbVpHYkQyZytPeHUvNm9QWURVTElpVzkrQWgzQ2FoT3VvNWxpNCtCVkpURWxTdlB6NHJsYWRjNmxnbHM4UXRDRWFBRGdxaWwyU1NiUDVzMW92UUYyQ0l0MHcwQ1dlTXgvZ09IS3Z6UUhsbE81MTZpVjI0dzI0YjFsZGZYN01SSG5ybUUvcStmTjM5cWxEUEtKVU8xbmc4UHJCWUJwNVRTVkVxdlAxK1UxVDdWeHpLckJsR1hvekVQUGJjcHFpVGtFNHBuYUFDTk1UdFRsaGllRTY0MmFDOGk2QUEzZ2pRL2dCNGRBWXAwQTd5bDVlWW9FS2dtOWlDcVhGNCsraUEyV0JSV1FiY2VNME1hbjNsNWlRT3kxdkdibi94NlVWdzgvVUxGWjlObVpRQ2wxODBIYVlVU0ovSjJ2ZS9nQjljUHBCL1Jsa09QSHlQR1Y1YmN4akt2K29hdHJOOXdkSVNZbXRiNkxUVERWdWJvYWJCSFRVdlF4cXAxWndTMmZkamR0azRTSENZd3FaRkVOSlRFOGVVVXlnRTNiVHBXZzNLVmhrTUFnYjVSWHdTb3RzUEhVUWpTMFlnMG13Q3RQWnd3SHZiZ1RIRUg5Q29HWFU2RXlRbEpCQmJkOXpJbWdKeHhOSlR4a0ZSWVk0S0VJSUNaa3p2ZmJvZjVzOHBrdGpvVXdwU3dHYnRuOC9CS0RSbFQ2OXlGUXFhTVpkZU9KVytQM3lzRTZycmUwTjFKNnBkSndLZFN1ZDk0RG1XWHpkZjlkb0cvSWp1dUI3NjVyMXQ5RFhWS2lnYXBkdlBZQ3lVYnFFcmRIdkZGdmt2REdVbmhSd0h2cThsVHZjVUR0bFo4a2lIUE5YV2R5a2VUclRGcC8yYVR3MlV3elZ1S0Q5UXAzUk9pVU9IRVJlMWF6eFlHWHVIVU55b1p2QytIa3FQbjZVRFBCZ0pZVlZHSnVXcHBzNFoyV2dtSG9YdkN6MnZFSnRTWG50OElqb3NBbXBvdnFXYnFaNllMRW8yckppWUVnYmFVeGZYbTgzRVdpZTQ4cTNQQ1lndXlNdEprS3ZoMEVpYkxPRWkyWWFtZHNreG5Jei8xSE9mZ0pHWU4ydmVyWUM1c3lkTDdGWThQMTZIWXVTUVBOS2Q1YTN3MkZQdnd2bm5sRWtEVS9RL0I1MnU3a2hqNk9uMWtnWlFIOWswaDI1a1E0NzFWelpkRFNOR255dUNOdjZyYis2TWEwZWY5elRRMTBtcHlzMGFDY00xK0xnWnNCZWwvSG1aNzZiclp3Zi9PRGhEWFFjTHQ2MnhBYU96Z2FWNEJjVGo1bjZvVGQxOTdlQnlONFBmSDlwK3RuUktPa3pNUzRVZCsrckIxWU1qY1drMFg3ZW5oZWJCZVJnV1lwZU9TN1pBeVZTYlpISHE3b29XNkhBSmRIZlBRTEF2dFBjZlRnazFKVkh4Qnp6UTYybURBTytsamNKZ3NFS0NOWlBhdWZMaGFaeXY3UFc1b052ZEFqNS9yMkt0SWE3N3cxRkFMQmZ6WXJtOWZjNVFDQStkSDUwUmJPWTBPcEtJYzYvOUFUY1VUOGI5TjRJMHBDaFB1eXVhb2Nkam9YRndIS3lKeDBDZDU2c0hRU1ErM2ROWDlVSldndlI1L1dPbjdqZTNyVFUraDA4NThPb3UvYTRmelFvS3pLQ3gwanlpMWxNc0luUjRla25MYUFUV25CMlhzVXJzamcwNmEyaS9DM0xnY0kwSEtxdnI2T1Fpc3pHQlZpNXF0LzQ4bUI4QlFYQS8ybFJINGUzWG5MakhCd3JDMmIvbEFPWTFHeE5KT1ZicVRPSStkRnd3NUxYUXJRbnd0MmxVdENJVGprbGJUTW1nWTQyS1ZlTllibWkrTk4xaGtKWmxOaVFDcnd2MUhHaHE0REdJekxsbVNTTjEwa2FpWElFZXVuYUx5VTRYRU1TamhoYjZHZ21wM2RSK3puSklOVFIycUN2MzZIWWh5d2kwZjFjRGUveDREMVJsT3NUSmd3czVvOEFQL3lvM0F0KzVCeGhUVmh5MmFvWkNZeWRhU2FUcjhrU3F2VkFiaHVZMGg3WVlZQms5c0ZZZHpSTWFjdGFGOCtnaXE2MnBrNG0yS240R0FzMkxyTkZHd0Jrb0tQaWV0ZWhET3lQUkg3dGhLYXloZWRHaXFsT0hqUUhORmJtR1ptampvanUxVWZneEQxNXZmejU2bmVTYy9Zc0k4TndtbzRNMkJIbmtobDQ3dVVZOVoxYWRCUmdYNWtiWFh2bzZmMUpBNFNFZjcyR3F0dGR5YUVQN3FZWW0wcnVua2QyV1lROUtnRjdRRDNUWEh1RFN6eUUxb0krLzRCMkJ3akNvdXcrdC9oQXBDUDFURVJFOGc4d2t3RXFuR2xJY3RQdlFvTytvUjFZNDllNWNqRDU0VFJzQ0YzMTdsSDc0YU1PTHNzQ0l6dEhHYmNsSUw2SG5MTXFReUtCcmowdjdtVGoyZk9lWEVTYmw5N0Nua2NNVkVMMVVRM2Y4dm9kUC9xM2QvY3dXdzRmblRnbGV5dzR5Ty9LVGVDZ2NGNFRLRmc4RVNZRnMwaHlJLzhRT0REQ0lzYlU3NmRobFVIN2JRMTVzVk52cjIzL3RNWGdtN0ltOGg3S0lUQTV1cnpoNUVObkZ5QjBxY2wzNDA3NHROZHl4Mms1bS80UmtZYkRMRFpkTjk4S0RIOXRBYUZzUGpPTVU4c3dNb0NVdGZYTTArMFBzaFZtVTl6NjFuZXgrWkJjWkRqWHAwT2VZcy8zMUwvVnI1YjlxT0NNbkFBVnB4Q1lNOXRDQ3RhU2xiNVRuOXZXVVBXUVFXWlR6U1prbDdJWVp4bCtTRmFIOVBoZmEwYTdITnhrM043aVlLaEVHL3VHM2ZqclBRMnc0WW45MWJRUFIyNlQ5RUtRbTM0d2dhNTNiS0h2SUlJQW8rWWVzSXJQSWJ0Z1hER3Zva0paR283cmxsZDJHTmZKV01ERTVDT2RPOWRMWlRrTFRhanBKUlB2SlhrMU9xaERHaE9iVmxEbGtEeG1VYy9uYWwvbzF5R3lZM1g0dklrSTBSdXlkajI0MGJxaDBzdnZrMzc3MlZEZE13RUlEN1NBZXgzSjRVSnhCRTAxR1JmZ1FZLzUyeWh5eUo4K0RqRDY4d2JRQm1RMnpDeElOM1g1dkZ3WTR1NGswM2ZtZStVVWZ6bDRhVklhZUdDZTNMZXdCbTBFRXhsMEowUHErcGtVME9TbUNiQ0ZqeUJveWgrd05aaEhaUkVhUjFUQ3prU0ErZDlmU2dUbkNqMncwbzlvVjZydFlKc0Vrd3V6YzRNekJCcnJOS01DMHpBQnNxVFlDMzlkRWpYWFJVaENYdytKYStsYTZnTUE0L3cxTTl5NHc2a1JZc2RRRmVVbksrU2wvM1c1NitlWGR4blhrN2JFdzBLSXEwSGN0OG9vRWFqU3VtZlZWK3A0RkU0UFpPUW1DWkdPSFpJc0ErYVFiMkZGbkJNSGJUTHFGRmhETmt5TS8xNklsTFoxb2VJNXRmUXVZM25MUWN5TGN2cWdicG1Vb0o0aDlVYWZic3Z3dDZ5dms3ZUd3L1N3aG5ydnJIT25lYUFSb1ZOODRSWTE5NzVDaGVWbXhyeVRSSkowcm5lbmdvVEE5Q0x2cmpSREErZEx1Z3lDYThrRGtiRnJGYUduRWlTRktrVDMrS2pEZVdyQVNNK1BPSlM0b3kxTE9rcXpyWW85ZC9BL0hrNzRnY3dqLzdBL1Z4UnhhYXZ0dGh4Z2VkYWwzZVptalAzekQvblNibTIyVzU1dVc0WWNIenUrZzJwb0pkQURYOURkZ08wa3ZJQWExR3RMUzhCSmhCWm5obXA0bkREa3BTOGdVc3FYZ2tqRDRnNVgycDVCSlpCTVpEYk1xYlJ6T1I5UlhMcWY5SVFVbmJ1QlNqK0tTak9EMFZkZjAzSlp1RXhRemxBSThBeXYzMk9IRFNrdklxT2ZzSURqbWdtQW41amVqMXlwTlN5b2dCNER0M1Flc2F3c3dmRGRkUzdGMGlnZCtPTE9IbWh0cU1GL3h1djJKL2NkMTVlUlAzT2U0eFhsUGV5RE02ZkNBRG1mR3FXSUljVkZ1b2xENDlyWGR2OGhQNGllcDVhM3UwTU9MT3h4d3RDMEVzY2hhUUxDV0FrOUVOR1JxbGFnbFlsbzBBK2V1QUpZSUkzam9zWUxVQU54NFdqZE1TRlpmV1ZUZnhWWmZ0ZEx4ekpFMjdpdnk1MEdNYkJDWWZZTVlsUU9kRnZNaTB2NlFpcE51Y1RKMEliR2xKNzU4VmZmVmMvTUM4MVViSHBHOWpVWjRaNzhORGpzSDVueUluQlZFWXo0SXhtd1E5U2tnNnBJbzhNQVl4dmIrYTk5SjdZdHpsZjBVV0NiWVNVeUpkbUI5amNENGFvZzJka2V5VFVuend5VWx2WEJLdGk5cWpHeGJuWDdyajFZNVZuWjVHWXhtVkJKcGRON1Q1cFh4S1FQNjRiUWhyekh0ZmdvMXFsbWNYcHAzOXhMM21UK2Y0NzNTd0ltbWFOK3A3OUxCeGlvTDdLZzNrUzZEMHlwYVM1Qmk0V0ZPbmhjV1RPcUR2TVRvYXozOVBIai9iN3Q1OWYzcnJKdkQ5akpHTkpxZGQ3ZDVWZGdjT2REaEw2TDVnWmtuRXNtZm5oa2MvL2o1dlplUzF4bERmYmU1V3dkZnRScWdocGdseDNzNGNQYnFvTmZQZ0RmSUFpOW9GVDJXRWtjNlhKTk9vSU1pcVRZZU11MUI0dXdGb0NqZEQ1bU9vUU1HKzVwMWUzLzl2dTF0OGxwTC9xeUJVS3paU1dEMlJlRlNCdlJEdzkraUlPMkJORFNRY2JNSC9LMndDVVRTbDgvdUsvbjVuTDd6Y3hQNGZLMDZ0WFNpcWQ3RjFUeTd3L3pCY3p2TUZlUlBYTjVkSGRiT1hjNFZ6a0FNSnFWQXR6NDBzajAzMGg5SVE2UFhHbzZBNUlXZHhzUWZuOXBYL09OWmZZc21wL0pUR1czb1VFdkRNYmZKZitMc0hYcGh0M25EQzd2TTZQRGhqanc0bkkweFpodzBjYmV1Y0FwRDhQajFnQTRYZ3NDaXRzYjEraGxocHhGTGRzek9DV1RjT0t0dnh1bDVnWkpzaDVETFJGMUdvYVh2S01SQ1l6ZGIvMFdkZnYrTHU4MTdkamJvY1MwZ0RsL2pKS05HSXZnM25RNUtZQmFId2FJYzZKUVR2cmowQjlJUlZtTVk3TFF3M0ZnZy9wNllPU2VCdHk4cjlrMlltUlhJeVUvaU0xSXNRckpGTDFwTk9qRHJPZEhBTXFCNWkyTXdDU0x3QVo3eGU0UFE1d2t3N25ZUDIxSFR5UjMvc2tuZnNQYWdzYnJCeGZWQWFJVUp2cmFISVhhR1FmYTFybWdWUnNDZ0RPZ0hVNzcyRGFUL01RSzJMV3hqWTZINDA2MzRleEM0YXRRUTF1ZzQ0WU1OQ3dPYWFUS0dGVEVWSVN6b0RhSWQ3QStEakJxNU13d3ptaG05Rk9UZnRBb253SjRVYUxBWGplYU5NR0ZvTVp4bkNZc3RMSmJ3Y1RuWVdocURTbG9HTW9iYlBHRndlOFB2UGVIalFSakZEVkYxSjZGbEJzS0MzUWtYQmxqVDBKcUc3dGZRK01xZnJCUC92d0FEQUNFREl5RExPTVhyQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUxRQUFBQlRDQVlBQUFBMmpDMElBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcENOa05CTmtKQ05ETkdNek14TVVVMk9VVkVORVJDTVRCRE1qQTFRVFEyUlNJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwQ05rTkJOa0pDTlROR016TXhNVVUyT1VWRU5FUkNNVEJETWpBMVFUUTJSU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tJMlEwRTJRa0l5TTBZek16RXhSVFk1UlVRMFJFSXhNRU15TURWQk5EWkZJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa0kyUTBFMlFrSXpNMFl6TXpFeFJUWTVSVVEwUkVJeE1FTXlNRFZCTkRaRklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCsrTHB6cVFBQUV2RkpSRUZVZU5yc25RdDBWUFdkeDMvM3pyMlRtY2xra3BCTVNBZ0o0U2xJVko2aUlFaXRwYWZxVm1wOWJYVmRwYlU5SHQydWE3Vm56NHJiNDZ0ZEZXMjdxMnlyWjJVUFhjVjNzY3BLV3hjQkR5Q1VwNEFsSUFUeUpwUEhQRExQKzlyZjc4NU55Tng1WmNLazBQRC9jbjdNWk9aLzc5emtmdTd2L242Ly8zLytmMDVidndSR1VNVm9WNkxOUTV1Sk5oR3RHcTBFelFsTW8xbDlhRjYwTnJRVGFJZlJkcVB0UVBQbDYwTzR2L01rL0N5QWx2ZGZaRHphYldnM29TMUFzN0J6ZTBIS2FSanhjUG1nMXhXMG5XanZvYjJOMXBUUER4VWdmMFNUcTM4RTdSc01ZcVlNSWpZV0d2WU0ya2RvcTlDMjVHUG5mQjcyc1JSdHEzRkFOekNZbVhLRW01alpiREMwOUt3OXREWjhCMTJsYXJDSzUrQTcyUm8yZVdUWWR5SUdSOXNrYU9wU29MVmJCbTlRaFZCVVk2ZDBGTXBSd0VGSklRL1ZaUUxVbGx0ZzJqZ1Jaayt5UXExYnlMVFpZclJQa0tuWGthbUg4WG43c0dKcTliMnJjdDVJVWVGV0N3OHZHMGxmU2gzdmtPSERQNFhoazRNUjZQQXE3Q3d6UVdXSkJiNXlpUTJ1bjJlSEtWVVo0ZlloWTk5SHh0N0tHbUw4ZlhkdVFQOWorTVdCNTcrMFAyREZLK2dGdklMdVQ5V1d2UDJPaGlpcytiOCtPSGhLR25oZExDd0cxOFI2Y0k2ZkNqWjNOZGhLeG9KUTZBSmVMQUJlRU5tWkhrVlNaUWxVS1FweTBBOFI3Mm1JZUZxaHIrVVkrQnNQZ1JROFU5eTRaSUlJZDEvamhJWFRDNERqMHV4TGc1ZVF0UjhWM0xZejJ2OWE5TTBGV1lCK053dlFrVGpRdjdROVVJVEFyc2NQdnlaVnV5T3RFcXhhNzRkRFRYR1FCVWNSbEY5Mk5aUmZ1aGdLcXlaQjJxTm11akNFOEFUYlQwRFg1NTlDMTRFdElJY0Mrc3YxdFNJOHZOd0YwNnZGZEp0OWl1Z3NMN2g5WjQ4TzlCc21vTzlPQW5wUnh1UDRZZmdsK0hmNy9XN2M4VWJjOFJ6eit6RlpnOVVmOWNGYjIwSjBSWUZZVkFwVkM3OEpGWE9YQVc4dFlDZVNLZG56b2dmMzdOc0U3Wi8rRm1LQkhrQXZERGN2ZE1BRDF6bkJLbkNwb1A0YzJidTI0UFpkbnVnYmw1dUE3a2tFV3NrQ05NWEpDT3BtL05CWjVqZWFNY0ZiK1pvWGpyWEp3UEVXR0h2bERWQjk5UzBJc28yZE5hYnNZTWNpMExybGJUajkyWWVnS1FwTUhTZkFVM2VVUUUyNUpWWDRjUUFadkJwTW5US1dKS0RmV1pqcE02MFluUDhlZy9Pa2NncUZGZy8vdHcvOElSVnNaVlV3K2VhSHdGRTFrWjBscHB3VjZqZ0pKOTc5QllROUxlQnk4TERxN21JOUZFbFJqTmlNTEg2ZEFvTUJvTy9wVFdoaitjbXROWm1xR1MvaURtNDJ2NzZqSVFhUElNekJxQVlsMCtmRDFEdFhnclhFemM0TTA3QWtPa3VnZk5aU0hXaGZld3Y4Y1g4VXBtRk1iZmJVNktIcmtFazNQbTdvZisySjl5TW1ELzMybFNrL0pCelRicmRidVhYbTF3ODNTL0FQci9nZ0ltbmdudnMxcUwzK1hndzNjdXVmVWZIK0VaWlVORVdQd1NYOFdWWTB2YzlTMDFodCtxOUpIQWEzRlBVS0ZnNUVKSTFpWUx0b1FlT0I1M01yQkdpcUNrMGJYZ0hQbmorQ1RlVGdQKzR0aHBrMVlpbzJ2OVBQcG1XRk56dlFQVUd0cHRUQkhjUmpUYWd6dDNRcmNPOXFML2d3ekhEUFc2YkRuTk90SmFhQ1B5THJqeW9EZDFTTFIzZ2NWaDVjTmtGL3pFVTYxTHYvZ09FSEI2L2NWNXJrcVJFZG56ZWtYVnBheURXWmdSYk1IbEg0cm84TC9icjRKZHlzZVBCYkVuclNsZXNDNEF2SHc0eWE2NzQ3NUFNTUlzQTlRUWxpaXBad1pUT05YbW5HZVEvR1ltQkY3MTFXS0E0WmJHSkw2dXNGYjhOdWVPeU5BTHo4QXhlSWlkV1BZb2NWdytFVjNodkJOQmdwNlJPNlgzUmRheFhnYjh5dnI5NFkwcXNaOXZKcXFGditRMzFUQWo2VEVjQnR2aGgwK0dNSk1ETmRXS0p6MzQ0TUVBdjBQQnMzeEJZeFJxd1JjOFJlVXJVQ0dlMTUwYlVzNmM0UUJ6eHU2SjE1dXdoUERuNk5yS0ZWZ25kM1J2VFMzSVNiSGdUT2FqTzFTTGErcUFLdDNpakcycW9lWXpGalJpd1FFOFJHTm42SU1aMDFaSTdZSXdiTnJXd2lQRzUyeXZ6Z05rMnJpcjVxdGNDQ3dhOXBLc0R6dnd0aElnZmdYbkE5Mk1kT3lIcEY5b1lrOFBSSndNSmtwcVJRQkprZ05vaVJiQ0xXM0ZmY29MUDN3Z2NobmNYQmJCS3JqYzg2cjAwQW1tSm9NdUY3ZnI3WXJqM1MvM08vVVludWl4Wlo3d0dzWEhKejFvT2dXTmtYWm9PUm1ES0xHT2tPWm9lNmN2RzNkZllPTjhzNmkyWSt4eFRxSS9QNHBCaDY0ME9POFhhUlN4cW44WnV0OFRwZnhhS2JnQk50R1dNZnV1b0NlRHVoZkk4WnMyeEdvUWN4azRrcFlvN1lJNjNkR2tuMjRzZ3NzVHNvNUlodmVYRVZkeGNIbW1YdzNtZ0k2S0VtOU02T0loZ3o2eXRaU25JSytDUE1NelBsSm1JbUdNdk1EYkZIREI1R0ZyOXNseE9JSjJhSjNUTWhCLzRuZnI5UGRObTVHODJCK2U4UFNQcWxWSExKRXVBc1lwSzc3emZxR09rTnl5enhZVFlzOHlJN3hGQTZ2b2c5WXBCWUpDYk5uQks3aFBHQWgzN3VGbXVGWGREbW1QMzl4d2ZqWGViRjlWZGx6RWk5eG0xRDd6Vml4aXhISTNaMGhqSXdWand6UHN4NTB5RXBLUzRoZG9saHZSK0ZtbDh6blYvQ2NWcEMrYU94VTRVdXY2WVB4TGRYcGg5MFJLVVlxaTJ5ZmhLbXM2MVZFMHMyTVhYbmk3MXFJZ2pPVXZENGU2RzVXNEdhTW41UUp4M3d4REErWGNkYmZ4Q3lGTnU1dWVaTDRtQlRQSzRwbkZBUGVxU1NvZDdNYnB2TThtR1o2OU1jRk5iTjFKbmMzNmdrTlVDRzUrTXpDMkV1MmtSdEpnME5Hdnp2YUhzY1ZNZTRLV212cWloZVViTEtpczFNK1JHeFJFeWxrNk55a3M3a2w2Y1ZNUE9LRE04Z2x1bWJpdFlDZ2FzMVQ4L1IxQlhmc1ZoV25iYURKQ0tyN0N3dzVWWEVsRlZJSFhhSVk4YnBqODNFcG9sSm5XRzlSeHpiV1huTmJXN1E2VE9BTGgyYmNpb2F5ajVqK09Fc2RtYktheXd0eDBkaXBocThKbzZwMUIvYmUxVXdlMWtyRHhYOUhscXdXTFFpTTdUK2NEemFGZ3BUejFRZ0c0T05HTTlNZVE4OWtDMHh4WGNMZFJhUlNXOFlRRE81V1lzRkNxa0pBVzNCYlcxbU54eU9HY0c2M2p1WTdLT3Bic2lHZ0RLTmhJaXRWRE1nRVl2NklLY1lKSVVjOUwwQ25XVVlHSEdYV3VuaVovcldDY09aYVNTa3F0b1FCcmFsYk1BVDBOeHd2dmJFaWh0TUl3YjBFTmhLd3l3bnBJY2RNcjZsZDBreUY4MDBBdEs3dklmbG9QV2V3dFR2RGlVK1pqd3ovYVYxaGtzdFBkQ1pRbzUwYjdHRWtHbGt2ZlN3UWc0UWhobXJzSENEYWNURGp1Rkl5SFk1YUN6Y1lEb1hRQS9UaFF2cDN1T0d1bU1tcHI4ZzBGeVdrRVFZTHJZczVHQTZINUZQSDNJWXhMS2trT204U2dyN3VkTnlybkp3bVpOQzlqZG5Pb2RKWVRwbTAxWTVzZ0diNjBSOFRFeTVTRldINTBnelZEazRsaFF5blhkSlllYVl4UERRV3NiQlNlbXVGT2FobWM1aHlKRTVLVXlmOUtWTkN0bmZuT2tjSklVRHhRZ3Q1NUFqczFpVmcrbDhKRDU3eUpFV2FQWTNaVHAzTVhUT0lVYzIxOC9DRHFhUmhGblRoa2Q4MnBDRHdjcDBQb29iV3NpUmU3WkpkVUphS0lhSktkOVNGRzBJVlk1Y2swSXVjeDFhWllraDB3aEpUUmNocTNKOEpnSSttVmxhU0cwQWFGblZJdGdvWWZsWHUwaExyM0g2YXAvMGJWdXpKRmtGbThDenZ6NVQza1ZzcGZLeFdqUStQN1RkcWlXNVd0d2tNZ0IwVElLUVlFMEUybVdqaVJoeHM1QWZ1T0lVUVBmUHk4R2NORk0rRTBMdERGdkpRSWYwR0xyUW1odzZ5RExRVERMNmpLTmFNQVk5NWpsNTNjNzR6RW1LNzNUYUNmUmliQ293cG54NzUvNEZXRk1Zc1VncUwxU1Q1cEJHaG4zOVFLditpSGJhdkhsMXFRRzB0eVB0aDBkbHRzSVZzM3l2bEpWK052OStGdU5zSnZJYWlHcjBwa3BBSzZmOVhLUDVjcGhVWmdCOStuamFtZFVKYURiN0tGTytwTTgrS3F0cGVWTThKL1Yyazh2VkpQZU5ETk9iS3NYUWNvT0grK0tLdWtRd3AxZFNSbWtEdWEzQnlEbFRCOHZCcUFJbGRvR2REYWF6VnRDWUh6cGRvVTV1TzZJbmJUUEh5VWwxa0NPZDNCZkVNcEVvL2M5dWNmZGRjMldWWmtMdmIxQ0xicjNNb1VFUEpvV0twd240OHRUckU5SWk5QTdNT2d0WXhZUHBMRVNlT1p4aGJtaTFxd21KOStyeDh6aFg0blM2Nkx6VmRmdUUzY1F5VVJqYjNjSjNkQVRndU5tUFh6VWx2c2FLZk95empBZmpDOHNETXlreFk1YXJFVHZFVU1adzVNdWQrdU9peWNrcnloSzdPMDlaS0lhT0VkRFVvbTlmSzcvREhMTXNHUUI2Qi80WHl4ajdlTE1jRUJOVE9oRTdHWE14WkU4K3VsMS9Ta3lhT1NWMmlXSGRRL2M4RWFDME1yaDZtM1dqcXVxZE5BUHcxNVVxY05GWTlMNlJQcENPYnN1NFNsRUlieGUwNkNaTDFabmxZc1FNc1pPSkxaMDlaSkJZSkNZSHYwbk1FcnZFTU5VdytxZlNEVzg3YVRseHFwYzdaTjdkdHkrTDZKOHQ3OTJBZTQ1bURUMkNFUVU0V3VLTkdiTXNScXhrQ3pXSU9XS1BHQ1FXelh3U3M4UXVNVXpOZVNPNHBwYmRyKzhWMTVzdmo5bmpKWmppUmk4ZDhvSzA1NE9NeTlpUzlZUms4TFBsa1psbE1XS0VXTW5HazdUM0E1MDlZcEJZTlBPcE00dnNHZ3pUU3JJYWREL3VvemphOS96V2drOWJmTnp4d2FzTDBWYmZXeGpTditVdEgvNFlzODFUYWV1RS9kWWJsS0NyankzR3lTejFJcHZFQmpHU2pTTmlUVDcwc2M0ZU1RaW1sYStJVldLVzJEVnlRY05EeDcwMEJkV25mN1BIK2s1U0o4c1lHYjQrSFM4QVZRRnAwOHU0YVNScm9FOXJ6clg1b2hsTE1Vd1hsb2dGWW9MWXlONEhIZ0hwazFkMDVvZzlZdERNNVd0N3hYZUlXWU5kaUFOOWhtZ0trRDNQYlNuWTNPRGhENWkzdm5OZUVDYmlUalYvSjBpYi93dXZvTXlCdkQ3V1E5R2dIWCtCemtBc3ZtSVd5NEV1U0tOelR3d1FDN0VNWXpVR0ROblNHZk9kMXBrajlzeXRpTkZuTnRzMkU3TUd1NURnb2J0LzRpVlg2a2RyZTJTRGZVMlVSaThOMm9lSXdjbURWd2ZBYWNVRGFqb0F5dloxV2VPZmZndGc4Ti9jR3gyNE9sbG4rZWlYTnVndVRlZWVHQmdxTHpwYnlCaXhSc3dSZTROWkpEYUpVV0xWWUhZZ0RMRDhlSmx6NENDZTNXS25lNEhhN09XNVlwc0c4MnZrT1lNUDBsbWd3c3dxQ2JZMUZvRGNlUW9nNUFPdXBuN0lZMGhwSkJYOWtwVFowdTFIMXM1MCtNU1RCWTRsVEg5bHB2ZmlJWVUwOERKSzV6ZW1RRzhvbmtOUlNTN2RVTkRVVjRFSzZ2YlhRRzNZQ2dXQ0JvOHU4MEZ0YVhJVjVOYzdiV3ZYN2luWWhFOVBHRUFQZkFqWHRhb3lvWEg1NDZVMDJwVDZ1Uy85OEo3QVAxMVJLeTh5NzNCZml4VmUyT3pDZzBVQUo4d0N5NUlWdE1BeWMwdE13NWNVQldYcnE2Q2QyZ2VpUllPSGx2cGg5dmprenJ6UG1vUnRONndwK2prKy9SenRGRVUwZzkvbmsveDlQRnVrYnNUR085WTVYejNWd3gwM3Q1bGRIWVYvL3FvUENpbjhPTFVmbFBlZkFxMjdpWjBVcHVHRkp6MHRvSHp3VXgxbVlvcllJc2JNM0RYMWNpZUlTV0xUWUZReTc0dnJlbTVzMGdlVVB6R0d1c1RMMEdaTWR5dHoxdDhWK0hGNW9WcGxidGZodDhBdnRoYkR5UjVCWHlHT3UyUVo4TE91eDBCR1pHZUpLYnNVQ2RUOUcwQTcrQWY5KzRKMW1BQSt1TVFIbGE3a0traFhrRzlmdnJibzJTTWV5MTc4OGM5VWUrNzYxeDRWV1UwRTJ2TnNSY3JQY2o5WlJsUVM3UmZYVjhxWHZmbTNnUWNybk9xNDVMaVlnM1g3aW1Camd5UHU0QjBsd05kL0RiaUxGZ01JQmV5a01hVWNtNkVkMnc3cXdZMEF3VjQ5Rmw4MkxRUjN6QW5vNFVZcW1HOTV2ZWpuaHpvRUNqTU9VNm5PODFpM1pIQTZOS0NOeGtRa1FUeWpwa1M5NkwwNy9mZlhsU3FUVTdWdDdCRmh6UzRYZk5sbGVHY2JKcHVURndBM2FRSDYraHBnTTMyd3VnZDBONE4yWWlmQWNiUkl2SFE4cFZ5Q2V5NzN3OFF4VXNxdG1yMTg0MjNyWEt1UGRWbklLOU9ZNXphRU9UcUlVVFBRN295SDRYNnluTEs5YXJTTFNtemFwTFczK1crL3NsWmFsSzVVczcrMUFONC81SVNqSHV1Wk4rd3VnTXBwd0xrbkFoUmo1RktFQjJFcmludHczc0xPOVdpU2l1R0NqTHhGQWdDQmJnQmZPMmdlREhrN2pnS0UvUVBOcHJsamNHTjlIOHpDV0RtZHE5dlJKRzYvNjAzWE9tK0VvMnBHQTFxcjU3R3VpSWxQRTlEUHVMTWVvL3NwSFdxS29hZWkxYTY4SnJqNHZnV1JXNjBXTFcxcG85a3J3SmJqRHRqVmJNTmJCb09XQ1cvVURnVVcxRVpneWVRdzFKWklhZHZGRklqODUwNzdXMDl0S3FSdTdXWTB2QnFnM2JPeUs1S0N6ZHlCTmphazhJTWFUMEtydTZ4S252RDhkWDNmd3NmWjJiWnQ5d3Z3NTA0ckpvOGlkQVFzNE9rVG9DL0dRVVRtUVdFOTQ2TktGaDV2dm9LcWQ0cVVPeFdvS3FKa1Q0SVpGVEdvY21VZk0zK2dYZGovby85MXZvZVBWSkk3Q2ZGYXN3ZGhqcWJoMGdUMHY1VVArV0RkVDdzcFFDNUJvNkFZNHdlb3VIZCt1UDYrQmVIcmFvcVZPblk2bVlhclpwL2w1SzkyMlQ5NmVaZjlJUDdZQ2ZIU0hIbG5yK2RSajVTQnlVU2dPM01BbWxUeHRKdEtlb1ZHQmFUV1NCcExWc3dMWDd4aWJuanAxSEpsT3NjeVFLYWhwWWthSm50SFh0MWozL3pxYmpzbGZGNklkMmRUcHdZTk9ncDJQdXBScy9CNGRrQWJPeUZneVZzWG8xVWFTU1B0MlRWL3ZGUjV6OXp3N0N0cXBmcHFsMXJEQWJCdnp6SU5obGh0OWZQTm56V0poOWJzc2UvN1U0dElIU1NVTGRJZ28xYUlkNWpvdzBFUlptMElMSnFCTGh2MndWVThYVUd3RmhoZ3V3MjRhWWRGVk5zWVg2d1VMYjg0T25IT09HbDhYYWxTV2VaUXh6aEVyZEFtZ0YyMGFGYWVBNVl0anNaQ2h3YUtwSEN4aUF6aGtNUUZ1ME44ejhsZVM4ZmVOckZsL1JjRmpTMCtTd0RpM3pDaHgyNERZbzhCY3JUejBVNDFCd1pOUVArczdLeC9nWXFmRG9EdE5HSnMybWtwZVd3Q0c4MXFlSFNhTm9FM3JIOTBJZE9vZE1TNnFZWlJOa2h4Y013QW1UeHlyd0V6aFJsOU9zai8wcWtPZzcxRW9LRm9SajUvRWM2QWxzcDVEc09jaGptTTE4MWdNNDFDSjIwQ21jcHRJUVBjUHVONXlIaGRoanl1SGlpTXdKVXBHVWEzRTRzQk1QUFF6RVAzZTJoNlZFYnFnLzlmZ0FFQUZJNGNQVEY4R2pvQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5oqV5rOo6YeR6aKdLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDnirbmgIHljLog77yM5bGV56S655So5oi355qE5LiA5Lqb54q25oCBXG4gICAgZGl2LnN0YXRlXG4gICAgICAgIGRpdi5zdGF0ZS1pdGVtLm1vbmV5LnRhYmxlXG4gICAgICAgICAgICBkaXYubW9uZXktc3RhdGUudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGRpdi5idXR0b25cbiAgICAgICAgICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5tb25leS1udW0oY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiLEBrZXl1cD1cImNoZWNrRGF0YVwiLEBibHVyPVwiY2hhbmdlRGF0YVwiLHYtYmluZDpzdHlsZT1cIntmb250U2l6ZTozNCp6b29tUmF0ZS54KydweCd9XCIsdi1odG1sPVwidXNlckJldC5iZXRtb25leVwiKVxuICAgICAgICBkaXYuc3RhdGUtaXRlbS5wb3J0cmFpdFxuICAgICAgICAgICAgZGl2LnBvbHlnb24oQHRvdWNoZW5kPVwic2hvd01lc3NhZ2VcIix2LWJpbmQ6c3R5bGU9XCJoZWFkc3R5bGVcIilcbiAgICAgICAgICAgICAgICBzdmcoeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZlcnNpb249XCIxLjFcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aCsncHgnXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodCsncHgnXCIpXG4gICAgICAgICAgICAgICAgICAgIGRlZnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4oaWQ9XCJpbWFnZVwiLHg9XCIwXCIseT1cIjBcIixwYXR0ZXJuVW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiLHYtYmluZDp3aWR0aD1cImhlYWRzaXplLndpZHRoXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlKHYtZWw6aW1hZ2UseD1cIjBcIix5PVwiMFwiLHYtYmluZDp3aWR0aD1cImhlYWRzaXplLndpZHRoXCIsdi1iaW5kOmhlaWdodD1cImhlYWRzaXplLmhlaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uKHYtYmluZDpwb2ludHM9XCJoZWFkYm9yZGVyXCIsZmlsbD1cInVybCgjaW1hZ2UpXCIpXG4gICAgICAgICAgICAgICAgICAgIGltYWdlKHg9XCIwXCIseT1cIjBcIix2LWJpbmQ6d2lkdGg9XCJoZWFkc2l6ZS53aWR0aFwiLHYtYmluZDpoZWlnaHQ9XCJoZWFkc2l6ZS5oZWlnaHRcIix2LWJpbmQ6eGxpbms6aHJlZj1cImhlYWRib3JkZXJpbWdcIilcbiAgICAgICAgZGl2LnN0YXRlLWl0ZW0uc3RhcnMudGFibGVcbiAgICAgICAgICAgIGRpdi5tb25leS1zdGF0ZS50YWJsZS1jZWxsXG4gICAgICAgICAgICAgICAgZGl2LmJ1dHRvbi51bmRvKEBjbGljaz1cImNhbmNlbGJldFwiKVxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlckJldCcsICd1c2VyaW5mbyddLFxuICAgIHJlYWR5KCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnpvb21SYXRlKVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiRlbHMuaW1hZ2UpXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZHpvb206IDEuMixcbiAgICAgICAgICAgIGhlYWRib3JkZXJpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgJ3VzZXJpbmZvLmhlYWRpbWd1cmwnOiBmdW5jdGlvbihuZXd2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVscy5pbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICd4bGluazpocmVmJywgbmV3dmFsKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBoZWFkc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDE0MiAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLngsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRib3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gNzAgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTUgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgMTI4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDQ4ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEyOCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyAxMTMgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS55ICsgJyAnICsgNzEgKiB0aGlzLmhlYWR6b29tICogdGhpcy56b29tUmF0ZS54ICsgJywnICsgMTQ2ICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueSArICcgJyArIDEzICogdGhpcy5oZWFkem9vbSAqIHRoaXMuem9vbVJhdGUueCArICcsJyArIDExMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnkgKyAnICcgKyAxMyAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnggKyAnLCcgKyA0OCAqIHRoaXMuaGVhZHpvb20gKiB0aGlzLnpvb21SYXRlLnlcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZHN0eWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyB3aWR0aDogNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiA2NDAgLyAzICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4ICcgKyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCAtIHRoaXMuaGVhZHNpemUud2lkdGgpIC8gMiArICdweCcgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtOiAnc2NhbGUoJyArIHRoaXMuaGVhZHNpemUud2lkdGggLyAoNjQwIC8gMyAqIHRoaXMuem9vbVJhdGUueCkgKyAnLCcgKyB0aGlzLmhlYWRzaXplLmhlaWdodCAvICgxMDA4ICogMC4xNykgKyAnKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzaG93TWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGRpc3BhdGNoKCdzaG93TWVzc2FnZScsIDUpIC8vIDXku6Pooajog4zmma/mlbDnu4TnmoTmnIDlkI7kuIDkuKrvvIzljbPmmL7npLrlhYXlgLznmoTog4zmma9cbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsYmV0KCkge1xuICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goJ2NhbmNlbGJldCcpXG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrRGF0YShldmVudCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coL1xcZCsvLnRlc3QoZXZlbnQudGFyZ2V0LmlubmVySFRNTCkpXG4gICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTC5yZXBsYWNlKC9cXEQrL2csICcnKVxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IDEgLy/mnIDlsI/lgLzkuLogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51c2VyQmV0LmJldG1vbmV5ID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LmlubmVySFRNTClcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlRGF0YShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUwucmVwbGFjZSgvXFxEKy9nLCAnJylcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAxIC8v5pyA5bCP5YC85Li6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlckJldC5iZXRtb25leSA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC5pbm5lckhUTUwpXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5zdGF0ZSB7XG4gICAgaGVpZ2h0OiAxNyU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm90dG9tOiAxZW07XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuXG50YWJsZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG5kaXYuc3RhdGUtaXRlbSB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDMzLjMzMzMlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2Lm1vbmV5LXN0YXRlIHtcbiAgICBwYWRkaW5nOiAwIDFlbTtcbn1cblxuZGl2LnBvcnRyYWl0IHtcbiAgICBwYWRkaW5nOiAwO1xufVxuXG5kaXYucG9ydHJhaXQtaW1nIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy90aC5qcGcpIDUwJSA1MCUgbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbn1cblxuZGl2LnBvbHlnb24ge1xuICAgIC8qY2xpcC1wYXRoOiBwb2x5Z29uKDUwJSAwLCAxMDAlIDI3JSwgMTAwJSA3MyUsIDUwJSAxMDAlLCAwJSA3MyUsIDAgMjclKTsqL1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICAvKiAgICBiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/kuLvnlYzpnaIv5aS05YOPMS5wbmcpIDUwJSA1MCUgbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsqL1xuICAgIG1hcmdpbjogYXV0bztcbn1cblxuZGl2LmJ1dHRvbi51bmRvIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mkqTplIAucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xufVxuXG5kaXYuYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi8uLi9hc3NldHMv5YiH5Zu+L+S4u+eVjOmdoi/mipXms6jph5Hpop0ucG5nKSA1MCUgNTAlO1xuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGhlaWdodDogNDAlO1xuICAgIHBhZGRpbmc6IDUlO1xufVxuXG5kaXYuYnV0dG9uIHNwYW4ge1xuICAgIC8qZm9udC1zaXplOiAxLjVyZW07Ki9cbn1cblxuXG4vKmRpdi5zdGFycy1idXR0b257XG4gICAgcGFkZGluZzogLjhlbTtcbn0qL1xuXG4ubW9uZXktaWNvbiB7XG4gICAgLypiYWNrZ3JvdW5kOiB1cmwoLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZykgNTAlIDUwJTsqL1xuICAgIC8qYmFja2dyb3VuZC1zaXplOiBjb250YWluOyovXG4gICAgLypiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyovXG59XG5cbnNwYW4ubW9uZXktaWNvbiB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgZm9udC1zaXplOiAxLjVlbTtcbn1cblxuLm1vbmV5LW51bSB7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIC13ZWJraXQtdXNlci1tb2RpZnk6IHJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHk7XG4gICAgZm9udC1zaXplOiAxLjVlbTtcbn1cbjwvc3R5bGU+XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBTdGF0ZS52dWU/NDZhOTFmNjhcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJNEFBQUNsQ0FZQUFBQ0tsc1g5QUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCM1JKVFVVSDRBY01Ed1VNWGZzdDJRQUFJQUJKUkVGVWVOcnRuWGw0SE5XWjduOVYzUzJwZCsxcUxSYmVrQzFabHJIQkxNYVlRQ0FCa3dsSnlEZzNETnlFTzRIQklVTXltUm1Jbndsejd3Vm1JRE4zY2ljYkRnVEdTU0RKWEJJbUpLd2hyQWFNV2VKRmxyeklOcFlsVzd2VWU3ZDZxVHIzRDdYMjdxNlNEVmhxMWZjOC9rTnlkVmZWcVZmZmVkLzMrODRwNmI3ZEFpTW1SUlB3TjhCNjRBM2cvd0xOdVhxejN6cm4xRDVuUHQwVFA5dlNteE1EdUxHeHdndzhBTnc4NGRkTGdTOERQd0crK1d4TGJ5ajNnRk54Wm9DVEk2RDVKdkFWb0Y0STZQQkdPRFlRWVZHcGpkb2lHNUxFemNBVkd4c3JIbm0ycGZlZmN1bmVKVmVEQVp4VEFNd25nYjhGcmdRWURNZHA3UW9TaWlVQmFPMEtjbnd3U24ybGt6SkgzaUxnM28yTkZWY0NEejdiMHZ1citUeDI1bmtLbUJyZ084RDFBTkdFd29IdUlEMkIyTFJqUTdFazc3WjdLWFBrVVYvcHhKRnZ2aFM0ZEdOanhmWEF2YysyOUw1dEFPY1VRakMzeVBVMWpaNTdnTnVBSWtVVkhPa1BjMnd3aktKbXY0KytVSXorSXpGcWkyelVWVGpJTThtZkFqNjFzYkhpcDhBZHo3VDA5QnZBeWNHNHB0SHpSZUIyNEVLQUx2OHdCM3VDUkJPSy9qOFNBY2VISW5UNWgxbGFabWRoaVExWmtyNE1YSFZObytmaFoxcDY3aktBb3pNNmRyOHhxMjl3ODQyZmJ3THVCZjRNSUJCTnNMODd5R0E0ZnNyZm1VaXFIT2dPMGpFWVlYbWxFNCtyd0FOOCs1cEd6eFhBUTFzZi9jMDJBemh6TkRiZitQbEo4anFlVkduckM5RXhGRUZveks2aGdXNEMvU2R4bEZUaUxLdENrcVMweDRYakNuODY3cVBFbmtkRHBST1gxWEloY09IbUd6Ky9DYmgvNjZPL2VjMEF6dHdDelRlQVc4Yms5VkNFUTcxQkVvcWE5WFBESVQrK2s4ZUlSOE1BK0xxT0VScnNwckJxSVRaM1NjYlBEWVpqdkhFa1JrMlJqV1VlSi9sbStTcmdxczAzZnY2WHdMZTJQdnFiVGdNNHN4c3dud0QrYnFLOGJ1bnlFeHhPWnYyY0VvL2g2MjRuNGgyWTluL0oyREFEeHc2UzczQlRXTDJJUEtzOWcwZ1k4WCs2L0ZHV2xEbFlYR3JISkV2WEE5ZHZ2dkh6UDk3NjZHODJHOENaNUNCSlp4NHdOMXhYRGZ6TFJIbTl2eXRBdDM4NE85bFZWWUw5SnduMG4wU29hdFo3aVlVRDlMYnR4VjVjanJ1aUZwTWxMKzF4U1VWd3FHZWMvMVFYV2dGdTNYemo1eThBSHQ3NjJCTVBHTUNaRFZubWh1dnVBYjRLRkkvSTZ4RHY5MnZMNjRodkFGLzNjWlJFYkVibkN3LzFFZkVONGlxdnhsbGFoU1RMYVkrTEpoUjJkL2hvSHdqVFVPV215R1paRGZ4bzh3M1hmUWI0N3RiSG5uamVBTTZaQWN3WGdiOEdMZ0xvOGtVNTBCM1FsTmZ4YUJoZmR6dXhVT0RVdlN0VndkL1RRV2l3bDhMS1dteUZwUm1QOVViaXZIbWtuK3BDSzhzclhWZ3RwaXVCS3pmZmNOMnZnVzl2ZmV5SnRyazQvdExwVnNlM2JhcjdTQy80cHNmYm1vQjdnRStQeXV1VzdnQ0RvZXlaUTAwbUNmUjJFaHJxUlZOV3pURHliRTdjbFdlUmIzZG1QYzRrU3l3dWRiQzAzSUZaSHBzV0h3Uyt0bTFUWGZKTUFLQ3R4NXpid0xucDhiWnA4dnBRYjVEamcrSHNPQkNDMEZBdmdkNFRxSXFPWnlNRXBzNC9ZVDY2WFZKcTE5NlNYSFRSZzhqNkJ0ZnFLc1pkV1lzNXJ5RHJjUVVXRThzOFRoWVUyMGpCNXdEdzhMWk5kZDgxZ1BQQmd1YnJ3RitOeXV2amcyRU85bWpMNjFqSWo2K3JuVVFzcXVzOHNyY0RjOHRUa2pUVWdZQ1JoMm9ySXRsd3RWQ3FtMFovbzZFVkpCd2xIcHpsMWNpbTdBL0ZiYld3b3NwRmlTTi85RmN2QXovWXRxbnVTUU00cHdlWUs0Ry9INVhYQTZFWUxTZjlCSVlUV1QrWGpBOFQ2T2tnR3ZEcUc0VGhJT2JXWnlUNXhCNkVxcUtvS2tLb1NKS0VMSnVRSlFsUmZCYkpsWjhTYWxHdFBoQ2F6TGdxYXJBWGxXc3F6MHEzbFlaS0YvYjhzWWY0SlBBL3QyMnFhemFBTXpQQVZBSC9PaWF2NHdxdFhYNjZmRkZOMGhvYzZDWTAwSU1RcXZhSmxBVG1vNjlMNXNPdm9DYUdVWlVSMEtpcWloQmlCRGlTaEd3eVlaSmxKRmxHclRtSFpNUFZRbGdMOWFtUGZDdHVUeTBGRG5kMm9Fa1NpOHJzMUZVNHNaakdsTm9qd0padG0rcjZEZUJvZytZZVlETlFvcWlDSTMxQmp2U0ZOT1YxMUQ5SW9LY0RKWm5RbHhHNld6QzNQaXNSR2tCVlZSUlZRVlZVVkNFUUUwaVRKRW1wekNOamttVmtrNHhzemtkWmNnbkpzeThUbVBOMG5TL2Y0Y2J0cWNXY2I4MU90TTB5eXowdXppcXhqeWFxbmhUL3Vjc0FUbnJBZkJINEdyQnVWRjYzZHZtSXhyUEw2MFEwakwrN2czaFVYMWVuRk96RjNQeWtKUFVmUlJVQ1ZWRW1aWmxzM0dVays4aVlaQk95TElQVmhWSjNoVkFXbmcrU3JPUGtFdmFpTWwzOHg1RnZwcjdLVGFWN0RHZzdnWWUyYmFyYlpnQm5YRjdmRFZ3TDRJOG1hRG5oWTBCVFhpY0k5cDhrNGh2UWQ2UHhNS1lETDBoeSswN0VHRmdVVkZWRlZmV1B3YlRzSThuZzhwQnMvSlJRSzVicDVEOG03Q1dWMkl2TGtUUUFWK3JJcDdHbUVMZlZNdnFyNTRIN3QyMnFlMjFlQWllZHZEN1lIYUI5TUpSVlhnc2hpSGo3Q0ExMG9TbzZlbW1FaXFuOWJVd0hYcEJFTERRQ0ZtV1VBSXVzV1VhTGs4Z3A4SmhrRTVJc0lTcVdrMno4bEJCT2ZRM2dKa3NlenZJYXJLN2k3QThKV0ZCaXA3N1NSWUhGTlByclh3TGYycmFwcm5QZUFPZW14OXR1QjI0ZGxkZnRneUVPZHZ1Sko3WGtkWUJBYndmSnVMNHlnVHh3RlBQZUp5VUNQU2tlbzZJcXlqUWVjOHJ1NlZUK0k4dElKaFBxd2d0UjZqOGhSSjVkMS9kWXJIYmNGUXV3V0xNZmI1WWx6cTV3c2FUY2lXbmNRUHp4dGsxMW0zTWFPRGM5M25ZRmNNZVl2QTdHYUQ3aEpSRE5UbWlWZUl4QWJ5ZXhzTDR5Z1JRZXhOenl0Q1IxNzBPb0FrVlZVQlJ0SG5PNkFCcVp2a2I0ajV4bkk3bnM0L2NyaXk2K0U1TytoMVBnS3NKWlZwMnhnRHBtTk9hWldGRmRTRTJSYmZSWHUxTUUrb0djQXM1Tmo3ZFZBdjlub3J4dU9lbmpwRGVTbmNjb0N1SEJIaUxlUG4wUFBCbkRmUGdWeVhSa08yb2lOcDVsVkJXaHFoOTZkL1JVK1M3TDhvaUJ1R0tqVUd2TzBXa2d5dGlMeTdHWGVESVdVRWVqMko1SFkwMFJ4Zll4b1AwUitPNjJUWFhQejNuZ3BPVDFyVUNwb2dvTzl3WTQzQnZRSWErSENBNTBvK3FTMXdLNWN3L21scWNrb3Y2eEtlbDBlY3hwQVdpTVFLY014SktGS0NzL0xkVGlzL1JOczJZTHp0SktyTzVpeldOcmlteXNxQzdFbWpjR2dsOEQzOTYycWE1dHpnRW5KYTl2QXk0R09PbU4wSExDUnlTZXZWNlVHQTRUN0R0SllqaWk3d2E4SFppYmZ5ZEpnKzJvUXAxbTRwMnBrQUJKbHBBbGVaS0JLR3BXazF4eGpSQTIvUWFpczZ5YVBKc2pPOUdXSlpaV09Lbnp1R2RVUUowMXdFbko2LzhOZkdaRVhzZHA3dlF5RUJ6V0lhKzdHQTc2OUYzNGNBRFQvdWNsdWVNZGhES0IrS29qSnQ1c2lZd0c0dEpMU2RaZEpqRG42ek1RN1M0Y1paVzZDcWdOVllYVWxqcDBGVkRQT0hEU3lldjlYVDZPRFFSMXlPdCtJa045STExNFdxRXFtSTYrL212endSYzJxWW5vdEF3anhPeGM1NVhlUUhTakxMOVNLQXN2MUcwZ1d0M0YyRXNxTkEzRVFsc2VLMnVLS0hPT0FTMXRBZldNQXVlbXg5dittcEV5UWIwUWNLdy95UDR1bjdhOER2c0pEWFNqSlBRdFZaRzdXekh2KzcxRXNQOURrZGNmUGY5SkdZaHVEOG1WbnhacXhYSjkzeUdic0JlWFkzV1habHlCTVJwVlJUWWFhNHB3WkNpZ25pbmdmQnk0YzFSZTl3ZUhhZTRjd2gvSkRvUmtQRVpvb0p0NFJHZVpJTkNMZWQvdkpLbjNBS3FxdjB3d215TzlnVmhQY3VXMVFyajBHNGlPVWcvNWRwZm11WmFVTzFsZVZUaXhnUG9UNEp0Yk5qU0VQa3JnZUlCL0c1WFhrWGlTZlNlOG5CZ0thNWk0Q3VIQlBxS0JJWDFkZUlrbzVvTXZTUEtSN1lnVWYxRk9vVXd3bTdOUFdnTngwVHFVaHF0bVpDQTZTaXN4NTJmblAvbG1FL1ZWaFN3dWM0eG1xbVBBSTFzMk5QelRSd0djZXhocHFpcFRWRUZiajU5RDNYNE5lUzJJQnJ4RXZMMDZ5d1FDMDdHZG1QWS9LNG5oMEFoUXpxQzgvcWdBTk0xQXJML3lQV1hKK25QMWRpQVdPSXV3RjJ2ekg1ZlZRdE9DWWlyR0M2aXZBUTl1MmREd3F3OERPRjlrWkRYQitoRjVIYWE1WTBoYlhrZkRoSVo2U2NhRzlhWHcvaU9ZbTUrVThKNUFGZXFZNHp1WHA2WFRNaER0eFNNRjFBV3I5Um1Jc295dHNCU3J1MFNULzFTNHJUUXRLTUUxWGtCOUdyaDN5NGFHdHo4STRFeVcxNUU0ZXpvRzZROW95K3Z3VUsvK01rSEVPOUsyMmJuckl5a1R6QjBDUGNGQVhQVlovUWFpeVl5dHFKd0NaNkhtdVJhWE9XbW9LU1RmUEZaQS9TbHd4NVlORGYybkFwd3A4bHFoOVlTWDkvdURXUitrRUlLb2I1Q29mMURmQTFjU21BKzlLSm5hWGtaTnhpYkw2NCtnVERCcndaUEpRRnl3aG1Uam53bGhLOUpuSU9ZVllDOHB4MUpneTg2VFRETDExVVVzclhBaGoyU3FIdURoTFJzYTdwb0pjTDZXbXBicWhSQzgzeDlrL3drdnNhU2lJYThEaEwzOU15Z1Q3TWE4N3ltSjhOQUk4YzFoSHZPQkc0aDFIeU81N0FyZEJtS2V6WW05cUV5emdPb29zTEJ5UVRIVlJXUEVmQ2Z3MEpZTkRkdXlBZWR5NEZ0ajhqb1FaYy94UVh3NjVIWEUyNmUvVE9BN2dYbnZieVdwNy9Dc0toUE1EZjR6eFVCc3VFb29peTdTYnlBNmkwYjRqMFlCdGN4bDVaemFZZ3J0WThCOEhyaC95NGFHMXlZQ3B3TDQ3a1I1M2R3eFNPZGdTRk5lUjN5RCtzc0VzVENtbHFja3VmMnRXVjBtbUhzR1lpWEpwczhJMVZPdjIwQzBGWlpRNEhSbkpkd1NzTERNU2VPQ2tva05aRC9kc3FIaEp1bSszYUlSZUFrb1YxVEJvUzRmQjdxOG12SjZPT2duR2hqVVh5WTQ4aHJtL1grUTFIZzROUzNOL2pMQm5ETVFQUTBrVjMxV0NKZEh0NEZvS3l6VDVEOW1rMHg5VlNGMWxZV2pEV1RyemNCV29QekVVSWc5eHdlSXhMU3ExeEVpdmdIOVpZS2VBNWozL2xiQzM0MHlSOHNFc3pGVUlSQ3BUSzNLWWlRRGRiVmk2VDBvcVl2WG82ellLRVMrWFVPWHhBbjJuOFJTWU1OV1dKcGxCdzZGZloyRFNCSXNyeW9DdU1RODZzdnNhT3ZKZnBKa2dxaHZjR3pUSVMxUFFRcjFZOTd6aENSMXQrUk1tV0MyeFdpMkZrS2dxdW9JZUlSQVByS2R2STczcEdURFZVSlplaW5JSm8xa0VNWGYwMG0rM1luVlhZSnNNbW1ydFlrWGtmN2lWSWFEUG9aRC9wRXlnWllIbFloaTN2KzhKQjkrRlpGTWptZVplUzZ2UHlvQXlhbzZJdC9WRUtZOS95V1pEcjlLc3VsYW9kYXUwZnhqajBXQ3hLTmhDcHlGNUR2YzB3ekVpUkF4QXdwZ2tpUnBHbmppa1JEUndOQ0VNb0dVN2VveHRlL0V0TzlwaWFqdmpIZmh6VmNBS1VLa3BxOFVnUTROWW41cm15UU92NFp5enVlRVdySkk4enVpQVM5Q0NLeXVvcXdaSnd5NFRKSkVZZ29oRG52MXJUeVZCNDloM3ZXNHhGREh2Q3NUekZZQXFZcUNFT3A0QnVvL2l2bWxmNU5FN1hra202N1ZOaEJGOWpxMGVkS1JVeWNTaldsSml2b3c3M2xTa2pyZUcxdXNiOGpyV1FJZVFLZ0NJYW1UTTlEeGQ4Zzd1VmRTbGwxT3N2NFRtUTFFYVRvZTFIRUZuYWRSZHBVeTBYRk1oMTc2dGZuQVNCZWVNa2U2OE9ZNy94R3FpaXhrVEtwQWJuMmV2R003cGVUYUc0UmEyYURyMlNmSFp5U3JlZW9KcG5vRjZVQmdlZTRlaWRCQWl2aU9GQ01Od013bC9wT1M3K0VoNUw3RGtxaHNFT2s0Ni9UbktkSk5WV25aQ3pEZDRCUEIvckc2a3NGajVpQ0FGQ1dWZlV5WUVzTVpaaFpKcHh3bkRjSXlmRGFwSkZFVUpTZTY4T1pycUVLQXFpQ3JTdHJubkE0UFUrVzRCc2VaL3EwcU1xcWFORVovem1lZjBjbG41aGxIbmlhcVJIcUJOVGxQNVJtalBtK2tXWG84bUlFNGpHeFRKOUxLY2NrWXdGd09TVXE3UjZFUWFwcDNrWWxKR1NjQ1lKWmxZeENOMEIzbXlST2VtTkU4WjBUT3BKM01KR2hDS09QYkEwL3djZExSR2dNMzh4czNVMzVXeG9HVW56M2pTRExvMmZiVmlCeEVqalFkRCtua2VNYU1ZMlNkM0k3RWNIb2ZSeUlMTmRZcWNtWkVqb0dtM05MY0V2b21xMHdsQjcxR3NNbGlqUGQ4d0ZPV2xKTjFxcEl5YUh5OW15RWFNVWNZVHJwbkxHbDR3RUFNd0NSSkgvaDduSXlZeXhrbmV5ZVhHUmdlQXc0R081NmZpdXAwcStQcGtwTmtVT1A1cU1iVDRTRXh2a1dOVFlNY0d4bG4zaUluRGNrUjQyMDBGdTJlWTRQMjVEaVhVVFdrbGRaVWxiWlVsVUZWR1Zrb2R5SVJ5L2dHdnl6R01VWkozSWhUaXF4VGxaU0o0MWdLakpITEtVMGxwZmw5T3A2U3pqbk8xUFdYVGxWSnhsU1ZNeFFuRXh0QmFEckhVUUNUU1U0dng0MWExYnhVVllMcEhhRmlTZ2RnQWhqZDkwMzNlUXpvR0J3bnM2d3lwcVI1a25EMDllTWt4L2VBZEppMUtJNFI4NWovVFBsNXdqSTZrd1k1bG93cEtkZERTV1pRVmRrenlXbnRWbUZFTGdBbmtVWC9uUExhY1drR2M2SVJ1YVNxVG0vdGVLWitESXZWR092NXdHK21yUjNYbTNHa0dmK0hFYm1TY0hUSThSQ0FKYzFPazFtcHNkRXhtRU80a1U0Sk9NbzRGektBWUVRV3FxSjdtNU5NSk5pWXFYSnJtcEwwTFFGT2pCdUFycXl0bzVLQmtubE9rRFBXcWlSdE9XNDBjdVYySk9NWm5ySFFhUUJtV01ocFFDVEhRMVhJMkZXaFowSGVUS3BWa3JHWHpyeVpyREw5ckUyTzA2VXhzOUVCbUR1cVNaeFNKV0JTeHBtMnp6SENLSFBPRTJHVkx0Y0lEZWM0QUdBeG16TnBOV05rNXlWMHRET095UHBSUTFRWnVKbk9lQ1NOUFFBTjVNenJ5V3FxQVpnWTI5dmFxYmxmaWRGQk1ROWdjNHBGVGcwNWJpQW5weU1lelRLcmZOQTdjaG1SRzJvODIwT2YyWTVjMDJ0VmFUZHJNcmJrenluMFpGemtrR1ZkbFk0OTJkSTBNaHQ3QU00RGNxemRPaW95cWlySklNZnpsaHpMYUc3bEZnRElzeGdHb0pGeFpwWnhQdWp2TkNJWGNKTW0yVXdvT1ppeUdvRFp0OEF3SW5kd28yOEo4QVFEMEpHMVA4SjQxK1o4VUZXbjlvek5XZk5UdG41VUkzSWpFdEVNbnN0cEdJQ1NNT2hNemllY2JKUlZud0U0dlZsZFpNbzR4bFp1dWEvSEplblVEY0NNZTI3TEptT3djMXhVNmVFNENxUzJIMDMzYWtYSjJGcDlYbVljV2M2NklFOEdnZ0JtcytsRHhxZ1J1UlJaVmRWSXI3b0JrdHhQT1BwZWRLYUtzWldjZWNZNkZ5TjBSM0w4TGNDMnJBdnloQ29NNXpqWEk4TldibnIyT2M2TW5FeEdqb0dibkFtUmpKMlNrYU5qS3pjREpmTlRrTStrT2o2dHlDblNxL0Y4dXpBUWxSc2h1OG96VjVXeWJPMTNTbTlsTmRjMElsbmRpSWpQR1BtNW1tTXMrVmpYL1lXd1h2RG5NOGhDRXdBSEpBRmthU0xQR2VjN2tpUk4rMmRaY2dIRm14OFYxZ3MyM1MrWjg0Mm5NTWVtcGZ3Vkg2ZjQxcDhMKy9vYmtTMEZhWit4TE10cDhERDVYUTVoU08wQm1QNlk5S2N2Y09DNFl2T2R4WnQvTHZKWGZOeVl1ZVpBbUQxblUvaWw3d3ZYWjc0dFpGZTVEdWFjRVRjYUJpRGFCcURKWFlIN3MzZUp4UG5YRVhyaGgxTGk1SDdqQ2MwMkhtTXJ4SEg1TGFKZzFkVzYybVJVUlNFYThFN0RnNktPR1lENVdkL2xFQTM2RUVKUTRIUWpTZG05UWt0MUEwVTMvVWdNdDc1TStPV0hKTVhmYXp5eE16MHBtU3hZMTM3dWNmdjZHLzljS25Eb3lEQ0M0WENBYU1DSFNQT3V6Z2tHWUg3VzFsRWhCTkdBbDFnNGdOVlZRcjdkcVRsL0ZxeTRndnhsbDRqSXpzZUo3UGlGSk9KUjR3bWVnY2hiY2o3T1QveTFNSlhVNmpvK0hnMFQ5UStpSkJQNnBqMDlCNm1LUXRqYlJ5enN4MVpZZ2lYZnFzbllIWmZjaUczMVJoSGEvak1wdXZ0cEdFOXpSbnlJWVNxdXdYWFYxMFhla3ZOMUhhOGs0b1I5Z3lTR0kxbVBjOWdLdUhCbDNlaVBiMGozN1JicmdkY1RTWVhkaDQ3UjNOWStNU1dsUjdQVmpxMndGSk5aMzhLOFpIODd3VC8rU0lvZmZkdDRzaC9XdEZUZ3dISEpsNFIxN2VkMExaZ1Vxa28wTUVRMDVNKytmc29rczZwdUlhdVhMOFpza2hHcUdwQmsrV0xwdnQyQ1pEejJLM05lL244RENFV0cyYm12alNPZDNScFhLbUYxRm1KekZldmVFekIyNUcyQ2YveVJsT3h2TjU3MEI0WVlHZXVxcTNGKy9CWWgyNHQwZldRNEZDRGlHMERWbUFVV1ZWZHc4YXJsT0d3akhaLzlIZSsvMmJyOXhiLzl3MFAvL3JaMDMyN0JsZzBOcmszL2NQOWZMbHgxN2xlS1BOVU5BTDJEUG5ic1BVVHZZSGFUVDVaTldOM0ZXSjJGK2hyYlZZWElydDhUZXZVUlNZMzRqUWQvR21GWjBJanI2bThLaStkc1hjY25ZbEhDUTMwazQ3R3N4eFc1SEZ5eXBwNnFzbUlBQms5MnRMMzM5Qk12di9xTG56d0h2QVAwakFMSERpd0ZHcSs3ODk3UExydndrZ3VkSldYVkFFYzZ1bm0zOVREK1VQWTUwR1RKdzE1VVJwN05vZXNteEhDSTBQYWYvU255emhQbkNTVmhvR0FtUE1aZGdmT0tXMFZCb3o3L1RFMG1DSHNIaUlVRFdZL0x0MWc0ZitYWjFDOWVnQ3hKaEgxRGZZZmYyL0hXLzd2N2ptZUFQdUI5NEJnUUdnV09HU2dCRmdHMVFNbGYvZkN4R3hZMnJWa0hvS29xKzQ1MHNHdi9VV0tKN0EvWlVtRERVVnlPT1UrZm82ejRld20rK0dNcDJ2SVN4ajRyR3JPU09SLzdSVjhRanZVM0lPVnB2L3BwUkJVUEVmRU5wWlhYNDZ4RG9tSHhBdGF1V0VwQi9zaE9KTWYzN1hyN2tXOSs1WkZFYk5nUG5BUk9BSU9NdkRWYWtlN2JQZkt3dG14b3NBQU9vQXlvQVNyUFdybm1GOWZjZHNlN0N4cWF6Z01ZanNWNXQvVXdCNDUyb21vczVDcHdGbUl2S2tNMjZTdUhKVTYwNHYvRDk2WEVpVllESWVuR3MvNVNYSis4WFpqY0ZmcjRaQ1JJYUxBWFZVTmVWNVVYczI1VlBhVkZMZ0Q2Mm84ZWVPbW5EOXpiL1BKekpxQXJCWmcrUmxxTXg1WnlqZ0VuQlI0SnNBQnV3QU5VQTU3enJybHU1U1ZmK1BMVjVRdVgxQU40QXlGMjdEbElaMCsvQm0rVHNSV1dZSE9YNkd4QkZVVDN2VVRneGEyR2dUaWF3VDFuNDdycWRwRy9jTFUrQlJ1UEVScnNJUjdWa3RkV0xteGF4dExhU2dEOGZUMGR6YTg4OTlxelAvclhWNEhlRkdDNkFUOFFuem9kVEFMT0JBREpRRDVRbEFKUURWQzI4YmEvdjdSeHc1VVhGMVhXTEFibzdPbG54NTREZUFPaDdIT3kyWUs5dUlJQ2gxc2YvMG5HQ08zNFQwSnZQRHB2RFVUWjVzWjUyVmVFL2R4clFjZHlwRkd2TFJyMGFzaHJFMDExaTFqVHNBUno2aDFsN2MyN2RqejR0UnQrRGd5a0FITVNHQUtHZ2JSelhGcmdUQUNRQ2JBQ3hVQlZDa0FsZjNIUHYxKzc5TnlMTGlod09JdFZJVGh3dElOM1d3OHpISXRyOEI4cmpwSktMQVg2WHMyb0JBY0p2dnFJRk5rMWp3eEUyWVI5N1djV095Ky81YWlzczB3UURYZ0plL3RRRlMxNTdXSGQ2bnFjdHBIeFAzbW9kZmZUUDdodlRYdnpydXNuOEpoK1JncmZXYjhzSzNBbUFNZ00ySUhTRkhpcVhHVVZyMS8vdi83dE4yZXRYSE1CUUN5UllGZnJFZllkUG82cVpqY1E4KzB1bktVVm1DejZ0b1JMOXJmamYvNEgwdkNSblRtTm1md2w1MU40OWRlRnVXeWhydVBqMFREQi9tNWQ4bnI5dVN1b0xpOFpsOWZQL05jcnJ6NzIwTTdVZEhRQzZFbnhtTGd1b3E0SE9CTUFsQWM0Z2ZKUkF0MTArZFhKeTc5MDY1YUtSV2MzQXZoRFlYYnVQY2l4RXowYS9xR0UxVjJDbzdoYzk4clE0U003OFQvL0F5blpmeXluQUdNdXJzSDFpZHVFdGY1U2ZaazRtU0RZMzZWTFhxOWR1WXlHcGJVajh0cnY3VHY4N3BzVDVmV0pGQUgyQXJHWnlOb1pBV2NDZ2M1UEVlaktGSURLci96SzdldFdmZnlhUzB1cUZ5d0Y2T29iWk1lZS9ReDRBeHFaMll5anBCeWJxMWkzZ1JoNjczY0VYbjVZVXVkNEI2S1VaOFcxNGI4THg4WFg2eTRUaEwzOWhMMEQydko2U1Mxckcrc215ZXYvK0x0YmZoR1BSbnJUeWVzWlgvdE1nVE9GUUZ0VEJMbzY5YS8wQy8vNEx4dlBQbS9kUmZiQzRuSWhCSWZhVC9ET3ZvTkVvdG5UcVRtdkFHZFpGZmsycDY3enE4TWhncTl0STdUejE5S2NNeEFsQ2R1cXEzRmZ1Vm1ZbktYNnNtM1FSM0NnR3lXWmZTYXBLaXRoM2VvR1NvdmNZL0w2NVo5dDNicjNwV2Q5VStWMW5TZVpiT3N4bjlvdG5DcHdwaEJvZThwQXJBR3FMZmtGenIvODdzTTNuYlZ5elVVQWlXU1MzZnVQMG56b2ZaSWFCQzdmN3NSWlhvVTVUOStPR0VsdkY0RVhmeXhGOXIwNEoxNUdtN2Vna2NLcnZ5N3lGalRxODdkaVVZSzlKNGxIdzlyeWV0VnlscDVWUFNhdjk3MzZoOWVlK2VGM1hrdnhsMG55dXM2VEZBQm5ERGpiTm8yVTJ0dDZ6SllKL0tjYXFGcDI0WVpIUDNuek4vWlducjI4Q1NBVWliSno3MEdPSEQrcC9SZnBMc0ZaV3FIYlFJeDN0dUI5N250U3ZMTmxWZ0xHNUN6RmZlV3R3bjdPUnAxZGVFbUMvZDFFL0VQWk03WEpSTk95eGF4WnNWU1h2Szd6SkNmTmNXY2NPS21Ma0lDOENRWmlEVkR4c1J0dXVlQzhhejUzV1VsMWJSMUE3NkNYSGJ0YTZSMzBadWMvc2dsSGlRZGJVYWxtQitLb05JM3MreU8rRng2UUZIL1A3SmlWVEJhY0YxOHZYSmQrV1ZlWkFDRUllL3NKRGZab1Y2OXJQS3hidlFLbjNhWXByK3M4eWJSZk5pdUFNK0ZpWktBZ3hYK3FVaG1vN0xvNzcvM2twQUxxOFpQczNIdUFVQ1M3eVdleTVPRXNxOExxMHRjMklCSXhnbS8raXNEMm41MVJBOUhhOERFS1AvazFZUzZwMFhWOExCd2cwSGVTWkd4WVExNDdXWDl1STlVVnBacnl1czZUblJUTkt1Qk11Q2dUWUV2eG4xRUNQYW1BbWxRVW1nOGVaZmYrSXlTU3llejh3R3JIVlZGRG50V3UwMEFjd1AvaVExSm85ek1mcVlGb0tWOUUwY1p2aUlLbEYramphZkVZZ2Q0VERJZXl0NW5rNTFsWXUzSTVEV2N2SEpYWC9ZZmZmWE5ISm5rOXltUG1ISEFtWEZ6YUF1cWYzYjVsVi9XeUZhc0JJdEZoM21rK3lLRmpuWnE3blZwZHhiaktxM1ViaUltK1kzaWYrNTQwZlBpdEQ5ZjBMWERpdnVJVzRUei9PbDFsQXFHcUJBZTZDQS8xWmIxblNaS29YM0lXNXpjdG55U3Z0OTF4Nnk5ajRWRHZCQjR6QUVRelRVdHpEamdUK00rMEF1cTY2LzdpM0FzL2UvMlZaYldMbGdFTWVQM3MyTlZLVjkrQUJuK1djWlJVNENqMTZPNUFIRzU3Qys5ejM1TVNmUit3Z1NpYmNLejk3QldGVjl6OFI5bFdxT3NqRWQ4Z3diNlRtczNobGVVbFhMeW1jWks4ZnVYbkQvNSt6NHRQdDA2UjE2RTZUM0xHdnNTc0I4NFUvak5hUUIwMUVNdXUvWnU3THErLytMS0wzZVdlV29Cako3clp1YWNWZnpDN0REV1pMYmpLYTdBVjZ2TkRVQldDNy80VzM0c1BmU0FHWXNHaWN5bmErQTJSVjdWTW4vcUxodkQzZEJLUGhyVGw5VGtOTEQyclpxSzgzdjdNRDcvemFqWjVuYlBBbWNKL3JGUDV6NWUrcy9Wemk4OVplMkdlMWVaVVZaVjloOTVuVjJzYnNiaDJBNW5iVTZ0akNjK29nUmpFLzhwL0VIenI4Vk15RU0yRkhvbzJma1BZVmx5dWoyOGxFd1I2VHhEeERXakw2K1ZMV0xPaWJteDd2Wm5JNjV3SHpvUUxOMC9nUDlWQWxXZHgzUzgvZCtjOTd5eW9YN2tXVWcxa3pRYzVjS1JkVndPWjIxT0RPVjlmQlQ0NTJJbnZ4WWVrY1BNTHVneEVLYytLKzlJdkM5ZjY2NUVzMmwyT1FnaENBejBFKzdzUUdzWGZSUXNxV2JlNkVhZmoxT1gxdkFIT0ZQN2pBaXBTMDVmbnZHdXVhNXJVUU9ZUHNtTlhDNTNkdlpvR29xT29ERmRGalc0RE1kYlp3dERUMzVWaW1ReEVTY0xlOUFtS1BubWJNQmQ2ZEgxbk5PREYzOU5KTXE0aHI5MU8xcC9iUkxXbkxKMjg3Z0U2OWNycmVRV2NLUURLQndvbitEL2wweHJJdW52WnNhc0Zyeitvd1ZsTk9NdXFjWlI0OUhVZ0NrRzQrUVc4Zi9paGxQU05HNGg1VmNzbytmUWRJcisyU1orS2kwWHhkM2N3SFBKcHl1dnpWaTVuUmQxaVpFa2lFdkQxdDczenhtbko2M2tKbkNrRWVyU0JySnBNRFdSSDJubTMrWUJtQTVrNXJ3QjNaZTJNRE1UQUc3OGcrTjd2cGNMTC9vZHduUHNwME9GY3E0cENzTzhrd2NHZXJOT0VqdXZ2QUFBRHhrbEVRVlRlbUx4ZTFUQkpYdi8wenMyL0hBNEZUMHRlejJ2Z1RPRS8yUnZJNGdsMnRSeGkzNkdqMmcxa0RoZUZsV2RoMFdrZ3ppVENRMzM0ZXpwUU5Vek15dklTTGo2dmlkS2l3akY1L2VwakR6MjkrNFduOW4wUTh0b0F6dVNiMDI0Z0M0Ylp1YnVGWTUxZG10OW5MeTdIWGJGQXQ0R1lsUnVGQS9pNjJ2VlZyMWMzc25UaHVMeHVlZTJGMTUvK3dmMnZNTkljM3ZsQnlPczVBNXhuOW4wMHhjUTNicnRjWHdOWjd3QnYvbWtmQTk3cy9FS1NUYmpMcTNHV1Z1bzJFQ2Vwc1VRTVgzZUhMbm05cW40cHExZlVZVEdiTmVYMStoKzlyUElSeGh1M1hYNkdnTlB5MFZhaDMvanE1Zm9heU40L3p0dDc5eE9KWmxjMEprc2Viazh0anVKeVhlY1hxa3F3dnd0LzN3a2Q4cnFLZFd0VzRuS01USTFkYmZ0M1AvWDlmMDRycjljLzhQSVo2Y1ovNDZ2ekJEZ1RibGhmQTFsckczc1BITlpzSU11ejJpbXNXcGgxQ1UvRVA0aXZxMTI3T2R6dFl2MTVUZFI0eWpYbDlmb0hYbzV6QnVPTUFlZlpsak83Y083MXIxNm0zVUFXanJCemR5dUgyenMxdjgvbUxxR29haUhtL1BFT3hIZzBqUGZrTVYzVjYvT2E2bWxjdGlRbHIvMERiZSs4L21ZbWVYM0pBNitjOFpiRjE3OTYyZndFVHVybTlUV1FEUXp4MXE0V3VqVUxxQkxPc2lxY0pSNEMvVjM2NVBYU2hWeHd6b3BKOHZyblcyNzdYaVRnVjZmSzYwc2VlR1hXTEJLYjE4Q1pNQWk2R3NpT2RYYngxcTU5K0lPaDB6NW5aWGtwNjg5YlJXbnh1THgrN1pjUFA3M3IrZDlOazllWFBQREtyT3VxTjRBemVURFNOcEI5K1Y4ZXZHN1JxblBQSHkrZ0h1VlArdzVvRmxBenl1czFLemw3NFlJeGVkMjYvY1hYbi9yK1A2ZVYxN05oV3BwVndObjYyQlBNMXVoNDZLNXBEV1NleFhXL21GeEFqZkh1M2dQc1AveStaZ0YxWEY2ZnplckdaWm5rOWFoYUdnS0dhMis1UjJVV1I4ZERkeG5BeVRBd0V4dklSZ3VvRmRNTHFBRjIvS21aanE1ZURYbmRoTXVaa3RlSEQreDU2bnYvdEhxS3ZCNEFRclczM0RNbkZydWZPZUE4K2h2bXhBRDk1QjlIRzhnS1V3WmkyZ0pxUjFjUE85NXJ4dXNQVEpiWGExZFJVMW1oS2E5cmI3NDd6aHlLanAvOG93R2NHUUJJczRDNnYrMTltZzhjcG5IWkVocVhMeDJWMTROdDc3eitSaVo1WFh2ejNYTnVTekVET0RNZk1NMEM2c1E0dm0vWDI0Lyt3KzEzaDMxRHpxbnl1dmJtdStmc0hpd0djRTU5NE5JV1VOZHYrdExmbE5TY3RXand4UEZqTzUvOHoxZDNQZjlrODFSNVhYdnozWE4rMThzekJweGNpRXc3Y0tROG9lRVVVQ2JKNi91Mjd4YzVjdStuOURrelJwQUN3ZkNXRFExeElKU2FnaW9aYVdVTnBqTE5FREI4My9iOXFqRmlCbkNtQWtnRndsczJOQXdEdmxRV2lnUFIrN2J2VHhvak5CNy9IMXRBd2dxN0hQQTVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5Li755WM6Z2iL+WktOWDjzEucG5nXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJzdGF0ZVxcXCI+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBtb25leSB0YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwibW9uZXktc3RhdGUgdGFibGUtY2VsbFxcXCI+PGRpdiBjbGFzcz1cXFwiYnV0dG9uXFxcIj48dGFibGU+PHRyPjx0ZD48c3BhbiBjbGFzcz1cXFwibW9uZXktbnVtXFxcIiBjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiIEBrZXl1cD1cXFwiY2hlY2tEYXRhXFxcIiBAYmx1cj1cXFwiY2hhbmdlRGF0YVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJ7Zm9udFNpemU6MzQqem9vbVJhdGUueCsncHgnfVxcXCIgdi1odG1sPVxcXCJ1c2VyQmV0LmJldG1vbmV5XFxcIj48L3NwYW4+PC90ZD48L3RyPjwvdGFibGU+PC9kaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwic3RhdGUtaXRlbSBwb3J0cmFpdFxcXCI+PGRpdiBjbGFzcz1cXFwicG9seWdvblxcXCIgQHRvdWNoZW5kPVxcXCJzaG93TWVzc2FnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJoZWFkc3R5bGVcXFwiPjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHYtYmluZDp3aWR0aD1cXFwiaGVhZHNpemUud2lkdGgrJ3B4J1xcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0KydweCdcXFwiPjxkZWZzPjxwYXR0ZXJuIGlkPVxcXCJpbWFnZVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgcGF0dGVyblVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIj48aW1hZ2Ugdi1lbDppbWFnZT1cXFwidi1lbDppbWFnZVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIj48L2ltYWdlPjwvcGF0dGVybj48L2RlZnM+PHBvbHlnb24gdi1iaW5kOnBvaW50cz1cXFwiaGVhZGJvcmRlclxcXCIgZmlsbD1cXFwidXJsKCNpbWFnZSlcXFwiPjwvcG9seWdvbj48aW1hZ2UgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgdi1iaW5kOndpZHRoPVxcXCJoZWFkc2l6ZS53aWR0aFxcXCIgdi1iaW5kOmhlaWdodD1cXFwiaGVhZHNpemUuaGVpZ2h0XFxcIiB2LWJpbmQ6eGxpbms6aHJlZj1cXFwiaGVhZGJvcmRlcmltZ1xcXCI+PC9pbWFnZT48L3N2Zz48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJzdGF0ZS1pdGVtIHN0YXJzIHRhYmxlXFxcIj48ZGl2IGNsYXNzPVxcXCJtb25leS1zdGF0ZSB0YWJsZS1jZWxsXFxcIj48ZGl2IGNsYXNzPVxcXCJidXR0b24gdW5kb1xcXCIgQGNsaWNrPVxcXCJjYW5jZWxiZXRcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1N0YXRlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHNyY1xcXFxjb21wb25lbnRzXFxcXEJldE11bHRpcGxlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtOGZmNDA2N2UvQmV0TXVsdGlwbGUudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvQmV0TXVsdGlwbGUudnVlXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vQmV0TXVsdGlwbGUudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0JldE11bHRpcGxlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9CZXRNdWx0aXBsZS52dWVcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4ubXVsdGlwbGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcXG4gICAgaGVpZ2h0OiAxMiU7XFxufVxcblxcbmRpdi5iZXQtYnV0dG9uLWFyZWEge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnRlbiB7XFxuICAgIHdpZHRoOiAzNCU7XFxufVxcblxcbmEuYnV0dG9uIHtcXG4gICAgLyp3aWR0aDogMTAwJTsqL1xcbiAgICAvKmhlaWdodDogNTAlOyovXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbiAgICAvKmJhY2tncm91bmQ6ICNDQ0M7Ki9cXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcXG4gICAgcGFkZGluZzogLjFlbSAxZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZT8zODAzOTc5YlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7SUFDQSxpQ0FBQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLGVBQUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFdBQUE7Q0FDQTs7QUFFQTtJQUNBLGdCQUFBO0lBQ0EsZ0JBQUE7SUFDQSxlQUFBO0lBQ0EscUJBQUE7SUFDQSxvRUFBQTtJQUNBLGtCQUFBO0lBQ0EsbUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiQmV0TXVsdGlwbGUudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICAvLy0g6YCJ5oup5LiL5rOo6YOo5YiGXFxuICAgIGRpdi5tdWx0aXBsZVxcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5vbmVcXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxcbiAgICAgICAgICAgICAgICBhLmJ1dHRvbiAxWFxcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5maXZlXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gNVhcXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEudGVuXFxuICAgICAgICAgICAgZGl2LnRhYmxlLWNlbGxcXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMTBYXFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB7fVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4ubXVsdGlwbGUge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMCwgMCwgMC42KTtcXG4gICAgaGVpZ2h0OiAxMiU7XFxufVxcblxcbmRpdi5iZXQtYnV0dG9uLWFyZWEge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIHdpZHRoOiAzMyU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuZGl2LnRlbiB7XFxuICAgIHdpZHRoOiAzNCU7XFxufVxcblxcbmEuYnV0dG9uIHtcXG4gICAgLyp3aWR0aDogMTAwJTsqL1xcbiAgICAvKmhlaWdodDogNTAlOyovXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcbiAgICAvKmJhY2tncm91bmQ6ICNDQ0M7Ki9cXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcXG4gICAgcGFkZGluZzogLjFlbSAxZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDFlbTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxuICAgIC8vLSDpgInmi6nkuIvms6jpg6jliIZcbiAgICBkaXYubXVsdGlwbGVcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5vbmVcbiAgICAgICAgICAgIGRpdi50YWJsZS1jZWxsXG4gICAgICAgICAgICAgICAgYS5idXR0b24gMVhcbiAgICAgICAgZGl2LmJldC1idXR0b24tYXJlYS5maXZlXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDVYXG4gICAgICAgIGRpdi5iZXQtYnV0dG9uLWFyZWEudGVuXG4gICAgICAgICAgICBkaXYudGFibGUtY2VsbFxuICAgICAgICAgICAgICAgIGEuYnV0dG9uIDEwWFxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubXVsdGlwbGUge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAwLCAwLCAwLjYpO1xuICAgIGhlaWdodDogMTIlO1xufVxuXG5kaXYuYmV0LWJ1dHRvbi1hcmVhIHtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgICBmbG9hdDogbGVmdDtcbiAgICB3aWR0aDogMzMlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuZGl2LnRlbiB7XG4gICAgd2lkdGg6IDM0JTtcbn1cblxuYS5idXR0b24ge1xuICAgIC8qd2lkdGg6IDEwMCU7Ki9cbiAgICAvKmhlaWdodDogNTAlOyovXG4gICAgZm9udC1zaXplOiAyZW07XG4gICAgLypiYWNrZ3JvdW5kOiAjQ0NDOyovXG4gICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoMzE1ZGVnLCAjZmVhZTNkLCAjZWY4YjExKTtcbiAgICBwYWRkaW5nOiAuMWVtIDFlbTtcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XG59XG48L3N0eWxlPlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogQmV0TXVsdGlwbGUudnVlPzM4MDM5NzliXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm11bHRpcGxlXFxcIj48ZGl2IGNsYXNzPVxcXCJiZXQtYnV0dG9uLWFyZWEgb25lXFxcIj48ZGl2IGNsYXNzPVxcXCJ0YWJsZS1jZWxsXFxcIj48YSBjbGFzcz1cXFwiYnV0dG9uXFxcIj4xWDwvYT48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJiZXQtYnV0dG9uLWFyZWEgZml2ZVxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+NVg8L2E+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiYmV0LWJ1dHRvbi1hcmVhIHRlblxcXCI+PGRpdiBjbGFzcz1cXFwidGFibGUtY2VsbFxcXCI+PGEgY2xhc3M9XFxcImJ1dHRvblxcXCI+MTBYPC9hPjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0JldE11bHRpcGxlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL01lc3NhZ2UudnVlXCIpXG5fX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj9wcmVzZXRzW109ZXMyMDE1JnBsdWdpbnNbXT10cmFuc2Zvcm0tcnVudGltZSZjb21tZW50cz1mYWxzZSEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxNZXNzYWdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi0zM2ZkYjgwNy9NZXNzYWdlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vTWVzc2FnZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9NZXNzYWdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9NZXNzYWdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5kaXYubW9kZWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHotaW5kZXg6IDk5OTtcXG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDEyLDI2LDU1LC4zNSk7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZ1wiKSArIFwiKTtcXG4gICAgdG9wOiAwO1xcbiAgICAvKnBhZGRpbmc6IDEwJSA3LjUlOyovXFxufVxcblxcbi5tZXNzYWdlLXRyYW5zaXRpb24ge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuM3MgZWFzZTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbn1cXG5cXG4ubWVzc2FnZS1lbnRlcixcXG4ubWVzc2FnZS1sZWF2ZSB7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi50aXRsZSB7XFxuICAgIGhlaWdodDogMjAlO1xcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXFxufVxcblxcbmRpdi5jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LmNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlPzVkMjNkMDU2XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrRkE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsYUFBQTtJQUNBLG1DQUFBO0lBQ0EsMENBQUE7SUFDQSxPQUFBO0lBQ0Esc0JBQUE7Q0FDQTs7QUFFQTtJQUNBLGlDQUFBO0lBQUEseUJBQUE7Q0FDQTs7QUFFQTs7SUFFQSxXQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0Esc0JBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGtDQUFBO0NBQ0FcIixcImZpbGVcIjpcIk1lc3NhZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcbiAgICBkaXYubW9kZWwodi1zaG93PSdkaWFsb2dTaG93Jyx0cmFuc2l0aW9uPVxcXCJtZXNzYWdlXFxcIilcXG4gICAgICAgIGRpdi5kaWFsb2codi1iaW5kOnN0eWxlPVxcXCJkaWFsb2dcXFwiKVxcbiAgICAgICAgICAgIGRpdi5jbG9zZSh2LWJpbmQ6c3R5bGU9XFxcImNsb3NlXFxcIixAdG91Y2hlbmQ9XFxcImRpYWxvZ1Nob3cgPSBmYWxzZVxcXCIpXFxuICAgICAgICAgICAgZGl2LmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXG4gICAgICAgICAgICBkaXYodi1iaW5kOmlzPVxcXCJkaWFsb2dJbWdbY3VycmVudEluZGV4XS50eXBlXFxcIix2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIsdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIpXFxuICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XFxcImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcXFwiKVxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGRpYWxvZ1Nob3c6IGZhbHNlLFxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogMCxcXG4gICAgICAgICAgICBkaWFsb2dJbWc6IFt7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdiZXRJbmZvJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5oqV5rOo6K6w5b2VLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9udXNSZWNvcmQnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lvIDlpZborrDlvZUucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdydWxlSW50cm9kdWNlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhZHmjaLllYbln44ucG5nJyksXFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhbPpl60ucG5nJylcXG4gICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIHR5cGU6ICdleGNoYW5nZScsXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+i1oOmAgeWlveWPi+mHkeW4gS5wbmcnKSxcXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+WFs+mXrS5wbmcnKVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlY2hhcmdlJyxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZycpLFxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZycpXFxuICAgICAgICAgICAgfV1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIGRpYWxvZygpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA3NjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDE0MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDQ1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBjb250ZW50KCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY2xvc2UoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQyICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0MiAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0ODQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAndXJsKCcgKyB0aGlzLmRpYWxvZ0ltZ1t0aGlzLmN1cnJlbnRJbmRleF0uY2xvc2UgKyAnKSA1MCUgNTAlIC8gY29udGFpbiBuby1yZXBlYXQnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XFxuICAgICAgICAgICAgdGhpcy5kaWFsb2dTaG93ID0gdHJ1ZVxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gZXZlbnRcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcG9uZW50czoge1xcbiAgICAgICAgYmV0SW5mbzogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlJyksXFxuICAgICAgICBib251c1JlY29yZDogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZScpLFxcbiAgICAgICAgZXhjaGFuZ2U6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWUnKSxcXG4gICAgICAgIFJlY2hhcmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlJyksXFxuICAgICAgICBydWxlSW50cm9kdWNlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWUnKVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG5kaXYubW9kZWwge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHotaW5kZXg6IDk5OTtcXG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDEyLDI2LDU1LC4zNSk7Ki9cXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZyk7XFxuICAgIHRvcDogMDtcXG4gICAgLypwYWRkaW5nOiAxMCUgNy41JTsqL1xcbn1cXG5cXG4ubWVzc2FnZS10cmFuc2l0aW9uIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xcbn1cXG5cXG4ubWVzc2FnZS1lbnRlcixcXG4ubWVzc2FnZS1sZWF2ZSB7XFxuICAgIG9wYWNpdHk6IDA7XFxufVxcblxcbmRpdi50aXRsZSB7XFxuICAgIGhlaWdodDogMjAlO1xcbiAgICAvKmJhY2tncm91bmQ6IGJsYWNrOyovXFxufVxcblxcbmRpdi5jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuZGl2LmNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC8qYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuNik7Ki9cXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBGTVRaRVF6TXdSRE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEZNVFpFUXpNd1JUTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rVXhOa1JETXpCQ00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tVeE5rUkRNekJETTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrWDJ5bWF3QUFBQTlKUkVGVWVOcGlZR0JnbUFrUVlBQUFuZ0Nhb01YTEN3QUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgICBkaXYubW9kZWwodi1zaG93PSdkaWFsb2dTaG93Jyx0cmFuc2l0aW9uPVwibWVzc2FnZVwiKVxuICAgICAgICBkaXYuZGlhbG9nKHYtYmluZDpzdHlsZT1cImRpYWxvZ1wiKVxuICAgICAgICAgICAgZGl2LmNsb3NlKHYtYmluZDpzdHlsZT1cImNsb3NlXCIsQHRvdWNoZW5kPVwiZGlhbG9nU2hvdyA9IGZhbHNlXCIpXG4gICAgICAgICAgICBkaXYuY29udGVudCh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXG4gICAgICAgICAgICBkaXYodi1iaW5kOmlzPVwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVwiLHYtYmluZDp6b29tLXJhdGU9XCJ6b29tUmF0ZVwiLHYtYmluZDp1c2VyaW5mbz1cInVzZXJpbmZvXCIpXG4gICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cImRpYWxvZ0ltZ1tjdXJyZW50SW5kZXhdLmJhY2tncm91bmRcIilcbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ3pvb21SYXRlJywgJ3VzZXJpbmZvJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpYWxvZ1Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgY3VycmVudEluZGV4OiAwLFxuICAgICAgICAgICAgZGlhbG9nSW1nOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiZXRJbmZvJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+aKleazqOiusOW9lS/mipXms6jorrDlvZUucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib251c1JlY29yZCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lvIDlpZborrDlvZUv5byA5aWW6K6w5b2VLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncnVsZUludHJvZHVjZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+a4uOaIj+inhOWImS/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNouWVhuWfji5wbmcnKSxcbiAgICAgICAgICAgICAgICBjbG9zZTogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWz6ZetLnBuZycpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nJyksXG4gICAgICAgICAgICAgICAgY2xvc2U6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v6LWg6YCBL+WFs+mXrS5wbmcnKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWNoYXJnZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZycpLFxuICAgICAgICAgICAgICAgIGNsb3NlOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhbPpl60ucG5nJylcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGRpYWxvZygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDU1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA3NjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMTQwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgNDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNDIgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMjMgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyA0ODQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICd1cmwoJyArIHRoaXMuZGlhbG9nSW1nW3RoaXMuY3VycmVudEluZGV4XS5jbG9zZSArICcpIDUwJSA1MCUgLyBjb250YWluIG5vLXJlcGVhdCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIHNob3dNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1Nob3cgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGV2ZW50XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgYmV0SW5mbzogcmVxdWlyZSgnLi9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlJyksXG4gICAgICAgIGJvbnVzUmVjb3JkOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvYm9udXNSZWNvcmQudnVlJyksXG4gICAgICAgIGV4Y2hhbmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvRXhjaGFuZ2UudnVlJyksXG4gICAgICAgIFJlY2hhcmdlOiByZXF1aXJlKCcuL21lc3NhZ2VDb21wb25lbnQvUmVjaGFyZ2UudnVlJyksXG4gICAgICAgIHJ1bGVJbnRyb2R1Y2U6IHJlcXVpcmUoJy4vbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZScpXG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5kaXYubW9kZWwge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgei1pbmRleDogOTk5O1xuICAgIC8qYmFja2dyb3VuZDogcmdiYSgxMiwyNiw1NSwuMzUpOyovXG4gICAgYmFja2dyb3VuZDogdXJsKC4uL2Fzc2V0cy/liIflm74v5pqX6Imy5oyh5p2/LnBuZyk7XG4gICAgdG9wOiAwO1xuICAgIC8qcGFkZGluZzogMTAlIDcuNSU7Ki9cbn1cblxuLm1lc3NhZ2UtdHJhbnNpdGlvbiB7XG4gICAgdHJhbnNpdGlvbjogYWxsIC4zcyBlYXNlO1xufVxuXG4ubWVzc2FnZS1lbnRlcixcbi5tZXNzYWdlLWxlYXZlIHtcbiAgICBvcGFjaXR5OiAwO1xufVxuXG5kaXYudGl0bGUge1xuICAgIGhlaWdodDogMjAlO1xuICAgIC8qYmFja2dyb3VuZDogYmxhY2s7Ki9cbn1cblxuZGl2LmNsb3NlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG5cbmRpdi5jb250ZW50IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgLypiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC42KTsqL1xufVxuPC9zdHlsZT5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIE1lc3NhZ2UudnVlPzVkMjNkMDU2XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd01EVkRORFkwTWpOR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TURWRE5EWTBNek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakF3TlVNME5qUXdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQXdOVU0wTmpReE0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0lpMk4rUUFBR0xOSlJFRlVlTnJzM1F0c1hmVjl3UEcvbjNIc0JGZ1NWbGg0ZFVCUjJNTFFJQlZVaUJaYUpsSlZ0QnNxS3hxMDY2b0tXQjlhcDAyYXFnbDE2NFEyVFlOSkJRbjJWRWM3dWpLbWxUSG95bFphVkExVVlDcGhEUVhLS0k4TUtDUlFIRHYydFgyOTg3dlkyZkc1NXo3OHVPWUdmejdTWDVCenI2K2RZMGZuNjNQKzUzOTdabmZkbVphZ054czdzbkZlTnM3TXh0dXlzVFViSTlsWWx3Q0F0V0l5RzJQWjJKT054N1B4WURidXljWUQyYWcyL0tqdE8wczM5eS95a3grVGpVOWs0OWV5Y2F6dkJRQ3NlZXZteHFiSWpXeGNQTGY5Mld4OE9SczNaT081ZGwrc3Q4M25iWjU3NFNlejhYdWlCQUJvNGRpNVpuaHlyaUUycjFTWVhKS05IMlRqTjdNeGFEOERBSXN3T05jUTBSSy8ydXJKL1MwZSswSTJyaXg3c1BxVDExSmw5eE5wZXMvemFlYmxmYWs2dWorbHFlazBPejN0V3dBQWEwUlBmNVlMQS8ycGQrT0cxTGRsVStyZmVuUWFQUFhrMUh2NFljV25ic25HVjdMeHJteDhLaHVsd2REVFlQTHJjRGIrSVJ2dkt6NHd2ZWVGVk5tMU8wMDg4RDNmRFFDZzFOQ08wOVBnYWFkbW9YSlUyY04zcERoN3NuM25lRHRoRW1kS2JzdkdSY1VIeHUrK04wM2M5NkM5RFFDMEZ5aG5uNW1HTHppMzdLSGJVMHlVM2I1enVoZ2hSZGNYbzJUNm1UMXA3T3YzcEprWGZtd1BBd0J0aXhNYVUwODluVVl1UEQvMUg3YzEvOUJGYzgyeFlNcEljZkpyVEVxNUlyOWg2c2tmcGRGYi9sbVVBQUJMTXZQQ1M3V1dpS1lvdUNJOWN0ZWxqY0prODF5NUhEVDk5SE5wLzIxM3B0bkpTWHNWQUZpeWFJbG9pbWlMZ3V1ek9EbXlMRXorS0wwK1kvYWdzWCs3SjgxT1ROaWJBTUR5NHlScmlwZ2FVaEFMczMyK0dDYkhaZU5qK1dmRlJOYzQ5UUlBc0ZKbVhud3BqWC9qMjhYTnY1RWV1ZXU0ZkpoY2xZMkIrVWRqYlJKMzN3QUFuVEJ4LzBPMTFzZ1ptR3VSV3BqRXVDei82T1REdSswMUFLQmpTbHJqc3ZUSVhiM3o3eEo4elB6VzZxdXZwY2tISDdiSEFJRE9oVW5XR3RFY09kRWlPeUpNenM5dnJUejZoTDBGQUhSY1NYT2NGMkZ5Um41TDRab1BBRUJIbERUSG1SRW1wK1MzeEJ2eUFRQjBXa2x6bkJKaGNuUitTM1gvbUQwRkFIUmNTWE1jSFdHeU1iOWxkckppVHdFQUhWZlNIQnNqVEFZWGJKcVpzYWNBZ002cmI0N0JYbnNGQU9nV3dnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBbmRadkYwQ0gvNUZ0UHlPdHYvU2pCLzg4ODh4VGFmekdQNnY5Zjg4Um0xUC9xYWN0K2JWbjlqeWJxay8vc083ejlXdzg3T0NmWjBkZlM5T1BQTlQrYnl2SG41VDZ0aDY3WU52MDdsMXA5dFc5aS82N2xqbHd5OS9XdnA1MXYzSlpHanp6ckdYdjMvblhtN2RTcjl2Vy9zOTlMd0ZoQW9lRWlJU0JrMDhwL3dlWVJjbkd6M3gyeWE4OWZ2dHRhZUxtaFdFU1laRC9mTE1IRHFSWFBueFJ5L2lZTjNqV3VXbmQyZWZVZlo2Wkp4OHJmWDQrV3ByOVhlZE56RVZUejhpR2xzOXR4MFF1d2xieWRRRmhBbThLOFJ0N0hCem45UjM1bGdXUDkyM2Vrb1l1dnpJTGloczc4dm1uSHYzdkJRZm1udlhyYXlHU1A3TXllTzU3MHZCRkY3ZjltczJlTzNyZE5XbnFQKy94alFlRUNYU2p1SXpRN0RmMjNrMmJhd2Y2VG9WSjljWG42Lytobi9KenFWSzQ1UE5tRldkMjRneFBKd3lkODY3YTl3OFFKckJtVE85NU5zMk9qNWYvZ3ozbXVOb1prS1lmLzlqMzZ6L3VaMDlLbGRXSWd1eHJieFVGOFp5bEJrUTdZUkJuYnpwMUJtZGcyODhMRXhBbXNMWWMrT3JORFErc0c2KzV2dVg4aWJoa0UvTks4Z0V6OU80TFU4L3dodFM3NWNqYW55ZnV1SzFoRk1UQnQvZzVKdS83VHBwNTZjV21vVEgvdVl0elhsWXlJTm9KZzRGM25KZjZUdXpNSEpPNERBY0lFemlreEowYWVUM0R3Nm0vTU5HMFU1Y2E1azAvOTB4ZFhPUW50STQyaTRMTHI2ejcyTXI5OXg0eTgwZ2lTaFl6ZndZUUp2Q21Wcng5Tkg2REw5NTUwNm41SmZPS0UyQUJoQW5RVU55VlU3bjMzenYyK3BQL2NtdnBKWmxPYTdZdVM5bWFLNTBRKzdYUnJjM0x0ZjZTeSt2T2ZnSENCQTU1Y2FsaEpRNmUvY2UvdGU1VzRCRHJpb3grOXBQTFhzQnQwVjlQazNWWnl0WmNXYXpaOGJHV3o0bDkwYWtBR25xZlMwUWdUT0FRMTN2VTFvWUh1Ykl6R3JGU2E3c0dmK0VYMC9UVDd6bDR3STlJR2JuaXR4WThKeTdyZFByUzBWSXNKWnA2aGtkYTcrOG1pOGN0KzJzZUhxNzdjNngydTVpVmRRRmhBbStvZ1ZPM0wrcjV6UTV5cmM0WXhKbUM0aTNGY2ZEc3hqQlo3cXEzRFdOdGtZdkhMZXZ2a0FWUXJMUTdLa3hnNVg2WnN3dWdnLy9Bc3QvZTQ2eEdVVnpXcUw3OFV0MzJxU2VhWDk2WitOcFhVM1ZmOC9lc21YcjgwYnFEWjN3ZHF5SE85c1RmWVRwM0MzR256YXppNXdKV0lmanRBdWljK08yOU5EQnV2ckYydDA1K2JaRFpzZjJwOHMyN21yNWVuRTE1OVlvUExYaWp2dUtCZWZycHArcGlLTDZPL1B5T1ptKzJWN1pXUjB6NmJEUy9JdjhtZXZIZk9IdFFkaWRTSjBTa1ZkZklpcllnVElEbGg4a1piMi80V05sNkd5T1hmbVRSbnlQZXF5Wi9jSjcrM2dNcEZWNTMvUVh2cmQybGN6Q003cmh0VVhmc05Mc1RwZmdtZXNzUkM4UEZHaXh0UFhkOHJIWUdxU3o2Rm5QcGF0T3RkeS80YzV6eGlZbkRnRENCTjVXNGZQSkczRm9hWnkyS0s3L0cvK2REWktKTDkxbEV5WEtqSUNiVmJ2emNuOWJ0Ky8xL2VYMnFmT05yeTNydGVJUEdlQytrdk1xRDk2ZkpmL3FTSDNnUUp0RGRHbDNHV1EweHo2UnNic3RhRUxkSzc3L3VtblQ0NTY5ZEVHY2JQcDRGejhmL1AzcGF2U3R5V1lRVXp6TEZYSnBXbDk4QVlRSmRJZDV3YmxVT3hDVzNGOGNsam9HM2JXdjRobi9UdTNmVkRzeWxRWFhXdVF1V3J3OHhXYmZSdWl2eFd0MG1MbTN0di9HNlpjMXo2Um5aMFBKeTEvaGYzMUFMSVVDWVFGZUx5Wit0M213dTVrSEVLcVZsYTI3RXdUNS93SXZmM3N2bW40emQ4c1hTMjR0ajJ5c2Z2cWoyZFRRNnE5RG9iRUhaRytCRmxCd3E3NVV6TDc3ZXNhTzJwdUVQWE5MeUhabVhJbUxOK2lVZ1RLRHJ0Zk1Pd0FjRDRTZXZwUFhaYi9YRitSQnhpV0QwYzc5YkM0aG1VZEpxYmtNY25PUHJLZHUrRnNUK2lWRzI2RnFyTXozTmxyYVBzMVNpQklRSkhKTGlMbzlHb1ZKYk9qNExrT0premZqLzJGWjU2THVsaTRYRmIrdnRUTGlNMjRMTDVrV3NOUkVseFROQmNadjFZaS9ERk05a0FjSUVEcjNmMnI5MWQ5TXpLTTNpcE95dW5zbjd2dFAyN2JEOXArK29QN2orNFB0cmF2L0hYVG9icnZ6TWdzczVFWXV0OW1IRVRIR095dXZ2OTNPakgycm9JQ3Uvd2dxTEJjZGlZbW1NVjMvbnFyWnVVWjJQazFabk15Skt4cTc5ZzdhL2x2emFKUWZENUgvVzFvSms2ei8wNjNWelRNWnUrdk9XSHhlWHU0b3I4Y1o2TUJFNmdEQ0JRMGJNUGFnZDFMS3htRlZKVzhWSjVlSC9XbFNVeEFHMDdFek4xSGUvczJhK0YzRXBhK2pkRnk3WVZuczdnRGEvTDdFUTNZSjltZ1ZPaEE0Z1RHQk42RHYyaE5TM2FVdnBZM0g3Ynh4bzJ6WHc5blBxbzJrSjh5cFdVOW43QnkwbFJ1SnVwTUZmZW44YS90Z25GcjcrdnIxMWwySmlNYnBHSWk3akxGVmVoRTZqdTUyQUZmaUZ3aTZBbFRkMCtaVXRueE4zMjhSYUdYbTFTd1VOYm0yTjdZZGQvY2UxQTJYK1BYYUt0L0xHWFRpeFhIdUVURjJZek0wdktTN0Qza3B0cmtXRE5VSGFYY0k5dnl4K28rZkgraW1EZjNmN29tN3ZMUzZVRnU4QjFHaE96OWdYYjNvOTJyS3dtSjhNMitwekhianR5M1hydXNUK3FIN2tpdG90NGZzK2VJRWZlQkFtME4zSzdxUXBpbFZGVzkxV1hIWkhUOW5pWi9rRGM3UFhuUG54aTIvWVBpa3VpOS9zZVowUVFUZS9uOHJlcDJoZVJGMWVYUGFKankzdTkxYnIxQUJMNDFJT3JMTGloTXBHSWpqaXpFSzh4MHV6eXczdGl0ZFlyZVhUeTFhanJZdWtWYnh0T1M3aHhKbVB0cjQvdXgrcDJ4WWZ1eExmQTZBMVoweGdGY1VFMXJKM3hNMkxlU0NUOTM3ejREb2xjVmRQOWZubjB0RDdMMGs5d3lQMUVUQzJ2K1huamRmTUw1L2ViaHkxWSthWnArby8zeU1QbFo1bEtKNkptUGlQcjZkMTczam5pcDRsYWVleVVseitpdkFyMjE2MitGeDhyYTkrK3FPcC85VFQvQkJEaC9YTTdycHpOcjloM3g5ZWE2OEFBS3RpMDlXL3ZlRFBMdVVBQUYxRG1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBckpEK2J2OENaN094cnpKVkc2TlRNNmxTcmRhMkFRQ3Q5ZlgwcE1IZW5qVFMzNWMyRFE3VVJvOHdXWnFJa2FmSEo5TEVUTlZQRmdBc3djenNiRG93RTZPYVhwNmNTa045dmVuNDRhRmFvSFNqcnJ5VUUyZEVJa2dlR3gwWEpRQ3dndUs0R3NmWE9NNTI0eFdJcmd5VFo3S2Q5YjhISnYzMEFFQ0h4SEUyanJmQ3BJVzlsU2xSQWdDckZDZHgzQlVtRGNRcHBSK05UZmhKQVlCVkVzZmRicnFrMDFWaHNuZHlxbmJYRFFDd091SzRHNU5paFVtSmZWMTJPZ2tBMW9KWEtzS2sxUDdwR1Q4ZEFMQ0dqNzlkRlNaVHN5N2pBTUJxNjZacEZGMFZKbFZMdWdMQXFqUDVGUUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdGaUZ3QUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtZGdFQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhZaGNBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENwQXYwOWZUNGpnREFLdXVtbzI5WGhjbEFyekFCZ05VMjJOczlPZEJWWVRMUzErZW5Bd0JXMlliKzdqbitkbFdZYkJvYzhOTUJBS3ZzcDdybytOdFZZYko1M1VCWG5VNENnRGU3T081dUZpYmxZb2JKQ1NORGZrb0FZSlhFY2JlYnBuaDIzZW1KcUxhZldiL09Ud29BZEZnY2J6ZDMyVFNLcnJ4dWN0endVRHBxYU5CUERBQjBTQnhuNDNqYmJmcTdjV2ZGR2FXM2pxeFBodzMwcDJmR0o5TEVUTlZQRUFDc2dLRyszbHFRYk83U0cwNzZ1M25ueFU2TE8zWDJUazZsZlpXcHRIOTZKbFdxMVRUcjV3b0EydjVsUHlhNHhpM0JjVXlORzAyNmVkV3cva05oaDI3SmRtSU1BT0ROemIyNUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQW9ENU1LZ3UyOVBYWkt3QkE1OVUzUnlYQ1pEUy9wV2Zkb0IwRkFIUmNTWE9NUnBnOG45L1N1MkhFbmdJQU9xNmtPWjZQTUhrc3Y2VnZ5eVo3Q2dEb3VKTG1lQ3pDNUtIOGx2NnRSOWxUQUVESDlXODl1cmpwd1FpVGUvSmJCcmU5elo0Q0FEcHVjTnZKeFUzM1JKaDhOeHZQelcvcFBlS3dOTFRqZEhzTEFPaVlhSTFvanB4b2tRY2lUS3JaK05LQ2dqbnRWSHNNQU9pWWt0YjRVdHErc3pxL3dOb05LYmVlU2N3ekdUcjdUSHNOQUZoeDBSaUZPYTJWdVJZNXVQSnJuRDc1cS93emhpODROL1c5NVVoN0R3QllNWDAvdmFYV0dBVi9rN2J2ZkM0Zkp1SHFiT3pOUDJ2a3d2TlN6OUNRdlFnQUxGczB4Y2pPODR1Ym96MStmLzRQdllVSFBwbC9adi94eDZRTkY3ODM5UXdPMkpzQXdOS2paTjFnclNtaUxRbytuYmJ2M0ZzV0p1RXIyYmdwdjJIZ3hCUFN4a3QvMldVZEFHQkpvaUUyZnVnRHRhWW8rSXNzU3Y1K1FjRE03cnF6K0tSWXVQN1diRnhVZkdEODdtK25pZnNlc29jQmdMWU1uWDFHR3I3Z25XVVAzWjZORDJaaFVta1ZKbUU0Ry8rWWpaM0ZCNmIzdkpBcXUzYW5pUWUrWjI4REFPVkJzdVAwMmkzQkRWYVUvOWRzWEpKRnlYanhnVVpoRW1KaXlSZXljVVhaZzlWWGY1SXFqLzR3QzVYbjA4ekwrMUoxZEgrYW5jeWlwMXIxM1FDQXRhSzN0elovcEhmamh0cDczOFF5ODRQYlRrcTlSeHplNkNOaXlzaW5zaWlaS251d3Y4bW5pZys0TWh2Zm1ndVVMUXUranV3VHh1a1pBSUEydkp4aW9tdEt0elR0bkRaZUtDYkVic3ZHalNtM0NCc0FRQnNxY3cyeHJWV1V0QnNtODVWelZUWk96TWFmWkdPUC9Rd0FOTEZucmhsT25HdUlsOXY1b0daelRGb0Z6WTVzeENvcGNUMG4zcEk0Ymt6ZWtGNmZtd0lBckEweDlXTi9lbjBWK2NlekViZnZmak1iRDZUWDM0K3YzUGFkcFp2L1Q0QUJBTUZuWSszRnQxcUlBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5oqV5rOo6K6w5b2VL+aKleazqOiusOW9lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dORUpHT1RNeFJETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd05FSkdPVE14UlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pBd05VTTBOalEwTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakEwUWtZNU16RkRNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtNZnRobkFBQUJsSkpSRUZVZU5yRW1WbHNWR1VVeDg5Mzc4eWRtVTVub0tVdDNVanBndG9BcllaQVVHTVV4QWVNb0xqeUlnODg0UExnOHVxTFQwWjkwY1JFM0dKSXdBU0NSQTJJTVpIbHhiZ0FCbWxrR3pxbGhkS09MZEIycHJQYzNYTm12cWxUT25QbjNwbHArWkwvTEhmdWQ3L2ZQWE8rYzc3elhmYkpxbllvbzBtb0IxRWJVRDJvZTFCTnFHcisrelJxRkJWQzlhRk9vbjVIS2RrTG5JZ1BPeHJRVlNMb0E2aFhVYytqYWkzT3ErVmFpZHFHZWhjMWdmb1c5VG5xck5PQkJZZm45NktPb3Y1QzdTb0NXNmpWOEw1MGpaODIrbHQ3NXdQWWkvb0lkUWIxSklwQitZMnVzWm11aWRBZm83eVZBdTVDL1lGNnV3d1hLdWFXYjlFWUNOMVZGckFKNWpvK1NYcGgvaHVOOGVjR2Y4djZrb0FSZGowRGRnSS8xc0hDdFZvYzg1Z1ZkRjVnQTh3VjJQRUlmdlREd2pjL2pmMll2MldGTFdEWjFIM1k0ZEFDVy9iT1ZrY01EMWMxK1lyR1lUY1RQbVNaSkREMy8ycFlDbzgvc3gzcW0xcWcvL3c1T0huNEVLaUs3Q3pUZUwyd1llc0wwSDd2U3JnWkdZSGpQeHlBaWZHeGZDR2tCMWsrd0k5djVoNFhOemZVekh4UlRXT05pd2xmNUxQOGtxVk44T3pPMTZHbXJnRUVRWUM2eG1ab1h0NEovZitjQTBQWGJjTSt2ZU1WYUZ0eEg0aWlDSUZGaTZGclpTOE1oaTVBS2hIUEE4M1d0THFyajE1VFk2TnpYQUpUSkJNWmU3OVE2TnEwYlR2NC9OV3pqalczdGNQV0hidkFMWGxzd3pZdWE1dDF2S282Z1AvYVN3VkRIbWRpYzREUlg5WUp3RFlWVEUvMURYbVBaNkVsajhjeDdJeXIxVGRhaERIMkJMSE5BazViRjlnYlZobHNLSFNwNEVVSmVzdkwrYUdMd1ZLN2V2bThaVWJNWlVzRHQwdkJnTWlFTFZhOWFIS01ERjExQkcwSDlzWmdPRDE1clJxeEVlTU1jSVBvZXdUeEExYWRGRm1HSS91K3RBMXRGL2J3M3E5QVU1VmlpNDRBTWFiaFBmNjRzRndLdm9iUllYMnhpYU5qTkFoak9HdHU2NFRBNHBxODU5QngrcjM3L3JVVmdmMC84OExZZFhYNkY3S3dHeDI3eDI0Y3RXdnBTc0x5eWRlVFlRWHdDSXc1S2p2c1FGY1NOZzJjWWZRUXNJUXZTNXdPWEFwMHFiQjhzaTNockpRb1dGVXBDZDhKZERtd2ZPb1JvNHVBeGZMcUJwWk8xY1ZQRS9DOHNnc1ZrVVppdVBaTmxsUXkyd2hkZHBLTHZTaVJabVJwMHhpbU9UV2ZzSldBempJU3NLbUNNVExmc09WQ2MwYVRnSFhGTU1LVmhLVUo1alNORjUzZ0dVYWRnTFVwUXo1VFNWaUtCazdTdUoyR2pMU1BvUkd3TXF4T256R0tURHluYXdPbmF3OUwvd1V6aFdtWmpLb1FzSnd5OWR0eFF6dHQxV25qMWhjZHAxdTcwSTgrOVp3bE1MS2R3bHJ6RnJFS2FYOEdpSTVxOFIrdE9uVjByeW9wS2RpQjd1aGViUWtjeWJCRmlWWFk2RzgxYUpjUjNlSjAwdEF1RnVvMEhybFJjZ1lyQmszRmFLRkdUT2dPcC9sT3FKRk5VVlFCamcycHNXOU1jcGw4Qy9qdkQwQmlPbFp5dWkwRUhZOUY0ZGgzK3dzdEtRMWsya2RzbkRGVE5WOVZvd1RKWW9hcTE0cWVWcS9nbXJONlM4YmpXQ1pkVEpmNGt1U0Y4SVUrK1BuZ1BrZHJnK3g2ZWxGTkhWUUhGOEg0NkRBYzNiOEhwbTdkekI4WmRQbGtTSms4U0ZVVUttMHRsdDNReHJxT2RnODdKQ2F1WGVkcmVBL2ZXKzdpUmdvb3BqNXlLam4yRHI2VE93eWdVbmZ1L05DT1NBUlBHTGdvVCt6V3dZemZMVmdhR3hrK0pSWmk0bXl6eTN5Y2ZDWTMrK0F0UGZYM0ZYbnlNMXh3S0FzTlMyUFMyTVJBTEp6SnpMdnpnNVdwZ2Y1TVljNUFmNVlWMDRqVXVyeTlESmg3SVdBeFFTUkM4dVR1RVMzK0czNjlESm5uSTdMbDNocjNGWXBoYnV3b1lNQk9kSHRxZHFKUE44KzN6NkliN09HV0RYR0cxSndGY2E2RnVaV0JXNWxTdFpZME5YVlVTNXdQQ3BJZm84Y3lWcG5IQmJOQzE2UXUvM28yTmY3MXRLRmU0cFlkNG1ITUxBcDhCM1NDN2hML0tqT2lKUVlTcHRwZkxVaTFiaVpVWkNzMllXaVhRc3JFM3JBeWRSekhHT1N3MXd2QkZuS0ptVW1Jb1k0Nlh1UGdzVEV0R1VjTkxIVlZkYlc0L0E4RlJXbTE0TEFlcEVWV1ZGZjZicUNmL3FzbCtpSHpHR3lZVDdDYjNBM01ncnVEbGd1ZVRPUklJbmlFM3pVdFFGcHdvQ25VRlpFeGY2UEwzNG5KcHRQSFhFMGVKdGJqc1NCT1Vpazc0M1hUak9JOEdFZlhHcjJ0eTJGY0Y0VHhXSnl2RGNhNHIwWjRORkNMMW9aMm40VFNoaUh0QzZDQ2ZIZStIaktsTiszQlV0SnhjNGs1bTRwbU9xeG1RRlJ1dldsKzQrUGNvbEVlQ1V3N0hDNEhqMDVOUGlCZGZJcUhuQUMvZ1FBSDkrVkFRdzVza29QR09HQ011NWxpRjlTV1MxaUF5em5nYm01NWlWOHZuNFUxRGlmekd6QktuYWovQ1RBQXdkUS9JUGhDYWg4QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/mipXms6jorrDlvZUv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBaVlBQUFMNENBWUFBQUJQK2p3WkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd05FSkdPVE15TlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TkVKR09UTXlOak5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakEwUWtZNU16SXpNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQTBRa1k1TXpJME0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K004WkszZ0FBRit4SlJFRlVlTnJzM1cxc1hmZGR3UEcvN2RoeFlpZU80enczYlpwMlRSKzIwYXBOaXhnd21tb0lsWTVxRXRCRnJBS0phWFFkZEMvNkFuZ0JUQlc4WUx6b20ycXdkc0NFVk5SUWloRFZxZ2lCU0RlZ0UzMVkyNjNyVTdZMmFaTTRhWndIeDNsdzdDVG0vRzV5MCt2amMrMXIrMTducHZsOHBQOExuM3Z0T0NkWE90K2M4ei8vMC9MRU8yTnBCbHF6Y1dzMk5tVmpZelkyWk9PeWJIUmxZMzRDQUM0Vko3TnhMQnU3cy9GMk5sN014clpzdkpDTk05VythZlA2NHUwdDB3eVR0ZG40L1d4OElSdVgrN2NBQUtwNFB4di9tSTF2WkdOWHJXSFNXdU1QN3p2M2czK2FqVDhXSlFEQUZDNC8xd3cvUGRjUWZiVjhVeTFoY2s4MjNzekdWN0xSWVQ4REFOUFFjYTRob2lVK1A5V2I1MDN4MmlQWitITFJpMGVHUjlQMmZVZFMvK0R4ZFBEWVNEcDZjalNkT24wbW5Ub3o1cDhBQUM0UjgxcGIwcnkyMXRROXZ6MHQ3ZXBJcTNzV3BtdFdMazZMTzl2emIxMldqUzNadUQwYkQyVGpWTkhQcXpiSFpHRTIvaWtibjgyL3NIZndSSHE5LzNCNjVmMkQvalVBZ0VJM1hiNDAzYkI2U1ZyVnM2RG81ZTlrNC9PYjE2Zmp0WVJKbkNuNWwyemNuWC9oZTIvdlN5L3VITEMzQVlDYWJGeTNMSDE2dzhxaWw1N094cTluY1hKcXFqRDVaamJ1cTl5dys5RHh0TzJ0L3ZUQjBMQTlEQUJNeS9KRm5lbU9hMWVueTNvWDVsOTZOQXVUTDA4V0pqRXBaVXZsaGgwSGpxWm5mcmdyblR4MTJwNEZBR1prL3J5MmROZlByRTFYOW5YblgvcXRMRTZlS0FxVHVJMG5ac3d1SzIvWWRlaDRldnJWOTlMd3FDZ0JBR2FuczcwdDNYM2pGV250K0RNbk1XbjF1aXhPOXNjWGxiY0wvMFZsbElTNGZDTktBSUI2aUtiWTltWi9mdlBTYlB4NStZdHltRnlSalM5V3Zpc211dTQzcHdRQXFLUDlSNGZUZDkvZW05Lzh1MXZlTGJYSStUQzVQeHZuYnpqdUh6emg3aHNBb0NGZTJubWcxQm9WMnMrMVNDbE1ZdHhiK2VycmV3N2Jhd0JBd3hTMHhyMWIzazJ0NWFjRXJ5MXZQWEppTkwyNnkrSnBBRURqUkd0RWMxU0lGcmsxd3VTT3lxM2JQemhpYndFQURWZlFISnNpVEc2cDNCTFB2Z0VBYUxTQzV0Z1lZWEp0NVpaNElCOEFRS01WTk1lMUVTYXJLN2NjT3pscVR3RUFEVmZRSEtzalRCWlZiaGs1ZmNhZUFnQWFycUE1RmtXWWRGUnVPWDFteko0Q0FCcXVvRGs2V3UwV0FLQlpDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQU5Obzh1d0RxNjhHTnkrZjB6M3RqLzRtMGRlZlJjZHZ1WE5jOTd1dksxL08vMzlhZkRLWTNEbytNKzk3cmx5ODQvL1dlSXlOcHk5dUROZjB1bjFxNUlOMzNzeXNuZmMrai83Y3ZQYmZ2UlByU0o1ZW1YMWkvZU5aLy8vTFBLNnZYejYzRk93UEQ2YUhuOXZyUWd6Q0I1clg1NWhWeit1ZHQrY0VIRThKazg0M0wwdldydXM1L3ZlUEo3ZWZqSS8vN1JkaFVoa24rZStQbjUwTW5yL3puOTNTMmpmdmVJdkdlc0dqKzFPK3RSZm5ubGRYcjV3TENCS2lUZlVNajR3N09ONjVZTUM0K3FybCtTY2VFZzNvdG9iWDFzUi9iNllBd0FZcnRIUm9kOS9XZDEvV21OWXM3MHNNdjdpOTgvOWMrdFNwZHRhd3pMZS91dU9qLzduRUdLTTd5Tk1Kbk52U21aZDN0UG1BZ1RJRHBIcHdyeFZtUUdOWENKS0trSHBjL2RneU9UQmtGOFo2WkJrUXRZUkNYbGZLWHR1cmx4alZkd2dTRUNWeGNianQzV2VNZjdyNXl3c0grYS8rK2MwWUh6WmpqOGRDdnJCc2ZIM3VQcGQ5NWVzZWtCLzlaQjA3MloxU0tNeXI1QS9ON0I0Yy9mUC9oa2ZSR2xmaXBSMERVRWdiNXlidjE5RkU0b3dUQ0JKaHpFUWpQdkhZZ2JkcXdKQzNzYUp2eS9YRjNTZDZyZTQ2Tk84T3lvck10UGJuNW1nbnYrN3NYOWpYVjN6MmlaSzRuSUFQQ0JKaEMzTVphNjYyc1Q3NStNRjNaTS81c3dPRHc2WEZmMzMvejhnbVI4K3oyUXcyN2JBSUlFK0FTZGVmSGVnclBNcFF2UGNYbGticyswVGZ1dGVNanA5TzNYeDRZdHkzT3F0eXlzdmd5U2x4ZXF1WE9vTmtxcmN1U20yTlRMMSs4ZFdXNlltbW5Ed3dJRTJBbThndWV4ZVdaNmZpMTYzcExZZkxBejYrWjhOclRyeDJZRUJvUkpmbTVNR1V4MGJYVytTZlZIRHQ1ZXNyM2xPYTVOQ2lBWW8wWFFKZ0FNL1M1RzNySFRjRGQrdWFod3ZjTlpRZjg4a1RYeXZkdlhMYzQvZFdtTlJNbW5BNGNIVTJQdjNad1ZyL2JaR2RYcXVtYVAvVjhtVmlMSlg5WnFsNjZjcGV5NHV1SXY4cVZad0ZoQWxRNThOKzI3c09sMmVQU1N5d3QvK0R0YXllODkxcy9PbGdhNGFuZnVIcmM1WXJicittZDhQNS8vZEZBK21ENDlLeCt2OG5PcnN4R3RjdFNqUkQ3S2M1SVBWZmw3aWhBbU1BRkY4OXFpV1hSaTI0dDNYVFY0aG5keXJwcTBjUmJaT1BueDNOdjhzL0tpZi9CMzN2VHN0TFpoY3JKcXMvdlBGTDE1eGZkMmx4Tm5Ga3BSMHhlVEppTjErTk13bHpOeGFqWHJkR0FNSUdQcEhpQVhMV0RmTkhaaDVtS3l5dHhaaUQvckp4NGRzekdkUk1mWXZlRDNjZnE4dWR1ZVhXZzZtdHhTU1BPSGhTdHU5SUljVWxwTGliVUFzSUVxS1B5Wlp6WmlyVlJHbmw3Y1B5ZU93OE8xL1RlbUFqNytDc1RJeW5XWG5sNEdwTnNuLys5ajQvN2VyS0Y2d0JoQWt4VCtYSktwY3F6SFBuWDR2MUZDNnpsL2MrN1I2cGV3cW1YaUpMWlJrSE1yZm5yejE0NTRWTFN3OC91bW5XY3hXVzZPQ00yMS9zRmhBbHcwU3BmVHFtbThzQWZkN0RFWk5HaGtkUG5ieVhPejFtNTJNU2szRC85ei9mVDMzenVxbkZ6YkdMU2IrWEUzNmtlRDFBVUlmbExkTEVjLzc5dEgvU2hBMkVDemF0ODRMK1F6OHFwVmR4V203K0RKVDluNVdJVTgwNit2bTNYck9hNXhBVG1xU1lFUC96ZmUyWjlkeElnVE9BamJiWVRUeU5VcG5PN2JZVE13N05jT0swUklxN1dmcjgvZmVHV0ZUVTlMMmk2NHU5dC9SSVFKZ0ExSzYvUFVyVG8ya3RUUk1Wa1M5dkh2QnhSQXNJRVlFWWlTdkxyeDhUNko5TzlEQk14NDlJTkNCT0FHWXU3ZFA1bzA5cHhsM05pZnM1VWw1OGladktYeEpyMXNoVUlFNkJweGR5S3JZLzllTkwzeEIwblgvcTUxWk8rSis0NCtjcDNkbHowWndqdXYzbjVoRGttZi9tOVBUWHR4ODFad0ZST2dMMzdFMzJsWndRNWF3S04wMm9Yd0tVbEhzbzNWWlNFV0FjazFnT0pNdzRYcTFpZS82NHNKaXFWbm5KYzQycXgrVlZ1STNBaWRBQmhBaGVkV0ptMG1VUmd4QzNNUmN2aVA3djlVT21BZmFIalpOL1E3SmVYanhpSk81TTJiK2hKRC83aW1uR3Z4UkwyK1VzeHNkcHNOWEhXSlBaTnBRaWQrUGxBWTdpVUEzVldmb2pmbFgwTExzaWZYMTQwTGU4ekczcEx6OWNwaXBJLzNIYjIwc1pRRmxQNXN5bmxPSG5xaHdOcHNDQzJZaEpwTFdjZzRqTElqV3ZPWGhhcHR2NUtSTk96NnhaUDYvYmUvTm93OGJUZmF1dVBQUEsvWi8rZUVSYmx5YkJUL1ZuZmZubGdRc3pGM0pNSHNzaUovWG5iRkpmTkFHRUNGOVJrRC9HYkMwV0xwbFVUejc1NTZMbTk1Nzh1TDYxZUZDZVZxNlpXS2wwYXFXRkNhQVJBTGZ1bEVXdU9sQU9zSERBUkpkWDJVZjVNVjBSWGZHOCtUb29pRDVnOWwzSmdEc1haaFdieHJlLzNqNHVTeWppSjEyWmpzSWJKb1hPNUwrSVNUcHo1cU1YTGV5WStoVG0rZDdKTFBrRDlPR01DY3lUKzExM3JwTXVpQTMzKzRYdTFQSGd2ci96MDNxMXZIcHIwZ1hZUkozRlo1N2MzcnB6Um1ZRllmS3pvTEVQK1RFU2NzZG0wWVVsZHo1TFVza3gvTEp4V05LZW0ybk9DNG5lOVo4djJkTXZLQlQ3STBHQXRUN3d6TmxhNTRlSC9jTDBVWmlNbVgvYmtKb3ZXT2crakdjWEUxOGtPeUJmejN3MjQ4Qjc4NVkrUCs5b1pFNml6ajlwUzViRm14OFgrVUQvZzRtR09DUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FCQW5jeHI5bDl3Ykd3c0hUdDhJQnNIMC9DeG9YUnFkS1MwRFFDWVdtdHJXNXJYMFpIbUwraEtYVXY2c3JFMHRiUzBDSk9aaUJnWjJMMGpqWjRjOXNrQ2dCazRjK1owR2hrK1VScERod1pTKy96TzFIZlp1dFNkUlVwVGhsUlQvbFpqWStuQTdwMnAvNTAzUlFrQTFGRWNWL2UrODFicE9KdWE4QXBFVTRiSmdUM3ZwVVA3ZHZ2MEFFQ0R4SEUyanJmQ1pBcEhEeDhRSlFBd1IzRVN4MTFoVWtWTWFoMTQvMTJmRkFDWUkzSGNiYWFiU3BvcVRJNGVHaWpkZFFNQXpJMDQ3c2J4VjVnVWlMdHdBSUJMOS9qYlZHRXlmUHlvVHdjQVhNTEgzNllLazlPam96NGRBRERueDkvbW1VYlJaSk5mei9oMEFNQ2NIMzlOZmdVQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNaMkFRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0ZpRndBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1kZ0VBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUxud3YweGJtMzhSQUpoakxTMHR3cVJJMjd3T253NEFtT3ZqYjN2ekhIK2JLa3ptTDFqbzB3RUFjNnh6WWJjd0tkSzFaS2xQQndCY3dzZmZwZ3FUN3Q1bGFWNjd5emtBTUZmaXVOdmQyeWRNaXNUa20yVnIxL3VVQU1BY2llTnVTMHZ6NUVEVDNTNGMxZGE3OGpLZkZBQm9zRGplTnRQWmtxWU1rOUMzNW9yVXMzeTFUd3dBTkVqUDhsV2w0MjJ6bWRlVWU2dWxKUzIvZkgxYXNHaHhPckI3WnhvOU9ld1RCQUIxMEQ2L00vVmR0aTUxTCtscnl0OXZYalB2dk5ocFhUMUwwOUZEQStuWTRZUHA1UEdqNmRUb1NCb2JHL1BKQW9DYS9xL2ZVcHJnT245aGQrbnVtN2pScEprV1ZMdW93cVM4UXhjdFhWNGFBTUJIbTJmbEFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQWdJbGhNbEs1b2EyMXhWNEJBQnF1b0RsR0lreUdLcmQwdERtSkFnQTBYa0Z6RE1XVy9zb3RYZlBiN1NrQW9PRUttcU0vd3VTdHlpMUx1enJzS1FDZzRRcWE0NjBJazVjcXQ2enFXV0JQQVFBTnQ3cG5ZWDdUaXhFbTJ5cTNiRmpSWTA4QkFBMTN6WXJGK1UzYklreWV6OGF1OHBiRkM5clRUWmN2dGJjQWdJYUoxb2ptcUJBdDhrS0V5WmxzUEY3NXlnMnJsOWhqQUVEREZMVEc0NXZYcHpQbCszUytrU3JXTTRsNUpodlhMYlBYQUlDNmk4Ykl6V2tkT2RjaTUxZCtqZE1uZjF2NWprOXZXSm1XTCtxMDl3Q0F1bG5XM1ZscWpKeS8zN3orN0xTU3lwVk4vaXdiQnlyZnRlbmExYW16dmMxZUJBQm1MWnJpanV0VzVUZEhlL3hKK1l2VzNBdC9VUG5PdGIwTDA2OStjbTFxdHhvc0FEQUxIZk5hUzAyeHRyY3IvOUpYTjYvLzhNUkl5eFB2ak9YZjhNMXMzRmU1WWRlaDQybmJXLzFwLzlDd1BRc0FUTXZ5N3M2MDZiclZwUk1lT1k5bFVUS3VPWXJDSkpaaCsrZHMzSjEvNGJ0djcwMHY3VHhnRHdNQU5ibGxYVi82cFEycmlsNTZPaHUvbVlYSnlGUmhFaUpwbnNyR25ma1g5ZzZlU0svM0gwNnZ2SC9RM2dZQUNzVTZKWEZMY0pVVjVaL0p4ajFabEJ6UHYxQXRURUtzZXZKSXlsM1dLUnM4TVpKKzhzRlE2aDg4bmc0ZUcwbEhUNDZta1ZObjBwbXhNZjhhQUhDSmFHMXBLYzBmNlo3ZlhucjJUU3d6LzdFVmkxTFBncXJQM25zMEd3OWtVVEphOU9Ka1lWSzIrVnlnV05nRUFKaXBnV3g4TlJ0UGxPSmlmWlhRcWVFSGJjbkc5ZW5zcE5nUit4VUFtSWFSY3cxeGZUbEtKbFByZmNCUk9mZG40K3BzZkQwYnUrMW5BR0FTdTg4MXc5WG5HbUtnbG0rcTVWSk90YUM1TlJ0M1pPT1diR3pJeHRwc2RLZXpjMU1BZ0V0RHpCVTVtczZ1SXY5Mk5sN0t4bjlsNDRWMDlubDhoYXBkeXZsL0FRWUFWT0FLeXJXZmMyRUFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5byA5aWW6K6w5b2VL+W8gOWlluiusOW9lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3lRMEkyT0RZek5ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRveVEwSTJPRFl6TlROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pKRFFqWTROak15TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakpEUWpZNE5qTXpNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtJTWtOUFFBQUJvWkpSRUZVZU5yRW1XdHNGRlVVeCsvTTd1eDJIOTJ5TGR0M2VXMUJETkRTR0tCQThKR0kwWUJHVTFHajhRc2ZmTVFvbXZnSXFNRmdGRTM4b3VHbGljR29BYlVLaGtlTkFWdGlTbHRwS1pVSWxLVkxDNFh0YTF1NmJiZjduQm5QbWIwbFc3cXpPN083TFNmNVp6WjM1OTc3bXpQM25udnZHY2IyN3U4a0JkT0JWb01lQXBXQkZvRUtRR2I2L3hpb0IrUUFuUWZWZ1JwQndZa0cxbFp2VXRXaE5rblFDdEFyb0tkQjJYSHV5NlphQW5vS3RCMTBDMVFOMmdjNnA3WmpWdVg5NWFEam9MT2dseExBeXBtVjFzVTJhazV2cWk1WFU1bFJPQ1F5UUorQ1hrL2hyY2haR0xRTHRCV0doejhkSGk0bFJHeUM2MXZUQURzeExOL0VQc0RicFNrQk13Sy9FaHFDU2NLVWsyazM3RVA4cDZIcXA4cWtnQUcyVW1UWld2ZzFtOHlZTWRuUTU4bDQwREdCV1NHMEVDb2VoUVpNWk1hTk1XSGZqVlVIRmlvQzF2a0dEUUtqL1hWbVBUc0Zlall5TkcvY1owZ1loOE42eStlRVljcGlOVFBmbGtrK2ZMeUMzSk9mUldvdnVzak9tbi9KZURDc0NzV3M1OGpXRGVWazNhSjhjcVhQUXo0K2VvNTB1Y2RpTURObHdQSVovTm9pRzlhNHdPaDlJWDFtVTZ3SHNlZGF5TjRYMXhDclVYKzdySzE3a0d3NTBLUVlHbUcvZW1FMVdWWmt2VjAyNUEyUWw3K3ZqdzBOL2dPbVZTdVBiRzZkTWlRZ0JqSThsN0ZUTG5SdGY2SmlFaXphOHBJYzh1WHpsY1NvMHlZRkt5MkZKajM1WUdPRmJNaWpUTXdVWUJndkt3V1dlMWl1NXR3Y2M4eHlKZEJ5c05GRFRjNkFhVDJ5VFFLV3ZLczF2aEg5SkhkYVEwZS9iS1B4b0JQQm90VTdldVBPd0dnMmpXbnRjempBTGNONVpWL0RWUzlYcTlIWlR5cm01cEQ4TEdQTS83RWMvLzhMSm1PSUZ4VER0bDV6ay9jUG55VmhRWlM5UjJTMTg0QnRkOWJBaFlEazRjR2lWZXVnSURQZVkrTEV3Z21HRTAySnA1WENiam5ZUlB3aFBrR1VZeklsUnZUd0k2N2YyQnYzVnIzS2M0YktSQk1IUFljZVZPTHBEZVZ6MGdNN3dTenkvVVdPWXlmUXc1eWc0Y3FVeGxHbG5rNG5yRFQ1SW93Y0F1c0ZqVzYrbXVDdkJEcWRzQkZnaVZHUHdEcVIwZWFvN1RnWjZHUmhwWWtYWWRRaHNGWmtXR015Szc0YTZGUmdJOEFTb3hhQk5hbHNVMWlHSVJvMjhUbUFaUm5wM2hSTncwcEJRK1I5eWRSV0VycVNXY1psb2dReU1wSnJOSHpBTTUydzZZQ2VZRVJnVVJ2MHVxWWJObFZveWlnaU1NLzViem5UQ1lzVFRPbUtxTlFvSTQvQVlZdjdja3M2WVRFYXFGbkdsWmhsMElGNWpEQUNCd3M2YWxvWUlleExGeXlHTHJWN2ovaW45N0MvMEhFY25ScEU0SUIrZkhESU9OTGRISy9TTmpqV3FGMXVsVUsvOTFqOG5RR3duWUd6SmpZaTdkWkNvSkc4enJwajhTbzlzTGdncVVWQkNmU0RjZHBHeSswNmhXd2p5TXFlM2xTTm05ZXhnbzQvbWpQRytpN0pWWEwwZXBKZXdSSkJPL3Jrb3lveUZWNnBhYWFaVUdGaWlmS0Mrb3ZiRC85SVJGR0lWWEVIbkc3eHdKanNjaXNIUFREcUp6dU95Q1F4Z2FXNC9kQVB5RVlaSXllT09SY2xMelBtNFU1K0pIZHBjY0JrbTdKN0d4NFBrdE5YK3NnaU9PSWI5VnBTZDZtSGJEdlVvbXB2TUxHZkxyYWFpTTFpSU8wOUh2Sk85Um5TUGVTTmVYK1crMUxkZ3JiOXY4RFBUdERvcEdNK25Pc3dRN2tnbURGclJkdjZMejRKWldRVmtidG9uTi9qV243aTdXMDYvekFPaDZzZy81MlpIM3pmdlhERDFZVXRlL2F3Zk1CN3QyQ3hiMkRZalN6SVJOa21IL05oOG9uVTdWM1dudGEyQlczZjdXVUVQampqU1Nyb0UvdEdCbVNoVEdMTTNCcEFZNGh6ZzV4NVYwODIybHUvMmNYeXdmR1o4Mnh3SFB2RXZwR0Jzb1RpNXRib1dMbUp3eWl2czViVitZYkdPMWE4dGhuR2R1RjB3c0xyZDVVMjc5bHY3VDJIbm5WUWhpa1orVWhlSXNxNmx6eURVUU9mQ3BmcXNHR3NONVRYVlhmQm0yMDMrWTI1SmJCN1p0SktDcUZyMXNCLzlVdFBmZlN0eVhPOUhVb3VnNjdSTURZbFdTSDdqUU96UVhEQi9EQkdDenVvMEYyeVp2SDFKYzl1OEdVV0xrNEhxMkhVMVQ3bndzL0haM2MzSUtpTERvT2JjckJ4Z2FPZ01keGhybmdlcUJoa2RaZXNMZTBwZlhUTm1OVytESTdmUm5Yak5PUXozM0tlejNmKzJXQzdYdDlCSXAvQmJ0QUo1cWJEUURZTnBPZ3JFb0J6Y01ITVVENzFlQzd1K0hpdHdkUS85MzY3SjYvTTdqUG5GNFF5WnRtZ3pDS3dXbDBra3g4T2FzSytFYzQvUEFCRHF5ZXI3N3d6OTlyZlRpanowcjFCUC9Wb0w0MEdvWVJSUk9tWFVPcHR6TDFacU1kdElEeDZtK2xiNEtnMFVVbEY5QlJQUVVMVWU3Z253UFY1Z0hwMGhNWlpVVkhZZTNJK3B6cFVrc2duV3lQMXVvVmVFZHdRQlUyaVlIMFVkSlFDNGhYRFpWQXBhTHl3bG5CZVU0K2dQQlJRVHg5Q0srUGhNSVVMMEFjUWtwMm8vd3N3QU42RUlIbmpDU3lvQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+W8gOWlluiusOW9lS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpWUFBQUw0Q0FZQUFBQlArandaQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG96TmtFNE1qRXdOak5HTlVZeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3pRek5GTmtOQ1FUTkdOVVl4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qTTJRVGd5TVRBME0wWTFSakV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pNMlFUZ3lNVEExTTBZMVJqRXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrakdWanBBQUFHZEpKUkVGVWVOcnMzVzFzWFhkOXdQRy9IMklITjJsYXAwOXAwcXhyUzlOU3ZGVTBwZDNLMUJZUUxHTmoycm9WRlpBMlVUWWV0bFpqcjZZeGVESGd4ZlptYUlBMktrQ2J4aGgwb0dsc3REQVZLTkxZK3BDeXRpblFBaTJsaWR1bVRkS21ka3pzeFBiT3ovWjF6am4zM090cng5ZmN4SitQZEpUNDNPdHIrL2hLNSt0ei91ZC91cVlmdmlNdFFYZTJYSmt0MTJmTDlteTVPRnMyWjhzcDJkS2ZBSURWWWp4YkRtWExjTGI4SUZ0MlpzczNzK1grYkpscStGbERPeXBYOXk3eWkyL0psai9LbHJkbHkzbCtGd0N3NnZYUExZT1JHOWx5dzl6NjNkbnl6OW55aVd6WjArcUxkYmY0dkkxekwveDR0dnlaS0FFQUZuRGVYRE04UHRjUUc1Y3JURzdNbGtlejViM1owbWM3QXdDTDBEZlhFTkVTYjFub3liMExQUGF4YkhsMzVhUGpCMU02a0gyTjBlR1VEdTlQYVdJa3Bha2oyWExVcndBQVZvdnVMQmU2MTJUNXNUNmx0UnRUV3JjNXBjRkxVdXJmVUg3bUdkbnkrV3k1TGx0dXlaYktZT2hxTVBoMUlGdStrQzIvWHZmSTZOTXA3ZHVWMHQ2ZGZoa0FRTFd6dDJjcE1wU0Z5cmxWai81bmlxTW5RenZHV2dtVE9GTHlwV3g1YzkzTFBQWDFsSjY1eDhZR0FGcXo2ZXFVdHI2dTZwRXZweGdvTzdTamNPU2thb3pKeCt1aVpHUjNTbzk4V3BRQUFJc1Q3YkRyVTdNdFVmVG11ZVpJemNJa0JxVzhxN0RtNEJNcFBmYUZsQTQ5YStNQ0FJczN0bmUySmFJcGl0NlZkdDE1VTZNdzJWaFhMaU5QcGZTamYwdHBjdHhHQlFDV0xsb2ltaUxhb3VqaldaeWNXUlVtSDA2ekkyYVBlZksvVWpwNjJNWUVBSTVmTk1XVFh5dXZqWW5aUGxRT2s2M1pjblBoYVRIUU5RNjlBQUFzbDdIbnNzYTRxN3oySFduWG5WdnpZZktlYkZrei8zRE1UV0tnS3dEUURzL2NPOXNheDZ5WmE1R1pNSW5sN1lWUGlIbEtBQURhcGI0MTNwNTIzZGxkdTB2d2x2blZNYVByM2dkc01BQ2dmYUkxb2ptT2lSYTVNc0xrdFlVbnhqVHpBQUR0VnQ4YzEwZVlYRkZZVlR6bkF3RFFIdlhOc1QzQ1pGdGhWZHlRRHdDZzNlcWJZMXVFeWFiQ3FvbFJHd29BYUwvNjV0Z1VZYksrc0dyS0xLOEF3QXFvYjQ3MUVTWjl4U2ROMmxBQXdBcUVTVjF6OUhYYktnQkFweEFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBd0VtcjF5YUFuNDJuOWg5T1krUEZHMWhkY3U0cGRjOTc5T2xEOC84ZjZPOUpXemV1YmV2M2RjZUR6NmVkangrYy8vamFWd3ltYXk4ZFhQTDNFNitYZDhGWkEzVS81NzZSaVhSZjdtc3V4cXN2M0pET1dOKzNvcis3YjMzL1FEcVUrOTM5MnVWbmVrT0RNSUhPRXp1c1AvL2NEK2MvZnNkck42ZWJyOTlTK2R4L3VIdFArdHFEK3d2cnZ2MmhxK3AyNmgvNTBoUHpINy8vaGdzV0RJRy8vTktQNmw2M21Yak44bzQxLy9tbkR2UVd3dVRtdjN0ay92OXZ2SHhqK3VBTkZ6VjkvZnozWC90NjlXRnlwTzU1cmZyMGUxNVpGeWJYZk9EZUpiMVcvdWRwRmgvZit0NkJ3allTSmlCTW9DTmRtZjMxZnVhR05lbjVnMGRtUHY2UEI1NUxOMTJ6S1EzMDlTejZ0ZUtJeW0xMzdaNy9PRjYzNmdoRXUzZUtMNDBkWFoyUktUNUFtTUNKTGdMa042NDRLMzNtRzhNekgwZWczSjN0NEdLblZqNzZVYVhaWC9yeFdsV2Z2eHc3ekRnNkVEdmk4T1R6UHkwODlwMGZ2elJ6RktaVkN4MnhpWjhoLzNQRVVZb2JmMm1UTnc4Z1RLQWRmblA3c1RBSlg3em4yZlRLODlhbjBjT1RLL0wxTDltOHJ1bmo1V2c0cGI5bjVwUkZvNWlJSUZyTXFhSGxFRWVIWHZYenAxWStGdUgwMlBEWXNyeFcxZllBaEFtY1ZHSzhReHdGcU8zd1lpZDYwMGNmbWxtM0ZGZGR2Q0c5ZnFqMXo3M3g2bk1hUGhZRFY4czc0c3UyckZ2eXdOTjJpWkJvTkhhbGxTTlBWYThWQTJ4akxFdk4xalBXemh6aEVpWWdUT0NrOTZaWG5WVzN3OXQrNFlhWkpZNmcxUDdpMzdaNUlQMU9rNUFJMTcxaWNGRmpWTXBYMWNRUmxGcXNQUEhjV0YzMEhNOFZMZkh6dE5QdDJiWjZkSGgwL3VPRkJ0bzJFL0dWRDVvWU5GdDFGUlFnVE9Da2MwWDJWM3BjZlpJUGhEaWRFMWZVeExwYW1KeC81c3NxeDRpTVRVeW1wL1lkbnZsLzdkOHFWWmZybnIyaHZ4QkZNVWFrRmlZN1MwZEdybjc1YVRQL3hpVzg4ZjNXNU9NcHhOVkZtMDd2TDN4dTdlY3BpM2pJQjBSNTNFelZWVUQ1UzVBTDY3TW95ZjhzeHhNbWdEQ0JWUzEydmtzZG1Cb3hrcjhzdDVHcXkzV3ZLSTJuaURFaWNZVlBSRVQ1S002Rlp3L00vQnRIRHZKSEQvTHhGQzQ2WjJEK2t1SGEvQ3V4UkZBNDZnQUlFK2hRNWRNbzczM0QxcWFuU2lJVXFzWTQ1STllTE1Ydi92TFo2Vi8vWisvOHg0L3NIa25QdnpSUjk3eExOMWRIUmN4ZGtwZWZ6Nk04LzBwNTdoV0E0MkZLZWxoR01RdHBuRHFwQmNlLzczenVaL0o5WEx5cEdCeDM3ZHFmSHQ5YkhGOFNSMXNhalYwcGYzNDVwdkt2QWJDY0hER0JaUlJIUi83dzllZk5EN0tNeTRiajh1SEZEakNOY1NJeE9MUHNyNy84Uk9FVVMwd1gzeWlROHU3OVFmMVZONHNadUJwSGdVd3dCZ2dUT0FIRlZUUXhZMnR0OXRkM2Z2S1JtVXRXZi8rNkxTM2Y1eWJtRmltUDNZanhIUGtvaWZrNXJtd1FGeEZDY2NWTlBraktjUktEVnh1SndiQlZ5b05VTncvVy96emxtV21ySXFmOHMwYUlBUWdUYUlNNFBmSytONTAvZjgrYzJnUmxWYk9iMWdhdnhnNi9hckJyczFsVTMvcWFjNXRlUmh4WDNGUWRLYWxGeldKdUJsaWVEYmFtZktWT1dHaU9rZks0R2pPL0FubkdtRUFieEJVc2NjU2luWDVoNi9vbFAzN2RaWU5OUHpjbUg4dXJIYWtwejRNQ3NOd2NNWUUyK2ZCYlhwNitQM3dvN1QwNFB2UHhHZXZYck9qWGoxTkIrUnNLNWpVYjNCcXFqc1RFM0NwbGpVNzVBQWdUNkRDeGM3K2l5VDFhV3BHZnJHeWhtK05WeWQ5UU1PL1ZMUXg4alZscDgyTmFZbTZWWjE0WVgvRHo4cGM2eC9Qelg3OXFwdHNZWXdJZ1RLRE40dDRzK1h2UXhOR0ZsWjZNTENaR3F3cU9WcTRTaWxscHl6ZkxHejVRbklXMmZNb241Sy9laWJzVzUxMno3ZlRLcTNzYXpmd0tDQk5nbVZUZG02VlZoK1ptVmMxN2NleG80ZVBhZUk5bXNWTjExVTdFUVN2S2s2ekYxeXNQZ2wzb0hqNTdEMDdVaFUxY3RmT3ppRFJBbU1DcVZyNHNkakU3NGhpWHN0RFZMYlhIbTgyOG1yK2JiczNJNGFOMTYvTDM1cWxadjdhMzd1ZkpIMEdKSXk4THVlZUhMeFkrcmwyUkUvZmVhV1Y3VkYwTkZLZCs4aE83RGJSNEttajA4R1JkL0FIQ0JGYU5UcGdodFJ3R0lhYXEvNU1kNXhmV3RYSnZudkw0bGpqVnM1QkdseXQvKzdFWDBzM1hieWxFV3ptdzRqUlFQb1JpbXYwUVZ6elY3dHV6R0ovNzc2Y0xIMy9sTzg4ZDl4Z2dRSmpBQ2FGOEdtWXhzNnd1cDY4Mm1PenNnUisvZE53NzVhckoxWnB0Zzd3SWpoaUQwMnlzeXo5K2E3Z3VxR3IzLzZtNlEzRmVQZ1F2MmJ4dUpuTEtWeWZWNXBZcFB4Y1FKbkRTS2MvMzBXeVcxU3BWVTlMZjl2WGRoU01Rc1hOdWRybHU3UGpMZzFkckhuenkrTVBrOHZOUFhkUTJpQURJSDNYNTdwN1Joa2MreWtkTEZxdDh4K1UvL2FkSEs1OTMrLzgrVS9kY1FKakFTU2R1bWxlejJGbFdROVdVOUtlVkJxTXVOSUQwdnNjUE5ueXNmQ3Bsb0RSdUkzOVVJUzhtall2dkk0NEFMUlEyNVRFMmNYUWkvM3IvbDhWUnd6RDVYdkZxbnZLbHk0c1JSMjRhblZLcUhUV3AybzZPbm9Bd2dSTmVIS1g0eWI3RGhSMWh6Q1d5SE1wWHlTd21qc3BpSi8vVS9zUHp3UlQvVmgwNWlEc2w1MCtCdk8wMTU3WjhwQ1UrTng4V3NmUFBCOGJkM3oxUU45YWxGaEw1Z0ltd2k3bFBGaG9NM01oWEgzcStMcTd5djU5R1IwMXVMTTIzQWdnVE9PR1VMeEVPdGJsRTR2UkVIQWtvSDRXNC9aNW5Ld2VwaHZ3TjhSNyt5VWhMMzBOOG5iamlwSHlVb0x4RC91Z2RUNmJYRDIxc09sWWpiajZZLzM1andHaHRKdHNRRTdXVng0bEU4RHl5ZTZRUU5MVkxsT1BmV3BqRTR6SFc1Y3hUKzJiQ0tJSWtac2VOVU1pTHV6V1h4Y1J0OFhYR3NwOHo1bEpwZE5seVBLYzJMcVVXU0RFajcxdi85cUg1NzYvWlVaTkc0MlFhM1RzSUVDYlE4UzdiTW50S0lHS2hIQ1Z4Rk9UUjRkR0dweHFXY3BTZ0tuN2lpcGFZaHI1OHQrRlltb1ZKZVlCcitRWjhNUTZtSENZM2ZmU2h1dGVwM2V5dlBPSGJyWi81L3Z5TkRCdGRGUlIzYTc2N2RHb25acE90elNnYjMwTStLaHJkRURIRWtaZUltSWlkL0xiTlB6OS9kZEJDVnlvQnk4OU4vS0NOWXI2T1psZWUvTW9sOVdNczR0UkZLM044TE9iZU83LzZpMmZPN09EanRSZWphdWJZcGFnTi9yMXlrVmNueGZaYmFCSzNWc1hQSHR1Z0ZqdUwzUmJOWGhkWVBvNll3REtLVXh1MXEybGlRR2wrMEd0K1lyQTRVaEpSRXVNMUh0OTdiRkJuclAvdFZ4OGIyNUMvNzB4ZURIeHRGRHpsUVp2WFpqdmhXdWg4NElhTFprN0h0Q29HcDhiM3NMUEJRTnFGSmplTG5mWmJYM1B1L0hhSXlJalhhK1ZJVUd5cm02N1pOTDlkajJjQWJJaWpKTFhJaVgvZjk2YnowOTk4NWNuS214eTJLcjZuMzd0MnN6YytMS091Nllmdm1DNnN1ZmNqdGdyUVZ2bVpabXNCVnh2UFVRNjY0M250K1Znei9UMTBycXZlWC9qUUVSTmd4Y1VSaTNJc0xGYzhWTDAyY09Jd3hnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFDZWIzbzcvRHJ1NjBtVGY2ZWxvLzJscGFzMHBhYnE3YjJZZEFOQ0M2YW5VUFRXUnVvNk1wZDd4RjFMUHhJdlp1bWxoc2hTVC9hZW5pWFZiMG5SUHZ6Y1dBQ3pwRC96dU5OV3pOcVZzbVZ3N21Mb214MVBmNko3VWswVktKK3JRVXpsZDZVZ1dKT01iTGhRbEFMQ01ZcjhhKzlmWXo4YitWcGkwNE1pNnplbkl3RG5lUFFEUXJuMXR0cCtOL2Ewd1dVQ2N2aEVsQUxBeWNSTDdYV0hTU0ZkWG1saC9ubmNLQUt5UW1mMXVCMTFVMGxGaGNyUi9jUGFxR3dCZ1JjUitOL2Evd3FUQ1pQOXAzaUVBc0lyM3Z4MFZKbE85cDNoM0FNQXEzdjkyVkpoTWQ2L3g3Z0NBVmJ6LzdiakJyd0RBNnQzL3VsY09BQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEd3Q0FFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBQWdUQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBZ1RBQUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3c1FtQUFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0NBTUFFQUVDWUFnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBQUlFd0JBbUFBQUNCTUFRSmdBQUFnVEFFQ1lBQUFJRXdCQW1BQUFDQk1BUUpnQUFBZ1RBRUNZQUFBSUV3QkFtQUFBQ0JNQUFHRUNBQWdUQUFCaEFnQUlFd0FBWVFJQUNCTUFBR0VDQUFnVEFBQmhBZ0FJRXdBQVlRSUFDQk1BQUdFQ0FBZ1RBQUJoQWdBSUV3QUFZUUlBSUV3QUFHRUNBQ0JNQUFCaEFnQWdUQUFBWVFJQUlFd0FBR0VDQUNCTUFBQmhBZ0FnVEFBQVlRSUFJRXdBQUdFQ0FDQk1BQUNFQ1FBZ1RBQUFoQWtBSUV3QUFJUUpBQ0JNQUFDRUNRQWdUQUFBaEFrQUlFd0FBSVFKQUNCTUFBQ0VDUUFnVEFBQWhBa0FJRXdBQUlRSkFJQXdBUUNFQ1FDQU1BRUFoQWtBZ0RBQkFJUUpBSUF3QVFDRUNRQ0FNQUVBaEFrQWdEQUJBSVFKQUlBd0FRQ0VDUUNBTUFFQWhBa0FnREFCQUJBbUFJQXdBUUFRSmdDQU1BRUFFQ1lBZ0RBQkFCQW1BSUF3QVFBUUpnQ0FNQUVBRUNZQWdEQUJBQkFtQUlBd0FRQVFKZ0FBd2dRQUVDWUFBTUlFQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQkFtQUFBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCZzFZWkoxL1NrM3dnQXJMVHBhV0ZTYWVxSU53Y0FyTEN1RHRyL2RsU1lkQi85cVhjSEFLejQvdmVRTUtuU00vNmlkd2NBck9MOWIwZUZTZS80Z2RRMU5lRWRBZ0FySlBhN3NmOFZKbFdtcDFQZnlHN3ZFZ0JZSVRQN1hZTmZHK3NaZnlHdEdYdldPd1VBMml6MnQ3SGY3U1FkT1kvSm10SGgxUHZUNTd4akFLQk5ZajhiKzl1Tys3NDZjM1BGS1oyblVzL0VTSnBZdHlWTjkvUjdCd0hBTXVpYUhFOTlvM3M2N2toSmg0ZkpyTmhvTDV0NE1SM3RIMHlUL2FlbHFkNkJMRkw2WXJONlp3RkFpMy9zZDAxT3BPNmpZek5YMzh3TWRPMmdNU1VuVkpqTWJzL3AxSHQ0Lzh3Q0FKemMzQ3NIQUJBbUFBRENCQUFRSmdBQXdnUUFFQ1lBQU1JRUFCQW1BQURDQkFBUUpnQUF3Z1FBRUNZQUFNSUVBQkFtQUFEQ0JBQVFKZ0FBd2dRQVFKZ0FBTUlFQUVDWUFBRENCQUJBbUFBQXdnUUFRSmdBQU1JRUFFQ1lBQURDQkFCQW1BQUF3Z1FBUUpnQUFNSUVBRUNZQUFEQ0JBQkFtQUFBMUlmSlJIRk5qNjBDQUt4QWhkUTF4MFNFeVVqeFNmMDJGQUN3QW1GUzF4d2pFU2JQRkZiMXJiT2hBSUQycTIrT1p5Sk1IaXVzV3J2UmhnSUEycSsrT1I2TE1IbWdzR3JkdVRZVUFOQis2emFYMSt5TU1QbG1ZZFhncFRZVUFOQitnNWVVMTN3end1UytiTmt6djZwL1EwcG5iN2V4QUlEMmlkYUk1amdtV3VUK0NKT3BiUGxzNGNsbkRObGdBRUQ3MUxmR1o5UFFqcW5hQkd1ZlNQbjVUR0tjeWFhcmJUUUFZUGxGWXhUSHRFN010Y2o4eks5eCtPUlRoVS9hK3JxVUJzNjI4UUNBNVROdzFteGpGSDBtRGUzWWt3K1Q4TUZzMlY5NDJ2bHZTS2wzclkwSUFCeS9hSXFmZTJONWJiVEhYOVErNkM0OThNZUZwNjdmbXRKRnY1VlNUNStOQ1FBc1hVLy9iRk9jdXJYOHlLMXBhTWYrcWpBSm44K1dUeGJXYkxnZ3BXMXZjVm9IQUZpYU9IMno3Y2JacGlpNkxZdVN6K1ZYVk4xZCtOWnMrWEpoVFJ3NUdYcG5TcHV1c25FQmdOWkZPd3o5d1d4TEZFVnIzRkplMlRYOThCMlZiWk10WDh5V0hYV1BqRDZkMHI1ZEtlM2RhV01EQU5WaW5wSzRKTGg2UnZtdlpNdU5hV2pIV0t0aEV0Wmt5OGV5NVYyVmo0Ni9tTktCeDdKUUdVN3A4UDZVSmtaU21oeFBhWHJLTHdNQVZvdXU3dG54STMzclorOTlFOVBNRDI1THFmKzBScDhSUTBadXlhTGtTTldEdlUyK1ZIekN1N1BsN3JsQU9hUHdhSHhCcDNZQWdOYnNTN1BEUmY2bDJaTzZXM2loR0JBYk45RDUrNVNmaEEwQVlHRVRjdzF4NlVKUjBtcVkxQ3JuUGRseVliYjhWYllNMjg0QVFCUERjODF3NFZ4RDdHdmxrNXFOTVZrb2FLN01sdGRteXhYWmNuRzJiTW1XZFdsMmJBb0FzRHJFMEkvUk5EdUwvQSt5NVlGcytVYTIzSjltNzhkWGJXaEg1ZXIvRjJBQXN0V3FXb1Q1bmQ0QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/muLjmiI/op4TliJkv5ri45oiP6KeE5YiZLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd05FSkdPVE15TVROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93TkVKR09UTXlNak5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakEwUWtZNU16RkdNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQTBRa1k1TXpJd00wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KytZS21id0FBQmtoSlJFRlVlTnJFbVgxSVcxY1V3RysralpyZzUycDFhS2RXK29jZkcxSS9Wb2NWTXNISi9tZ3BnMjJNd2Y3WUI3b3lIVk0zaGdqaXBoVlJWKzBIVyt0S3U2M3JuTUphaDFDcFVteTFzN3ExRHVla3hpbjFXMnVxSmpHSk1Udm41VVpTKy9MeVhvejJ3Q0g2OHU0OXYzZHk3am52bml1eTJXeGtHeUlIVFFmTkFrMEVqUVBkQytwUHYxOEZuUVlkQWIwUDJnbmFBMnAyVEhBa1dpN0lvTWhENEpkQVB3UTlCaG9rY093UzZDK2daMEQvM0duZ0pOQ3ZRSE53TE5tZW9PRjIwTThCK3A2M2dYMG82TWVnVXVKZFdRZHRvT0JyN200Vzg1Z3dGaDZxRno0TGRnQ1cwRGsvUVJ1dFduUHN0b0N0NjVZVW1LaEhKQklsa1IwV3RBRzI3alNQNk5NOEFnYllOTEZFZWdNbUNpRzdKR0FyQ0d4MmNFR3pBbHZNcHYwdzhDcE00RWQyV2RBbTJyNHl2TEtmRi9EaXpLUlNLcFUxNzZabldhQkRrT0c3MjJOS3Q4RHFvSkFxa1ZpY3lEYlIrUGc0eWN2TEk5bloyYVNpb29JWWpVYkJNSHE5bnBTWGw1T2NuQnlTbjU5UEppWW0yS0dCQVZncU9kUGE4dEpDc2pvd3BKY3RHNHlOalpIQ3drS2kwK2sycnlVa0pKQ3FxaXFpVkNwNXd4WVZGWkdob2FITmE0R0JnYVN1cm81RVJrYXlwanhnU24wM09YemdLUTlERGhRcC9WUmZ1MHBkQ09ZTWl6STRPRWlLaTR0NWVab05saWw3UzB1a3VycmFaY3FqVEtLbmdDRmVVbVJ5aGNiVlNGYy9uUVBhWURBSWhuVU9OVmNDVEs4aTJ4UEFqSGY5VmNlNXltMXFhcXJMU1JHNnBLU0VGZG9kTEVwNmVqcm5HblJtazVTVmxlRmY2aGN6TkdkaGRTcGNqVXBKU1dIQTV1Ym1XTC9INi9oOVptWW1rY2xrdkdHVGtwSklhV2twa1VwZEYxSElHUHVBcmZIdk96ZE5qSWZUYzQ2K0FxdFN4ZldZdnI2K3BMS3lrbGxvZkR6TkZ4Ylhoa0toNEU1endJYU1URWhBT0lqOTFJRWFQcXRjQ0xTM1lCMUNHY1ZpZTF3ckV2bm1VYjdRM29SbGRncDJSaGtDSytRK3loZUVKSDgrME42RVpZRHRqQW9FbGt0bHNtQ2hoajJCOWhTV1dYaDJSamtDUzhWaWlhOG5OVjhJOUhaZ21jVm1aNVFpc0dSYit4d283VmFyMWUxOUd4c2J2TzV6SXhJRUZsbXQ2MFpQUnZOSlhYeUtDeCtoakNJbUQ1dU1oc2M3Q2VzTmFBY2pBdHRXSCt1bWRocDJ1OUNVMFliQTFxWDU2VkZ2d3VJQzQxc1JlVGN6N0l4V0JGNGY3dSs1NjAxWXpBWkN5amdmK1hlZ3R4OVpFZGpjOW4zRDNYV0wyZWd0V0V4ZFF0ODlPQnNYRnZQYTFmUGZvRlBOQ0d4YW1INzRhR0prcUk5clVFMU5qZUJ5eXhlNnZyNmVFeGpZL29DOTVpS3lJckFGZDBjM21pOWM0eHJVM2QzdFVWSGdBODAxTjBwbnkwVmtXMFpXY2F2V3ZJR0xzTzFDWTkvTWhQWWZsKzJmMkZpUEs1Zzc2SmlZR0pkamtlbGEwOGsrMmduZGNHeVI5UGdPM25MNnhDVWJsaVFXd1cwUWJoZzlMYmV1b0lPRGc1bTVXYXNvc1B4NnF1b2lzbEhHelQwZDltc1hydjk4dm0rb3I3dUxiWEJVVkJTcHJhMGw4Zkh4UktWU0VZMUdJL2pkd0FHZGxaWEZ6SUZ6NFk0NUlpS0M5WDVrNmJqU2hJdHR3ZEZUM3R6bXc0czhkaWlqQTBMRER0YTI5VlVFaE95SklNOVFkQXV6VXdXNUI3L1F6YzlnT0doQjE3WTJVa3dZTW5DRHRxSDRnMU5RQ3ZYUENoWnRBME1qc2lBVFpYdHltdytMRDEyOUF2cGZmK2Z2ZjUwci8vUzBGUkxnYnNPaVRiU05ETWhDbVd5c3JTcUF0dEI0R2IxKytWelBtUy96Rzh4clJzTnV3YUl0dEltMmtZR3lXTFkyazdjS3hzb2s3cDhnNE1XTHMxT0c0eWUrZlE5aU8zeEhZM1orWnVwazhmdE5BMTN0Nk5rUnlyREcyVnR6YmxzUiswbFFGR2ljZjBCUTVHY05QeDVOU0R0OENMYmNZbStDWXVvYTdPMjZWWjMvVnN1cTd0RUVoUjJuZWRmR0M5Z0pHdnZEbUMwd3M0Y2Z5ajEyNE0yQ3N0eUk2TGdEM29DZDFJNE0vMVJiMW5hcnJYa1kvcDJpWVRCSmN5NHJHT2VoRElYR2RJZTk0bjJnejJQRE1lUDFOMkpmZStlamwyTVRraE5rQ2g5QiswR0xhYzM0WUxEL2Z2dWxzN2R2L25iNUFiRWZnejJrQzJ5QmhvRkxLRjZuU0FDT3ZTZnNESVZSanorSHJXU2xuOHJ2OEpHM1k1SXlOREZoVWRGN0EwUDNoTUkxdFZRbWw5TzNMTE5SdjdLOE5EODdQek91bmI3WDNUSGExZnJES0Z6VDAzZURPZXJSR1pvTkxHNmIzWHpQNmFpM3NheXBxY2REc2JMU1dNZGZRVVpWNHRSVXhNbXRGTVJDdllleGlXOWU4OVNqeXpUUDhnS1JDamlKdEZHRE9EbnVyNmFwMTlYMEU4R1ZUdERFQ2RaSVFWY29JSDRhYUxrVmRMTHB5Ym1ialVJN3dHWFU4M0k2SDV1SDF5bWNpVDdBaHFjTDlYOEJCZ0I1aURuME1zKzI3d0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+a4uOaIj+inhOWImS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xUlRVMk1rWTVPRE5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFSVFUyTWtZNU9UTkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVkZOVFl5UmprMk0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pWRk5UWXlSamszTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrTVRHV0JBQUFGamRKUkVGVWVOcnMzWDFzWFdkOXdQRW5qdC9pT0MrTm5UWnAzb2lTcG10Unhmb0dhNFhVVXZMSEVCME1wallJcUdDVURTaURQOUEwSVcyYUpqWk4ybFNoYVVBSEhmRFBDbTNHeTBRRm1yU21kQjJvd0JLb1J0ZXU3Um9GbXFSSnV5UWx0ZXZZanVQcy9HNTh5L0c1NTlyWDlyMkpuWHcrMHFQYTU5eGMzL3M0NnYzbTNPZWN1K2owb1lmU0xMUmw0L3BzdkNVYjEyVmpXemJXWldOcE5yb1NBSEMrRzhuR3E5azRtSTFuczdFbkc0OWtZM2MyeHFmOTAydTJUL3EyZllZL2ZIMDJQcDZOOTJWamc5OEZBRnl3dWliR3FteGNsWTNmbTlpK1B4dGZ5OFlYc25HZzBUdHJhL0IyZlJOM3ZEY2JueFlqQUVBZEd5WmFZZTlFTy9RMUswaHV6OGJUMmJnckc1M21HUUJvUU9kRU8wUkQ3Smp1eHUzVDdQdGNOajVhdHZQVTBMRTA4c0xQMHNtWDk2VlRneSttOGVIajZmVFlhRG85ZnRLdkFBRE9jNHZhT3RLaTlzN1UxcjBpTGU2OUpIVmN0RGwxWFhwTld0eXpxbmpUL213OGtJMmJzL0dKYkl5VjNsK2RSYTA5MmRpWmpWdUxPMDYrL0lzMHZQOG42Y1MrUi8wMkFJQkpsbXkrS1hWdmVGTVdLSzhyMi8zZGRPWm95VkJ4VVd0WmtNU1JrVzlsNHgzRkhZTlBmanNOUGJmTGJBTUFVK3JadWozMXZ2N2RaYnNlVExFQWRzMzJzZW1DNUl2WitFaCt3OG1qejZXQko3NlJ4bzd2TjhNQVFFUGFWNnhQeTY2NlBYWDBiUzN1K2xJV0pCK2RLa2ppTU1vRCtRMmpMejJWanUvNVNqcDk4b1NaQlFCbVpGSEhrclRpdWp0VDU4VlhGbmU5TjR1Uys2dmY1TSt5aWROeVBwKy9aUndaT2I3bnEySUVBSmlWYUlob2lXaUtncytudzd0V2x3WEpYNlV6SzJGZk0vREVQMmQzTkdRMkFZQTVSTWxRR3ZqNXp1TG1PQjNuTDR0QnNqRWJkK1p2RlF0WXg0NGZNSXNBd0p5TnZYSXdEZjczdDRxYlA1UU83OXFZRDVLUFphT2p1amRPN1hVMkRRRFFURU43SDY0MFJrN0hSSU5VZ2lURysvTjdoL2YvMkt3QkFFMVgwaGp2VDRkM3RWVS90WGQ5ZGV1cG9hUHB4TDcvTUdNQVFOTkZZMFJyNUVTRFhCOUJja3QrNjhnTGo1c3RBS0JsU2xyakxSRWsxK2EzeEdmVEFBQzBTa2xyWEJkQmNubCtTM3hRSGdCQXE1UzB4dVVSSkd2elc4YUhYekZUQUVETGxMVEcyZ2lTWmZrdHA4ZUd6UlFBMERJbHJiRXNncVJ6MG8zR3g4d1VBTkM2SUtsdGpjNDIwd0lBbkd1Q0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFEam4yazBCTk5leHdiSDArL2Y4c21iN1ozYXNUVy9ZMURQbG4zMXd6OHZwSzk4L05tbmJsa3ZhMDJjL3NHbEdqK0hnc2RHMDg3R2prN1o5NnRhMU5iZTdkOWRMNlhzL0c1aTA3Wk52NjA5dnZXcEZ5K2JuZnc4TnB6LytwNE0xMjcvekoxdm1mTitmL2U2aFNkL3Z1TEV2clZ2Vk9lUDdlZWZmN3ExNWJDZEd4OU9CbzZPVjczdTYybVoxdjRBZ2diTm1WVzk3OWtLNElndUM0NU8yUDdsL2FOb2crZmNuWDZuWjl2WnJWczc0TVF5TmpLZEhueG9xQk1uazIvelhMNGRxWWlUODRPbUJ5cjZwNUYvbzZ3WEdYQ05nS3ZXaXFmaWNmK2ZhaTVyMmU0MFlxVDdQbTY3c0tRMDhRSkRBdkhMOWx0NmFJSW52My9YR1ZXbEpuUS9aanFNYWUxK3MrVWp1ZE9QbHk1cjJ1T0xvemVQN1hxMThmZDhQanBYZTV2RjlJOVBlVHpOZjZKdjVuSXAyN3gxTXp4OFpTVmR2WGxvNXdsRThhdFNvT1BKU1BUb0NDQktZdCtJRnEvaXY4ekx2K2J0OU03N3Y0cDhwT3pyUXlOR0Z1RTM4eTc2Ung3bVFIQjBZUzMvL3IwZEs5MVdqOE80N3Vpci9uZTF6UDkvbURPWWppMW9CZ0hQT0VSSzR3TVdpMlEvY3ZEcjFsTHlWOUQ4SFQ5UXNzbzJqTEpldDdYN3QrL2c2dnlEMTZ6ODhVdk4yMWFyZXRuVFBoemZWZmJzcUw5NWErZFA3OTllOGZkWHF4YmFOaXVjeUh4NEhDQktnb1JmNTJTeEdMVlB2N1lqWjJMcW11MmI5Uno0dWltSHcxLzl5cU9iRitJTlp2RXpsdDM5elpVMlFIQnNjVDQ4OU05RFFDL2xEUHo5ZUV5TXhuL1hXMHF6djYweDMzN0d1OG5WeGNXMUV6TWIrcnNwdGltdEFwbHFZV25hV0RTQklZTUdKRjhCbS9TdTZrU0NKRjllOFYwNmNxbG1jR3JkWjJ0VldXZVNaVi95K0tzNjBpWkRJMjdTNm83S0FOQmFKeHRsRVZUOTZkakFOalp5YUZCREZxS2kzaURidjFaSHhtaU15MWZtTW9Lbkt6MjBjZGFrWFZSRWo5ZmJOUlA2VTM2a2lEaEFrY0VFci9rcy9Uc1Y5Zk4vQm10dk05UlRkaUp3WXNVaDBjcEFNVEx2d00rSm10a2Q3NHI3ejk5K00ySHZpK2VHYTY1YVV6V1hJbi9JYkhERUJRUUxNVXJ6NHJsblpZU0p5Z1ZRV1VjWHJ0UUJuaDdOczRBSVJMNzZIZjNYU1JBRHpraU1rY0I2cXR5Nms2T3JOWGVsOWIrNnZmUDIxSHg2WnRPNGt2MjgyYi9QRVF0UHFXb3VIbnpoZTgzWk45VzJQcWZhRlJxL3hBaXhzanBEQWVTYXVYTnJvV28zbFN4WlhvaUZHZkYxdjM5a1dhMTFpeEdMU1ZvbEZ2dGFDd1B6aENBbk1ZM0U1K1puNjVvK1B6WnZIUDl1akc5VWpNdFhUZVFGQkFzekNtYk5DOXA3MW54dEhGY28rTUMvRTBZRFk3KzBQWUQ3eWxnMHNNRDFkaSt2dSs0ZC9lM0ZCUEllM1g3T3NvZWNEWERnY0lZRUZKSzZVZXZtbDVXczZZbkZvMmFjRm4wczNiRnVXM3JDcHAyWjcvcXFyTjJ6clRaL1owWmFPdkZKN0JsRGZNditMQWtFQ3pQbUZOeFFYbU5hN3JIeGNHYlg0ZGtwYytyeXFmM2xIMnJhMnUvVHpZR0x4WnlOWFFqM2Irck9nZUQ1M0JkZXEvRlZYcHc0dy80c0NRUUxNSUVoNlM3ZkhtbzJpaUpGNlZ4b3RCa2tqVnlTTmhhODdIenRhYzVuM01rY0dKaDlCaVV2TVZ4OWpmRjF2WDluOVhMWjIrbm1KMDQvbjhsazhQc1FPQkFuUUJHWFhBNGtqSGMwME5GSjd4ZEU3YjFsVitwa3djWW4zdkRPWGdpKy94c2hVKytKKzZrWFkrV2d1bDlzSEdtTlJLN1JRZkZoYzBZYSt6cGIrekxpK3hoWHJscGg4WUVGeGhBUmE2TG5EdFc5NXRISmRSQ3g2L2VETnE5UFJnYkY1T3lmMXJpMnllKzlnMnZuWThYbi9PNDByMkFLQ0JCYVU0bHNwY2ZTaTJlSk1sRmo4R204RnhkR1hDSjU2UVZKdjhXMHNpQzFiZzFKdkFlNWNUdFd0ZCtYWFJpOTNmeTdrZjI4N2J1enpGeHNFQ1N3Y1pWZFozYnFtK1pkaGp3QnBkUEZuMmJxUE9GMjQzb0xZT0kzNE45WXRTZXRXZFY3UXY4dFAzYnJXWDJnUUpMQXdQWDN3Uk0yMjFUTmMwRnJ2TEpmMWZaMmxwLzlXRFRYNEdUQVJUZE9kQmZPUEQ3K1UvdUsyOVUyYmw3aWNmSmtubmg5dTZlK2piRTRhL2F5Y0IvZThuSloyL1hxK3I5NjgxQ25KSUVoZ2ZvbG9hUFFzakkzOU16dlNVTzkrODUra20zK2huKzZ5OEQ5NmRqQU41YTRMVW5idGtuaDdJbjgvY2JiTnZidGVTbHN1K2ZYYWlYakxaclpuMmN6azB2WHhjNmNMbGVwcHoxUE5YNnl0S1hzY2p6NjFyNkhIVVR4ajZlNDd1Z1FKQ0JKWW1PS0ZmcXEzUHVKZjNTa2RhY25QcnI0Z3grbTZVd1hCamh0WHBQZStPUzdHTmpsdXpudyt6c0NrNTlMcTAzNWo4V2k5eitYSkt6dnR1YWlSYTdUazV5bCtkb1FZSUVqZ3ZCSXZjSEgyeTlRdmh1M3AwNzk3U2JwMzEvODEvQUxhcUJ1MkxXM29NYjdyamFzbXdxU3ZLUi9DRjBkU1pyT1FkODNLanV6UExVOTNmWGwvemI3ODUrRE1SZHhQUG5oaUFlOXRONXhac1BvSGI3MDQyL2VyaG9JSUVDUXdMMVRQY3FsblkzOVgzVE5MYXNPaHR6TGliWWloa2ZwUnNuNEcxektKSUNnN1V5WXZqb3hFakZUWHBjU1JuSHMrdktIeW9qdzRmR3JXY1ZKOVByTlZqSm5lN3NVMXp5WG1vdDZweEZPSjM4a2Zicis0ZEY4OC85aFhiei9RZkl0T0gzcm9kSDdEUzkrNXk2d0FBQzExOFR2dm1mUzlLN1VDQU9lY0lBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUlBZ0FRQUVDUUNBSUFFQUJBa0FnQ0FCQUFRSkFJQWdBUUFFQ1FDQUlBRUFCQWtBZ0NBQkFBUUpBSUFnQVFBRUNRQ0FJQUVBQkFrQWdDQUJBQVFKQUVBRXlXaCt3NksyZHJNQ0FMUk1TV3VNUnBBTVRMcFJlN2VaQWdCYUZ5UzFyVEVRUVhJb3Y2V3RlN21aQWdCYXBxUTFEa1dRUEpQZnNyajNFak1GQUxSTVNXczhFMEh5MC95V2pvczJteWtBb0dWS1dtTlBCTWtqK1MxZGwxNXRwZ0NBbGlscGpVY2lTUDR6R3dlcVd4YjM5S1VsbTI4eVd3QkEwMFZqUkd2a1JJUHNqaUFaejhaOStUM2RHOTVreGdDQXBpdHBqUHZTbXUzajFRdWpmU0hscmtmU2NkSHJVcy9XN1dZTkFHaWFhSXRvakp6UmlRWjU3VXF0Y2Jqa3kvbGI5TDcrM2FsOXhYcXpCd0RNV2Z2eVN5dHRVZkRWdEdiN2dYeVFoRC9QeHRIOHJaWmRkWHRhMU5GakZnR0FXWXVXV0hiVmp1TG1hSTQvcTM3VFZ0anhSL2xiZHZSdFRTdXUrMUJhMU41bE5nR0FtY2RJZTNlbEpUcjZMeXZ1K21SYXMvMW9XWkNFQjdMeHBmeUd6b3V2VEN0LzYrUGV2Z0VBWnFSOSticXNJZTZxdEVUQnZWbU1mSDFTdUp3KzlGRHhScDNaK0VZMjNsSGNNZmprdDlQUWM3dk1NQUF3cFZqQVdySm1KRHlZamR1eUlCbWRMa2dxOTVPTmIyYmpiY1VkSjEvK1JScmUvNU4wWXQralpoc0FtQ1N1TXhLbjloYk9wcW42WGpadXo4WlFGaVNwa1NBSkhkbjRYRFkrVXJiejFORFJOUExDNDFtZzdFdW5CbDlNNDhQSDAvalljRXJqcC93MkFPQjgxN1k0dGJWM3A3YnVGWlhQcG9uTHdjY1ZXQXNYUGN1TEpTR2Z5TWJKeW5jekNKS3E5MHlFU2IvWkJ3Qm02RWlLQmF3cDNUOXBheUZJMmhxNG8xam9la1UydnBoeUYwOERBSmpDNkVRN1hGRVRJeVhhR3J6VHFKdVBaV05MTnY0bUd3Zk5Nd0JRNHVCRUsyeVphSWNqamZ5aFJ0NnlxUmN5MTJmamxteGNtNDF0MllqemdudlRtYlVuQU1ENUxkYUNES1l6VjN0L05ocy96Y2IzczdFN25mbWN2S2tWM3JMNWZ3RUdBRURJTW1VeUVRQzVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNouWVhuWfji5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUN3QUFBQXRDQVlBQUFEVjJJbWtBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFSVFUyTWtZNVF6TkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMVJUVTJNa1k1UkROR05qQXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pWRk5UWXlSamxCTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalZGTlRZeVJqbENNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCt1QitEWXdBQUJtSkpSRUZVZU5yRW1WMXNGRlVVZ00vTTdHL2IzUmJhQWdYS1QwdVJpQlNJQ20wTkR5YndZSHdoeXBNWU5UNFlUTFFZSGt4RW5veWdKUDVFRUZCNXNDSytLT0ZCVkNBU01hSUZiUGxwK1M4dFB4YTZaYUhkN3JiYjNabWRIOCtadVlXVzdzek9iTGZsSnFlem5abDc3emRuemozbjNETmNmTzFDR0VQem9OU2lQSXRTalRJZnBReWxnRjBmUUFtaHRLRzBvaHhGT1k0aURRMnd0ckhOMFlSY2xzQkxVZGFockVHWjdMQnZCT1VubEs5UXpvdzM4R0tVTFNqUFVWOFlXOU5RRHFHOGg5QXR1UWIyTWRDM1VWeVEyeWFqZk1uQWs3a0Fub2VxMk1jWjJoMjNobk8wNEJ4ckVMcmQ2ajdlNnFLaWFjdHdvT1BqRFF1R2ZTM0d1VTd1cWEycXlRb1lZV3Q0anZzREJ5cUJDV280MTJTYzg0Z1ZkRnJnbEtwVlljY0RPRUErVEhDak9XbnVocHFxS2x2QXZaTHNkL0hjdm9uVWJCcm9FbUxZL2xTRi8rRnJvMVo4d0NWczVZd2dNUHJweW1hQjU5VU53TStxQlBuVU1aRDJiZ2NRRTg1Zy9QbmdlYmtlaE9ybG9ONjZCdEozbjRQYTNaa091aHBaUHNhZjYwMjlSSDlLZVRMZ0ZrNmtleEIreGh6d2J0Z0tYS0R3L2ptMS9RSWt2OWhrRzVwZ3ZlczNBMSt4NElGM2lFVkEvT1RkdE5EazhwQnArYnFtanRPalRBTGRDZWNUK0kvTS9Lem50UTBqWVBYTzh4YUNiLzJIQUY1L1ZyRDYrZUFrOEx6eWpsazNGMlBpUmdHanZTeHo4OXhLMDlVNXJUejllUWJOK2Z5T1llOWZuejdidEM4eXJTSzJFY0NrWGIvQTExdUZXK1Y4czdsdlJHaHZmWHJvVExENjJLMG5yVi9PTURiaC9lb3A5Q3U0cUNqL2F6eDZ6WHFwRjVwQnFGb0UzT1FwNlVmRjgzUmR3Y1VJc213YlZtMDdCK0p1Zk91S1lub1Blb3c1eUxialVpd2g2aHBlVmx5d0FrOEVMRU5uTWdIaXRrMzZRck9qYWJ1d1NSd1RKREdUbXdzUW82N2hpd045L09xWnhXK2kybXN5cHlteXJrRTdtbmJWcnN3SjdJUElDK0hmdWlLL2s0YmRhTmpWdHBNVW01ck9KU3hiZk5YNkFmOTRQVHcvMTFGbVpRTTZsN0M2V3pVWXZRVHNFVGdvZHB3T1pnR2RMYXh1dXdhamh6Y1dJWmVYVlE3ckFIb3NzTHFaR1l3dUFoYkdscW5nRUx5TklYZ2ViK1hIbWhjSk5BS0h1VzhpSzFZYnJzdE9jTEhuSlhSR1RuOWtTZEdpNHdtYkMrZ2hSZ0xXNHJMU05kNndZNFZtakJvQks1R1UzSkZMV0ZwZ2RpT2k3V0tHd2FnUXNIeTFQOW1jUzFqeUJrN0N1SjNXM3A4OFJhd0VMQjBPUlpybERBdlBhVzdnTlBld3pBZzBMWG13SzBKS2xRaFk3QkhsM2x1RFVwTmxwTUZ0amROd2F4ZmEvZEpibHNESTlpL3VOWHVJbFlCVEtMRy93dEZmTEIzZzBycXNnb0lkYUdGSm5TWHdzWENNMkdMRXl2OVFOMStsS3VQaFVGL1RuV1Rxa2lsVVowZldFU3dUdElhYlViTkdUSWRDa1NaV0NWV0hRazhjSlh6Z2R1OWVEVSttOVlNTm4ra2J4bXpEclJtMDF0Y0RZc09uWnVVcjllZmJ2ZDhURzJNMGRoejdPM3NJa3JzUkY1WEhDL05tbG5yZG83STNiU0FLNnJrbTRNc3JBSHg1b0p6KzI5Z3BPTWtOV0Q3Tmw1UUJONmtFdEp0WFFkejFBV2poOUdIZ2NpeHhkTS8xOEkvNDh6cHQ2a2RzODNGZlJ4WEtpaUszNitrdFMyWnZMblFMTStBUnRtaEs2ZHA0OXViR3ZwUk01a0EyazN5NDhrT3E2c1licnUxdTc5NHBxVnI4VWNIUzNNaXdnMWlJaWJHTjNPYmo0dE9ZMm0rY2ljVFA0cXZZaFFtSE5OR3dOQ2ZOVFF6RXdwaTAreDZGYkhpb3ZWaGVyS0k5azV0VDBaN0ZTRXJweHQzMFlvSGozQk9rMmNHRzYrR2RmOTZKTnVLL1Y4RDRQaUphMXRhWXJkeW0vUk4yNUNPaVBQaEcxZFRYMGJhbmp5Y3N2djZ1YjlydmZOdGlhTGFOTVl5cXlLZXR3Rk5oQll3dlFWU1NtVi9nRW1iVlAxYjJBbnFRWjdnTVJYREh1eFo4bXhlamcvOXN1eExhUHlBci96SFltOHp2YXJhQWgwRlRmWmk4UlNYSzlKcVN3SUkxNWNYUGwvazlDM0lCRzBwSWwvZDE5dng2NGw3L1pmeVhmRnNIMDJ3OEhhd2w4REJvY25kVUs1NkRNaE5sVW0xSllONnFhVVYxRlFXK1JiajlkclFmVEtsYTR0cEFzdlZJZDE5ajQ3MSsrcDVCMGVnV1cyRDNtQmxvcGttWW5hOUlDRTZMamlwRDA1akdhYVVHZlFLZnY2STBXUGxFVVY3bFZKKzdyTkR0S3ZVTGZCQjN0UjQ5VHFpYWxGRFVXRFFsMzhVUUd6cmZOOWh4N0c2c0k2bW9jWlliaEpsR3U1azNTR1ZNY2UxK3AyUGFwdHBia0dtOEZLV1kyVHE5QlRjVFlWaFJrVFNsTUpBVTB4N1pKbVZlZDVsR1k4d1RhTFp5OHRWekhYc3NnaUVONWpHdEI5bVJ3UDNEb0dFWWJJS0I5ak5BT2c2QzhRbFhjeks1Szd1RnJXdUVKTW9BdmV3aFhDWWFsaG1jeUI1QXpYYWgvaS9BQUlOK0tYUnFLNEUrQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wTkRrNFFUVXdOek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBORGs0UVRVd09ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUTBPVGhCTlRBMU0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pRME9UaEJOVEEyTTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrRTdaMW93QUFJUE5KUkVGVWVOcnMzVnVNWFBkOTJQSC96TjU0VzVIVVVoUkpVYUprU2hSMXRXekpkcHpVOFUxRmFpTVFDZ2gxR3pkQWJ3OXRXcnNQZVdrZjJqNDBmUW1LdGc5T2dMWW8ycGMwZHRLcUtJekVhV0VsamdNMHR1WFlrU1ZaMXRVV0pkNGtrVnlLNUpMY0pYZW01M2RtWnZmTTJUTzdzOHU5Ni9OSlRwWTdlNTFETWYvdi9NLy9uRk5ybnZwbVdvSjZ0bjBrMno2ZGJZOWwyNUZzdXkzYnRtZmJTQUlBTnJ2SmJKdkl0aFBaOWtxMi9VVzJmU3ZidnA5dGpRVy9ldC9qWGU4T0x2S0hIOHkyZjVKdGZ6dmJidmQzQVFEdld5UHQ3ZVpzZXlqYm5tdy8vbGEyL2ZkcysrMXNPOTd2TjZ2MytYbGo3Vy84ZXJiOWN6RUNBUFJ3ZTdzVlhtKzN3OWh5QmNrWHN1MmxiUHZIMlRac1B3TUFmUmh1dDBNMHhOOWM2Sk1IRi9qWVY3THRIMVY5OFBUVmdmU3R0N2VrRjk0YlNtOWVIa3huSnV2cHluUXRUVFZxL2dvQVlMUFhScjJadGc0MDA1NlJScnBqMi9YMDRNNXI2ZE8zWGszN3RreVhQM1ZQdG4wdDJ6NlZiVi9PdHV0VjM2L1dZMUhydG16N3ZXejc1ZklIWHJ3d2xQN28xTmIwMUZ2Yi9HMEFBRjJldlAxeSt0eitLK24rbTY1VmZmZ1BVbXUyNUhKNVVXdFZrTVRNeUZQWjlrVDVBNy8xNm1qNjNXUGI3VzBBWUY1ZlBEU1J2blRQeGFvUGZUMjZKUXVTcnBtU3FqVWt2MVdPa1IrZEgwNS85M3RqWWdRQTZFczB3OS9KMmlFYW91U0pkbXQwS2MrUXhEVEsxNG9QZk8vc1NQcVh6KzlLbDY1Ykd3SUFMTTZPd1diNmpZZk9wNCtOVFpZLzlNVzA3L0d2VmdWSm5KWVRLMkgzZEI1NGRudzQvYlBuZHFXTDErcjJLQUN3SktORGpmU2JENTlQait5ZUtqNThMdHVPWmxIeWJyeFRMSTEvVTR5UjhCOWVHUlVqQU1BTmlaYjQ5eS9mVkg0NExxajJHNTEzT3JWeFI3YjlnK0pueFFMV1Z5OE8yWXNBd0ExNzdkSmcrc29ybytXSC8zNDYvZlFkeFNENXRXeWJxWThmdnpka0FTc0FzS3krK3ViMnZERUtodG9Oa2dkSmJMOWEvR2hjWndRQVlMbFZOTWF2cHROUDF6dDM3VDNZZWZUVWxZSDB2NDY3NkJrQXNQeWlNYUkxQ3FKQlBoSkI4cG5pbzMvNnpoWjdDd0JZTVJXdDhla0lra2VMajd6d25vV3NBTURLcVdpTnh5Skk3aTArRWpmS0F3QllLUld0Y1c4RXlmN2lJMmNuWFhjRUFGZzVGYTJ4UHg3cE9pbDRZdG9sNGdHQWxWUFJHcU1SSkYxM3ZibldFQ1FBd01xcGFJMWh4MmNBZ0RVblNBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFNR2dYc05sY3V6S1JybDIrMVBmbmo5eTBPeld1WDBzWFRyN1o5ZmhOQis1SVExdTNkejEyOXZXZmRMMi9kZGZOYWR2WXJUUHZYejc3ZG5ycFQ3L1I5VG03cys5ejE4Yy9tLy81WjkvNTR6UmUrRG5GajgwbmZ1NnhaNy9iOWRqUlQzMis2MmNYeGMvcCtoME8zcGwyM1g2NDhtUDdIL2h3MnBMdGcvSno2MWZWZnVwNDU2VWZwWW54TTEyUDlmTjhsL08vaGVlLzhmczMvSDJHUnJha281OTlvdWZ6WEExcnZTOUJrTUFpUlZpVUIrLzV4TUFleWw5enFCMGNSZVhQT1pnTjVoRTBBMFBEUy9wZHA2Y20wOVVMNDZseGJhbzE4RzNia1E5NnhjZkM1TVRGUlgzZjhYSmM3VDNRODJPM0hubXc4cm4xdmYreWZkUnJvRDcrNHgvT2liUFZkSHlKejJsTzJFeGVUY2VlK1hhNis1T2ZuL2Z6ZnZqVWYxdlY1M2VYZis0SUV0aGN5ck1hL1E3UU1lRHV1R1ZmejVtS0JlUHB6TnZweFcvKzc5a0lldVRuMHRqaCs5S3A3UHVXdzJFaktNOEFWWVhTK0RJUDJoOSs4dTlWUGg0elBzdTVEK1B2S21ZcDloNzlvSDh3SUVoZ1l4dlpQcnFpMzMvNjJsU2F2REErNS9HWVlZbkRTVld1bkQrWHo4eHNCdkVjNDdsTW5EbWRUdjdrMldYLy9oR2dreE1YMHE3YjdzeG54VzVrZHV4R2JSM2Q2UjhVZ2dRMmlqajJ2Mk5zYitVcjlYNCt2N3plWTZHdlg4am8zdjNwOUtzL1hwYm5GWVBoblBESVlxUnF0aWQrWnErZkd6TkJjWGlxYytocVBwZmVQZDExR0NaK2o2WE9EcTJFcXVkZS9QdGI3SnFMMTc3OWpYeG1wT2pkTjE3THQ1VG1YOGV6MHZZZXZzOC9jQVFKYkJRUkYxV0RVSy9EQnZINW5UVVZNZEFVUCsvZ0l6K1hMNWFOVitDOWdpUytwdGNoaER4STl0MmU3dityZnoxTlpBTjc1YXZlOXBxVldJUmFYUGRSTkRBOG5MYnYyYmZzcjh6N0dWalB2dkZLMS91NzloL3NIdlFMdjNmTXlwUWphTjg5RDZ6NExGR3YyWVE3SHZ2RW9yL3UwRWMvbVY3NjQ2L25hMGo2c1pnMU1wZk92alBuKzhidnVXV0JtWS9CN085L05OdkhuVVhLSUVoZ0F5a3VOcHd2R01McjMvbVRmS0FvZjE1bnNXeXM4NmhTZFlaTjhaVjVQMmV4eE9HVDJPWXpQVFUxYzBaUStTeWZsZGFaR1pnSnJGSTBGUWZKaTZmZm1oTWt1MjQ3dENZekNvY2UvWVVsQlZ3czFyM25GLzlhZXZYUC9rOWZVYktZR1ppcTlUWXg2ekZtNWdOQkFuUm1TV0tnaUZOR2w5T3haVHJqbzJ1Z3plS29PTURYczBIM3BqMjN6am5NRUk4TkRJL2tmeTRQZ2hGTU1ldXlrQWlNc3BqeDZXVnE0dEtxLzkyVlp5aTI3OTV6UTR1T1E1d1NmZjh2UFprZkRpdkg0bVpaZXdPQ0JOYmpQNHIyNFB4dTZkWDkrUEdmemN4S3JGY3hlQjU0OE5GMG9UUlRFNDkxQnVYeTRhcmlxL3I1Wm5FdXZIT3k2LzFiN3J4NzBiTU84NjN4V0dxUUZXY1U0bkJiT1JyNm1YVmFpcTBWcHp1ZmYrdjFmQWFySDFjdnZyZmdQbDZJMlJRRUNXeGkyM2J0eWY3dmEzTU9ONVJuSGNwaWRpSmVvVy9FMDNVN0ZqT0wwOXBQcWUrQVdRMFJIaXN4RTlVcmhzb3pMK1BIMzdpaHYvLzh0T2hGZkwwZ1FaREFKcmI5bG4zNTJTTlZhd2JpOFY3VDlERTdFYk1OdlJiTUxyUjJwV3BOd1VKZkF5QklZSk9Lc0hqb2wzOGwvL05pRnNQU3JYeElJczRnV2VxcHFwZlBuNW16b0RZTWI3ZUdBd1FKYk5KQnROYzZpdUxqdldaUU5ycjVvbXV4bDBXL1VncVNPSjExS1ljWTRtSnZWUmM1aTh2Mmx4ZlZ4bjExanZhNXh1ZjhpV09WcHlYSG1VRDlzS0FWQkFtc21CaEVlNjFCdU5HMUNVdTV6OGxDWDdPV0YrWmFLQ0xtL0QrYjRlRjgwV2VzczZnUzF5OHBCMHQ4bjUvOStkTno0aThXMUZaZHdqMFdtZlo3QTd5cWhhNXhqWlRsM3AvbGhiY2RWWWZvZW4xdXIxUEtRWkFBWGluUG8rcnk5YkVJTnM1QTZiVm9NeDZQMDQrTDF6STUrZHozS2s5aFB2RHd4eXEvUjlWZGtSY2p2cmJmcis4VkQ0QWdnUnQ2RmJzVVcrZTUwKzFHVW5Wcit3Vy9KaHY4NDB5YS9ROThPRjkzc3h4KytzeWZwYU5aNE1Vc1JmeE81WFVqY2FqczRJYyt2bWIzandFRUNheW9PTE9tY1cxcVJYL0dmSmNWajdVclZ5cXVTN0hRMTlXWGFXQ09HRm5zNmFwWDJyOXo1MUw3WFIrck9Cd1NDMURqRUV6eCtWUmRQajJ1bEh2Z3ZrZTY3cG5UY2VkamYyWFo0Z2NRSkxEdW5Nb0d2NlZlUDZMZnMyOTZYVlk4cmdnYjkwdnBKZFkxSEhqNG94dCtIOGVzUml4Q0xWOWUvdFgvOTNUMy9zZ0NwZXF3U2N4aXpYZGwyUHhuREEvM2ZUK1o2YW5KT1llREZuT3ZuZlY4Z1R3UUpNQ2l4SXpCc1dlK1BlOFpPNTB6UVc0a1NxWlhlUGFuTEc2c1YxYTExaVlDNHdNZi9jWDhVTTE4SWhUNldhOFJOeDBjTHYyY1hvdFVZNkZvK1lxMnZlNjFFOUVZTjFiczUvc0NnZ1NXelh4M1hWMnVLN0ZHSkx6OWsyY3JGMjNHb1pCaXBFU1VURitiekJkekxyUitZcVRpa01iYkx6K2ZENkRuMzN5OThtdGk5dWF1Qlg3Zjhoay84eTNxckF5U0htdHRZc1prMy9qWk9hZmdGdmZIcmZjOTB2YytMWitORW5kWHZ0SERQSEViZ2ZMdjU3bzBJRWhnVWNvM3lldm5wbm56M1hWMWZBbW43MVlONkZWaTBXYmM4ajRHMXZJZFptT0JaM21SWjFVVVJMQ1VyNU1TMFJObnJGUXRFbDBQSWpqT1pyRlVOVk1VTndYc2R4RnJoRWZFWkhFOXp2Ry8vRTdhZmJBN3R4YWFiU25maytac0tlUWlrZ0JCQW9zeWZxeDdFTDdReHd6SFd0eUhKUnorK0dkbXJxV3htTnZlbDkzK3dZL09PUXhTZGFYVHNUc09yOHcrcjdpajhIeGlwcWpYODR6dk5mTGNNMzBmc3RxNTcyQlhrRVNNbFdlaEZncVNoZTVKTTdKajFEOHNFQ1F3djdIQzdFYk1OTHo0ZjU4cURUWS9xNWh1ZjJIT0lMaHNoMmFtSnZ2NnZQTE4ydUxWL2xLakpBNkRITXBlNGM5M1RZM0ZIQXBaU1NlejJPaDF1S1lqUGg2TFRmdFpSeExyUUJiNmZqZHFkTzhCLzlCQWtFRC80aXlPOG1BZXI1YXZYaGhmdGROSDQrZkZZYUtxV1lLNGVtbGNNQ3pPMktoYUpCbS80OUhQUHBIUDhsUmRKeVRPS3BrdnpHSXRSOVhnSEljMTd2cjV4MWZrZWg1WEt5Nkt0bjEzOVoyQjQwSm1WYjlmMWFYNUk2N0tGMDZyRXZ2eG5sOTRQQjEvN3ZzOVQ2VytFZkgzdU5EdkFBZ1M2SExxSnorcWpvU1RiODRiSkRIbzNOVGpWZkJTcmdRYVo5TEUycENsWEVRdHZxYnFNdWtMaWRtaHl6MHVkaFlEZGNUYVNneXNWZGR6cVFxZldLZFJ0UzlqMzkveDJDZnltYTF5bEx6MW8yZlNscDAzTHhpVGNmYk9mUXVjSWp5ZnVOaGIxZlZWNHJvdnEza2RsS3JMeTRNZ2dRMG1UdXNzdmtLT203RjFMcllWaXhUbkcrU3I3cXV5VUpETWQ3K1JtQ1Y1L2h1L3YrelBzWHd2bStLOVl1YTcyRnFJTlNZSEp5N2xzUkEzcFl2dzZYVmp3Y1VNb0hHeHN6bEJNanc4NTJxd1ZRTnRIRWFLR0luZnFlcHdWZnc1SHRzeHRuZm1zZUwxWGVMbjl4MXNGWWZTVHI3d2czd1I3V0xDeFlYYVFKQkFwYXI3bWNRaGl0Mkg3cDRKa2hpb08yZTlWSjIrdVpoN21zdzd1N0hLZHdXZTcxNHhWVHI3NDJqN0V2aUxlYzV4NWRXeVhqODdyZzh5ZnZ5NzgvNXVFU1BGdzBpOTF0REVuNHZmNTY0K2ZuNi95b3RmRjFJMWk3SmE0dG9zc0puVTdRTGVEK0pza2hod1YvTjB6WWlSR0ZCanNlcGFuMTRiei91aHozOGhEN1BsRW9kTytoRXpVd3NkcXVwMWo1cUlramhqaUc1eFdHczlMRWlHNVdTR2hFMnZNenVTdjZLOTk2RTVGeDI3MFlHK0l5NUlGb2RRaXU4UHROY2N4T0dmT0tTejNNb1hRYXU2ZEhvY2Z0cVZCVm44TG5kLzRwZlM4V2UvZTBNekNiRS9Eejc4a2NySUtOK2tNTzRSMURta3NmdmduVDNYNVhRT0dWV0pkUzV4dzcycSsrTlVEZFNyK29xdUZGQlZ6N0hYSmViNytkeXF0U3h4eGR2TmNFTkhLS3MxVDMyeldYemc1NS9lWjYvd3ZoTm5oaXoyNW5xcnZjQVJZRFA1ODhkUGQ3MXZoZ1JTRWhZQWE4d2FFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFDQklBUUpBQUFBZ1NBRUNRQUFBSUVnQkFrQUFBQ0JJQVFKQUFBQWdTQUVDUUFBQUlFZ0JBa0FBQUNCSUFRSkFBQUFnU0FFQ1FBQUFJRWdCQWtBQUFESzdMMzZyWlRKTVh6cWVyNDJmVDVNWDMwdlVybDlQMDFHUnFUamV5RHpYOHJRSEFBbXExZXFvTjFOUEE4RWdhM0xvdGpZenVURnQyajZXUm0zYkZCd1hKZks1ZnZaSXVIaitXSnQ0NW1RWElWTDdEWW9lbVdtcnR2R3pIMW1vRC9pc0RnRDVlM0RkamJKMjhtbzJ2VjlPVmMyZFNldU8xTEZDRzAvYTlCOUxvd1VOcGNNdFdRVkxVdURhVnhuLzZTcG80ZlNMZmViVjZGaDZEUSswZ3FiVmlKSSs1enR1Wi92TWZIQURNVmtqcGo4M1cyMlp6Wm10TVQ2Y0xKNDZsaTltMmZkOXRhZmNIanFUNjBMQWdtWGo3WkRyM3lvdXAwWmh1aFVoOUlOc2lQT3JkUVpMM2h3QUJnUDc3cERuN2RtWnJwTlRJM2pZYTZkTHBFK255TzZmVHpmZmNuOFhKZ2ZkbmtEU3puWEx1NVJmeW5WRWJ5Q0prY0RDUGtSUlJFdUZSYjRWSUxWWE5qZ2dUQUpobmxDMjhhUmJlUm9oa0wvanJyU0JKalZyV0o0MTA1cVhuMHRYelo5UE45ejdZR29QZkwwSFNuSjVPNzc3d3czUmwvR3dXSTRONWtPUWhVcS9QQmtseG0ra1FJUUlBaTNqMVB6dUVkbVpJYXAyM25YRzJrYi9RandtQzZjbXI2WllIUDl3YWx6ZDdrTVRNeUxzdi9HVVdJK2Rhc3lMeHBHT0dKQStSZW50bXBENFRJRFd6SWdDd05Qa2cybXlQdjdXWlFLbkZZWnYyMFlobW96M1dabHVNelRGRzMvTHdvNnMrVTdMcVFYTHVwUmV5SjN5bUhTT2wyWkYycmRYTWpBREFjbFZKSGlLMXpobXIrZGszcmNNMnRXYTdSR2EybEkvUnNhUmk3T2hEcS9wYnJ1cUYwU1pPbjB5WDNqNHhFeUt0MlpIV2VkS3BjN2ltRXlhZEVCRWpBSENEVGRKOWdraG5pVVErN3NZWW5JL0ZBKzF0TUQ5OEUyZStic29naVZON3o3MzZZaUZFaWpNanJYVWpOU0VDQUtzU0pqUGpibTEyRFdlYWlaS0JkRFlicy9OcmdtMjJJQmwvL1pYODFON2lURWd4UnB6YUN3Q3JHQ2J0dDhVb0tjNmN4TmszNTMvNjh1WUtrcmdDNjhUcDQrMXJqQlFXc0piUHBCRWpBTERxVVRLN2hyTmV1Q2JZUUg3WUpzYndUUk1rY1RuNFpyNmF0MTdZQ2d0WXhRZ0FyRm1VekJ5cHFIZVAxVEYyeHhpK09ZS2syY3l2eHRvcXJscjNNU3N4QWdEcktFcG0xM1RtWTNZMmRzY1lYcnlleVlZTmtyaHI3L1MxcWZhbDRHZG5Sb1FJQUt5L01KbVpLV21QMnpHR3gxaSs0WVBrNnZqWjJlTlQ5WnAxSXdDd25tT2tZc3pPeC9JVnR1SVhScHU4K0Y1cmtVejd2alN0ZTlQVWRBZ0FyTU11YVhidUk1YzZRVkxQeC9LVnR1SXpKTmN2WDI1ZkFLN3p4Q3FLREFCWSt4cVorWFAzdUoyUDVSczlTS2F2VFpaQ3BGWjZDd0Nza3lycGZ0c09rM3dzMytoQjBweHV6RDY1VHBpWUdRR0FkZG9reGJHNlZockxOM0tRZE80b3FFRUFZSVBGU1N0TThyRjhvd2RKOWJNREFOWjNpYXl1dXAwT0FLeTFWUXdTTXlNQXNMR3MzdGh0aGdRQVdIT0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQVFKQUFBZ2dRQUVDUUFBSUlFQUJBa0FBQ0NCQUFRSkFBQWdnUUFFQ1FBQUlJRUFCQWtBQUNDQkFBUUpBQUFnZ1FBRUNRQUFJSUVBQkFrQUFDQ0JBQjRQd1ZKMDk0R2dBMWw5Y1p1TXlRQXdKcGJneUF4VXdJQTY5dnFqOVVySGlTMVd2WWptazBkQWdBYnNVdXlNVHdmeXpkOGtBelVaNTlWSjB5YTZnUUExbWVFRk1mcVpta3MzOEJCTWpBMFVwb2hhWmJlQWdEcnBFYTYzN2JESkIvTE4zcVFERzdiTmx0YTVVTTNaa29BWUoyMFNMTzdTd3JqZGo2V2IvUWdHUm5kbVQyZlJyWTFVK2QvNGdscUVRQlloMDFTR0svenNUc2J3Mk1zMy9CQnNtWDMyR3hsTlpxRjRtck9MVElBWUkxS0pIV1AwWVV4T3gvTE4zcVFqTnkwS3cwTURXZFBxTkhhR21JRUFOWjFsT1JqZFd2Y2pqRTh4dklOSHlTcFZrdmJiejJRUGFkR3RuV21mMXBQdENsTUFHQmRoRWh4Yk02M0dMT3pzVHZHOEJqTE4zNlFaRVlQSGtyNVUyazBDbHRuTFlrb0FZQzFqNUgyekVoaHJLNjF4L0RWc0NwQk1yaGxhOXErNzdhc3RLYmJXeU5mSkdNOUNRQ3NiWXdVeCtMOEpKVDhpRVpydk41KzYyMzVHTDVwZ2lUcy9zQ1JWS3NQekZSWHM3M05ITG9SSlFDdzZqRXljNmltTXk1M1prZXlNWHYzNFNPcjlpdXRXcERVaDRiVDJEMzNwK2IwZEw2bDJFcFIwaXpYR2dDd3ZDRlNPRXhUakpFOFJOcGpkR3hqOTl5WGo5MmJMa2pDOW4wSDBvNDRkRE45dlJBbTJZNlliblRObkNSaEFnQXJFaUw1ckVoaEppUWZnL094dUJNajEvT3hPcFphcktiQjFkNG5OeDk1SUUxUFRxWXI0MmM3ZXluYkJ2SzMrYzE3NnJYc1QrMGI4dFZxcllXOStVNnMrUThLQUJaZkl6Tk5NaHNsclpOTE9tdEdabVpHcmsrbnJidjM1R1AxYWx2MUlLblY2K21XQnorVTNubitCK25xK1hQNWZxcEZ1Tld6LzFQUC81QkZTQ3RHWW12T25HclVYSlhUamdCZzg3UklzL3ZQemNJWnJvVTFJNTJaa2JnQVdvelJNVlp2K2lESm8yUmdJTzM5NEdQcDNNcy9UcGRPbjJqRlJqTm1SUVptWmtaaXBpU2ZJWW1aa2J4RGFvVkpFbUVDQVBPVVNPRk5zLzIvczZmMnpnYko5RXlReEdHYW0rOTlvSFcwWWcwTXJ0V3VpaWM4ZHZTaHRHWFhXRHIzNm91cGNmMTZhNGFrM2pwc2t4cnR0NmsyT3pOaWhnUUFGdEVsaFhVamFmWUtyTTNHYkpEVTZ3UDVlTHphYTBiV1RaQjB4RUxYTFdONzB2blhYMGtUYjU5bzFWcEVTUlJhKzdCTmEwdXBlNWFrL1Q0QTBDbVEwaCtiTTNmdW5ibkVSbnZkU0l5Z08yNjlMZTA2ZktSMWk1YzFOcmdlZGwvc2lMR2pENmFkZHg1T0Y0Ky9rUzY5ZlNvMXJrMjFRNlRlNmc2ekpBQ3dpRFlwbnJHYVppNUlHcWZ5anU0L21FWVAzcmxxRnozYk1FRXk4OHRrTzJiMzNmZWwzWWVQcHNrTDU5UFY4Yk5wOHVKNzZmcVZ5L21aT2ZtaW0rUTBZQUJZU0w0S2MyQWdEWXhzU1lOYnQ2V1IwWjM1b3RYOFJubnI4TVg5NFByY2k3VTBzbk4zdmdFQW0xL2RMZ0FBQkFrQUlFanNBZ0JBa0FBQWdzUXVBQUFFQ1FBZ1NPd0NBRUNRQUFDQ3hDNEFBQVFKQUNCSTdBSUFRSkFBQUlMRUxnQUFCQWtBSUVqc0FnQkFrQUFBZ3NRdUFBQUVDUUFnU093Q0FFQ1FBQUNDeEM0QUFBUUpBQ0JJN0FJQVFKQUFBSUxFTGdBQUJBa0FJRWpzQWdCZ1BRVEpWUEdCb1hyVFhnRUFWa3hGYTB4RmtGd3NQcko5UUpBQUFDdW5valV1UnBDY0tqNHlOdEt3cHdDQUZWUFJHcWNpU0Y0dVBuTEh0dXYyRkFDd1lpcGE0K1VJa2g4VUgzbGc1elY3Q2dCWU1RL09iWTIvaUNENVZ2R1JUKys5YWs4QkFDdm1VM05iNDFzUkpNOWsyL0hPSS91M1RxY25iNzlzYndFQXl5NGFJMXFqSUJyayt4RWtzYkxrZDRvZitkeitLL1lZQUxEc0tocmpkOUsreHh1ZEM2UDlkaXBjaitUK202NmxMeDZhc05jQWdHVVRiUkdOVVREVmJwQ1pLN1hHZE1sL0tYN0dsKzY1bU80ZWRjWU5BSERqRHUrNG5yZEZ5WDlOK3g0L1hneVM4Syt5N1d6eHMzNzl5SVUwT3VTNkpBREEwa1ZML1BxOUY4b1BSM1A4aTg0NzlkSUh2bFQ4ekVkMlQ2Vi8vZUI3YWF1cnR3SUFTN0I5c0ptM3hJZDJUNVUvOUUvVHZzZlBWZ1ZKK0ZxMi9hZmlBeDhibTB6LzdwRnhoMjhBZ0VXNWU4ZjE5RzgvT0o2M1JNbC96bUxrZDRzUDFKcW52bG4rcE9Gcyt4L1o5a1Q1QTE5NWRUUjk5ZGgyZXhnQW1OZXZISnBJWDU2N1ppUjhQZHYrUmhZa1V3c0ZTZGlXYmY4ejJ6NVgvc0NMRjRiU0g1M2FtcDU2YTV1OURRQjBpZXVNeEttOXBiTnBPdjR3Mjc2UWJaZXpJRW45QkVrWXlyYXZaTnMvclByZ3lTc0Q2ZHZ2YkVrdnZEZVUzcnc4bU42ZHJLZkwxK3ZwdXVVbUFMRHBEZFpTMmpiWVNMZU1OUEo3MDhUbDREKzU5Mm82MEgzUnM2SllFdkxsYkd1VnlpS0NwT052dGNOa2o5MFBBQ3pTbVJRTFdGUDZhdGVqcFNDcDkvR05ZcUhyZmRuMkgxUGg0bWtBQVBPWWFyZkRmWE5pcEVLOXoyOGFkZk5yMlhZNDIzNHoyMDdZendCQWhSUHRWampjYm9jei9YeFJQNGRzZW9YTVI3THRNOW4yYUxZZHliYUQyYllqdGRhZUFBQ2JXNndGdVpSYVYzdC9KZHQra0cxL2ttM2ZUNjM3NU0ydmRNam0vd3N3QU9GSGNLWUdCSytCQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+i1oOmAgS/otaDpgIHlpb3lj4vph5HluIEucG5nXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDd0FBQUF0Q0FZQUFBRFYySW1rQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wTkRrNFFUVXdNek5HTmpBeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBORGs0UVRVd05ETkdOakF4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qUTBPVGhCTlRBeE0wWTJNREV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pRME9UaEJOVEF5TTBZMk1ERXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrL0lLVHBnQUFCb0pKUkVGVWVOckVtWHRzVTNVVXgzLzMwZmZhdmJxeHdTQ2JHeE1aYklGRkJCSWxFalVhWWxCak5CZzBFUklqSmlyR1lLSUd3Y1FIRXY4VUVKTzVoSWNtalBnSEFpWnVTRlJnd0Fib2ROQXRheG12UFRxMmRXM1g5NzNYYzlyZmNGdDcyM3ZiYnB6a205N2MzdC85ZmU2NTU1emY0ekpMdGg4Z0daZ1d0QXIwT0tnV1ZBMHFCZVhRLzcyZ2ZsQTNxQU4wR3RRS0NrM2NvT3JRWmxVZDhtbUNMZ085Q1hvUlZKRGt1Z0txR3REem9CMmdVVkFUNkZ2UUZiVWRzeXF2cndPZEFGMEN2WkVDVnM3eWFWdTh4OG1lalExMWFob3pDa05DRC9vQzlIWUdiMFhPSXFCdlFCOUNlQVN5NGVFcVFxVHo4UHZlRE1CT2hPVlc3QU84WFpVUk1DTUtLK0JHa0NSTUhabHh3ejZrQy9aWHZsdVpGakRBcnBSWTlqYzRzcEpaTTZZQStteEpCcDBRbUJFaUM2SGh6M0JrSXJOdWpBbjd0bS9ZdjFBUk1POGJOVWdzZDNSMlBSc0hiVVdHM2hlK05xUUVGblRtcndqRDFDYTZUYVhWUkE2L1ZrOHViVnREZGoyN21CaTFuR3FVSEIxUGRxK3ZJUmZmZjR3Y2ZIVTVxU2cweWpBenRjQ3lLMmxaNDRMZWVrR1hjejVSTmFncU1wSHZOeXdqK1ViTnZYT1hiNCtSTFVmK0pyNlFvQmgyLzh0MXBIYXU1ZDY1NGZFUWVmMkhLK1Q2c0M5aHlRT21SeXFhM3IwYzUyR29nWXpJNjcrVUsxMmZyWHRvQ2l6YThySmNzdStsT2tXZVRnU0xWbWpTa2srZldTUmI4aWdURXdjTThiSkM0dmduNUZwV0ZDUitkUlBRcGlUUWNyQ1RRMDNPZ09sSlpKc0NIUFd1UnYvTzVDZVpibWNjdzdJM1JlaTlNdENwWU5GKzc3bWJmRGlZeE1ZVnI4RTVDV1B4bGRic2gwRFh5YlU2NnhnaHkrZm5rVktMUHVIL2VCNy9iN1k1U1ZpUUZNTzIzM1NSRDQ1ZEpSRlJrdmN5eTVjRDJ4N0RZRmN3Nm1Idmd2cEg0WVE1MldPT1EySzlCUW1HaWFiRTAwcGh0elIxa0VBNFJkSUNXNVFSUGJ6NjFuRjJkTW02TGFMR3NESlY0cURuMElOS1BMMSthVWwyWVA4ZmVaMTUxMzV0Umc5ckpFNVRxN1NPS3ZWME5tRmp5UmRsMUNDd1R1UzBGV3FLdnhMb2JNS2lVVVlkRzEzbXNGeWgybzdUZ1U0WE5sYlBvb3hhQk9ZbGhqV21NK0tyZ2M0SUZrTWl4c2dqTUVjeU1JWmg0QzVNYWdmQk5SeERNaldPamZZcENmNTBXaXNwWFVvR0YwV09pVEV5MFRyTVJFSmpNd21iRGVnSlJqWmFNVUsrdnBtR3pSU2FNa29JTEhCK2x6MmJzSmhnU2tkRXhjQXhSZ0dCSS9vaGUzczJZYkVhcUJuR0ZlMHozTFhqUGtZRWdVTjV0cFoyUm96NHN3V0xwVXZ0M0NQNXNCd0o1RjFyUnFlR0VEakkrMFpHdEs2K3RtU05kano5b09yaFZpbjB4MDlWSjkvQWMvVmRoTFVtem0ranM3VXd5RzJ4bnptZXJOSGFhbXRhZzRJUzZMWFZSVW1Celk2enlPWkdWclpuWTRPSU04emNybE50R28vem1sd2oyNkEzN1JFc0ZYU1gweXZiRnBrZ1pOdm9UcWc0c1VRYUJ6bnpPMzg1UkNSSlROVHdrNU8yNklJeDNlRldEdHJwRFpMdEoyVDhCQ3o1blNjUDRtV1VNYmJpS09nNGhwQ01idVNHNEM5WlZCYkpzY2JOM2taOVlmS0hmWmdzbW1PR0pPRkpTOWNRMlFZckJUVnpnNG41ZEZtZWdSU2JkZVRxZ0lkcy9lbGZjbk0wY2I0Ym5OMm5pOXAvUEFLSDEwR2VLY3Q4V05maGpQd0J3WkQ3OE0xMU96OFg5Slo1NUQ0YUYzRDNMVGl4OHlQT1A0Ymg0QUFGcG0ra0JFRURjSUdqdUxWeEx3eUY0L2R0M3dmNkJvWTl5SUpNbEczcU1oK1NUNkp1N3pYZDZmZ0xYc1UrV0phRVpoMFcrc1Mra1FGWktOTzlGU3BkTmNkc3BIYTlDUEdNWlU2RWVBN3lmdGVBcjNSeEhVeWVOYk1DSzRSOFJXMkg5MXA2L2p5SHhZUEV2bzhFcDI4bVR6ZU1sVHRZVWFBaEN3WGJON2hxMHlhSTdia3pHclArc2I0NXJZMk54cjUvMExQZGxDRnVSMzZLaDZtWENmVXlwbTRFNm1BWUJwWE9ZR0c1S1dLeXpvL08yTE5wVUxvTWc3WXo4NXAzTitoY3QyM1VzemRvR1pOU0FrK0R4aDI2QUN1RUpZdmpuRVByN3U4SjVaY1ZDTHFjckd6RmF0MEROZ2lCQTlZclIwOUJINzBVOXBZY2JOenVaZHlPNWFITjZFMHNkd2hZRGlvRDVYdkxWMVM1cXRldUJxOHZoZVczVVYyY2h2MjY0ZDZPM083VDU4eTlGM3BJN0RQWWJacGdkMmtZeUc0REtmcUtCT0NZZExnelZBTEMrbHdNc29nYXZjbFRzYXJTVjFwVEdUWVhsUXI2M0NJNFo1RllYa3RuV1NFMkhIQnpnYkVoaldlbzM5amZhVGRmYjdYRHVYRTZOM0RTV0IyZzFTQ2M4b0dWZmdtbDNzYTlOd3YxT001WWNPbWRROStDaG9xYnRLbUluaElvU0poNkQrY0VPUE1hb2g1MTAwb2dLWHBEejFXb3JsZ01pWDJ5TlZLdlcrZ3ZnaHNtUVpOSnNINEs2cUdBSHBvZklhV2d5Y3BheXJ5bUhrR05VVUFkZlFoZXhzTVJDaGVrRHlDbW02ai9DVEFBQTFraEFQTkJSZmtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+i1oOmAgS/lhbPpl60ucG5nXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFpUUFBQUw0Q0FZQUFBQkxEK3drQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xTlVSRk5qRkdOek5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFOVVJGTmpGR09ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVTFSRVUyTVVZMU0wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pVMVJFVTJNVVkyTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgreEJWRzZ3QUFEejVKUkVGVWVOcnMzVTlzVlZVZXdQSEQ2MnRMclhWYUNwcGFhbVJxSkNYT3dpQnVSOTFOWW5SaG9qSGp5aUhCLzJ0ampCdmR1RllUSFlrclozU1NXVTB5MjhHWnBVakdoWUtZSUNiUWFZWi9WYUNVdnJZUHo2Kzg0dTNsU2wrbEx5YjQrU1MvQmVlKzlpWG5iYjY1dlp5MzRmMkRsOUxQVU11eks4K0RlZTdMYzNlZTBUejllWG9UQUhDam04c3prMmN5ejlkNVBzdXpMOC8rUE0zVmZuajN4TXAvMTlmNDVsdnpQSi9uajNuR2ZCWUE4S3ZWMjVwTmVYNlg1N0hXK3JFOGY4bnpUcDdqN2Y2eVdwdXZHMjc5NGlONVhoWWpBTUJQR0d1MXdwRldPd3l2VjVBOG51ZXJQTS9sNmJIUEFFQWJlbHJ0RUEzeHhHb3ZycTl5N2EwOHoxUmRuSjFycFArZG1rN1Q1MmJTek94Y3VqZzNueGFhemRSc05uMEVBSENEcTlWcXFaNW5ZMjkzNnUvclRVTUQvZW4yelVPcHIvZXFleGViODN5YzU0RThMK1paV0V1UTNKVG5iM2tlTGwvNExnZklzUk5uMHJkVEozMGFBUEFyRlRjZ0dqRUxDK25zekd5YU92VmRPbmgwTXQwNXNpV04zYm9wRFE3MGwzOGtibkRFczZoeHQrUkNPMEVTYXg5VnhVaTgwWkhKLy9zVUFJQktjY01pWm56MHRyUmoyMmo1OHNPdHhvZ0hZRmZjS2FsNmh1VHRQSThVRjg2Y1BaLys4L2xYWWdRQWFFczB3Ny8vZTJpcElVb2VhYlZHdWxhUXhHMlVQY1dGazlObjA2Y0hqNlR2ejErd3V3QkEyK0pQT2RFUTBSSWxlL1llU2svK1ZKQU1sNHZsOVBmbjA0SERSOVA4d3FKZEJRRFdMQm9pV2lLYW91VHRIQ1ZicW9Ma2pYVDVTZGdydnZqbW1CZ0JBSzQ3U3FJcFN1SkF0ZGZMUVhKSG5qOFZYeFVQc01hdEZnQ0E2eFZOOGVYUnF3NXVmWHJ2b2FVR3VSSWt6K2JwWHI0YVo0dDRnQlVBV0UvZlRKNVlhb3lDN2xhRExBVkp6RlBGcThkUG5MRnJBTUM2cTJpTXAvWWVTclhsYiszZHVyeDY0V0xEb1djQVFFZEVZMFJyRkVTRDdJb2dlYWk0T25WNjJtNEJBQjFUMFJvUFJwRHNMSzZVL3JZREFMQ3VLbHJqdmdpUzdjV1YrS0k4QUlCT3FXaU43UkVrSThXVmk0MTVPd1VBZEV4RmE0eEVrQXdVVnhZV0hZUUdBSFJPUldzTVJKRDBGRmVhelV0MkNnRG9tSXJXNktuWkZnRGdseVpJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBSUVnQUFFRUNBQ0JJQUFCQkFnQWdTQUFBUVFJQUlFZ0FBRUVDQUNCSUFBQkJBZ0FnU0FBQVFRSUFJRWdBQUVFQ0FDQklBQUJCQWdBZ1NBQUFRUUlBRUVIU1dMRlEyMkJYQUlET3hjZlZyZEdJSURsWFhLbDNkZGtwQUtCaktscmpYQVRKVkhGbFkwKzNuUUlBT3FhaU5hWWlTQTRYVi9yN2V1MFVBTkF4RmExeE9JTGtRSEZsYUtEZlRnRUFIVlBSR3A5RmtPd3Jyb3dNRDlrcEFLQmpLbHBqWHdUSnAzbU9MNi9jdExFbjNUbXl4VzRCQU9zdUdpTmFveUFhWkg4RVNUUFBoOFVyWTdkdXNtTUF3THFyYUl3UGQwK2s1dkxCYU8ra3dua2tnd1A5YVh6ME5yc0dBS3liYUl2QmxjK1BORm9OY3VXazFyaGRzcmY0aWgzYlJ0TXQvWDEyRHdDNGJ0RVUwUllsSCt5ZXVQellTUEhvK05meW5DNis2cDdmanFYdXVvUFNBSUNmTDFvaW1xSWttdVBWNVgvVVNoZGVLTDV5K0RjM3A1M2J0NlY2bDYrOEFRRFdMazVsalphSXBpaDVhZmZFanpkQ3lxWHhjWjczaWd0YmhtNUo5Kys0eTU5dkFJQTFpWGE0ZjhmNFVrdVUvRG5IeUYrTEMxVzNQbDdLODQvaVFsVE43KytkOEtBckFOQ1dhSVpvaDRvN0k5RVlMNVlYNnhXL0k1NTRmVExQMy9QOG9YZ2hIa2E1ZmZOZ09uYmlUUHAyNnFUZEJnQldpSE5HNHIvMkRsYWYvUDdQVm1NMDJnbVNjQ0hQbzNuZXlyT25lQ0hlWVBtL0JVK2RuazdUNTJiU3pPeGNtcDJiVDR1TGk2bDU2WkpQQXdCdWNMVU5HMUpYVjFmcTYrMWUrbTZhT0E0K1RtQXRIWHBXRkkrRXhKMlIrYXFMOVd1OFYvekFNM2srYVlYSjV1TEZlRU4vd2dFQVZuRXFYWDRjNUtOckJrNGJ2eWdlZEozSTgyNnF1TVVDQUZDaDBXcUhpZFZpcE4wZ1dhNmJaL09NNTNreno2UjlCZ0FxVExaYVlielZEcWZhK2FINkd0OGtUbE43T2M4cmVYYmxlU2pQemp4MzU5bWFKeDZsN2ZaWkFNQU5MeDd0T045cWc2L3pITWp6cnp6NzArWHZ5VnVUSHdRWUFOc0ZZTVdhOTlNckFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5bqVLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ3dBQUFBdENBWUFBQURWMklta0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk4wSXlNRVk0TUROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTjBJeU1FWTRNVE5HTlVVeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalkzUWpJd1JqZEZNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWTNRakl3UmpkR00wWTFSVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K281Q3JtUUFBQnAxSlJFRlVlTnJFbVd0c0ZGVVV4Ky9NN081MGQ5dWwzVDYzdE5BbkZiQ3R0aWxCRFRFU1VlRURRYTBmL0dCNHhPY1hSZmxpMUdDaU1lb1gvQ0t2UkZSUUU2T1FFSkdLRDBBVFJHaExnQUtoTGZURmxtNjdwVnU3NzUzZG1mR2MzVnR0NmM3dXpPNjIzdVNmVG5mbjN2dWJzK2VlYys4Wm5hWDFmWkpHTTRBZUFEMENhZ0F0QTlsQTJmUjdMOGdCNmdWMWdVNkQvZ0lKMHdPc3ZmQ2VwZ2wxS1lMZUQzb1oxQXF5SnJqUFNyVVM5Q1RvWGRBazZIdlFQdEJGclJPekd1OXZCQjBIWFFDOW1BUldxZVhSdmpoRzI2bm1uWTN6QVp3RjJnWHFCRzBBTVNUOWhtT3N4ekVCK2hOUVZxYUFhMERuUUsrbjRVTEozSEk3emdIUU5Xa0JNN0swaWk2U1JqTC9EZWM0ZjdycG5kVXBBUVBzYXBsaFQ4RmxBVm00Wm9VNWYwc0VIUmVZbGNWYTZIZ01MczFrNFpzWjUvNjk2ZTFhVmNDODREWkNoOE1MYk5tN1d3RXkvRm0vM1pnMERvZjE1bzlsd2pURUc2VzBLSjlzZTNvOVdXb3JKaDFYZThqQm83K1FrQ0JvSWpGbThXVHpwc2ZJZmZmVUVQdW9rM3grNUFSeGpFL011UThaZ09VanVIeHQ1dWNjdjJMdHYvL29JLzVta2VQM3g3UDg0dUlDOHVZTHo1S1NBaXRoV1phVWx4U1N1b295MG42bGg0aWlxQnAyeDlablNQMnlLcUxqT0dKZFpDRXQ5WFhrY25jLzhmb0RjNkVadG5tNHFPWDQwckd6amprdUFTbVNBZGdQbFVMWDg2MGJTSTdaTk91eldnRGVzYVdWOEFhRGF0anE4dEpabjF1eXpXVHJVMDhvaGp6S3hNd0JCbjlaSlRIY28wbzliWVh4azlvMGRCWnYwQXc3MDlXVUdqQ3RRN1pad05TNnJ5YktZRjA5QTRxREl2UWJtK05ESjRQRmRybTdMMkU2bU1rVzgyR0dXQ1l0VmVDN0RLL1U2OHFOZ2FqUDV1ZGE0bjZQbitQM3VCZ2oxS2ZWd1BZTTJNbStiNDhSVVpJVTc1Rlpyb0l3ek80OHoxQW9hbUZuN3ZJMXNDcHpFajFtTUNTUVhRY1BreHVEdzZvc3JSWjIxNWVIaVJBT0ovUi9aRVBHcUlYWEI4NndRN1kxcjREWlZ5ZGJPR2c1dEtBYVN6L1VkRzlHWVAvelhjbTVaT3pjcjJoaHZjVG9HdFRHVWJXV3ppUnNiUEZGR2ZVSXpFdXNybEpMOEZjRG5VbllLSENNa1VkZ0E0U09mSzBUcHdLZEtpd05iOGhvWUtPSmdtRk1xU1I4TGREcHdNYUNXNVJSaDhCY1dzY0doaUVzbC93Y3dPSjliTm9IbGVoTURPeDlBNm4wVmhPNjFDUVhWWWFKTVRKUjA3QlNlR28rWVRNQlBjMkl3TEkrRWh5WmI5aDBvU21qak1DaUllenB5eVFzTGpDMUdWRjF4U2JHS0NKd1pKRnZ1RE9Uc0JnTnRLUnhOUTBZc1k0UlFXQ2h6SG0rRTg1eGdVekJZdWpTdXZkSTZMK3lHQ3dIUm1SRjRGQ1c0SGFaQStNZGlUcHQyZlM0NW5TckZ2cTVqZXNTbjBvRDQrMXcxc1J6VkhTM2hqTzRiUk9YZmt6VXFXbEZiVXBKUVExMG9yR3hsVXhjUmpZM3NyS25tbmZpUnRSYjVtenZNSVltcnl0MXV1VndwcHpCa2tIYkZjYU91aUl3Z1R0MDBFcW9OSjJpZkxndFhqcDY1bXVHeUhGMzBnZU90QkczMTVkeXVsV0MvdHZ0Slo4ZCtVbWgrQ1pMd1BRVnNsSEcySW1qMHZFSFFqSTUvbEZ4TXFleUxNam56dG05ZVh3Qk9DYjFreVZ3eE1kRmN1RmFMOWtMSndVdGU0UHAvWFNSTlpma1dyTEowTWdZK2ZTYm8yUnNZakx1L2JtZVc2ZVgyVTk4QjVkNFB2TkVIMks2b0Ezbk9xd2VWZ242N0piMjVTOTlJT2pOaS8vSFFnckVYZC9JcXV2NzN6S0V2ZWdPL2ZnajNWMzVDWUZHNFliKzVVTS83T0drc08vL2dzVzVnV0Uzc2lBVFpadDl6SWZGSjFPekQrWlAzYmhVYS85NUwydzRoSVdHeFRseGJtUkFGc29reDYzOERKUStMSUUvbzFOS09YNUhpQTk3UmwyVzZrYVpZZlVMQWN0S0VYK2R2VzFQNloyTFozRk5rOWo3a1ZEQzJocjFsZHU0MzRDT0xDOTQvTmNyTm00RDN5NmRYNS8xam9BYmZKRS9kUk10MjBzWmduUGNaYWFGcVpVSnRUS202b2dwNUFwRFVybm1NWmVhUTN4dU9XNmZNK29DRUxyeVBJTm5tbm9QSGNnT09MdXBaWWRvR0pPVEF0OEY3Y2VuNUtTSWJKdm82amNINzl6MEdvdXRZWjBwSTZWWVUzQ2l1KzVXMjZHYTJ5ZFB3aHlERk5hdUJEc3JyTVZyV01JaXNSY3lDRmdCS2dQbGpWbFgxdHd1YkhuUWJTcXRoOU9zU2FPZkJpeitrYTdGNDUxbmkxMVhiNUxZYTdCaHVzRHVVRGVRRlg4Uk5TOFdBUndYSFZhR1NyRHlDaXJDd3FQSUdjeWoxb1pxbDZXcU9zQmJiU0Y5ZHFISUdpd3l5MFczWDR3a0Nwd2t1UG13ZDl3WWNqbXM3djYrRWxkWEh5Y0tQcm8zY0ZKZkhhWFJJR2tXWXRTK0NhWFd4dHFiaFZxOEVBczlKUGJXRTM4RlBSVTNvNmlJbGhJcFNKaGFEL2NFdVBNYXB4WjEwMGdncS9MNVRaVjY3ZXNrOXNyV1JLMXVvWDhSM0RnRG1zeUFEVkJRRHdYMDBQVWhxQVZORk5hU05abGFCRFZGQVhuNkVEb0ZDMGNvWElnK2dKVHFRdjFIZ0FFQVJEQW13YU5ZSVE0QUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWz6ZetLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9iZXRJbmZvLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxiZXRJbmZvLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi1lMmE0YWM2ZS9iZXRJbmZvLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYmV0SW5mby52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9iZXRJbmZvLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcclxcbmRpdi5iZXQtaW5mbyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQge1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JldEluZm8udnVlPzc2NjFlMmExXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7Q0FDQTs7QUFFQTtJQUNBLGFBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiYmV0SW5mby52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCIpXFxyXFxuXFx0XFx0ZGl2LnJlY29yZCh2LWZvcj1cXFwiaXRlbSBpbiBiZXRSZWNvcmRcXFwiKVxcclxcblxcdFxcdFxcdHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXRcXFwiKVxcclxcblxcdFxcdFxcdHAuZGV0YWlsXFxyXFxuXFx0XFx0XFx0XFx0c3BhbiDnjqnms5XvvJpcXHJcXG5cXHRcXHRcXHRcXHRzcGFuKHYtaHRtbD1cXFwiaXRlbS5wbGF5bGF3XFxcIilcXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOS4i+azqOmHkemine+8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLmJldG1vbmV5XFxcIilcXHJcXG5cXHRcXHRcXHRcXHRzcGFuIOWAjeaVsO+8mlxcclxcblxcdFxcdFxcdFxcdHNwYW4odi1odG1sPVxcXCJpdGVtLm11bHRpcGxlXFxcIilcXHJcXG5cXHRcXHRcXHRwLmJvbnVzLW51bVxcclxcblxcdFxcdFxcdFxcdHNwYW4g5pWw5a2X77yaXFxyXFxuXFx0XFx0XFx0XFx0c3Bhbih2LWh0bWw9XFxcIml0ZW0ubnVtXFxcIilcXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICByZWFkeSgpIHt9LFxcclxcbiAgICAgICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcXHJcXG4gICAgICAgIGRhdGEoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgYmV0UmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JldFJlY29yZCcpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAgICAgY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvYmV0SW5mby52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcblx0ZGl2LmJldC1pbmZvKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuXHRcdGRpdi5yZWNvcmQodi1mb3I9XCJpdGVtIGluIGJldFJlY29yZFwiKVxyXG5cdFx0XHRwLmNyZWF0ZWQtdGltZSh2LWh0bWw9XCJpdGVtLmNyZWF0ZWRBdFwiKVxyXG5cdFx0XHRwLmRldGFpbFxyXG5cdFx0XHRcdHNwYW4g546p5rOV77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLnBsYXlsYXdcIilcclxuXHRcdFx0XHRzcGFuIOS4i+azqOmHkemine+8mlxyXG5cdFx0XHRcdHNwYW4odi1odG1sPVwiaXRlbS5iZXRtb25leVwiKVxyXG5cdFx0XHRcdHNwYW4g5YCN5pWw77yaXHJcblx0XHRcdFx0c3Bhbih2LWh0bWw9XCJpdGVtLm11bHRpcGxlXCIpXHJcblx0XHRcdHAuYm9udXMtbnVtXHJcblx0XHRcdFx0c3BhbiDmlbDlrZfvvJpcclxuXHRcdFx0XHRzcGFuKHYtaHRtbD1cIml0ZW0ubnVtXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge30sXHJcbiAgICAgICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcclxuICAgICAgICBkYXRhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmV0UmVjb3JkOiByZXF1aXJlKCcuLi8uLi9kYXRhL2JldFJlY29yZCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmJldC1pbmZvIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIG92ZXJmbG93OiBhdXRvO1xyXG4gICAgcGFkZGluZzogMTBweDtcclxufVxyXG5cclxuZGl2LnJlY29yZCB7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYmV0SW5mby52dWU/NzY2MWUyYTFcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gW3tcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBwbGF5bGF3OiAn5Y2V5Y+MJyxcclxuICAgICAgICBiZXRtb25leTogMTAwMCxcclxuICAgICAgICBtdWx0aXBsZTogNSxcclxuICAgICAgICBudW06IDNcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvYmV0UmVjb3JkLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJldC1pbmZvXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcInJlY29yZFxcXCIgdi1mb3I9XFxcIml0ZW0gaW4gYmV0UmVjb3JkXFxcIj48cCBjbGFzcz1cXFwiY3JlYXRlZC10aW1lXFxcIiB2LWh0bWw9XFxcIml0ZW0uY3JlYXRlZEF0XFxcIj48L3A+PHAgY2xhc3M9XFxcImRldGFpbFxcXCI+PHNwYW4+546p5rOV77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5wbGF5bGF3XFxcIj48L3NwYW4+PHNwYW4+5LiL5rOo6YeR6aKd77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5iZXRtb25leVxcXCI+PC9zcGFuPjxzcGFuPuWAjeaVsO+8mjwvc3Bhbj48c3BhbiB2LWh0bWw9XFxcIml0ZW0ubXVsdGlwbGVcXFwiPjwvc3Bhbj48L3A+PHAgY2xhc3M9XFxcImJvbnVzLW51bVxcXCI+PHNwYW4+5pWw5a2X77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwiaXRlbS5udW1cXFwiPjwvc3Bhbj48L3A+PC9kaXY+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9iZXRJbmZvLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ib251c1JlY29yZC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXGJvbnVzUmVjb3JkLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNjkyY2QwYmEvYm9udXNSZWNvcmQudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vYm9udXNSZWNvcmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL2JvbnVzUmVjb3JkLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuYmV0LWluZm8ge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAyZW07XFxyXFxufVxcclxcblxcclxcbmRpdi5yZWNvcmQgcCB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IC41ZW07XFxyXFxuICAgIG1hcmdpbi10b3A6IC41ZW07XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZT9jNzY1ZjAxOFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0E7SUFDQSxtQkFBQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0NBQ0E7O0FBRUE7SUFDQSxhQUFBO0lBQ0EsbUJBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0lBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiYm9udXNSZWNvcmQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICBkaXYuYmV0LWluZm8odi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIGRpdi5yZWNvcmQodi1mb3I9XFxcIml0ZW0gaW4gYm9udXNSZWNvcmRcXFwiKVxcclxcbiAgICAgICAgICAgIHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cXFwiaXRlbS5jcmVhdGVkQXQgfCBkYXRldGltZVxcXCIpXFxyXFxuICAgICAgICAgICAgcC5ib251cy1udW1cXHJcXG4gICAgICAgICAgICAgICAgc3BhbiDlvIDlpZblj7fnoIHvvJpcXHJcXG4gICAgICAgICAgICAgICAgc3Bhbih2LWh0bWw9XFxcImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5pbXBvcnQgUmVxdWVzdExpc3QgZnJvbSAnLi4vLi4vanMvcmVxdWVzdC1saXN0J1xcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuICAgICAgICBSZXF1ZXN0TGlzdC5nZXRCb251c1JlY29yZCgpLnRoZW4ocmVzID0+IHRoaXMuYm9udXNSZWNvcmQgPSByZXMuZGF0YSlcXHJcXG4gICAgfSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4uLy4uL2RhdGEvYm91bnNSZWNvcmQnKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICBsb3R0ZXJ5bnVtKG51bXMpIHtcXHJcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG51bXMpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xcclxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+iOt+WPluS4reWllue7k+aenOWHuumUmScpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIC8vIOS4reWlluaVsOWtl+aAu+WFseWNgeS9jeaVsO+8jOWPluesrOS4gOS9jeWSjOacgOWQjuS4gOS9jeebuOWKoOe7k+aenOeahOS4quS9jeaVsOS9nOS4uuW8gOWllue7k+aenFxcclxcbiAgICAgICAgICAgIG51bXMgPSBudW1zLnNwbGl0KCcsJylcXHJcXG4gICAgICAgICAgICByZXR1cm4gKG51bXNbMF0gKyBudW1zW251bXMubGVuZ3RoIC0gMV0pICUgMTBcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ1OCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmJldC1pbmZvIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogYXV0bztcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LnJlY29yZCB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYucmVjb3JkIHAge1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xcclxcbiAgICBtYXJnaW4tdG9wOiAuNWVtO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ib251c1JlY29yZC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcbiAgICBkaXYuYmV0LWluZm8odi1iaW5kOnN0eWxlPVwiY29udGVudFwiKVxyXG4gICAgICAgIGRpdi5yZWNvcmQodi1mb3I9XCJpdGVtIGluIGJvbnVzUmVjb3JkXCIpXHJcbiAgICAgICAgICAgIHAuY3JlYXRlZC10aW1lKHYtaHRtbD1cIml0ZW0uY3JlYXRlZEF0IHwgZGF0ZXRpbWVcIilcclxuICAgICAgICAgICAgcC5ib251cy1udW1cclxuICAgICAgICAgICAgICAgIHNwYW4g5byA5aWW5Y+356CB77yaXHJcbiAgICAgICAgICAgICAgICBzcGFuKHYtaHRtbD1cImxvdHRlcnludW0oaXRlbS5sb3R0ZXJ5bnVtcylcIilcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IFJlcXVlc3RMaXN0IGZyb20gJy4uLy4uL2pzL3JlcXVlc3QtbGlzdCdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnXSxcclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgIFJlcXVlc3RMaXN0LmdldEJvbnVzUmVjb3JkKCkudGhlbihyZXMgPT4gdGhpcy5ib251c1JlY29yZCA9IHJlcy5kYXRhKVxyXG4gICAgfSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm9udXNSZWNvcmQ6IHJlcXVpcmUoJy4uLy4uL2RhdGEvYm91bnNSZWNvcmQnKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgbG90dGVyeW51bShudW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobnVtcykgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+iOt+WPluS4reWllue7k+aenOWHuumUmScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5Lit5aWW5pWw5a2X5oC75YWx5Y2B5L2N5pWw77yM5Y+W56ys5LiA5L2N5ZKM5pyA5ZCO5LiA5L2N55u45Yqg57uT5p6c55qE5Liq5L2N5pWw5L2c5Li65byA5aWW57uT5p6cXHJcbiAgICAgICAgICAgIG51bXMgPSBudW1zLnNwbGl0KCcsJylcclxuICAgICAgICAgICAgcmV0dXJuIChudW1zWzBdICsgbnVtc1tudW1zLmxlbmd0aCAtIDFdKSAlIDEwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5iZXQtaW5mbyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuXHJcbmRpdi5yZWNvcmQge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMmVtO1xyXG59XHJcblxyXG5kaXYucmVjb3JkIHAge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogLjVlbTtcclxuICAgIG1hcmdpbi10b3A6IC41ZW07XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogYm9udXNSZWNvcmQudnVlP2M3NjVmMDE4XG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH0sIHtcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcclxuICAgICAgICBsb3R0ZXJ5bnVtczogJzAxLDAzJ1xyXG4gICAgfSwge1xyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpLFxyXG4gICAgICAgIGxvdHRlcnludW1zOiAnMDEsMDMnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCksXHJcbiAgICAgICAgbG90dGVyeW51bXM6ICcwMSwwMydcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvYm91bnNSZWNvcmQuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiYmV0LWluZm9cXFwiIHYtYmluZDpzdHlsZT1cXFwiY29udGVudFxcXCI+PGRpdiBjbGFzcz1cXFwicmVjb3JkXFxcIiB2LWZvcj1cXFwiaXRlbSBpbiBib251c1JlY29yZFxcXCI+PHAgY2xhc3M9XFxcImNyZWF0ZWQtdGltZVxcXCIgdi1odG1sPVxcXCJpdGVtLmNyZWF0ZWRBdCB8IGRhdGV0aW1lXFxcIj48L3A+PHAgY2xhc3M9XFxcImJvbnVzLW51bVxcXCI+PHNwYW4+5byA5aWW5Y+356CB77yaPC9zcGFuPjxzcGFuIHYtaHRtbD1cXFwibG90dGVyeW51bShpdGVtLmxvdHRlcnludW1zKVxcXCI+PC9zcGFuPjwvcD48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L2JvbnVzUmVjb3JkLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGNoYW5nZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXEV4Y2hhbmdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtZjM2N2E4NmUvRXhjaGFuZ2UudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhjaGFuZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4Y2hhbmdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYuZXhjaGFuZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5leGNoYW5nZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLm1vbmV5LWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQgZGl2IHtcXHJcXG4gICAgZmxvYXQ6IGxlZnQ7XFxyXFxufVxcclxcblxcclxcbmRpdi5ib251cy1tb25leSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4uYmFja2dyb3VuZC1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBhZGRpbmc6IDElO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogNTAlO1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9FeGNoYW5nZS52dWU/NGQ3MDUwMThcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5RkE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7Q0FDQTs7QUFFQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0lBQ0EsV0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJFeGNoYW5nZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xcclxcbiAgICBkaXYuZXhjaGFuZ2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIC8vLSBpbWcuYmFja2dyb3VuZC1pbWcodi1iaW5kOnNyYz1cXFwiYmFja2dyb3VuZEltZ1xcXCIpXFxyXFxuICAgICAgICBkaXYuYmFja2dyb3VuZC1pbWdcXHJcXG4gICAgICAgICAgICBkaXYodi1mb3I9XFxcIml0ZW0gaW4gbW9uZXlEYXRhXFxcIix2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5YmxvY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBpbWcodi1iaW5kOnNyYz1cXFwibW9uZXlCYWNrXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJhcmNvbnRlbnQodi1iaW5kOnN0eWxlPVxcXCJiYXJjb250ZW50XFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5tb25leS1pbWcodi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIsdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVxcXCJib251c01vbmV5XFxcIix2LWh0bWw9XFxcIml0ZW0uZ29vZG5hbWVcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLmV4Y2hhbmdlKHYtYmluZDpzcmM9XFxcImRvZXhjaGFuZ2VcXFwiLHYtYmluZDpzdHlsZT1cXFwiZXhjaGFuZ2VCdG5cXFwiKVxcclxcbiAgICAgICAgICAgIGRpdi5jaGFuZ2UtYnV0dG9uKHYtYmluZDpzdHlsZT1cXFwiYnV0dG9uQmFyXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgZGl2LmJvbnVzLWJ1dHRvblxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLmJvbnVzLWJ1dHRvbih2LWJpbmQ6c3JjPVxcXCJib251c0J1dHRvblxcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGRpdi5wcml6ZS1idXR0b25cXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5wcml6ZS1idXR0b24odi1iaW5kOnNyYz1cXFwicHJpemVCdXR0b25cXFwiKVxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIHJlYWR5KCkge1xcclxcblxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9tb25leS1kYXRhLmpzJyksXFxyXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WGheW6lS5wbmcnKSxcXHJcXG4gICAgICAgICAgICAgICAgbW9uZXlCYWNrOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lnZcucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIGJvbnVzQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIHByaXplQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZblk4EucG5nJyksXFxyXFxuICAgICAgICAgICAgICAgIGRvZXhjaGFuZ2U6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WFkeaNoi5wbmcnKSxcXHJcXG4gICAgICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogOTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNyAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgbW9uZXlibG9jaygpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NzggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBidXR0b25CYXIoKSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYmFyY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYm9udXNNb25leSgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDM1ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBtb25leUltZygpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGV4Y2hhbmdlQnRuKCkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDkwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgzNjQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIG1ldGhvZHM6IHtcXHJcXG5cXHJcXG4gICAgICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbmRpdi5leGNoYW5nZSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG59XFxyXFxuXFxyXFxuaW1nLmV4Y2hhbmdlIHtcXHJcXG4gICAgei1pbmRleDogMztcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhcmNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcubW9uZXktaW1nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCBkaXYge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLW1vbmV5IHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xyXG4gICAgZGl2LmV4Y2hhbmdlKHYtYmluZDpzdHlsZT1cImNvbnRlbnRcIilcclxuICAgICAgICAvLy0gaW1nLmJhY2tncm91bmQtaW1nKHYtYmluZDpzcmM9XCJiYWNrZ3JvdW5kSW1nXCIpXHJcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXHJcbiAgICAgICAgICAgIGRpdih2LWZvcj1cIml0ZW0gaW4gbW9uZXlEYXRhXCIsdi1iaW5kOnN0eWxlPVwibW9uZXlibG9ja1wiKVxyXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJtb25leUJhY2tcIilcclxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cImJhcmNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cIm1vbmV5SW1nXCIsdi1iaW5kOnNyYz1cIml0ZW0uZ29vZHNpbWdcIilcclxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVwiYm9udXNNb25leVwiLHYtaHRtbD1cIml0ZW0uZ29vZG5hbWVcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcuZXhjaGFuZ2Uodi1iaW5kOnNyYz1cImRvZXhjaGFuZ2VcIix2LWJpbmQ6c3R5bGU9XCJleGNoYW5nZUJ0blwiKVxyXG4gICAgICAgICAgICBkaXYuY2hhbmdlLWJ1dHRvbih2LWJpbmQ6c3R5bGU9XCJidXR0b25CYXJcIilcclxuICAgICAgICAgICAgICAgIGRpdi5ib251cy1idXR0b25cclxuICAgICAgICAgICAgICAgICAgICBpbWcuYm9udXMtYnV0dG9uKHYtYmluZDpzcmM9XCJib251c0J1dHRvblwiKVxyXG4gICAgICAgICAgICAgICAgZGl2LnByaXplLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5wcml6ZS1idXR0b24odi1iaW5kOnNyYz1cInByaXplQnV0dG9uXCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHJlYWR5KCkge1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9tb25leS1kYXRhLmpzJyksXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1nOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lhoXlupUucG5nJyksXHJcbiAgICAgICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+Wdly5wbmcnKSxcclxuICAgICAgICAgICAgICAgIGJvbnVzQnV0dG9uOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nJyksXHJcbiAgICAgICAgICAgICAgICBwcml6ZUJ1dHRvbjogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgZG9leGNoYW5nZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2iLnBuZycpLFxyXG4gICAgICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb25leWJsb2NrKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNDc4ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBidXR0b25CYXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNjAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogNTIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxMDUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJhcmNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9udXNNb25leSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDE1MSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW9uZXlJbWcoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwIDBweCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhjaGFuZ2VCdG4oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAzMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArICgzNjQpICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcblxyXG4gICAgICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5kaXYuZXhjaGFuZ2Uge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcuZXhjaGFuZ2Uge1xyXG4gICAgei1pbmRleDogMztcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmltZy5tb25leS1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5kaXYuYmFyY29udGVudCBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbn1cclxuXHJcbmRpdi5ib251cy1tb25leSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuXHJcbi5iYWNrZ3JvdW5kLWltZyB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuZGl2LmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBhZGRpbmc6IDElO1xyXG59XHJcblxyXG5kaXYuY2hhbmdlLWJ1dHRvbiBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbiAgICB3aWR0aDogNTAlO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIEV4Y2hhbmdlLnZ1ZT80ZDcwNTAxOFxuICoqLyIsImRlZmluZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTAwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwMDAw6YeR5biBJyxcclxuICAgICAgICBwcmljZTogJzEwMCcsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKSxcclxuICAgICAgICBnb29kc251bTogMjAwXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ29vZG5hbWU6ICcxMFfph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAnMTAwJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzUwV+mHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6ICcxMDAnLFxyXG4gICAgICAgIGdvb2RzaW1nOiByZXF1aXJlKCcuLi9hc3NldHMv5YiH5Zu+L+WVhuWfji/ph5HluIEucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfV1cclxufSlcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZGF0YS9tb25leS1kYXRhLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRwRU16UkVPVVV4TWpRd00wSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRHBFTXpSRU9VVXhNelF3TTBJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa1F6TkVRNVJURXdOREF6UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rUXpORVE1UlRFeE5EQXpRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K01yUEYxd0FBSU45SlJFRlVlTnJzZlFtVVhOVjU1dmUyZXJWWDcvdWlYVUpDRWtJc0VpUUdHMklUSEM4NEJFN3NlSnhoenNTUWM3eE01Z1NmR1dLUzJCT2ZjYzRzZUpMWUpqTW1NTVBrakdNSGlET1l3VGJnSlVic1FoSklRbEpMcUZmMVV0MWRlNzMxenYvZjk2cTdFWklzd0Vpa2VWZm5xcnFyNnIzNy8vZTcvM3IvKzFvUlFpQnF5NmVwMFJSRWdFWXRBalJxRWFCUml3Q05XZ1JvQkdqVUlrQ2pGZ0VhdFFqUXFFV0FSb0JHTFFJMGFoR2dVWXNBalZvRWFBUm8xQ0pBb3hZQkdyVzMxdlMzZTRDZEs3ck8rcnVWR25ENWhRTGJOdmg0enlVcU1ta1ZOVnREWDY4SnAxYUZFa3RRandHdURUV2VoTEFyVUZRSFdpb3pxTVJiTDFhTjFxMWFxblU5akdTdm91aGQ5SjJjb3VrSnZyZnczSnBmcnhXRWNFN0FxWTU3bGZ4QjRlVDMrUFg4QzE2bGRGejRCdDA3QmI5ZXBWbUowYjF0NmpVWWlTUkd4eXdrWWg1S1pSOC9mYzdIN29NcW5uNUpRU3B4ZG56dGV2WEU4Z0gwbDlxRWdHL1hBV2VlUURRdk1qbzNma3pQOWwrdnBadTNLekVUaUJFN3dnVVVqMTRkQXA1V2lPL0tTeFZEejJnSnN3TktlaTFFRzNSbEZXQzdFaml2UFB1OFd4ajV2bHM2K29CdnpiNEl2d21LVUNJSmZWdWFRaE1yQ0JlV1JsRXpZcTFyUDJXMC91b3RSbnZ2VGpWSklxTFpnRmVnUGd4WTlDcHN5QXZZbWtoUVFtQjhlcy9qOS8zZ1BZVWtYY2xCU1RSRFQ3ZHUxOXU3dC92VnpWOTBwc2QyT2ZtRDk5ajV3L2NKeDNkQW1rRFNFQUg2Vm9Ga0RCUTQ5VHFCV1lXUkdmaTM1c0FsbjQ5MWRmY3BTUUxMbTZKT3Fzd2hpVVVzN0diWUYrOXhlbW5uVHVyVm42ZDcwQ0pRNDFDVFhUQlhEZXlNZGZYdk5FNXMrbU5yK0xtN2ZIdmlQenQxRmFadW5QbCtFYUJuUnROekJSU25pRlFzZTRQWnMrTS9Hb05yMTZscFVxWGVFRWtpZ1NEaVM0QTh6WXBRVGdFaXhFaytZVHpvTExqK0pLbnA0MURNSmdLMnY4L28rT0IvY280Zi9uUnErcWt2RUMwUHVtNFM3M1JVMzFHQXFqUlhycWVnVUNhSnFWdnBqcFZyN281dnVPemphbWVLUGp4S1FKWUlENTdVN0VuQThNVWFjVU5TcE92aHBETkMzcEx2OFh0YUNDSzk1NUp0ZGNuTyt0NlNtOUQxZ2hhSXc1KzlERFdkZ1hsQi85b1ZMUzBQMUE4Kzg3ZUZBMGR1TFpUTmt1dVprdFlJMERNUlFuTmRxQ3FZSzlheHRjKzVhc1AyaS83VzNMS2xCeWx5YkN5V1NsWjU2WWF1bEE0U1ZDSS9uZ2h0WEFXb1RxSnlmQjdWNlRMc1VwMThJaGUrRTRDcUdqcjBoSTVZSm81a2V4cXA3aVlnU1IyWjRGNzEwSUZTUXZBRmpVWFhReCtDMnR0S1g3M2k0eHRTNmF2SFR1ejl4TlA3OE9OQ05ZNU1TdEFDakFBOUpaalRCUVhWcW8xUFhlVisrdnAvZWZFM3NXWWRUV3FlUUhJQ3U2aGdFVWlkZmpjNVppakRtVHFNcVgzaktJOFU0QlRvdTQ1Q1h6V2dVZWloR3RSVlE0N2hrQ1RXeU41NmJwSHVNa1plcjRDZU01RHV6NkZqY3crTWpqNzZGZ0ZzRWJDdUZZeW5zSzJtc2Fya2JDV3JNSGRzN0xtK1RYL0NxdXkrOWJhOTl0M1RoUmphYys4c1VQVjNCSmhGRmJPek5yNXhhKzFMTjl5Ky9Zdm9YazBUU1hheVRtcFQwUlpDRmpBNFNaYlNPY3p2MjR1Slo0ZGhUZG5RMVF4U3JWMW9XOXVLZEdjYVpvYlVab3l1MDlSUWVrVWcyQjdkei9aZ0ZXMlVTWXFMNDNuTVBUK042V2VmaDltK0QxMlhEYUI1ODNwYUxNMGtuV1dTV0NlOG51NVZKZFRpUk5PYTFiamhkdkZOWVQzZmUrczNsVHZaVzI3UCt1OFlVSlczKzdEU21SSUxHczFUdnFRaW4zZng5VnRtdjNyalZ5NitIZTJiU0p6S2N1SVh3YURYRktsRzJDaStzaGZIZjNnRWJsNUJwbU1BblJmMkl6T1FDMkpRWHlQTHFRYVNwYXAwK1JMSFNBbzN4ejhFcXZEcGJlcXFKMlBSMG5BQmt5K05vRFExQXIzTngrQzFhNUJkdnlWd3VDb2xucVZRRFl0Z29SaTBxR2IyNDd2Lzd2ay8vLzE3V3I3UTJxcWpOZVBEODg1L1l1RzhBY3BPUmJtdVlHck94MTAzVC8zUnpWL2QrbVYwYlE4Y0gzWllsSEFDbFZBcXJWZHg4TnRQb1hqUVJ0dXE5UmpjdVJwYWV3ckNKUkFWbmN5cFRzSWNndG1JR3hzTG91RVVOWGpsVndKVmtNVDZOSllxWENpNkIyKzZndU83aGpCejlCVmtOOFN3NGVZZEpLMHJTRHJMUWFLaVFST3JGWk1jc3hQUDQrKytzT2ZPejMyNzQ4c2R6U3JTY1NIRDNYY2xvRHpzd1JFVlg3cit4Q2MrZS9lNis5Rjc1VWxna2lUcDVOR2FNUlFQUDRXRDl4OUVJdEdQOWUrL0NER3llNTdEQUJxRU4zVlZmZlBCUHhFaVNHb0ZlYmJDdGFIRlhOaGtqMS81d1l1bzFVYXc0Uk1ia0YxSHdGcmtlYnZWWU1GSVVFa2ptS1ExeG42Ty8zYnJvVS9lK1hEWC9SdjYvVk9Tc2V3QjFXbE9Eb3pwdUdIRDVBWC8vZDd1L2RoMkxhbSthaERnTjhDTWtWUWFQaVorOGlNY2ZXZ0tLeS9mZ1o2cjFwQzh4U0JVVTNxdE1sUlJsc2FZYnk2QnNiRENDRmlmZ0ZWOGk5NjJNZjZUSVJ4N2VoZFdmYlFEM1ZjUmpRNFJicGNYUVRYWVZ0T2kyLzBZL3ZYdmptOTg0RURuZ1kxOUxsei9YUVFvYThYeE9RMXRhZ0dQZnNNWWJiN3B1bDY0OUdhOXNmb1pUSW83WXg2R3YvZVBHSDNNd2ViZnZCYVpqZDN3YkFOcXpDVDFxQzFLcERoVEtrZzVlOENYQUN2SXcvRnRpNlRWUVduL0JQWTk4Q1AwdmMvQXdJYy9SSURTMkhabGtWWk9EZW9DYzkvNWYyUFgzV3IzVGZzNTlEUjcwdjg2SDRDZTgrMHp5MVZRbXJmeDVVKzZmOVY4MDQ1ZTZYalVLbUd1ajd3S1BVNXYrUVRtOTBoQ0JMWi82a1BJWE5CSDRVWUNXanhGWU1ZQ3IxT29RY2ZwdWhaK3I1RmdVTS9jRis2bnlURjRMQjZUeDk3K3lROUpXcGdtcGszU0tCTVNTa2k3Z2ViZnVyejN5Ly9DL1RyenhqeWV0K1RNdVE1UmhpWlUvTmJXdWMwZnVIM0Q3d1BkRUtVQ0NZOUNna0YyakJQbWNSTVRqeitLMGNjZGJQdjRyOE9rb043MzQ5RE1lS0JpenpiMXh1R09Zc0dlZFZFZmRjajVLUVJTZFZiWEszSXNIcFBITnZ0YUpTMU1FOU9HZUV6U0ttbG0yb2tINXVYOWY3amh0aHN2bXR2TVBPcmFNZ2VVTlNTSEtQM3hBdTY4cy90NzZObElJVUVoektHeS9WS2dwRTNNUFAwNGhoK3RZT3R2L3diTXdYWjZPeUhWYkFDR09EdGpHWHEzenZ5WWxES2hiMEo5ZklLRXRSWXVpbC9vS1FXZHhsUk5VOUxBdEZ4RU5ERnRNMDg5SVdsbG1nUGFFZkJDUFAzeEY3di9nWGxrWHMvSEpzMjVBNVQ2eExTSFQzOVlmS2JyWXh0WGdOU1N6NTVqNkdVcTJRenFJL3R3NUxzaldQOXIxeUMxcG91a2c1d2YzdEJXbFRmbTlaQjBDbEdETlVYMzFlcUlyeWFiVnFjaGkrT0x0dlhzWEdDNU9KZ0dwaVZKTkcwZzJvNzgvUWhxUkN2VExHUmNLd0plaUNmaWJlV25QeUkrdzd3cXkxbEM1NnNxMWpXVjhQRmIrdjRVYUlOZkxNckpZcldscUN5QnN6anl3QjYwcjltQ3BpM2tBRmtrSGF5M0ZwSUI0aXc3cE4xMGl5Zm94d0hvelRteWlVL1Nhei9zNlRwTmVtVXhuanliSG83TnREQk5PYUt0ZmMxV0RQMzlIcnBQWHRMT1BQQTlKVS9FMnlkdTZmc1Q1cFY1WHBhQXNvQk5UUHY0amF2MG01cmUxOStNdXIwNFdSNVpvVndNMHovZFRmWXVpMVZYWDBqZXJFWmhpUkVtQS95ejdsSmErQktLRjYycEN2UmNEL1JzSHFKNERMRldsN1RqYWppVnlVQXJoTW1Gcys1MFk2YUphVnQxOVNiWWMxbWkrVVZKdTl3NGJ5dzY0aTEzZFY4TDhYb3o4M3l1ZDJYT0NhRHM5VFdyRlh6NEkrMmZoOUlNcjF5VkU4cGRZWSt4T282SlowNmdhK01XS0JuNlhUTVdwRmY0NHF4N0kreHdxNVBraEs2QTBVelgxdzVCMkJsbzZURm9tVjRDdWtTQUIxNzFHN2wzUXdxWk5xYVJhWjE0WmxMU3J1am1BajllaWNJdnRRVWZJVjZaNTNQdDhhcm53bmJPa0w5d3lRWXhzUFdhOXAxd3dpUzVkQ1lJMEpTR3lhY1BRYkdiMEhOUlAxd0szbFZPOG1JeDczcTJYVnBha2s1N3FremdrYnJOakVEVU9TZE1jVzM5SUl3bWlpL2RsV1JQOHh5QUw2UUF6Nm96TGJ3TlI3UXhqVXlyWW1VRDJsUDZBai95ZThUamxtdmFkMXk2UVF3eTc4c0tVTTZybDBvT2R1NU0zNGlCSnZpRjJxSzY1VGpSbTBYK1FCNjVubFZBTWthclhWOEU4NDMwRUNBR3kzWDZKWGpDT2toM1NrdFY3TlVjR0psUmt0UUJrdEo1Q2J6eVpzYmhRSVZwSkZwenZhdVIzNStYUEVoZUdnNFM4MGk4N3R5WnVaRjVYMWFBc3ZPWFZXMWNlbm51QTF6cTRkdE9vSjU4SVcxU1pXaWMxSlNPOW5VOXNvQkFrYXFXUC9jQ2xYdmFIa3BZdy91bEVFTjRkVmdrRW1wNkpZenNCUHhxUFZ3OG5BUWdqOVFoS2VYOVM2dVA2SmdMMlZjV00wUkNuSGxNU1pPUU5ES3Q3ZXQ3eUh6b3hNT1k1Q1ZRelVMeUNDUnc2WTdzQjVqM1pRVm9rY3pWWURmaUYyN0pYTW1xU0lTcVNVNk02U0YvWkFheFdETVNIWW5GdmM5VFNGNmd2cGYrYSt5SitYSW5SS0VZMDYrUHdDNjNJSmFsR05BNUlFR1VZSXBRY2lvVkFub1NTbUlGYWlkR2FRSE15aTA1V2ZySjIya3lUYUJJd0JiR0VJdDUza1VwRFVLalJIdEMwcDQva3BlOEJOdHpvVDEzQkM3Y25MbHlSUThTNXhMUXQzMkR1MXp5c0hLenVTMDNtRXloYUFmZXFBZ3pPVzRaZFFvbGtzMjljbTBwYWxnTDVDOUptQ3NJSjVnbUNpd2xMZ0hoeUZ5cloxbHdhN2FzSEJHZUFhdFFSYXpqVnhITGpjSXJrdkhTMjdDNG44V3ZXU2p1UHBpdDEySCs1ZlZ3cXNNeXlhL3FMalRUZ0I0MzZaVnp4YnlEUTUxcERFdEJGNXl1Y0k5VjB1cXBTRFczb3pvOUZPemhDcDFJRGpkRmlkZnNZREs1Y29XNWpYNTdjdGtBeWdDc1dwWGVpcFlZdkVsbllZSVZYWVV6VzRSZlU1QmVtWVBMNFl2UmtBU3h1SXZKZWZ2OEpPcXpCUkkyWGVaTmhTeEo0ZTJ6RklIUkJOVk1RS1gxa216S0lONDZDMUhkQ3kzWkZ1UWF2ZkJPbWlKVHVsNXBDa1ppTjVvMmJvVTkzMHowMWNudVZ1QVFBR0xPa3I5VG5DTjNXeFRGSVpBMUpMdTZhSXkwM0QrVmNxc0dDOFIxQlZMdE9aU0hGRGh6QmFLL25TdjA1WEJzczdYT0dQRWUzN0tzQU5VVmdaNWVjeTBNQ3N3ZFo4SG04YTVMWWFaTTJrNUhvamtlQ0dOb08vbVhZT0lVek93OURDV1dRYko3UFVsakZWcE1wUjVVbzJneFFSSkYzOVhZbFp5VWRiWitsV3hvVXl2S1IrWXgrOUtFTEF6anhnVmpMUmQySWIyMkcxNytHTXo0Y1ppOXpaRDFTc0lrMmxTUytBUkpQb0hoS1BTekw5T0VxcXBpOHNWRHlBMjJJOVhkSGhTZCthSE5aVXZaUkxUVFFpdlBWTWhKYW9jYnFtU1BGcVZHZHJXN3oxeTNyRlJ1TnFXZ3V5ZldEMm5LL0lWMG1FcEFXL04xOGcwTmtoZzkwTEl5UEdoVUtuQXVsQ2JOS3RLRUhzVGEzN3dVcWUwVWZreVRCSEp4TlRzb1hIRlFhZXlzQk5VS1dxSUpwY096T1BHVElRS1hKQzZVVUlVa2RJSVdVQmZkTzlPWGt4S0VPcGVGRnNMZEdGL3UwM0lSTjZ0YlpNbitrbFFlZitBQXFxTlRhRnZidG1oREZTellkU091U3g2c1FoMXFuMWpRUUJKdXVtMVB0OUczckFDTnhSU2tNa2FibkRQUGsyNUgwRnk0ZFZkV0hRU2xzbUdtQjQwSjhjalJVZEYrOFFWazYrYncwbDgvak5VZjNZcm1yYjBRRmJLanZ2YTZLZ1cydGI3dFl2YUZFU2cwVnRNRjdVaDBaYVFOckU0VVVTVG5KZi9jTUZJZEZ3U1krTXJpTmh2L0xvL0VrR1J4a1ZtcGpsZnUrU2ZVWjRwWTgrSDNJdGJVSkczMllpbzR6R0l4R2NTRFczVWxUMkxwUnFqckk1VTJXcGNWb0pxbW1LWmZ5WEpwaVFUVER6TXVKQkcrVGFHTG9pOEo4TDFnaFMvVWh2RU1hK2k3NmtxU1loT0h2N3NISzZzKzJuZjBRZVFyNUF6NUorWFpLWFNoOTR5a1R2YVIxR0ZYRnRudGZiS3dTOTg5UnFBV0VHOHhTZXJKSzJiajdKOVVXa0IwYUt4Q2FhRzkvTDlma0hXNkcyOStQM25HSGJUNG5BVW5UYW9UZFRFdHFaTHo1TnUyL0VBMFFxbndHSTJtcTlsbEJTZ0Y0YVp1RlV6TW55Q0F1bVNZb0hoaDd0VUxiU1VhMlJodk1jR094dHMrTFhRTm5aZGVRaVpOd2JGSDlzR3BXZWo1bFVGb0ZVdmFScDVjaWV0clBORmdhOHVmS3NISzE2VkV0VzdyQTFFVGFvUEZHTGFCazlhU0lFZXRqZ1BmZmw1NnZlcy9laFdwOEJicFNRZmdMZG1vOFpXRmNFajY0SDVvTXBnM05oV2FLYXN3WXRaTWJGa0JLc2kvcHpVc1VKeUdXdkxocGR1RDdTMHZPQ0cyRUxCekRTUjdTZzBKeFNLb0RMUlQxZEMrYlpzczR6bjZ4Q3VvejF0WWRjMEs2Q1NOVGptc1JRcHlQNHZxUGtWQi8xZ0J4Lzd4TUpLZGFhZ2txVEZTcDEyWDlRUmhrSXlIdWVKVGtaSlpHcHJEa1lmM0lkT1J4c29QWEVGa1pnak0rbUsxb0xKa1M1YXVZWm9iQ1JDWjJIQ0Qrd2tPZVN3S3dQTVR0SDR0c2F3QTlYMWhPNTVxU1kreE5BMkZRZ1F2M1FZLzNVS2hBS0hqVzhGWkV0V1ZjVjJ3MUUvUktQWjBmQU5OR3k3Q3hxU0dWeDdiajcyVEpWejQwUTB3MGdScXdlYjlrTmRzY251V2kwVE9STjk3ZWlrMGNWRWVMdEYzZEN3VS9OQ3JTcDZRbG8xaDhwbHhISHY4SUFZdTdrTFBsVHZndVJSbTFXcW4zNGZsY2hVT1ViaEtrVlF6VituN0NtZUxLRndwVDBHdDVybUlBYlp2MUpkVnBvZ2lsVnExNmhjRGFUVmtkWjgyT3dvbFAwcjJWUVFDNkxpTFpTZ2lYUFduNnVUZE9xUmlZMjByY01FMWE2Q0xNdmIrM1Q1VXg4dWtJZ1A3TEtYR0RVQ3dpaGIwOWdSYTNqTUFzemtKMXdwc3ROUUdmbEJ5eWQ3MnlCUEhjZnhuaDdENjhqYjBYTElWanFYVEFxZ0dTWXhUMFNHOHhmSVRoN2ZsT0VTaHFaeWZKdDZHYWVGTzBlZEJHVXV0NnBlV2xZU1dTUE5NVEdGS092SitPQ1RycGRsSm1Hb1NaWlZDbGpvdFlwVzhXaTZvamlYQzhNQTdwYlFLcHdhWFZKcHF0R0RkVGgvN2YzWWMweFNtREY0OVFJSkNBRktjcXNaNVAxVkRhYVNFR3RsRXRuRk94U2FWcTVOVzBPVjMySGxpNmF3WFhlU0hUbUJ3YXhxdHExZkE5dUtjRlRpMXBwQVYrWnFzeW9kZG83Q1h0RTNkSm51cEk2YlNPRk9jcUNjSGljT2U4T2ppK0RUenZvd0FKWWVTbVJxQnV6U1hUaFBzYWpCNTI0a3pSb1VDREZKZmZwVVBJYVdnbUVrSzhNd2dwQW1yQzJSbGcwdzI2QVJHbmVhY1lsaWF1SmFCSEdKSlVxOFRjM0FkbnlSVlIvTmdFcDd0b1Q1cnlTNjliUUk1M2hvUFBpdFZwUXFXVWtvT1Y4dEFSdExpbE1nVzYxWlFXZWdGaVFPbDRXQXhEYXhpNjJYeWtxdkVHSzFVenlMN0hmREFaNmNjaXhZS2UrM2hJWEhtZVh3S284c0tVRzZ2am92REtBc1o3VG1OaFUvMnkweW84bVI4YmE1S29VR2NWQytoYjlFcVYrZUNTVFhpVU5nTDBvTzhxZ3diT2Z5cHpNbXpuYjdtd2JVVnhCTUNUcjVNWWE3Z25MaE1WRFIzR3FnUzBHcFlNc0JDbjh4b1VNbzExRWx0QnhnSlVnZ01Ic1dwRlIrSlpCMytESm1EVkpPc2pGZGtuc0NUWXdtSGJiMGxxK3ZsemRnbklDQnI4L3d3RDFvc1NWcVlGYnBBQ3hnMG1Oa3ljSHhjT2JLc0FFMlJzQjBkVlY0dVRmbklaQlRZVGlOVUlNK1NiQlI3cVpWSkYwMThhbHZHRDRGS0ZoVEVDeTYrWnJsVXd6TXJjaUVFUnlWWWV1MnFSWnFaUURGVnV0WmZyUFlqd0RqRXlXWlZOQXJKV2RJODI0WGpoVjYwb2l3ay9UVzZ2OE9xazYrMmF2QzUxbGJURjNaK2hBajNRWlZRM1lZMDBuSkVwVVE4ZEdxU0Y0dDRVdnhHQmtsQmFVcmc2Smk2ZjFrNVJia1VjR3djZXc0Y3d3bWtndGd6aUFGSjdjNVhrTXlwRkptU0hiVThlWERJSjRlRlFlTG5Ld2g2bitWYW1sU3VadWRPSlB0Q2s1TmNxOWhTaGZPQk1FR2l6M1pSSnVONXE0eCtkOG9reFhWeVlHejZ1ZUxJOTZUZVp4cmM0UHZza0drRXZzcy84eTRPZWE5eWpNWjRNaXhXSlMxTWs2VE5DMmtsbXNtbmxUd3dMd3RsTFV4RDBnZnhQSGwwREh1V0ZhQnhNb3V6UmFYeXdnRThEZDJYRTlJQTFTYWJsVzBoTlppTW9UaFJDV0pEenorRlora3YxT3pJbjZYRDVNR3VPMUpLR0FJSmtCZkVzOEx4NUhFRzF0YWNmblBMTGt6eWdoWDJUQjF2OFh2VVBRTEZJRUI5OG93ZHl3NWp5NVBITzRrbUx6aU95RFFqYVVvZW1KY0dtTXdqVjlnVHowL05scFR5c2dLVXRTQS9vT21wbDlUSFVBaWxTVFR5OEJwMHIwb2hoWTdDckVlcVQ1R3JYNExhQVA0MFhTWWIyQWtpRmVnNzRUVlM0a2krVklGRVFrRjUwc0hCNTJheDkra3BETzhyVTVqRDZsa0p3QThsMmlVMWJPakJvM1BxTldjQmxOTjNYOUxJNHhieUhtSkV1MEU4TUM5aDRranlpSG5pK1dYMThWVDhuQllzbklPYUltS3d2VW5nbWYzcXcvc1B3SW5uU0Nya3BOQ0VrbU5SbmNnajEwVTJNSmxCblZOMGZ2alpHVG83VkI0N1JaeTNWUlhwMFRJNGJMK1M1R2loNXVQUU0wVzgvUHdNNGkxQTM2WUVKcWRLMlAyelBQTEg2a2hTMk1KVm9sSkZrMlRHeVB2aEIwMVpCS2dpL0FYZ1R0VjlMOWh4WVZxOVZBWk5SSHVGZUdCZStEUG1qWGxrWHA5NVdYMlllVjlXZ0VxMVM2cnZ4Q3lPUHZLVTlnT1lRbFo4QkxsNFFRNmtnb1JTZ2RtWnhNd294Wkc2SnUzYW9xU2UzTWwrMFlSYUZBK3hBOHJ4dkVjU3lpcVZjTUxJL2dwMjc4cWpXSzloOVNVWkRLNXVRVnRMTXpidGFFR21XOFdSUS9QWXUydU9BSEVsK0VHT25TUk9jSlpPbGo2Y0FVeFAwc1kwTXExbVo0Sm9MOHNxd01DTWhOVXN4T01qVDJzL0pKNkg0akVzUDBCOUthWEF3MCtxOXhXSGdYUXlsRUtPQXlrOHFRNVBvTFZmZzVOcFF2VkVLY2lyczBNaXdUdTVCL2FzenJzZk5JbHBVcTFKUThIY2lJMFhuNXpINklreU90YVoySFFaQVpoS29VNmhSTDFDQzhRMnNHSk5NOWJ2eU1LTHU5ajM0aHlPN0M1RHRRWFplVVZLdWt2T2t5K2NVNHdaMGtJME1XMU1JOVBLTkZlSFQ4aVNGV2xuaVNmbWpYbjh2ejlYNzJXZWZiRU1BZVhXbWhQWU02UTk5TkJQdFZkaXpWNVlCeFJLcVV1MnREQ08zTHBXVEpPcnIvSXVpUnVxWnZma0h0aFBpN3pYTk1XYm91cmhwV2RMZU9WSUFXWUhzT255SExvNnM3REtHcXlxdDdBdzJGWldpNlNpRWNmNnpTMFkySkpBdmxiREM4L09ZK1JBRmRtNEptMDRTK25yeC9SRFdqeW9aRU9ZeHR5NkZxSjVRdEllcU9nZ3JSdHI4Y0E4TXEvTTg3bHU1L1R3UlhOR09QYzlhdnpYOGpqRmlFbGZKZ0trUjBoU1docVpSbk8yaE5qYVFVd2ZMY0F3TmJsWjdZZDJhMmxYRkY4K29HVDhpSVVYWGl5Z2JqcFl1ejJObGF1eVVoSnJaVm9NQ3lIUTBtdkprU0xBYWtXQmJEcUZUZHR6YUZtbDRlaDRHYS9zTGFNMkwyU2NLdnpYajhtME1FM1RRd1hFMWd3U3JXVkpNOVBPUERBdnpCUHpkdDhQakx0YU1zTEJlV2puREZCMmpqcWJCVjQ0b3QxNzd5UEdmck1sakRkRFZjVXB2OHFoUStoYVk4SnU2a05oWkk3Q0RnYlZlNzBOWlFmSVZWQWwwTnBXRzFpL0tRc1RNZFJLUWlZUGhPZWQwYW5peisycUM3dXNvcnNqalFzdVNjTlBrNk5USmE5WmFvM1hYczgwTUMzRjRUbEpXOWRhVTlMS05NdlAvU0FjaXhOUGYvTjlZLzhMaDdXL1lWN1B4MS9EUHFkSDh0bitGQ29LMjVVYnZ2OW5wUWRXOW5zWUhkZUN3N0ZzTnlrT2pHY01xS3N1dzhnVFE4Z3BFMGkwWitIVWZGa1R0SFJ4Y0wyUmJnVFpIc2RHV0FEOTVoYWFSbUdMcHROaWNFU3dKNkFvaXlmMENTZ2pxYUkyVlVSQmRLSC92V3ZnSDMwRzlaSVRiUC94VStib21yNGVEOGVHTlh6d2pzekhGQlVQNWxLTGdDN2JJL25NWUhOYW9GUlZIdnpjWHlYL2twL3QxTVlQYlhLREdJL3p0cFY4RGQ2eDNlaS9haFVxeVJYazdNeks2ajdQV2JSbmpUalZzY1NDblR5bG1qeUxMaXNpTEpaWVh6NHcwZyt6U05KdTBwZzZqVDAzUEN0cDZidHF0YVNOYVdSYUEvc3YwSmJ4T1dlUHozODkrWmZGbXZJZ3FWdWNyNzlWZjg0UE1MSjJIZXowOGVPOXhoL2M4YTNrcm5qS1JWd0xKNU1tVVlzblVKa3N3RG4wREhwM0RzTHIzb3laWXdXb1doRDBTMUJsSE9yTGNHVUJIUGN0OUlYN0xkNUxIdFdnTWFkcGJKOW82TjI1QWk3UnhMUXhqUkp3b3BscGo2ZGQzSEZQOGlubWlYazduMDhWT3kvUG5PZlZ1NzdQYy83bjQvSGIvc2VEaVptMkRsZDZqOUttaHFCVzUrcW9QUGRqOUczT0lYbnhsWmdlZGVCVWl6Sm5MdHpGOU9FdnRVdnBGSElNSG10NnpFRnkyNVhvSVJxWUZxYXBBU2JUeW5YRVRQdTNIa3JNM1B0WS9MWjF4TlA1a3N6ellrTmZzNUxVd0o3T2xkVWJ2L1daNHYrNWJtZGRHeDdWRjJ5dFBCRk5ObFVobzViYmVoR3FhTWZzaXdlQjZSRmtPblM2UGk1dFh2RFl0bC9HS2lNN2FpaXljcjQ0UmZGSFd6OWF0bTFBRXRNbzduMVJwdllDbTdtb1RnZjZYRHk2Sys3OXE3L0kvblpUMnY4TzIwMy9GUHZpNzRvbmljbE5ad0oxcXFDeUd2N2NmWitkdit0WExySndmRlJmVXZvYWxKVzQ1SUJrMS9SQTY5Mkl3a1FWNVVNSG9CYm5rR3BWQ1FUZVJ3MU9yTDNoaHhxSVlGdE5OZGhHazBiSWsrUmxtNUJldXhHNW5pUzhzZjBvRG8xRFR4dkJDZ3lyNVhtWXdWNFgvN1RYeE85K3JlbnpGTDUrcmFQSmY4MnppZDZWZ01vTldmSnd4MmRWUG5yeTcrKytiZjdQM251eGhaRUpQYWdiVXhmZFk3ZGs4WDQzTXB1MndsYmJVTXRUM0RqNkt0eXBTWmhjNkpCUjZmdmtxUGpxUXBMOGRKc0Y4bkdBS29jYk5xd1NweEdKam81T0pQcFdJTkdhUnN5ZlFXbi9Idkt1NmYyTXVYQXp6dnJ3eG5WL3Q0TWY3NDdqOTc3UmRBZUIrSldlbGpQYnpYY1ZvQTFRSitaSVVqM2xENy82eWNLWGJucFBOVDZWcDdpdlNrQ3JpN1cyblBKeml4N2liU1pTcXkrQXF6YkJxcENIU3RKcXowekNtNStHWWdmUFJlWXp1ZnphMkJlWHV6dU5JajBPVGZoc1RGTTdZbTJkaU9XYVlTWXBmUExuVVJrNmdQcU1CVDJyMGJYYUFwaWVyeUNUOE5IWjV1RTdQMHRhdC8rdjNKMnFJdjc4RjRINXJnUzBBU28vTjdkUVZXNzU3SytYLzhNZmZMRFV6U3BzYkZiRDBxZWtTbUE5RjI1WnlNY0JwbGF1cFAvYUtSYU5TVTlWZURhcFlBdkN0Z2hBSjl3NzVWSmdMaG5odjgzQ3p3bmtlcVVZVjdYRGlORUtxRXlqY3V5WWZJeWZudVpxQ0gwQnlNYngwTjRXVDU1OStTOFBaeWErOWtqbWozSkovNTZ6ZlU3dXV4TFFoazJ0V0FwR1pyUnJmMjFML1UvdnVLRjR4WVg5RGtiektzcVdWTXRMS0E5bTJxdDU4c21uQnA4dGFtdUhsczBSWUltZ1pCVHFhMFdVRC9WeThwMTBLWjhmdFdhbTRaU0NKN2hxQ1czaFQ0b3NoRmowYzlyMDBkZnE0NlVSQTE5NUtQdmtEL2JFLzZTdnpmdGgyaFNudFprUm9DZlpPQ2JwMVdsOVZYdkcremUzWGx2Nm5adDNWcG95Q1dDVWJDMC9WZVRrUjhVRWxVUmhRc0FPa3Y0TlcvbWFCeUNIdGxXV0JzV0NNNnJLU2RYMmpiQXFwZ3Ywa1RvdDFZRnY3MHJOZi9OSG1mdW5pOXBkSzlyZElVWEJHMG9jdktzQlhTcXRzMlhWbUNtcEg3bGluZlY3djNObDVlcjNiYXdaYVhLTVRwQm56SkxjT0FUMnl3bGJBdUZNa2VSMWtpcXRrS1AwK1A2RWMvL1BVejk1OHBCNWQxdkcvNGVXdE8rY3JWUkdnSjVHV25tV3grZTFIbktZYnJoeWZmMm02N2ZVTHIxaWJUM1IxMHplS1RrNHN4VExXbzRTSGxOOG83d0U4bWxTMk5KQ01TU2ZZeG9sNSt6bmgrTzFSL1lrbnFYWDcyaUtlTENuMlJ2REc1VEtDTkF6cGJNVVdldEZrcW10Y0QzbG1rMjk5blU3MTlRdjNiN0NHdGpRN1NnZFdTR2RLbjc0Q0ovajVVUFdidU9aRzB2VU10K0h2OGVoUjRMc1pzd0lFdXRUUlFVSEp3engvS3ZtOEs0ajhlZGVIb3Q5WDlmRTQxMDU3MVZkZmV1YjFCR2d2OEMremxYVjF2bUt1aVdYOEhldTduUXZXZHRwcjF2ZDRmUU10TGhOWkhlVkxJVVhyRHFOOEE5RE5ITElERFNyNm1KTnhYUkpFOE96K3Z6UWxERitlREoyZUdoU2Y3WlFVM2MxcGZ5OXpVay9yN3dGaVl3QWZaUGdzblNWNm1vSDlRSDZkVlVtN3ErbWNLS1hnTzZnM2tTcU5FV1NGcE9uR0h6RkpvZXFXcWlxOHdUY0ZMMk8wWFZEeFAxUnV1NDQ5V2xkdzl1eVN4TDl1Y216VFBDejlEVWwvU251OU5aekxnWC9OVnRKRkdwNnl2R1VKQmZnQ1NGNTVDMU9sOElleTlCRk5hYUpTaW91YXJtays3cDcvbk52Yjd1RVJ1M2N0dWhQTmtlQVJpMENOR29Sb0ZHTEFJMWFCR2dFYU5RaVFLTVdBUnExQ05Db1JZQkdnRVl0QWpScUVhQlJpd0NOV2dSb0JHalVJa0NqRmdFYXRRalFxRVdBUm9CRzdaOUwrLzhDREFEYUtLWGhRdmxxV0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFmUUFBQUlJQ0FZQUFBQ1liaHgxQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8yTXpnMFJqZzRNVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzJNemcwUmpnNE1qUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qWXpPRFJHT0RkR05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pZek9EUkdPRGd3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNmU3Zzh3QUFEMlJKUkVGVWVOcnMzYjJ2SldkOXdQSG5lZWJjM1NqZ2hqaUtMQllxQTFVcVRJK3BFZ2taS1k0QUUxZUFaQU9HSW1rUUlpNUNJdjRBcjR0RUtGVVNMeEtLb2tpcGdvQWFTRWNEdUdPQkJsZThLSHZ2bVhueWUyYWVPV2ZPN3RYYUVvaDdOL3A4N05tWjgzTFBXbEI4NzIvZVR2N3EwMytTVW03LzVsUmlYWEtzWTJPSTdTSFd1MUxTTUxSMVRtZkh4MlhJK1FQeCt0UHgxRlB4TSsrTjlUdFR6bThyS2QxTVRVNEF3UDNxc3BwU3VwZHEvZlZVMDArblduOFU2KytQVS8zMldPdjN4ckZPKzJsS0YvSGtQcFo0bk5yanNXM0h6MCt4L3B2Ly90bkp4Kzd1ajNtTCtCTHlXSVlXOFpMT1d0Q0gwb0orSzlhZmk5ZitLcFozTGVHUG4rNC8yeHFlczVZRHdKczF2ZFowTTlZM0krYnZpTzAvalpBL095MEIvOGwrcVArNkgvT3J1Nm5lM1k4UjlseFRpZDhBOWxIejNLSit5V2Z1RGpIdmNUNkV2QVU4bGh2TDloL2RHTXJmUmRnL0hVRy9zZXZSYis5ZmZ4R1lROTZqZnFEc0FQREFkSDZNZW0xaFR4SDFXRkpNMzdWTjRlK0txSDh4Z3Y3WEYyUDkybm5KTHc5bGVxT01yYmxUeWhINHkvSzZPMHptUGVaTHlIT0thaS9MVUQ0YXk2dXgvZmk4eXoxZVg0TisyRVhmeC9JaTVBRHdsc00rOWUwbDZEM3FmVGY3ZnNnM2RtUDk3TERQSDQzbXZsVEs5UFhTOTRMbjdXOEd4NkFmZDdIUE1ZK1ovV2FzYis2R1hVVDhsWnU3OHVJYzl2NzZmRHk5SDJjdmZVSmZkclVmOTdYck9RQzhoVUc5OWlrOXlqbXRZVzh4YjVQNjJIbzd0VVkvSGxHL0U4MzlZRW41ODlIWWZjclRKVUZmajVuUHU5Wjd6TStHUDR5UWZ6MldEOTljcHZRbDl1Mjl3N3FydmNkODNjMSsrSzFCemdIZ3phTmVsN0RYZk5qOVBzWDJWR29hV3REYmNmTTJQSTlUNzIxNk1aWmJrZG1QeGR0LzgwRFEyOW5zNjNUZUp2RTJtVWZFWC91RE9lYkQ4bHpiemQ3UGREODVFUzR0Njdubm00NkxPZ0E4UE9ici91emF4L1hhWXQ1ZWlYV0pKNGY1UkxqYW01dlQ4ay82Y0x6MXRYamJzNmxONmlkQjM1d0UxNCtiMzQ2Z1A5TmlIbEZQWjd2bG1IbzcyNzJVKzA2Q1crTjlFbk1BNEdIeTVpajRQQkMzWGUrNUxzL0hkbTY3MytjOTRmRmMyNzJleStFOHRYanBtZmpqZG15K3VQM00wcTRyYjdGdVo3UGZHTXJISXVZdjNPd254SjF0ZHJmUFo3L256Y2x3S1IrT20rZDBYQUNBdHhMMVRUdjdJZXpTcnp3YmVuTVBlOUNIM3VSNVQvcThmdUUvUHZHZTUwNkNQdlJqNS8zU3ROdjl6UFo1Ti90eS9mbm1KTGh5ZWNnQmdOOCs3aWRoTDhzbDVYUFlOK2U1M1JnT1Y2SGQvdmVQUC9uSG13bDl1UlF0WHZqN2RtbmFlamI3ZWxPWjR4bnRwN3ZYaFJ3QWZ2ZGhYemUyOTRscExaNmJ2QjRpTC9QbDVlK0k3YThjZ242MjNOTDEzVkgrVDUydE41UXB4eFBnanBlbWlUa0FYRW5VKzNDOTNvWjl2V2RNTEorTUtmM2RmVUp2eFMrZmllVnN2Vzk3V3c1VGVSRnpBTGpLcUxjV0grN3EyanZkKzMzV0dqNEh2WDNSU2hULytkMTYvL1orMTdqMVd2TzgrV1F4QjRDcmlQcnhycTd6blYzWFc3VXZ5L1BmK1BpVFpmN1d0SGh3YS8xU2xuVTMrM0p2OXVNMTVXSU9BRmNUOVp5T1hUNThLK3J4eTlSdXRaYVhlUENoOVdZeDJ6dkFsWFI2QnpnQTRJcWl2azdwMjI5SFhidTloUDNwdG43L2NMaU5henJlempXNzR4c0FYSit3SDcvWmROdnMzdkNuSXVqNWZkdHZUVHU1dHR4MERnRFhaa3BmVitzeDlYTDhHdlAzdFFuOWlYVWlYeTlvVC9uMDN1d0F3RFVJK3lXdDdoUDdFeVcySGx1Ly9yU1l5Z0hna1pqV1M5cCs0Mmwrck4xWjdrYStMK0xPYkFlQWF4anlkSHArVys1VGUydDVPUWwzdnZ3SEFJRHJFUFY4TXFWdkcxNTBHd0FlL2ZHOVBERExBd0NQVE1qVFlVSUhBQjU1Z2c0QWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FBZzZBQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FnNkFBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQWdLQURnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBd0NDRGdDQ0RnQUlPZ0FnNkFDQW9BT0FvQU1BZ2c0QUNEb0FJT2dBSU9nQWdLQURBSUlPQUFnNkFBZzZBQ0RvQUlDZ0F3Q0NEZ0NDRGdBSU9nQWc2QUNBb0FPQW9BTUFnZzRBQ0RvQUlPZ0FJT2dBZ0tBREFJSU9BQWc2QUFnNkFDRG9BSUNnQXdDQ0RnQ0NEZ0FJT2dBZzZBQ0FvQU9Bb0FNQWdnNEFDRG9BSU9nQUlPZ0FnS0FEQUlJT0FBZzZBQ0RvQUNEb0FJQ2dBd0NDRGdBSU9nQUlPZ0FnNkFDQW9BTUFnZzRBZ2c0QUNEb0FJT2dBZ0tBRGdLQURBSUlPQUFnNkFDRG9BQ0RvQUlDZ0F3Q0NEZ0FJT2dBSU9nQWc2QUNBb0FNQWdnNEFnZzRBQ0RvQUlPZ0FnS0FEZ0tBREFJSU9BQWc2QUNEb0FDRG9BSUNnQXdDQ0RnQUlPZ0FJT2dBZzZBQ0FvQU1BZ2c0QUNEb0FDRG9BSU9nQWdLQURBSUlPQUlJT0FBZzZBQ0RvQUlDZ0E0Q2dBd0NDRGdBSU9nQWc2QUFnNkFDQW9BTUFnZzRBQ0RvQUNEb0FJT2dBZ0tBREFJSU9BSUlPQUFnNkFDRG9BSUNnQTRDZ0F3Q0NEZ0FJT2dBZzZBQWc2QUNBb0FNQWdnNEFDRG9BQ0RvQUlPZ0FnS0FEQUlJT0FJSU9BQWc2QUNEb0FJQ2dBNENnQXdEL2Y0SmUvWThCQUkrVXVnMjZrQVBBSXgvMmNoTDRldHl1U2c4QTE2emI5VGlZMTlNaHZVd3BuZGQ2dXNmOTVBY0FnT3N3aEQ4d2NMZXQxdkRXOGhKYnYxeWVxTzJKa3lrZEFMaUdZVjhpUHJkN2VWeC9XYWFhZmo0L1VYdk0rN2hlVlIwQXJsZk1MMm4xMUFieWFIa0V2ZjV3T2p5eGxQNnlZK29Bd05WTzVldXFMWWR1THczL1ladlEvMmRjNnQ2ZjdDTjhkV0ljQUZ5ZnFQYzIzOWZzM3ZEdmwzR3EzNTVpcXoweDl0clBFL3VhYzFNNkFGejVkRDVQNWFrM3VtNjYzUm9lTFMveDRMdjdxZDRkbHlmbUY5WVJmanVsaXpvQVhFSE1UNmJ6dnF1OU43c3RjOE5yL1Y0Wnh6ckZnMy9aTDArbWZUMmQxaSs3MWcwQStQM0UvRENkYi9yY1duM29kalQ4TCsrOFBwWDlOS1g5T0wwYXkzbmJqc0RQeXpLcHg0ZE1mVW9YZFFDNGdwalh1Y1h6cnZhcEhqcmQrMzNlR3Q3ZVdpN2l4Vmp1WG96MWE3R2tpM0ZxaitmcXI3dmZweXJxQUhBVk1aODJ1OW4zUzdPWFZzL05ydi84RjNkZXZ6c0hmUjdYNDRYemNYbzVSdlEzenZzYjkrMk5yZjUxTTYyTE9nRDhmbVBlRDRmUFRlNkRkMnYxM094eCt2TDZJKzBZZXEvOC9NSkw4WVlXOTNTdjE3Lzk4Q0hxVXovN2ZiMmdYZGdCNEhjUzhzUFo3UE9kVzN0emU4ejN2ZFgzbGdFODlWWi80ZGs3cjcreGZzYndaMDgrbG5KT3NlUzIva0ZKK1ltVTAxUHhhUG5tbHJ5OHNUMnVlZjJ4ZlBKOHlzZi9xT3ovRndCNDY5UDRaaUkvM0p0OVB2a3R6V2V4dDhsOEhyejNTOGovZDFuLzAwZis3Y2RmM1g3RWJqN2xQZDVZOGhSTCsvcTEvSVdvOGhPeCtVeUw4M0ovOTVMcU1LVmRGTDNFbTRiNUY0RDV2YkZlUnZXY2ovK0JXZFlCNENFeDMzekJTajJ1cDM1NTJyZzVacjd2ay9uRkhQTXgzZHRQL3huTDUrLy96RjM3RFNESEQrUjRjMTRtN1BQNDQ3blkvRWE4OU9mckx2YXppUHJVWWg0MW42TGVaVjdxTXRsdmh2YmxrUjN4QVBCbVVkL2VOR2E5QTl6aDhyVHhlQUxjZkNoOFB5Ly9GY3R6OS9iaitRTkJuMCtCVDJ1TTU3cTM1MzhUbXgrSjVaWDR6QmZXZy9MVFVOSVFVL291TDVQNkllcHAyV1cvbEwyYXp3SGdvVEUvYnF6Zm1IWnlOdnNhOU9NSmNHMzV4emFaUjh3djJzVCtZTkRyNFg1eS9ZOHlYM3dlVDEzRW55L0did25mR2FmNnlyZ3JqN2UvWURlVnRHdVQrcnpyUFMrNzN1ZVkxK1dZZTUvV0FZQ0hGMzM5MnZMMURxM3paSDY0WWN4eTdEeEMvb3QyQWx3c3IvV3d6ODlmRXZUK2EwRTVScjB1cy9wNnV2eWQrUEJ2eHZLVi9aQS91UnZxalczUVN3LzY0Y1M2N2FjTE93QmNNcG9mZDdOdnZnTDFOT2pqZE42dU00K1EvMjFNNmhIMTlmcno1ZksxQjRLK1hPZVdUNksrL0NWVEgvMUwrL0JmeFBLWml6SC9Rd1Q5cFFqNjg3RzhzMnlpdnNZOFp4MEhnRGZyZXIzdjJQbm1STGlmenJka0g2ZmIrL25HYi8wczkzNGQrcjdmdy8yQm9NLzc3L01tNm5uN0YrUVVQVS83V0xjRDgyY2wzOTJOOVl2RGtMOFVJZjlBVE9rZmlwaS9QeWIwOThiNlZ0VDg3ZkgyTTlNNUFEeDhTby81K1NKaSs2dkk2OTBZb0g4MGY1MzVWTC9Wdm1obCtaNlY0NTFiMTF1OXpsL0kwczlydTkvL0NUQUF3Y0k4YUdVRHBZb0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+WGheW6lS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWZRQUFBQnNDQVlBQUFDY2xFQVFBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJPVFJDTlRWRVF6TkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk9UUkNOVFZFUkROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZNU5FSTFOVVJCTTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalk1TkVJMU5VUkNNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtGSVdNd2dBQUovRkpSRUZVZU5yc25UMnNOTXRaNTZ1cWUyYk9lZC83WWhiZkRTd3VCQnZBSmtUWUVkSjZzVVN3a3VVTmtJeXN0WXpFbCszRkVHeUVWcnNFR0VTS1pEdFlaQ0Zrc1RKSUpDQ1JXWUEzQkpOdEF1bGVSR0l2K043MzQ1eVo2U3JxZWFxcXU3cTdxcnU2WitaODNmL2ZHcDg1ODlIVE0rZTk4NnYvVTgrSC9PSW5mMFlJS1lVVVJsUlN1SXNTb3BaME1XS2o2Q0w0c20ydkcyWHYvMWl0eEU4cktUNWFTZk5qOXVjUDI2Yzh0ejkzd2hnaFRDUDQ1eG9wSmFTcTgvZmI4NzJFVEhNUVF1dDFUNmJQa000NW5OdlM5NTU4dkxFMzYvV2ZJd1JCRVBUZ1pOcXZmWGxycjc5cWpQaEhiY1EvTkVaKzUyakVYeDJOL051REZ2cWdwZGpiQy8wODJBZlN6Nk85Mk1jTCt6anhlMy8ycmQ1eGF6bzBJU2pBdkZZQjVBN2cyMHFJSGYxMHY3OWpMNzlxNy9zdm0wcjhTT1doTC8xekpYUE5IWS9QZURVYzZZUzB2NUlDK0FVQVI5Q1VCTStWNTB3d1Y2Wi9ib3VoUHZqRm5IQStFQVJCMEFPR3VoVGFtSjM5cHQ5Wm1QK1F2ZnlFQmZyUEhoMjQvNSs5L08rOUZsL2JhL1B1M29OOWIxRklGd3Q3aTZ1eHNhMlpuZDZkMTlaZWJ6eThDZUk3Z25sbDZQcUhyeXJ6V3hibXYyVHYyMXFZTS9DdE0rZm5LYnJZWXlnNW9MSVdLOTFsSXlTRkNWUjFBc0J6aXdDWlBwNXU3SzNOQ2U2Y2Zwb0Y3bnY2VDgzT1hOOER6T1BGRXlJREVBUkJGM0huenJRNVRHcERjTGZrczkrNUZ1cldmWnNmc1VEL0RRdngvM2FyNWRkdkd2R2JHeTIrVnpXQnQyUENNZEFka0ExWmRiR1JCRy9CSUxjQUY5Y1ZRLzNUVjhwOHpmNytkbkRzUHV6T0J3N1BwNE1Ib0VzUEJvcTY4MW11NFFxZE9VRjlFYlJMWEh6bTlrWVRSbGVlcXhMOTFZdzVDZXJHTGk0WTV0VjlnTnljdUJpQklBaUNTc0d1bWV2R0E1MWR1emdZQ3JOYjNtcTV0WmYvV2t2NTZkdEdmcW1TOGsrcWhyYklaUkovTmNGNEk0VjM1ZzdvMTViU0Z1YTF2WHpsdWpaZklMQno2TDF5MEE5aGVaVUt0ZE4xNVYyd3NyNjlXYmtIckxRRnBabUI5L2xnWTNqMXNlSjQ1TTdwQXhrOTEweTkyRFRNNVIzQ1BBZHlBQjJDSU9qeVR0MTB3ZXpnZ2JmMi93NUtjbWg5bzRtNTh1MWFxVDlXUi9FZkxXMSt6VDdzbUhUb25Qeld3dHdJNjhZSjZNK2UxZUpQbmxYbWt4Ym8xcTI3MEh2WVZ3K3VQSVRiVzVBVDNJWmhkMGxRUDY0QWplRkZnb3RsTDMxdTlJbkpFc2JhOVJHOWxsb09MMW5WTHBJd0F0OFVLR1VhbEViYjg5Q3J6dU0wbUFQb0VBUkI5d0gxOEJYTGFXZkdjUGk5SVpOTmUrbGtvTzMzTkxQV1lsOEorUVVsMVRzV0lUOW5ILzU2QlBSSytnejJTbkNJM1VLOGZxYjBONS9YOHBQWEZIcXYzZTBodzczeURqMkUySlVIUWV2S2V3eDFLZlBHeUJYSlhZMTlkak9kMFQ2WDdDNExIeC8yejVjbXo5dkZocXdyOTc3bEhBRE4rRnhNUDRIT21HUC9XQmNGK1hEQllmS2ZJYUFPUVJCMEdZY3VRMnE2YytjRWRkb0NwK1M0VUhWR09lSnNudGxBNjAvYTM3NXBuL1N6OUxDK1E0L2RlY1dYcjE1WCtsTlg5aURQckgyL3NrZDA3dHh3QmwyOGJ4Nis3NldTQ1diS0NPcVZDNzJmd3AwU2dKL3cwWm9WeDVaMW5WZzA1TXJXRXNsNDBqdDFEM041SnpCWEU2c2ZrLzlEQU9vUUJFR1hnVG9uUW91MllveGNPcGVTRTh4Tmx3VFgyVEQ5S1NQVVYrM1ZMOFRIVTJIdm5HR3V6TTlkMStiejVNaXZsUlk3ZWJTZzE2NThUYm1TTnBjTTF5WEJFY3psNE1WR1ZLSnM5UldoYzk1UEZxT0RGeTRHNUpJWFdnZEd6c0tYRTZ1UnNwQ0MwY2ZMQTFPNjdZODFueVVFUVJCMGdhL2wrQkp0WVN2ZkF5WXdkOHNKNnFaTlZyOTIxei8vaHovL0h6N1RCN3IwOWViS2ZIam4zSGx3Nmhib2xERFgrRkM3QzdlM0lKZCt6eng1ZWtPUVNMZlh2SnpvV2Rmbzl1dnpsNUxIOE9OTXRIQlk4b2ZnOXlQRjVJckR2M2VSKzR6SW1UZDNBWE1WWWpVemF3czVFeTZCSUFpQ0xncjNDT3loTkp5UzBRZVJkRUdzSm1aLy9YTWYvN2NwaC83Ymx2cHY3L3lUUE9URlJqUkNtV1ByeXFYL1B5a0xOcWpqeDVDYlZRdGQrZ0IwUTJDZkxlaXhGS2owUHBLZDdPVDg1eEE5MWpuekM5YWE4NzhNdFJER2dEb0VRZEI5Z3IzMWc2SkxRQTlRRDJEZmNRSzcrU0VMOVMrM2FQTGg5QisxZC83aXR1c0l4MCt1ZkdtYW9wSXVDeDhwYzEvNXNzQ1ppdWwycmpsWjkzeCtpUGVQdjl5ZGIwUmluMkYrY1JPOWg1UGF6QmE3Y2pXSUlwU3lHK0NHSUFoNlNGQlhQa3JlZ1YwRXVQK0NkZWsvR2p2MEw5ckx4dlZ0OTluc1NyUUhZRzVSU1pXSDZ5ek1jODZWMjZNdWMrbnNZdWVERktzdjA4ZFB1Zk1xNm1BM3hiOEp0MDZ2cVpzTC9VdVF2aGUrQXFnaENJS2VDTlNEd2E1VTE5ek44M3RERFBkQVo2aC90aDNDNHAxNTdXMSt6R2pKSGN5YUZUQWZ1TnRGUkRjVEVEK0RGb2JiWmIxTlJ3dEszWHB6WEZlWHY4Q1ZTNStBV0JUVldPclNFWGFISUFpNmM2Z0w0ZWV0ZUVadnBJbkIvdG5mLzl6SGxiSjNmc3orOGs3dFkvU1Y2cnEvcWJqN1crQWZ3VWpyQXBpbkV1UXlEbmZXcFd0eGlmVHNwY2x3bEFnWG5HOFdsbE5RcDNwM0NyVmZRdDZWejBOOFNlaGRBT29RQkVFUEFlb1JrME45T25kdWRaMWUzeUdXVTZlNFQ5USt0QjdDN0NGZUg5djlIZ2d0bEdRb2c4ckNQSDhUdVZ4enVDbHp4OXdQN3ppOUNGZ0xtQ1VaNWx3Z3VCM2NKUDBwbXZSN2pXOG1tQi8zRjNIbGJwR1I3dnBHNTJoSzNtT3lESDJpTmgyQ0lBaTZPNmo3ZGlBZG82VTM0SzZibk9YNFR5djd5MCsyVTlPb2tOMVBUVk55WnZRSk9VM0swRjRJOHdESEpRbHlacGdKTG1YL3N0YWhMOGd3cC9OMURYUVN5WDY1cEwwVzdQb3l6cHhkZWJYR1l1Ty9FQWlDb0VjSTlzQm5acldmbE9vWWJqNnE3QjAvSGg3UXRaYkx1L1BZT1k5cnFNdkN1UXcvcXVNdWJUWmovSnp4RXdIZVArYUNvVEYwbnJ6M0x5ZUJtQTUzMjgvcGVIdmVXbk5mMTgrTG9teXQrOXg1eVFYL2hNNFlGWUVnQ0lKV3dUeXVOSk1SdC8zbHg2MURGeDlSOFFqVTlza2w0WEJ5bm5zUHEzbVk5NXErdE81U0ZMN09jZXB0THI2WXBpbXVBYWZ6SEdlTjU5MTZ4UElMd0Z6NXNqazFBOWdTcU1PNFF4QUVQUzZ3TzU0b01TeHBjeXgvRVVBZUlzcUx6SmNPNFdRekMvT1JHRXlGTHphS0JKeVlKRmNhYnFmenE2Zk9VMmJoeVRBL1Y2MTVjT1ZUSGZja1F1OFFCRUZQSHVxaEVsejIrcnkvVUZLYTdYQnJXQzc5dXFkczhYaVB1QVRtTktLZFhYcmhYbm9MOUxzdFZ5TTMzRVlTSmtQK1VkTVlPallsd0oycjFsejZ6MGt0SFpKK0xwZU9zRHNFUWREOXUvUEVOM0s3WFc1WnpyQ0l4cDR1aG5tQUdJWEVDZXFGTUcrdmJiWkZZS0FHTUpObFprc2k3cVlwYXloRHJyamVwa0UyOWI3T1dXdE80WDZLRUNoMUlSZCt3bDQ2SnJCQkVBVGRHOVM3Nno0TXI3Z3VmSE1XdDhXaDl3aGtzcWcyWGFXaG1ZSkhBRWdLMGt2T1U1ZjFiNWYxTG1xZldqWjhoVUIrbHZJMHY1aVF2V1M4MGxqTTFOMW5jTlhHQU9ZUUJFRVBEUFNxdGV3YzBqMEQxSDJvZWNud0ZsbWE4VzdPTlMrOHBDNWJPV2M4dHlBWnd2eHdleVpYdnN0L0puTlFMdm5zRjV0MkE1QkRFQVE5VU1jdVJKZlU3c0c2c1pmcVpMZE9VT2NzOGdLWUwzSHBMcU4rN3EzTlhFTG0rZHlIdE5tVko4SlI4eFp1SEhNaXpEbnhiZU0raTVIN0wybXpXL295UzRCdmxwWDRRUkFFUWZjaU5RSUV1Y05xczN6VTZjQkpFOXhNcWtWc3hrR3lTNTlMK3FMajliTFQxOFRkelh6bWVmZ01aazI1ejJhM2k1Zml6bmZaMTFUT2xVL09qVDhsOUw1Z0w5MEE1QkFFUVk4VDZES3hyMTF0cDB1a1NxQitDRkNQSUpNRFRhaXZMZ0xWQ1NWclJYdm4yMFIzdS9STHNqTS9FZWJPbFY4TnhwMFdPUEd6dW5UalFCNFdUUUE1QkVIUUkzWG95WHRyRDdlVmJwMGF3aHh2Smxxc3lqRklaeUlEaS9hb0V5MWlaeFBXZVA5Nm0xOHd5TUg3WTVpdnJEV25SUXlGOXBONzlaZHc2Wm1JQlozL0tQb0JRUkFFUFM2Z1Q0Vm11YmVjQjl6aUdtZ3ZhanpERURiellDTHVrbE9kd2srcUovb1EzTG15TXRycm51bXB6b0NkcytYU2daQmh2ckp4RERlSjJWeDFuNnRjQ2VaRkxyMGJKbU1Dd0RYY09BUkIwQk4wNlBrR0lyUy8yeVpyTFlZNmhhWDMrZGVKdUNucmdyMzBrNGF6eUdsM25nejd5MlNrWUZXdE9YMldkdEhBRjdYV2lhOXo2UlFwWVpEckJtRjFDSUtncHczMG5QTUxDWFBCVlM0UHdaTXpkazVkenJKSmJTZGN1dCtiWHlOZVZFeUVsZFgydWlpem5XRytwdGFjRmd6Mk5iSzVDVkpNUjB2V3VIVDZ2RUlqSGQwZ3JBNUJFUFQwZ1Y0SUQ4cEl0MUJmNDlhNW5DMEdZYTdOYUx1UG5WRTJiRDVUc3Ria0lkemJWcGh3L3VaNFdMNmc4RTFpYU1FZ0Iva0k2eHU5ekR6UEQ3VGhMUWFFMVNFSWdwNjhscWV4QjQ3UUhyQ0ZFOWVHTDloSDVuMW40VnUrWmcvdUFPaG1ycHZDRXpvQmdpRTVUV1l5elAwNThJSmsvMmJoa2tseFhrQi9XaHYzbjgyZm9wbHc0ak9mQjdmSE5RWk9ISUlnNklQcDBLZmN1Y3p5a0pyUU1LeEt5czBHVU8vdnFTY096aU5MNnd5MC9EN3dFcGhQOUlMbjRTdHFlb3JaR3BpM3JqelpyRWZtWGJxYytGeFNXeUdVZUtpREcwZFlIWUlnQ0E1OWdmdnQ1cHBUaU55RnE1Zk0vbWFuVHU2Vjk1UFRHZW0wMzJ4dUVvRGljcmlEdmIrZVBMYyt6dzlwMEpFNzMxMG4zbS8wUG1qL2Z3bk1PZkV0M2lzM3N3NmJ6dGxrUDd1VWJUY3UyVEE0Y2dpQ0lBaEFMNFBVOUoydTA1dmlzYUdsMmQ5bWYyTmgrbXljMWQ1MnJYUEFUeWFnaFFWRjZSNTA1bkd1ajN5Vmg2Z0ZwcjR0aHprM2lkbnNDbXYzcCtMcnFRL01oZElaNHVjYXpRcEJFQVE5Q2FrUzZKVTRZSGU3Y2xuY3BRbHpGazZhblcva1lBZlBZK0NueEl1R3dtZ0FPZlBNSWtQdW51Y1hCUmFnK3ZaMVdRZzdsS09SMng5VkFjakZuL0d3Z1kwYnlicHZoOTlBRUFSQlVBL29YTTZVQkpZc2R1ZWpXd2hzVkFKVzBveUd3c1paQit5eTArVjJEUFhocU5aSmhXenZFY3lmZFZzSEJPVGhLRlNDZVFrODdmdFV0RERvTmFWWkh2b1lMU3lNRy9qaWh0MGNWamV4Z1NBSWdwNithb1pFbzRXaHZmQksrUkdxODN2bk9aZmFYcVdhOVYzbEc3Qk1aNnZ6L2RhcDU5dzROWnN4QjNWQ2k5WFVIbjI2ZDN4NGYvcjIxV3hYdVhZNkd0Zk5EOExubzJpNkZDVjc2YTZmK3RGdFd5QzVEWUlnQ0NvR2Vnc1NTalJyZkdKVzVlQXU1eHoyL0FRdjE0aW01cDd1VXc0ejdKTjNVSThqQkJVZngreGY5NTlEYzljTDNtUnFUNTlyNlRNUkJJYjVYSzI1VXE0UlRTODdmdUdlZU84Y0c1L2tka1NTR3dSQkVIUUMwQWNBTk5vSVEyVnBYTkpWTUNOOVluWTNPV3haUGVja3VDblgyMEg5K2RnMWswcy9xdDZpZ0RMUERZWDNKeExRdU4zcE1FT2RHOWZVcTJGT09RTHN5dWwxVGFwSHZTbDA2UzViSDBsdUVBUkIwRVdBM3RITmwwVVJ1SHkzczhXOTAyVUhmRTRZYXpZT3NCa1hPb1I2Vng1WDgwaFhvMi9FdWhNWUFEbFJkejRMYzNzdWlpSUljYWkrb05uTDZEM1NaMHI3NHBod0JrRVFCTjBKMERzQ3VTbWIxQkNHOTQzZG1OTjJQMzNDblEvaHludk9WeFhETXhlQ1o2aFRvdG4ydXY5c3Frc2ZkcWFqYzhzNWREb3ZQUWkzaDFENUVPWVVQWmlDT1QzdjZxMW9HOEtVUVQyWWNqOFloYmNldVB6c2lZWFY0MzhEMkRLQUlBaDZvRUNQdjZoNTlPYU4rd0lucDhvVHloWjJrSlVFeHhjdVllNlFkdHg4SDhFL09qWm5vdE5lK20yM2w2N2Z2QlRWOHg5TUxDeTYrM3RjRGdOWUl1aHdsN1ZEM3ZsektkN21hbUZVd0xlTGJkeFFGRjZrUEdiUXlZVVQzZ0IxQ0lLZ0J3ejBBZHpiaGk4TWRqVWVxRExUd3BUM29lM3oyQmtQOTVDcFJ0MjZlSFg5QTczTWVtWEIyZ3dmWDFvL0gyYVFENkNqYjE2bFE5OGNKYmppMGJIdUxac2t0TWNRTSsxa3QxVlQyUjRFdERQdGFKT2NOb0E2QkVIUW93VjYvSFhPTmVIdXA2U005TGFNcTRBaHRKOU4zZUFzQUVjdW1aenR6ZnRDV3FqM09MdDdacDMzKzh0NU5heG50OURScjcrZlRFampMSGlDZVJUT24yN1A2a0ZPb2Z2SGtPUW1mWG1pekFCOEN0YWwwUndJZ2lEb2NRRzlBN0IxcE1KZWJvNHVnWXpEMjZvZ1E5N05DZWNoS09TK0k3ZE1JV3Y5NWoxMjZ0M0RYWHZWOEZpQ3U3cCtNVDRkZ3I0L0ZqZTdxVGM5NE5EOW81STJqalRza3Z2c2lSUG41aS8wdnJuam5YbGdZMHBsTjczTzhUbzB6OG5iYlhPdTg0ZERoeUFJZXNSQWo5MFpBWk5DMlg3Zm04ZUhoc3p5WE90WWVoenRrZCs4N0pXM09hajNvZDJPVjgzTytwWWpTUGRnUG5pTnNGQklMUXo2blBJdW5RYTJjRW5jemYxbnF2ZmNkZ1R0aVphMi9jOEk0SVVnQ0FMUUMrRE85ZUsrcXhwM2FOdGVwY0hyZ1Nrb201eEhyTjUwczhndFFGdW8reEk2U1lsemVqK2JaYzhsYiszK3ZvZDV2TGZ0cDZPcDdYemlHMlhEaXpDcTlENGNhQ2doSEVLN2RkNG1BVzRJZ2lEbzZRT2RtOGJRMVF2ditjWkpkRlJLeG1OTG4yVmRNSmVvV1Fqcm0vZmJNalVIOWZlRWV2WWg5emo3Zkc2Q1F4Y0w5emdUblV2c0NMcjhPbDJqR3YzNnZiNHpwM0kwU3J5THU4WWxRT2pLN0pyaVNYSm5FWmNHK3FZK2NXbmVxT2Y3SFlKN2ZUTThDSUlnNkpKQTU3S3dTcmx1Ym15Z3FaMHFBVFFHMTNucnBnTVVBM0Jwc0ltYlVEWnc2NVJsZnYwaFRvd0xUVmc0L0g3elNxaXI1M3gvR0s4NmJBTnJmQ2llOXMwRHJIdjkyUW4wZlB3WHlkQzA4YU5LeWMxZmJHODgzcyttUmN4Y1Z6NlQvUVdDSUFqNndEdjBBSlkyZjhwQmhjUFVNbktBbExVZEo2dlI5Vk9uZnpFMEczYmRvVVRNRElhbXNGdTNEdHFCL0dWYkNtYWFIY09jbXIwMEwvLy9lT3lxa293OGJnYmpGdzl0NHhoYVJGeS81UnJrRE1CSXJWamJzYTduekZRUGJydjluUllqVmVlOGV3c0cweTBxTHVLeWtiQUdRUkQwTklFKzkvM1BDVzBoNU90YnNWS0oxckIxNlNraGFmdGNUcUlUUGlPZE10bWp1bmFHdDRXd09SNTVTQXZCM1lYS2xRdTFFK1RySGJ0Y2N1c2NnZzlaOXBIVDVwR3AzTEJtRTcwZjQzcXFIL2VURFdhS2VVbFJEMG9BbEFQM3pTQXRkOW56WlhKM0ljVFlJUWlDbmd6UWMxLzAvUTV4N290ZmtvT21VSGVBa1ErSDkxejVuSEUvdUJuZ2t1RHFaNDA3VURvUUd3dHhBalRWa0ZPWE9BSzNmdlhQUXRMckVEaU5XMWhVWE9wbVJQUHFYeGptRkY3dlpidjdCRGt1dDFzeTVXdzRKbmF6N1FhMVNOa1BwVDk2R0FMbUVBUkJUeHpvR1RkSE5lVXE4dkxVblMyKzM3dG5ZNW8rTTRhbFg1UkVSMjdmWGhxQ08wODR1M1lMQ2V2Z2xYMFIyaE52TE1pcjUvL0czMmZhNDBsZlIrN0M4VDd4alVMc2ZzSEJtZmZIMjJtSXR6WDBKb0wzbFZzMENKTjNzRk1kNVI2NDFrVUY0T0loQ0lLZUdOQnpYL2FSQ1BBdDVQMTkrdGdmakVKUThYdlpMZHk1Ny91dEg2N2lKcDZSTzZjd1BUbHdSWlBjak44Q3NJc0ZDc1hUN1FSZzNrZm5mdXEzK2FFd3RIY2ZONTRSUHZTdjBoK1JNYVZBZTF5Z00xUGpZT0hpSVFpQ1BzaEFOMks2cmFqay9XYTVxM3M5MjAxOWRGM1lJdEJ3RXhmdDk4TTVlYTUyV2V6Vk05Zms1WEJqZVY5elFodDFlcU5NZU5jUjdyMytBb0V6NjYvNzV6VWNNbU1ldy83Mm5TQWUvNVZBRUFRQjZFTE1qVlBOM3NOd3JmcytrZmUvSThCUTV2dit0ZDliOTRsb3RJL1BQNlhQaGovd0hqejFjUThRbHNPNjdoWFFlcW93LytBc1ZDQUlnZ0QwOHp2MExEUUg5ZC9EK214T21IdkxaWkZ6Zi9kclRwVGp4alAwMk1ZNmVMTnpiajRDbGFzeFAwYUhWY3ZHZzBLbHF3T1V4MEVRQkQwS29JZXM3cExIY1RLYTdwdGhPY1o3NnhLYlk5ZXJQUU9MMEVxMmc0ZDJKV3ZObnBQejJuMTVLbHVibWtmTzRmWjQ5cnFaZE9hdHcyOFhBdWRjRE53dkFNL3F6Z0Z6Q0lLZ2h3VjA1Mmc5YlBoTE91b2NOL3pTamdIdkg5czY3Y0l2K0tsSGNSMDVnZFR2ZWV2Yk4rNDFHTjZTaytHb1Z0MTF1bk1OYzlUdWhTdWRDd05WYmwvM0QwcUxBTTYrWDRCY2hybm9Xck9XdUZXcDJuUHFSUVh1R254bmZ6MWt1VU1RQk4wLzBLazBURm5JU2VlZ2piWndwSkpxYVgvS0RHcnZDa0RlL1hKeW0yL2ZHdHE0MHY1NHFDK25zalY5KzVvN3J4bFRPYWhiUUZOaUhKVzFOUmIyTkVPZHA3bUpzQmN2ZkRPYmwySlZhMXNmYlRCQ3IzaFB2Tk0vemNmYzFMUjRKT3BhZDMvMlVEaGdEa0VRZE85QVorZEtZVzFONFhNVE9lbjdtQ1FtdXlFcDlWYW96WGo2R1lmaXVTZTdHL0JDTUhmSmIzc3VNNk5HTmdSLzZpWm43RSs2bjhCUGs5cGs5VWJJcTdlNlVqU2x1UFROTFJCdTJ4QTlmeWFYV3JTMHh6V3pmRFFMUDdzVzlISzBPdkFQa2ZPUkdMQWJnaURva1RyMCs1WWZoY3BYcVhsTXRjbkF4dmR3cHg3ckJCNGVyUElEL0h4eTJkUklocnZJbVZlK2JleU9iNjlldk0zUWJsNS8zeTBHS0dtT3ByeFZXOWZTMWtNdXpHSVBEVzNDWkxqWjVqTVBSZkZDd1N4a2NYRkNvQ3duTy9iUElRaUNQZ0JBNS9ualY5R0VzZW5UNFBubDFKclZKOGd4K0NtRTdsdkE4bjc2Smk1cE0vdzdRWm5HcjZxckZ3eC9kdlo4Mnl2N25KdHUydG9BUXRJM3YrR2JhTEZCcldSOWQ3a25DYXJpOXdSSVF4QUVmWENCSG9XQzJRWFRoREhPVkZNWnRuUjk0TGs5SzJXc2gweDNLYm5yVzNEeEJHWWV3bEs1RWFrTy9HNWZuQjhuRmQrdi9UNDhoZHZkMUxiMzIwUTQ3aVpINFgzZktuWjArcjRlbnZmZStYWGQ1RG1YakJjY01VQUhRUkFFUFVXZ1I0MWJLUFJOczlhblM3djY5ZWpzb3Zldit5VnJEUE1YblhQbWthNitsanpzdS9zWjZPM3o2SFl1Zld2YUVqdnFMRWV1blBiVXcxaFlXamcweDF2WGdDWVQ4dWRUb0wxNWVvNWRsS2huZnZScU5KYjFvbnZ2RUFSQkVIUW5RUGV0V0IxSWZjaDZhWG0yNytrZTlxLzdNSCtyQjNORGJwd1Q0M3dXZkJ3TjhEL3BkZ0kxMWJNVHdEbTg3dXZYNlhodXBLcHBGd09jT0VmOTIrdmRZSkpjRnowWUtSckZLa1B0ZkJnc1l6VCtoVUVRQkVHUEFPanRRQk1YUW5jWjZqSmp2QWRkNGVLbU5CeGVmNTJGWUJ4bVp6V3VwV3VJQUV5NVlycWZlcnpUNDNrazY4YVZyRG1vditBKzd6MW84NExpNFBiUlE4MTdFdWFKQ1d1MGx4L0s2emlrNzRiRjhBSUZjSWNnQ0lJZUJOQWo5K3M2dEJHOEVuWFNNKzFjK3hDa0ppOXZmS2hhSjE5ekNIUEtkdS8ycjBVTDZPeHBiNjhaNkd6Q2IxOWI1bTdhOGkyQ05pWEw4WjU2RE95UVVhK1BibVFxWmNVdkNqY1l2OEFKMnc0YjM4VnVBSGVFNXlFSWdxQTdBYnFVYlhNWDF4cTFHajVnN0xiblFDZWtEMGtmSEdoelVLT0phRmZQQnpCM2s5TmFJQ28xR0xJeWNNekMxMTZUYS9hTEJ2M20rNko2OW9QZHl4RFV5YW5mdmh5M21TVUFheGNOb0Q3eERHWit2YW41NXlrajcrZkVWOTFFTnpmci9kQzF3NFdEaHlBSWdzNEtkSGJnbFdNNUFUektSbS83bUplQ08ySFkyZm1TUzlWTmZoMUJpd2NhYnlxcjNtdHk4bGtFWFU1aUMvZjVQdTdPWURmOGV3aVgwK1BhMERydGxlOXZoTnBlOWFIT1pXMnZ4L3YzSHRpMEpVRERYcWpoVGFpYlA4Vmx1K2x3bGN1ZTU4WStSL2M2dVdnRkJFRVFCTTBDblJQYUtBT2N3c01XTVpWeVhlT2tLSStnejdsMDdwVis2NXpwRk9pb3RJMWhLM3NMQ1pjd2Q5Tno4TDNISEtKRkFyL1czaC9IUDR3ZTcwSEplK3BScmJsYng5ajdkODk5bDdrMzZiZklydnJJM2Vnb2xOOW0xNDh0K2VqcStENFR2UlhxVGU4akVkU3h6elFlN3NmOGNCb0lnaUFJaW9IT2JyUFNEbnJNeUNWdFgwdG9iNko5OHVuamNyZTNkazg4ZHZtMGIvNnE1MXpsQU1qamM0NkJXWE80dkRkOTdmYWxkZVVmNmtVYzZEcWRBOVd0c3lQUHZTUEtacjk1eFNEdTc2K3YzUk9QUjhUeW0ydlBPOVM5dDg0ZCsrNFFCRUZRMXFFdm1KWTFHWGJ2WmE0M25DMmVER0hublBrb3djMUJuWTR6ckVrWDFiSUVmWUsvaVVlb2NvTGFyZXRZTjN4L3Z1dGN6cW1IUllGcDdPWDFlNzdVYlR1WU5GZm16cWRQbWg0clhSbmdDTzZEcVhjUUJFRVFnSDZhRVIrWG83a1NzVVB4WGpBN2MyNnhPZzdiODlDVWdWdW0wakJaNzVZQm5XckxCeUYvM2pQblpqTzdVVm1hQS8yMFUyK1BFMHJkd3Y3Nm92cDdVM2lYL3lXVXh2a1o4L3g1dCtOcEVaNkhJQWdDMEVmT01VL3huRXRua0JNd0p4TGUrdFQwN1dEakpMTVJMRzh5MXJXckRaZWx3MFVTR2ZIYXVuQlZiVE5SZzYwL2g0SWU3dVRZZmIyN0d3NnpYZXpPZTRzS014a202ZDZQcEVHc0twcFByOXY2ZHdpQ0lBZ09mWkZMZC9YVk44c1N1Q2dSYjNzMTdzZ1dRWTFEM3NOajBpS0E5NjBISURUenBXVDB2TkRKclNPNjVxRXQ0MXB6MDBLZGg4QllOMThFU1I4U3B4NzAzQjgrVjFZM1MrMkZDalBPT2NGUmRYQnYzVHRDOHhBRVFSOHNvSnVZM05NdW5SOGJYUGtTMFpRenpoSlgyZGZKN3IvTFJPMDU3MmZ2QjlFQ2FneXpHenpXOTVnM3plQzE5cnduNzhMNHFmYXVOZGZFTTlSTG93OVVIbmZqUnJtS2V0T0Z5VE13bjU1RnZoTEdCSGVwMnYzMnR1WWRlKzhRQkVGUFRtb1JNRXdFL2VQQmg1aVh3WnhicnBJYkhrMWI2OE9PNTVDblRwaWR0SWt1emhXbm1zS2s0S3NHN3I1OVJjNkF6dzBTTjEyam00bnRnZVJUYWNGRFUrTm9uNzAwREc0bVlENnhLSmo1NUMzYzNmNjdHMW5yRjBaUzRyOENDSUtncCtYUUIvdTh1UjdzQlBLVnpVOTRiem5VbUNmTnY3dVI1NVhublBBSVFBdWRaZzVnRkNhL2Vja2pWdFB3OUZEMHRlMmwyZnZoT1B4NFd2eFV0ZTkvbjNIbkpYdm5zNkF2K1JpVWI5cG5YS2tpbkRzRVFkQlRBZnFNWmVSOTRjTUpuZEUybzRZeEthaTdFclUwek9Yc252U3MzZlY3OTgrUzJlc21OSTJaR0tIcXptTUYxUGtKdmtlOGZSMkdlckl4elgxSStyK0Q3TU45eFVJQmdpQUllbWhBRHlWa25PUjFXc2N5THVkS05ZeUplVXMzYVozSmFuZk9tanVxdFJuZWNyVkxwK09Za0VRMmZOdjdHK3ZTcTh6Q3dad085UUIyQ3ZGVCtKc1dEMHFWTFVhS25QdkNCVTZHNzkzZlNBTHVFQVJCancvb3c0bGpUWGtTV0E3Q294S3VuRFUzWEVLV0MrVnpZNVhZMFJiQkpmTVkza2V1MnhHc1E5anlWRFpxQXl1bk84QnhyYnFVL1lZMVN4U2F4Q2cvdEVWVytYTmZDOVBTTXJsNXdnK0tBQUIzQ0lLZ2h5UTFMdmZTdnA3OGNEck02MTBIODVsNTRyUDE2MHFKYk1aOTA4emZIckx5dzNrb05RMWFUdmJMdE1HTmJ1YjM2TUcrV3ZSNnZNZGVPamQ5UmRlNUluYytkNytNNEM2UlVBZEJFUFNnZ0I2N3RRQ3lncjdyMDkvN3lqV01tVzNQR2tLNVRUN1U3dUdiTFNrVEp1MjBoZWoyL0ZNMTZiUUZNQUYxYmlhVDJtWkluQUwzbGQrczJkL3ZPMTd1RVUvWi9jTmNoYldaN2FlNjZKS25BK3dRQkVIM3B2aHJXdkV2UFBmNzZCenRxUkJRSHVZcU16Yzg0ZFJwbk9uVTY0YU03TDQ5TnQydk9XZlB0NXVzMjVSVEFBNWJBTE9BOHcxb2FPUXM3YXNyZGVKZko3VE8zYzh2ckU3NFd4bHpoa0V5RUFSQjBJTUJ1ekxSc0k4NHdMenFhNXVkTk1GOEptRXQ3Z2JITTg2YlNRYzRIdHF5QUM0bWZ3Y2Z0MkRrYXpyeVByNVIrc2pFV2JMWDI0ejRlSGI4S2U3Y3pNRGNnTnNRQkVHUHhKSDNlUzI5UTlkbXJ3ZHNXZ1YxSHBoeTFkVTJ6OUdoRFRFWFpJbFRzcGc1OVNNd1kzZGZBTjcwRFBmOElvV2dyclpYNXl0SjB5R25ZVDhSaGovVlZadlRqb01FT1FpQ29EdUZlWHlqNXVDMzNGUEkvWDJPV2d0MzQ1cmVJakswVGUwTlhadUhlZ25NZTFQVlRNb1lud2FUb3FsdDNGYldGRVVjL0ZFWjZuTGhpTmRac1BzYTl2bEJNUUFzQkVIUWt3Vzc2VUN1T3l5K3J4b2ovb2x2TkZJRXNNY1d2Z1RtSWt3ckcyMlptNHhURnQwZThlenhxMG5UYmVhT1lacjU4NS83OENpU2tHb05tOGtKNkFhNzdCYTNpcDBIdTJ2d2szM2ZNekF2Mmp2SGVnQ0NJT2lCdW5USDVnQnlZamN4bkZpdTdKVy8xNEgwb2JJcjV0VWtERGNkekRNd1NBSEVoREt0V1podmZPYTRtUVRjSEl5VEVmZHc0Zks2ZWVnNmQ5ek1nRE05Mk9Yc1VEZG1IdXpGZEVhNEhZSWc2T0dEUEpxU0hURFF2L3k5ZGVqeTcreUY2RzZKYjM4SzJjRjlDcllFS1hhM1p2YTdmd2gxNTNZTHBLcWs4MTBDOVBrb2dDemU3K2JTdWhsWG5uemZsNEI2RCt6SEROaVhUSFNiNGphZ0RVRVE5QkNnSHZqTXJCYU8zWTdoOGp2cWFNUmZIY01OT2p6WVFUM3Awb09qVmRYMEYzNEc2aTVydktCNUNtWE1KOFB0Zll0dFpsclNtb0tXdGUzMHNkbFBNOVdhTmczeUVUeFZQWjlWdi9xdnJBZk5jSmI4ODRBZ0NJSWVpenVQR1UzTUpuWVR3NG5sRnVqeWJ3NWF2a3MzSER6VUc5UEY1bnVwWUw2VnE1QnF0dk5iRXVwWko1bUFMTGRCbGRuR01Ncy9qdkZpb0wxd24vaXlCRFl6MDBVdTZZTGJmdldWV3d4SmRhRy91bTQvNCtHbzFvdnNuU1BjRGtFUWRIR1lkKzdjTWJueE1EOTRtRHVHeTc5VkJ5MjAvZVdQN01YZTZLSE9EM0pXdnYzZUpnaTFlOXE1TC9RSm1JVVJvaVVRSUJjN1RGWTdHZXd6enlXZ2w3aG4vejZNWGdqekxoemdJeHpxZ3Y4Q3RJTTdaY2Fub2dXTDZJMjljd2lDb0h1RnViL1NzQk4zakNaV003T1ozZktQZnVVYjM5YUtmdGxyK1RWNzJmczcrRUVoL0U1UE5BUWZEend6T3pRazRWeU5XRGJBSkV4V3k0RmsySmQ5clpPTWpzT3ZWeG9PSjJBMit4N0lpMkFldjcvcTBsQTNMZGpYUkZNZ0NJS2dod0Z6NThxN01Ic0VjdUwzbmhqT3ZuVFBONGgzYjdYOHVyOU9EMmlkdXBZMGFuVEQ0MGE3REx1Rms4RDBjZEdnbHk3OGJTWko0L2JINTdPNFRZRGF6R0pnYmc1Njc2Z1UycVpMZHJFZ3BoYzZMZFF2UEJOOUJIYnNzVU1RQkQwbW1IZWxhWTdOTWFzdHUvL2dsNzd4N1hjWjZKN3c0cWFSdi9tbWtkKzdkUTl3VHhDVk9JcmFaY0RyWWRwOG9WUDNMVXpMYVU1SmQ1dDUxKytvV3Raa3BYVGZucmNVeXBQV2tsR0hiSnZZZE5UQXpVT3Y3dUJmaU9tZ1htRFlWMFU4SUFpQ29MUER2UEU1Ym52UDVzQnBZclpsOS84SXoxVUhJOEtEdm5mYnlDKzlhUlRCWGR6b1N1eE43ZHk2VDVSclF2T1p0bDU5Z1BWVXpYbG1FbHJlblZjemJ6VzZuQnB5VHh4YkxvRnJteGN3RlV5WTd5ekhuZmJPMlZWdUNkZ04zRGtFUWRCREFIbGNYeDdDN0RITWI1MzU1Z3V4MmpMNzEzLzVHOS8rWGpoRzlWUC8vdDhKbXFWQ3Z0VCsvTC8yOGhFTHRZOHE2czN1YjI5TnEzRmRhdmgvTXZyS2oxeXRqRy9qVWF6SFpVQWZER0tSRTQ3WkhBL0ZVQzhHSmlYOU5Rdk9tZmJmK1lOU1pVRE03V2RUc2h4L3FQcHUvd25KM2w5dEh1Wnc1eEFFUVdkMTQ3RWpGOTZWaDhUMFl3TG1yeDNRZi8vbi8vRC8vRzU4dlBwSTdsd3l6RVZsaWErVS9IV3B4VWZVMFh5S3Z1WjFGUld6VTZJN3VkTEtBdDIrQ0QxSGVhY3NoMUFQNVYxTHZ2K3A5dHpJTEVDR2NOZWxXOElMdG81cHdXSUl6bm9CV08zQ1F0WXFnbnBKdi9mRTQ2aFV6MzZvTk1yMnpzQnB1dEk5TWRmdUZ6Q0hJQWc2UDh4RE85ZkluUjk5R1hsdzV5M01qd3p6UDM5emxMODJQR2JOZGw0VFJ5eWdDYWlOMmR1cm43SDMvYW05Nno5cC96M2VWRnk0THJiS2hkK1ZOS0pTa3A4bkk3TVhvR3VPVFNoZUwzZm5jbU9mSThzK0FUNHZPZjM0OW9IU0QzNHZZUlc1N1kzOWZiL3NMOE5RM3czakZOSEJVeU5sWmVJRWxILzk0OTBDMUloNXNJUG5FQVJCWi8zYWpkdTVocVl4WVl2NzBDVysrVEE3dy93dnJFUC9qTDJNSUZVVHBNa1Y4NlVKWCtYbXRWMHgvR2Y3Q2wreHgvdTg5akRmMFU5N0E1blJtdHk1dlU1UWR5QVBhd3o3MDVBN040dGd6c2x3Um5YVFlVbytESDczc3Voamswc2kvL1k4akZITGdLcnBmUi83OWZOTDZyLzc3ZmpvVDJPZjN0eWZLNVp6aXhJSWdpRG9aSWNlSnFhRmRxNVIwNWlEejJaM0NYQ2MzL2EveUpsYm1COEk4Q09naC83dE1VaDlVOVdEZGNCZnNDRC9hd3Z4cjF4Vjh1MmpmY1dOZmVoR3VVdmxvYzRsM0RReU5EeWJxTC8weTUraUEzb21JVTMyQVdPT3NzdzFhdW1OWitrNVZYYXhzRERzVG1xYVFlZzl0VGVkMjFLUTR6ZExTWWk2dWY5UXQ1Unc1eEFFUVJjQXVqYVJPeGN5Z3JrSWRlYmt6TDlMQ1hBM1duNHpPUFZiblFTNmN2eFZmcGtnWkMvVHpnTDlqNDlHZnV1b3paZnRTdUVYdGtwdU4vYXhHK3ZNS3dxNysvMzNzSi9PdGVFK0RMNEU2ZEk2VW5GYzhDeHVjMW9JR3Q0V01OT05YSWJIMGZYaURIMzNQSjNvUVorQjlxenJkZUZ2OTVucWUvN25CM2NPUVJCME5tY2V1Zk5vQkdyYm16MDBqYUU2Y3d2eC8ybXZmL2ZHZzN6ZnVGRDhDT2pHUjYwcE9TNUEzVVFIOTAzZnYzdFU0b3NiTFg5bnE4eVhyRHYvckwzOGNHVkJXVnVvQjZBVGRKUnhibjJ4QTdTdWVCdytuemdPZlFyTkF0RHdvbVhKZWRYc3VKZTdZeDh2YWN2ZmxyankxT0c0L3NDOVdhM3hYd01FUWRDVEFMdnN1L00relArUjJybGFhSC8xWU1TNzFwMjNOZWlobFB5WUJIcFlKWGlvR3d0bzNqN1dFZFR0bGIyRjRiWVM3MjZrK0Ezcnp2OTdyY3pIYWlrK29hVDhTZXZVZjh5NjgzZWtGbTlKem14YmlIUXFrVE5xbVR0c3BBdUxsNjRaNkxGcVdjeEFOSFh4TUpuaDZvRmRlaXJCYk1sZWRHOHhZYytGVmlXQU9nUkIwSk53NmRZOFV5dVlsNWF6NzFyTS9nT05NN2RBLzBzYXRPTG5ySGlBVTRjNDU5cUowOEZzRC9XdkFnd0FWbVlrWXN5Vm8rZ0FBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+Wdly5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlRQUFBQkdDQVlBQUFBTlpEd1lBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEJPRGN4TmpJMlJUTkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwQk9EY3hOakkyUmpOR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pjek16VkJPRGc1TTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPamN6TXpWQk9EaEJNMFkyTVRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtOemRjOEFBQUIvWkpSRUZVZU5yc1hXdHNrMVVZUGkxZDEyN2QyTmptR1BjWkZDZUlSS2dEMU9BV2pZb2dMQXFCRU5CZ0pJNC9Kc09OaUJLeW9CQ0MvTkdFRWczK21DR1NEWUlvVG8wR0pDaUlvQ0lCQm9FNHQwWEczS1c3dDNTejgzdk9kajYrbG5ZOTNjMnYzZnNrSjkyNmZwZWU4NXpudk85ejNxNkc2cUo1TEJDU3NwZVpsWWZsZlcyQjBpWW96Y3dJMFF5SEtRZ1pDbGlQZDA5WFV5M3JjdDVpM2UxTnpPdHhNK1U1NnJJb2hqTHUrU2EvSjZZcEQwVmR6dHA4Vi9WbDVuVjNVQytOTXBoOHlORFRVK21xcVdDM2E2OVR6NHhTR0RVL0Z4RVpDTVkrZGRqUzFYUXpuOGhBTVBKc29zZjducXZxRXZVR2dTdkVDay9qVFNXTGNGRnZFRGdobGl0WkJmVUVRU1dFL2QrT1p1b0pna3FJOGQ0dU4vVUVRU1ZFTFBPU0EwblFwSjBFQWhHQ1FJUWdFQ0VJUkFnQ0VZSXdPZ2xodE4zRG14N3ZLMXBnaXFTYm5iajFLLzdZOXZNeDFueWtPT2pnWkJTV01VOWRGV3M3ZVpDNUw1Y1ArMzJsYlhBd295V090ZjEwaExXZi9JZ1VZbGlZbXA0MW9PUEdyU3ptZzJPWm1zVzhuY052eVNmbGJXUG05Q25NTkRhVkdhMEpwQkREUVlTVU5lL3lEcTdiK3pycnJxdVFQamJ4MlUzTU9xTzNhTmhkVmNGTXFWTjRDd1pQOVI5aG5kOGZ0a1ViV01MOEpYZnVQWGs4RVdLb2dRSENERWRMZnZFdFZyOTNuZlRnak0xWnBmNE9oVURyRDE1M0oyc3MzVFdnWlFYWFMxNzhXdTg5dHpSd0FzZlBlVkpSQ1FkcitDU2Zsb3loaFBQb2grcWdvdU5sbEVFTVRyandWSjBmTkJucTl4Y3daL25IL0hjb1ZIckI0UUV2ZWFRUUFZQVoyM0VoaDgrNGhNZnlnZ1pxQ0NBUk00aGx3bE5YelJvUHZOUHZNaUNDVGloUXg0WGp6TnYrVDNneHl1cmQvTDYwWk1EMTJwWG03V3hsS1M5dDRqRkYrc1o5ck9YNGdZZ0xNblViVkRaL3VadExPcVE0enI0cTZNQUtNcml1bmVka01FOTVXQ3JveExsYnYzTkkzNDg1Y3lHZitZSU1JSjhnZzBEbnVZT3NidDhibkNoOHlWTlVKRzFqU1VTcGhXN1RUc3pjdGpOZk1FOU5SY0ExWHZ3OVljRUwvTEh6OTNJK0szbUdNWDB1YS9xc01LRFVDd0poOXNxb0E0aVgrSFMrVC9DSWdMV3g1TTJBeDNzcVQ3TzZEMTVtS2V2ZVYrT1lqSUlTbmlxRGdPRXEwa2pEMEhwNGUwL3oyYU82TjZTMGc2TDFJZkEzMGNsUUVraTJHRFJ0UUdxWnVaaWxyU3RXMVNSVTRJZnoyaDVmeXdrSGtnbjA1NEVFREhSejE2akhRNVZBM3ZZZlA5VWxNWkt5bCtuYm1CSkVpSitUNnpNby9rcWhsV3lzNHhoNHpFeklOVWlCb0ZOa0lKRDZwdEp0L2FhOWlibnJtZldCUisrNkpvamtkYlh6ODhrQ2NZcTRmelRjQjBqbXV2b0w2N3g0WWtTTXM0aGZNakFvdG9VcmZZaUFnVVN3SmhPUU5oNUs1RXJCNVhyTDF6d09DU1gxL2dxalRVM0Ywb1RsUml3NTRhSytaQnNiKzh5ci9EM2dQU0VXUVhPV1Q5SlY0R25TbXlJa0xTMVVBemNSeVF0TGVQS3VjM0plUmtPMVNpQkJCaG1waDhJZy9zRDFjZDJPMzc1WDVUMytrYWVDcWxUSSsxSE9CYUtpZ1hUeDlzV2NyRkFjdldVaHVsTUlTTFYyWnJaK3MwZnFPTVFJbHZ2dHpKbzFYeVdCVUphV2IvZExTek95Ry9lTlh6azV0S2pkOFZ6QTE2ZXVkNmlxVWJQWkh2TDhPQzhhc3BidStodVVaY2hrRmtDb3dBc0VpSnVkdzhZa3B3ZDBKRUdFdGxObGR3MnN6RDJFZTh5QURERWxHNkcwVXdLeWl0RGRVS2xJZS9GZEpIQmRPYzNjMTg3b3RzUEpoeGhDSUNnMFd1SjVwQTlEcU9YRVFXYTAycFRuYk14ejh6cHpYejAxcU0wcVFvVDRFS0V5RWhnLzNHeFNDQ0tyTUtHQ1cxRjdNVno0ZS92enV2TWk0RU5FZkFtZEtUWHp6cEpSUStvUWRVdUcxamVRQ2dLVmJFUWdaZVZtWmZrb0R1dDYySHZ3anpjd2N4c1B5U2xOd2hNcmVIcUwrM0Flazk4YjBhdUZyYjhDbVRESXdPVmQ0dzBNeENmd2RqcURwb2RhYndUcGNLQ0NuYmlIRmpIV1p6WUZ5azZRWHFhOXNwTTdsdTJuUzNVZjQraU9FSEQwakhHSlVxODFUNXJocytrRWRGejRnZnNJMG9Ub2FBdzVrMk15N3VVRERrczcwS1paZjBqTVdkdm5UT2FHdGJ0S2hCQ1pSQmplZnJ5OVJGMDJVRlFMUHlJMmMxYnYxdmtRU2pLTUxleVB3TUZzUFo0bFBjdmhsWVM3dS9wL0kyS0RTbXd3Q1VNS2N1dzh2Rk90bjhEVzgxQ1RGQ2t2djY2aUVySklXTFJLVFpjanBWREdHS2xrME81ZVlvOENzMVlFZFdLbmN5Zy9MNEdTZnE1S3FKdVVPQysydmdWaFFkWklRVVFSQXA0RDlnNEVHYkJwaENvcGJTQW9haHY1VG1kaG1WUk5wcXhLZ0h3OGtKeTdQS1NQZ1RvSTRZMUVrbGtXRVU0bEluWGIvRHlmR29WZzlaT1FadFJFSkMvSlY4dllVSmVKblV0VVZRMW1jTEEzZ25PSGluTjQybHE2aTIrMkRZVlJOcExRcFZPSkdXYWVPbzkzYUd6bWJKODZDTVFKaUJsQ2JXVkRUVkRHNzcveEJTSjExZjdKclc1UDlTVys0NmdOOXJRVjFjT05jS3F2UmdLNnE1aUNFcVNzM2hyUWl4QkVrSzFMaEJLZ1dncVJ2aTE3cVJydGcxeG9vdWJDZjFDaTRkTlhVYk5rd0RIc3V2V1hTZ2pFQ0xjckx3MnExRXdVcGtCMUxGbTV2QUFHdmdKSUlRSlNuOWRmT3pOeTcxZUhWcnZ1bGd4SVBmWW44QUdhNGM3YnRRVzZCSjBXMlVMcVJ5b3FKekpFaVE5QklFSVFpQkFFSWdTQkNFRWdRaENJRUFRaUJJRUlRWWdPUXJRWnhwaW9Kd2dxSVdvTk1SYnFDWUpLaUl0akpLdWNDYU9ERUovSEpHZFFUeEJVUXBTWlV5WXdvOWxLdlVGZ3h1YXpSejNNWUh6Yk9uVVc5UWFoTisxVVNMRWpadHdFUjJ6R2RPb1JJb1NLM2RiSkQ3TFk5RXpxRlNJRVY0bEtaakRNdEU2YjdZaS96ODcvTVFkaDlNSEhrVkpJY1VWNTJKaVV2ZXhHVFBMNFBmaVNlSHd2T0w0SzJ1dHhNOVpEWC9nYTdUQlVGd1grdjRzS0tjekt3d3FsNVNsdHJ0SW1LaTJHdWl5cTRmaFBnQUVBVll5NXpvTE1FSDBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WVhuWfji/lpZbph5EucG5nXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJUUFBQUJHQ0FZQUFBQU5aRHdZQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBCT0RjeE5qSTNNak5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEJPRGN4TmpJM016TkdOakV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rRTROekUyTWpjd00wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tFNE56RTJNamN4TTBZMk1URXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrUVFqSlV3QUFDQnBKUkVGVWVOcnNuWHRzMDFVVXgwOS92N1gwc1kyTlBXQXYyUk1IaU9CQUhoSlExQkJpb2lFalFFeGNvaExJZ0Q5SUhJaEdkS0NRT0dRa0EyRUx4R0Nja1NEeWtrU1JJRk1XVGNZeklBdFQ5eUtNelkyTndyYXVvMTFiNzduZHI3UmIyL1d4a0Q3T043bmQ5bnQwWGUvbmQ4NzNubnU3bjZ6NzJHZjdBV0F0a0VKWnZheTFzSGFOdFJPc25mcXlyTXd3WUxiQXg5V2REZ2ZLR0JDV1kxL3RBN1ZjZ0RFUk1oQmw5TzZGa2l6WXlhSWM1Q28xcUdNU0lDRXRBNUtlU2dkQkVJc3E5dTdadmFtcVl6Z1FQMzlURGxGakJGQXhJT1JFUkVqQmdHS0JBTXpzWVlCOU5aZ3NJQ2lqSUdQR1hFaWVtRm5PZHUrTXl0L1M3QURFK2U4cVlDd0RRcTBRUUNFUUVLRUdCVy9zd2NTZ01MTDJpRUhSWnpCRDRxVHBrSnMzRjJReVdZWUVSUVErWUZEQXlJQXdVSVFJelNpQjM1Z0YxczhXN0dNTFJNaGswUG52RGFoanV5YlBuUGMrKzdJT0R4UG9MUXR0eWFUR0hnUzg0Rmtid3k1NnRWd0drU3dyZFB4ekhWcWJHOWIySE4vK0VRRVJqbkRJTUNOWU00R1NlVWEwQ2ZWWC8yQWV3N1NkUWFFZ0lNSVJqRUVvRklQUlFtYlV3OTJtQnR5MWdvQUk0M0FoREhwSGhLS3pwUW0zTG8yZ2R5WjgwNGNnczlhZFJFYUdUc3NMVkxNb1FvUTVGZGIwQVREUXI4TXRTUVFFTWNHaEFJc1pmeVJUU1VQU3g0MkduYVJoSWlCSUJBU0pnQ0FSRUtTUUJrS01UdUdOUkVCdzVlNnE1bTNDVzd2ZFFwTzc1eWFrZjNBYUl2T1dVKy82b0lBc1hTdFNuZ1BEM1d0ZW41Zjh6aTRRbFdyUVpFNkZkcDEyVkY0TGdxVktmOGF2NXpEMWRjUDlNNlVFaEM4Z3BLMHBCWGxzSWpTV0ZIZ0ZSVUwrTm9pZU9vZC9yMnVzQlVWaUJtdXJYUjZ2Yjd6czBmTkhUcGtIY1F1WCt2MjNFUkErQ0R0SVZHcjRWWjVjOENrMGYvNjZSK2VOVzFJRWlVc0tiRDlqaE1EbTlxcnQ3NE9XcjdkQjc5V2psQ2NDT1dXMEh0a0ZFd3RMZUlkaVI0OTBaV0Zrc0lmQkcrbnIvL1RxK05vMW1WNGRqMzVuTktKTFdBT0JWNnoyMG1LSWZmNFZpRiswd2lVUWFDRFJNMGhwb3IrdEdlNGNLSEtiQnZDY25PMi84QWowNE9KWk1IWGZwWkFRREtPTTlpTmJlVWlYeHliQTJBV3JYWGFzQkVOM2JRMkhRWlU1eXlQVGljOTk3OGRTNnYxZ0dXWGdsZHYxMnpIUU45OTBtdU9sL1hFdkxlTmZIOWFjaE16TmxkWVJSdTVzYUQyNDJxblBrQURxK09rUVJZZGdBZ0oxNzNpeExSb2t2RkhrZFAvOWN3ZHNIZHQydEF4U0N6N2txVVlSZDlyQmtPTFFNU2wvdlMyYUJJdmpKeUNHcEFVRUlXYjJZbjdsdTRva2toNVdId1NUN29ITmtHSnhDcUd3TjUzb00xb1BiZlRyTlhtVmoxVlJCTVJvMUNMR0xTcHdBQUU3VXBtVTdwRWhiYW1NNFpFQ29aaFVVc045aUZTYnVMTy8wSzlVZ1pWU2loQlBNQ0tNWDdtVmgzeEpSdTA5Nkt6Nm5vZjRxUWNhUGF0bGREVFpBSkpnNkxwd0V2Nzc5ajNLQjhFV0lhS256Yk9tQWpZS1FMTW8rWWlSaEI0Qks0clIwK2JiSUpBaVMvdXBjcitLVC9lcktrRi8rNVovSnBtbE1nTEN4NUVGN3dRN3MrZ0tnT2laaTVsNW5PQzBJb2tnZEo0N3pIMkZ2OEs2aGkvektoUWhSbkZrTVdJbnRkZXoxRkl5RElMdTY5WFFXMXNOK3IvUFVld1B0VkhHVUtFcEZGVWFNUFgxOEN1MjQwd2xpT29vN3VUNzc5UkI3MS9uL2I2UzBkQ09uYlBVSjRDOW5SVjFWV01oSUR6VTBJa3U3QXpzd0p4aWxtYVlFZTFRUjdOdC9nR0JsVTV2NWtYc1U1dTNzNkpvZEFNUmlLQmVRcWNZbisxd3hUMFJyOE1NTDZXTUp5VDd1b0czblpQNmRqR0loU1ZlL2I3RzBqVXUvVWJkeGdWT2phMG5zNnZ1WmtVOUhUNVRoR0R5QmdaZXU3Q3JZTHFxWnJvRnFyZUxYR1FnUjRqYkZadEIxTVI0bHU4blRoNldzN1dYZmdWZDNVWFBnZWpwSUFJQ0dRaHZURmJzL05PMnROSGYyc1RyRVpIWnoxcW56bWttTTd4TUplWnhxU0NGQzExYUt6K3hyWjlJVzFkQnZScE9RQXlkdmNRNUNxdy80UFEzU3BycHBNOXdoRGdRZkVYMmhzTTJHSERpQzFkSlNjSXlkZHZ4ZlRZb2NFVVZMb29oQmJHSGNHb2VuMzRWWWhldTVCTmY5dFBoenRaUDRxeW9TZGNOU2NzMzhHTnhVUXl1eTlUV25PR3JxcnlwWk9MTXExbmZNMnk3TWpWbnhIUGRmWmlJZ1BCU0dPcFYyUy93eXA4bVo0YkRPZ2owQ2VnWjNFMWxZNlRBejF6Z01uNk1GT2dyTUtwZ1E1RDBMUTI4MUsxdnVnNkd0bHN1RGFqOU5MeTNDcmFWMWdFSkJFYUN0SGQzT0sxRlNDRGd3bGhQUmhBWUNiRFVqZk1Mc1F2eWJXc3BFUzRPMkdCbnUxc25nZkE0cjMxb1JxeVh1RHBYZWcwRWhBZkNpcUcrZFpYdHpVYVAwRnQvQTdxdm5QVzU1by9uWWNPb0V6bjlOYjRBVjVXYXhUdEZNcVN1MUZ4YTRIT2xzcUg0WlpmN0FyMVNHVkFwby8ySG5hQ3R6dVlmb0JuTldnSStGNllTKy9VUnprWWhtR293YWtqbk9CTk9hS0VmR1hvTUxxTHB1akR5YTVHS2IvaTdBbEg4ditIL2ZyZ0NZbFVpYU9RQy9mUHpNSlBSWkFHZDBReGF2UWxlZkxPUS9tRUlLVWpyRUNRQ2drUkFrQWdJRWdGQklpQklCQVNKZ0NBRmxTeERHZ0ZCc3QzVEUyUWNCUU1CRWVZMDhCdThzaGFoMU9DV05nSWlqQ09EbWRGZ3dtYTJnQ1kySGpkZkppRENtQWk4SnpoT2J1R3RuK05UTTNEclNRSWlIRm5nYWNJQ2hzSDdnRnZrS2toSno4SmRSd21JTURTUUNBTkdodjRCNjAzaHMvTG1neUNLVzZMeXR6eWkrM2FHQVFTUFU0U0Zwd21NREFoREw0TWhjZEowakE3bERJWWRlQmdId2pTWVN3eWloZDdCVUswMTJFVUdUQk1ZR2VJeXAwQnUzbHc4N0F2cGVBN0VJMGFMbnNOZ0JpT3RtQXJSTkFGOE5JRXdDTW9veUprNUI1SlpaR0M3OTdIbzBPUUFSSitSMzhRVERDYnJyWDlKSVFhRVRBQ0ZVZ1BxdUhoSVlxT0psSXdzRUFTeHFHTHZudDJicWh3LzhJeEFsQzlidFg0dHZYVWhMU05ydUNMNENtc25jRFN4cjZ6TVlEUVB0d2ovQ3pBQVBzTjRYRnp3QjZFQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5aWW5ZOBLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFBL0NBWUFBQUF4QmV5SUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMk5EZzVSa1F4T1ROR05qRXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8yTkRnNVJrUXhRVE5HTmpFeE1VVTJRVU14UWprNE4wWkdNMEV4T1VZMFJpSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalZGTlRZeVJqbEZNMFkyTURFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qWTBPRGxHUkRFNE0wWTJNVEV4UlRaQlF6RkNPVGczUmtZelFURTVSalJHSWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0Nnc0ZGQUFBQzJSSlJFRlVlTnJzWFhtTUZHVVdmOVZkM1RQZGMvY2NPOENnRURZWWlTS0N1aWhLZ3E0b3NPc3RtSlVWaGVnQ2k5Ri9GRHpZQkJFQkV5VWl5NUpzQUEvSUxnaEIzSUJYc3BwQndFU1F3eUVnY2hrRzVtS21lL3FhbnI1cTMvdnFxNXJ1bnU2WjZwbWVycDZsWHVhbHVvNnY2cXYzKzk1WjMxUUpUUTgrQ0gwa0UvS3R5Rk9RYjBFZWpUd011UUE1RHd6U1FwM0lQdVJMeUtlUkR5Ri9nL3dEY2xUTENVYWVMNHhiRi92UWlScmt2eUkvaVR6Y3dLUmZsTWZaZ1h3ajhxTjgrMFhrcmNoL1I2NVBWOHUwVWptL3dGbmtKUWFZQTByRHVZelBjcG1YWnhyUW1jaW5rQmNpV3cxNVo0MnNYT1lrKzFtWkFGUkVRNzRCbDl1UUt3ejU2a1lrKzM5ekxIcDBrNktVZXA4ZDkyMFhBR1pJaGtCemdoQ0x2eUNvTllKc01mM3BhS2dZUWEwa01BMHg1aHlvTXlLeXhSUTFBNG9OMXBzQi9tQ0lMemVKc0NHTU5BSGFLY0dmc01Hemh0aHlIdFJuRWF2WjNUUzQ4WUVIMUpXV2lGQlpicFpPbWVTOHlLQWNKNHh0bkpmQ3BqR1Q2d3NhazJwb3NVbGFhWUE1cVB4cFdhVTV1aUxPNUVveTBuQWhaQnBsRVdDT3NtN3c0R0RFN0tuL0R2T05pdFBRVVJlS0JEUzFpNFMrbFFJTjBsZExSY0pPL3NrQi9WMStKTThtU0U4WTRobWNSTmdSaGlxZ2YzTUVKcGtGcURaRU0wZ2pYc1NPTUdRRkJEUzNwdjAxM252MTdwVDk4Y2ZaMHYvSkoybTFLMW04R0RxUEg0Zmc5OTlEMU9sTXEyM0JNOCtBWmNRSWlMUzBnR2ZkdWw2UEwxMjJEQ1MvbjEwdjhQbm5PUVZxcVVuNlBTNitJWjlweVRQQmVEM0xlOFdMRmtIQnZmS1lDcDQrRGFGanh6UVBBdHNkZHpEdXZQdHVhSHZwcGJTdVMyRG1qeHNIb2ZwNjZPMytiZE9tc1dOWkg4K2RnMXdyaHlLR0UraVd5T1JhclJnWDZka1o3OWF0RUdsclk3L0xYbnhSVXh0VFdSa1VQU28vUG94MmRFRDcrdlVEMnNlaW1UUFprdnFacmhYSkJuRU1yU0lEVkpCMGZaSkNwcko5NDBad29JYVpIUTVtUnR0WHIrNVp3TTg5QnlhYmpmMzI3TndKa2ZQbkI2eC9oV2lhcVYvTVgrRnl5TzdkeWU4REI1YnZ5eS9CdTNsejlnR1ZNYlNhbUpvS1lOZDdoSFYrOXgwRWpoNlZUU21hVU10Tk42VTJMM2ZleVk0aG9qWURxVEhVajZLSEh0Sm1OWENBRmR4M0g1aEhqc3k2L0RpR0ZwRUZTWklrNW9KUGNLMVpBMVViTmpEQkZEN3lDTFJ4Z0JOTmJjbThlYXI1b3phUzFQL2VKenNIWFV0eEFjeXNmL2hoY3Y4NmNhTHFYOGxhaE5ISDZwR1BFcGFpa3BEcTRzanZ1Z3RNUlVWeDIwSVhMNEpZVVFHZGRYVmdtejQ5cWZBVTgrZXJyWVc4MjIrUE4zc2VEM1R1MjVkUzIvSW1UT2dLOXl0a1QyT3kyNkZ3N2x4NWtEUTJRc2ZldmJJL2YrMDE5VnBPaklLVG5aZnVRUUhUZitBQStMWnYxN1hPb0N1ZzVUMUVwU1d6Wi9jZUhhY3doWmRUQUVwZ0ptdERvQ25iS2VMdFBIaVFnWmszZWpUYjFyNWxTMUl3YVlDVUxWb2t1d3lNemwyclZ1bGVPTHFxU24yUzE2dHRvSzFZQVphYW1yakIxZHNBc3d3ZkRrTS8rMHhkYjFtNlZIUDZsVWxpZ09ydFA3MWZmdzN0NzcvZnIzTTQzbmdEYk56MHBib2ZMNXBEYjR4SlZOcVFWall2WE5nVk1hTG1sYi82cWhwRmF3Mkk0a3kvMjYyTFhJMWlmQklLb21ZMXpaOFBRM2dRNVA3MFUvRHQydFZWWVhyNFlkVkVONzN3QWtSZEx0bWtvejkzWURzOXlRQzBoOXk0cDNWMU80S1pic2x4UU5NWEE3ci9MOG9KSHlwbHVBOVNodHNrOWsvUzBIZEpKN21LUEt2V0dWRXBzMzNvdzdsTXBhVmdtem9WOG0rNEFWb3hRdTJ4ZjRtL2xmVlUyNjgySDFxRWdpVFdpeWhGR2ZyUlIzRVZJcTErTVpmODUxVVpGRmt4VGJGUmRXZk1tTGhjVXlFcUVQUXF0S29xdGd5M3RobytOSlphM242N1crbVBKZllMRnJCbEJ4WGVEeDZNMjFmMjlOTXM1MHUyajJtTXg1UHlmaHhMbGtEQnBFbmQyMUNkZHVkTzhILzFGVnZQNStWRTJrN1hJZ0JqeTVDV2E2OVY5OGR0SDlYMUZOSTJaUXFFcjc4ZWdpZFBRbmdBbndUbGxJWUdrcFRUeEpnbkZZRzZPdkR6dW1vaTJPSG01bTc3ZXMwdlViQUtvQUhVUkxHOG5ERnBtbmZiTnJiZGpnQXAxMUR6VG15VGJDQllVY01UajFXb0JITlZvbmJNWDkxWEM2REpLUCsyMjlUZjRjdVhNM3B1UlFOcFNiNnZZdmx5Qm1paWhxZVZyM0l0VHJuZjU3dTZmYWcxUmtPRHFLR1pMaFlvbXRpVDFiaVlvcmhQTk9TREQrSUdnZWVMTDhDOWFaTlJXRWhGdHZIalpURHI2M011Z2l5ZU8xY0YwN2Qvdnh5aDMzOS9uSnZJQ1VCelpSWjR3YXhacXZueWZ2dHQwbU1TRS9kVVRMTUd0RnhUNi9ub3VhZmlGLzBZa0xXdVdzWDhNUFczL09XWFFjQlVSMi81ZFdtb2tnVHJ5SlQ3bGNaTSttTCtMdG14eVJMK0pGeTllalZVdmZNT2UzS1M4amlONTZKelZEei92SnFxdEwzN0x0dmV0bTRkNnlzRlJ4V3Z2NjYvSEhQRjVKb2NEcWg2NnkxVk8xMDdka0NVendMczYvbm9YUG1qUjRNNGJGaS8rbWFmTVFPcTMzeVRuWS9BYTE2MlRPMGJUVFc1d2gvNzBiV3FFR2lUdzZHL3lZMWkzM1NMYWlkUGh1bzFhOWdvWjZZV2ZWTnZnWXVXTWw1Zm85YllRZUY0NVJXb1VOSWsxTXpHeFl1N3pSY0sxTlpDMjhjZnE2RFN2ZEE5WlpzVURGbVVHNUlnWUJXZ01Kc2FhY1BrdmZDZWU1Z1FGQ0l3VzFldTdMRXRDWllDRTZyMGtQWWtIU1JqeDNaVmZqQlNUbFZvb0xsRXNUNVVMVVdpTHk5OTdESFZZcEN2YkVFdFRXVTFQRGdBd3cwTnpDeFQzNnJRcC9xblRnVW5Sci9abWpCR0dDcUFTZ0ZKY0ZvRktTdUFWcUpnOHErN0xpNTNJNUJjMjdlRGI4K2Uzb3NETklrTWhjYjhWb3FrWHMwN01YaEpCS0VjdGE0d29VZ1E5ZnRWSUl1blQxY2pXVEt4Ymt4TGFNNXdiOVNCbXRxQWtYa2xna2w5czQ4YkIvYTFhelVOMG93VWFSQkR3cEpNcnRRZUZTNWxTenVwWEtlQXlZRGN0UXN1elptakNVeWlWdlJUSktTZTZxZ3NxS0pJbElLWHhCcy9mcnpic1RRamdmMzJlbFV3cVgwRFRmaldBS1k2TUZFYkcrYlBaL2RFNTJVbHhYNjZENjNFTVpSSVF5T05FZFBwNFdKMFlqWXVUTUNKMWRYUWNmZ3dCSlBNdSszVlY2REc5V2ZFZCtDQWNsWEwvMmdYcGltYnVLNW9NZldOZkc3RTdlNVQzMVRoNGlEd0lLamlOZGRremVSZVJnd0pTd0kwZEtoVFBIUkxYdmlwYkdtcEs0MVJuMmxpazdON3VMNGZUV2VtcmhQcFI2U2VMdjNZS2RJTEgwTmtjb1AvZE9jZDlzczIyS0JCU0lRZFl2Z2pZY2tBUllmcU9oRTA3emRFTXppSnNDTU1DVXRtY3BIZEc5MTV1OFpYaEthWjJTdHdEQm9zRk1FL3dvNHdaQ2IzUkkyVFhyVHIyUmV3L0Z3WEZQY1pJaHBzMmludUord0lRNG9aVFR5aDdrQnVYdTYwYjBIVjlSbXZpeGtjVEZndGM5cXBUTlhNTVZScnVXUjJXMCtHekwvczhGbi9aWXo3d1VHSTFiWlRJVE9sSzYwY1F4blF1aG9uQVU3L3lWTy8wbVhmZXpRb0hqREVsZHQwRERGQ3JLZ2FVOCt4azJJMWxFQU40cUlGK2RjRlZ3bzNuZzJaVHhoaXkwMGliT1lqUm9RVnh5eW83RXQ4ZkVaRnpZdWVxSEJtM3BYQzlSZkM1bE9HK0hLTHpvWE1Kd2tid2dqa2p3M0V2UWc1RGxEVTBnZ1ZjbWdRWEltWWZwN1pWUFRla2FCNDBCQmpiaEJoOFVSejBWckNCdVFQRERqbHpDVUcwTVRJNmFjYVo0aXI4V20vSkp6NWMzUFJwazJlZkNQNjFUbWEzWXdZRUJhSXlTOGdmK09saFdNVlIwbG4vZUdCd1J2cnk1cjQrWUx2dHR1Q3UvM1drMHRML1grOE9TOThxOGtvUG1TRm9xaDlSenJGSDVhNzdQOUJ2MG5CendXdW1RUm1NRmtiNFd5U0YxTW9oS0JhY0VHUC8razdJalJkdkdxc05UeDBRWEZnTWdKN2M0RWdsUmhpenp6NUpLRWRnVHp5RDNkKzdmR2dlSm5ubWI5eW4rbUsxVXpFU0R1Z3ZBRnBJejNhcndUNXEwcERDR1JSQVBzTWUzRGs1UHpRYjBlSWtacHlrMVJaYUpKS0xJSmtOVFJZdXdhR0pDSG9qUXJ0clZHaEJZUFErdHFBNWN3ZXYvVjhXR0xCRHNVekRUdzFJVGZvLzBtT2M2RFBnTVkwcEkvQzBLd0dlZ0w4Rzc0c1JzNEgrWU14SW1jQmRIeXp5aUFqeFUyR09aTVpwYWtrYmw0c2FPSkxieW9UMncxUSs5Z24wK2tBQVVWbW1LWWNGSEZBaXpuUU5nNnNHWXovREU5RFNWbVVHdVNsT3k4SGs5akR0NFVnamY4bkUvc3dvb0tjUGR3TVdEbGJPSmlHaHFhdm9SRU9uQ0xiRUdqOE9tRWkvVStBQVFCTHkvRmJPUThONUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/llYbln44v5YWR5o2iLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImV4Y2hhbmdlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcImJhY2tncm91bmQtaW1nXFxcIj48ZGl2IHYtZm9yPVxcXCJpdGVtIGluIG1vbmV5RGF0YVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leWJsb2NrXFxcIj48aW1nIHYtYmluZDpzcmM9XFxcIm1vbmV5QmFja1xcXCIvPjxkaXYgY2xhc3M9XFxcImJhcmNvbnRlbnRcXFwiIHYtYmluZDpzdHlsZT1cXFwiYmFyY29udGVudFxcXCI+PGltZyBjbGFzcz1cXFwibW9uZXktaW1nXFxcIiB2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5SW1nXFxcIiB2LWJpbmQ6c3JjPVxcXCJpdGVtLmdvb2RzaW1nXFxcIi8+PGRpdiBjbGFzcz1cXFwiYm9udXMtbW9uZXlcXFwiIHYtYmluZDpzdHlsZT1cXFwiYm9udXNNb25leVxcXCIgdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIj48L2Rpdj48aW1nIGNsYXNzPVxcXCJleGNoYW5nZVxcXCIgdi1iaW5kOnNyYz1cXFwiZG9leGNoYW5nZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJleGNoYW5nZUJ0blxcXCIvPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcImNoYW5nZS1idXR0b25cXFwiIHYtYmluZDpzdHlsZT1cXFwiYnV0dG9uQmFyXFxcIj48ZGl2IGNsYXNzPVxcXCJib251cy1idXR0b25cXFwiPjxpbWcgY2xhc3M9XFxcImJvbnVzLWJ1dHRvblxcXCIgdi1iaW5kOnNyYz1cXFwiYm9udXNCdXR0b25cXFwiLz48L2Rpdj48ZGl2IGNsYXNzPVxcXCJwcml6ZS1idXR0b25cXFwiPjxpbWcgY2xhc3M9XFxcInByaXplLWJ1dHRvblxcXCIgdi1iaW5kOnNyYz1cXFwicHJpemVCdXR0b25cXFwiLz48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L0V4Y2hhbmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9SZWNoYXJnZS52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKVxuaWYgKF9fdnVlX3NjcmlwdF9fICYmXG4gICAgX192dWVfc2NyaXB0X18uX19lc01vZHVsZSAmJlxuICAgIE9iamVjdC5rZXlzKF9fdnVlX3NjcmlwdF9fKS5sZW5ndGggPiAxKSB7XG4gIGNvbnNvbGUud2FybihcIlt2dWUtbG9hZGVyXSBzcmNcXFxcY29tcG9uZW50c1xcXFxtZXNzYWdlQ29tcG9uZW50XFxcXFJlY2hhcmdlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtOWUxZDhiNjYvUmVjaGFyZ2UudnVlXCJcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKGlkLCBtb2R1bGUuZXhwb3J0cylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkudXBkYXRlKGlkLCBtb2R1bGUuZXhwb3J0cywgX192dWVfdGVtcGxhdGVfXylcbiAgfVxufSkoKX1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9SZWNoYXJnZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vUmVjaGFyZ2UudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtc3R5bGUtbG9hZGVyLzEuMC4wL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL1JlY2hhcmdlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG5kaXYucmVjaGFyZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5yZWNoYXJnZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5teS1tb25leSB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLXN1YiB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZT80ZDU3MzY2N1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxSEE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsV0FBQTtDQUNBOztBQUVBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG1CQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLGFBQUE7Q0FDQTs7QUFFQTtJQUNBLG9CQUFBO0NBQ0E7O0FBRUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7SUFDQSxhQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0NBQ0E7O0FBRUE7SUFDQSxZQUFBO0lBQ0EsYUFBQTtJQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiUmVjaGFyZ2UudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSBsYW5nPVxcXCJwdWdcXFwiPlxcclxcbiAgICAvLy0g5YWR5o2iIOWVhuWfjiDmqKHmnb9cXHJcXG4gICAgaW1nLnJlY2hhcmdlLXJlY29yZCh2LWJpbmQ6c3JjPVxcXCJyZWNvcmRJbWdcXFwiLHYtYmluZDpzdHlsZT1cXFwicmVjb3JkSW1nU3R5bGVcXFwiKVxcclxcbiAgICBkaXYucmVjaGFyZ2Uodi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIilcXHJcXG4gICAgICAgIGRpdi5iYWNrZ3JvdW5kLWltZ1xcclxcbiAgICAgICAgICAgIGRpdih2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiLHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCIpXFxyXFxuICAgICAgICAgICAgICAgIGltZyh2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiKVxcclxcbiAgICAgICAgICAgICAgICBkaXYuYmFyY29udGVudCh2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nLm1vbmV5LWltZyh2LWJpbmQ6c3R5bGU9XFxcIm1vbmV5SW1nXFxcIix2LWJpbmQ6c3JjPVxcXCJpdGVtLmdvb2RzaW1nXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGRpdi5ib251cy1tb25leSh2LWJpbmQ6c3R5bGU9XFxcIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVxcXCIsdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0g5Ymv5qCH6aKYXFxyXFxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkuYm9udXMtc3ViKHYtaWY9XFxcIml0ZW0uc3ViXFxcIix2LWJpbmQ6c3R5bGU9XFxcImJvbnVzU3ViXFxcIix2LWh0bWw9XFxcIml0ZW0uc3ViXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZy5yZWNoYXJnZSh2LWJpbmQ6c3JjPVxcXCJkb3JlY2hhcmdlXFxcIix2LWJpbmQ6c3R5bGU9XFxcInJlY2hhcmdlQnRuXFxcIilcXHJcXG4gICAgZGl2Lm15LW1vbmV5KHYtYmluZDpzdHlsZT1cXFwiZm9vdGVyXFxcIikg5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX1cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBwcm9wczogWyd6b29tUmF0ZScsICd1c2VyaW5mbyddLFxcclxcbiAgICByZWFkeSgpIHtcXHJcXG5cXHJcXG4gICAgfSxcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgbW9uZXlEYXRhOiByZXF1aXJlKCcuLi8uLi9kYXRhL2V4Y2hhbmdlLWRhdGEnKSxcXHJcXG4gICAgICAgICAgICByZWNvcmRJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmcnKSxcXHJcXG4gICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmcnKSxcXHJcXG4gICAgICAgICAgICBkb3JlY2hhcmdlOiByZXF1aXJlKCcuLi8uLi9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nJyksXFxyXFxuICAgICAgICAgICAgbW9uZXlJbWc6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5ZWG5Z+OL+mHkeW4gS5wbmcnKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjb21wdXRlZDoge1xcclxcbiAgICAgICAgcmVjb3JkSW1nU3R5bGUoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDI4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbnRlbnQoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ5NSAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjE4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb25leWJsb2NrKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTA4ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBidXR0b25CYXIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDI2MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDUyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTA1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBiYXJjb250ZW50KCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYm9udXNNb25leSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzcgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJvbnVzTW9uZXlIYXNTdWIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMyICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBib251c1N1YigpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxLjUgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggJyArIDYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIC8vIGhlaWdodDogMjAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtb25leUltZygpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTE2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcXHJcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC0yICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAwcHgnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHJlY2hhcmdlQnRuKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDMwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzY0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBmb290ZXIoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gd2lkdGg6IDEzNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzNCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXFxyXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcxMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcblxcclxcbiAgICB9XFxyXFxufVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5kaXYucmVjaGFyZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmltZy5yZWNoYXJnZSB7XFxyXFxuICAgIHotaW5kZXg6IDM7XFxyXFxufVxcclxcblxcclxcbmRpdi5teS1tb25leSB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYmFyY29udGVudCB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmltZy5tb25leS1pbWcge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbmRpdi5iYXJjb250ZW50IGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG5kaXYuYm9udXMtbW9uZXkge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJvbnVzLXN1YiB7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmMjZhMzA7XFxyXFxufVxcclxcblxcclxcbi5iYWNrZ3JvdW5kLWltZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuZGl2LmJhY2tncm91bmQtaW1nIHtcXHJcXG4gICAgcGFkZGluZzogMSU7XFxyXFxufVxcclxcblxcclxcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiA1MCU7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cclxuICAgIC8vLSDlhZHmjaIg5ZWG5Z+OIOaooeadv1xyXG4gICAgaW1nLnJlY2hhcmdlLXJlY29yZCh2LWJpbmQ6c3JjPVwicmVjb3JkSW1nXCIsdi1iaW5kOnN0eWxlPVwicmVjb3JkSW1nU3R5bGVcIilcclxuICAgIGRpdi5yZWNoYXJnZSh2LWJpbmQ6c3R5bGU9XCJjb250ZW50XCIpXHJcbiAgICAgICAgZGl2LmJhY2tncm91bmQtaW1nXHJcbiAgICAgICAgICAgIGRpdih2LWZvcj1cIml0ZW0gaW4gbW9uZXlEYXRhXCIsdi1iaW5kOnN0eWxlPVwibW9uZXlibG9ja1wiKVxyXG4gICAgICAgICAgICAgICAgaW1nKHYtYmluZDpzcmM9XCJtb25leUJhY2tcIilcclxuICAgICAgICAgICAgICAgIGRpdi5iYXJjb250ZW50KHYtYmluZDpzdHlsZT1cImJhcmNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICBpbWcubW9uZXktaW1nKHYtYmluZDpzdHlsZT1cIm1vbmV5SW1nXCIsdi1iaW5kOnNyYz1cIml0ZW0uZ29vZHNpbWdcIilcclxuICAgICAgICAgICAgICAgICAgICBkaXYuYm9udXMtbW9uZXkodi1iaW5kOnN0eWxlPVwiaXRlbS5zdWI/Ym9udXNNb25leUhhc1N1Yjpib251c01vbmV5XCIsdi1odG1sPVwiaXRlbS5nb29kbmFtZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0g5Ymv5qCH6aKYXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmJvbnVzLW1vbmV5LmJvbnVzLXN1Yih2LWlmPVwiaXRlbS5zdWJcIix2LWJpbmQ6c3R5bGU9XCJib251c1N1YlwiLHYtaHRtbD1cIml0ZW0uc3ViXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLnJlY2hhcmdlKHYtYmluZDpzcmM9XCJkb3JlY2hhcmdlXCIsdi1iaW5kOnN0eWxlPVwicmVjaGFyZ2VCdG5cIilcclxuICAgIGRpdi5teS1tb25leSh2LWJpbmQ6c3R5bGU9XCJmb290ZXJcIikg5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX1cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcHJvcHM6IFsnem9vbVJhdGUnLCAndXNlcmluZm8nXSxcclxuICAgIHJlYWR5KCkge1xyXG5cclxuICAgIH0sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1vbmV5RGF0YTogcmVxdWlyZSgnLi4vLi4vZGF0YS9leGNoYW5nZS1kYXRhJyksXHJcbiAgICAgICAgICAgIHJlY29yZEltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC86K6w5b2V5oyJ6ZKuLnBuZycpLFxyXG4gICAgICAgICAgICBtb25leUJhY2s6IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmcnKSxcclxuICAgICAgICAgICAgZG9yZWNoYXJnZTogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwv5YWF5YC8LnBuZycpLFxyXG4gICAgICAgICAgICBtb25leUltZzogcmVxdWlyZSgnLi4vLi4vYXNzZXRzL+WIh+Wbvi/llYbln44v6YeR5biBLnBuZycpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgcmVjb3JkSW1nU3R5bGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTM2ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAyOCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDI1ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50KCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ5NSAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYxOCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMjUgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vbmV5YmxvY2soKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwICcgKyAxNiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidXR0b25CYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjYwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNjggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA1MiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDEwNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmFyY29udGVudCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogLTExMCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9udXNNb25leSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDM3ICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib251c01vbmV5SGFzU3ViKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzIgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAxNTEgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvbnVzU3ViKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEuNSAqIHRoaXMuem9vbVJhdGUueSArICdweCAnICsgNiAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxNTAgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgLy8gaGVpZ2h0OiAyMCAqIHRoaXMuem9vbVJhdGUueSArICdweCcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDcwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMTUxICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb25leUltZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMTYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDggKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAtMiAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgMHB4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWNoYXJnZUJ0bigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA5MCAqIHRoaXMuem9vbVJhdGUueCArICdweCcsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogMzAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAzNjQgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvb3RlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAxMzYgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDM0ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiA3MTAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHggMCAwICcgKyAyNSAqIHRoaXMuem9vbVJhdGUueCArICdweCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcblxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmRpdi5yZWNoYXJnZSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbn1cclxuXHJcbmltZy5yZWNoYXJnZSB7XHJcbiAgICB6LWluZGV4OiAzO1xyXG59XHJcblxyXG5kaXYubXktbW9uZXkge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5pbWcucmVjaGFyZ2UtcmVjb3JkIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxufVxyXG5cclxuZGl2LmJhcmNvbnRlbnQge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmltZy5tb25leS1pbWcge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG59XHJcblxyXG5kaXYuYmFyY29udGVudCBkaXYge1xyXG4gICAgZmxvYXQ6IGxlZnQ7XHJcbn1cclxuXHJcbmRpdi5ib251cy1tb25leSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuXHJcbmRpdi5ib251cy1zdWIge1xyXG4gICAgYmFja2dyb3VuZDogI2YyNmEzMDtcclxufVxyXG5cclxuLmJhY2tncm91bmQtaW1nIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG59XHJcblxyXG5kaXYuYmFja2dyb3VuZC1pbWcge1xyXG4gICAgcGFkZGluZzogMSU7XHJcbn1cclxuXHJcbmRpdi5jaGFuZ2UtYnV0dG9uIGRpdiB7XHJcbiAgICBmbG9hdDogbGVmdDtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIHdpZHRoOiA1MCU7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogUmVjaGFyZ2UudnVlPzRkNTczNjY3XG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgZ29vZG5hbWU6ICc1MDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiA1MDAsXHJcbiAgICAgICAgc3ViOiAnJyxcclxuICAgICAgICBnb29kc2ltZzogcmVxdWlyZSgnLi4vYXNzZXRzL+WIh+Wbvi/lhYXlgLwvNTAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH0sIHtcclxuICAgICAgICBnb29kbmFtZTogJzEwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAxMDAwLFxyXG4gICAgICAgIHN1YjogJycsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMjAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6IDIwMDAsXHJcbiAgICAgICAgc3ViOiAnKzE4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzIwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnNTAwMOmHkeW4gScsXHJcbiAgICAgICAgcHJpY2U6IDUwMDAsXHJcbiAgICAgICAgc3ViOiAnKzg4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMDAucG5nJyksXHJcbiAgICAgICAgZ29vZHNudW06IDIwMFxyXG4gICAgfSwge1xyXG4gICAgICAgIGdvb2RuYW1lOiAnMTAwMDDph5HluIEnLFxyXG4gICAgICAgIHByaWNlOiAxMDAwMCxcclxuICAgICAgICBzdWI6ICcrMjg4OOmHkeW4gScsXHJcbiAgICAgICAgZ29vZHNpbWc6IHJlcXVpcmUoJy4uL2Fzc2V0cy/liIflm74v5YWF5YC8LzEwMDAwLnBuZycpLFxyXG4gICAgICAgIGdvb2RzbnVtOiAyMDBcclxuICAgIH1dXHJcbn0pXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvZXhjaGFuZ2UtZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJNemcwUmpnM09UUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk16ZzBSamczUVRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOalF3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPall6T0RSR09EYzROREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCszUS85S1FBQUVqOUpSRUZVZU5yc25IdU1YTlY5eDcvbnZ1Yk9ZMmZmVDl0ckc5WVBjSW5CTVk4YWt6YVFJa0lMVVZYUkpHMXAxZnpSVmduL0pLbWEveXIxamZOUDJxcUpxcWhxVUtxbWtVaWFKbWxVSlNCSUs0SkZ3QUVNeHZaaWUyM3ZldGY3bnZlZCt6cW52M1B2akJrbU03dHJJQjVqbjU5MWRHZm1QdWJPL2R6djczV3Vsd2tob096YU1VMWRBZ1ZVbVFLcVRBRlZwb0FxVTBBVlVHVUtxRElGVkprQ3Frd0JWVUNWS2FES0ZGQmxDcWd5QlZRQlZhYUFLbE5BbFNtZ3loUlFCVlNaQXFwTUFWV21nQ3BUUUJWUVpRcW9NZ1ZVbVFLcVRBRlZRSlVwb01vVVVHVUtxRElGVkFGVnBvQXFVMENWS2FES0ZGQUZWTm43MEl4T2Z2bUI3U052UHhrZEtGWVpTbFVOT3FQM1RLQW53N0ZVME5DVkV2QThnVnUyY3pnZXkvN2FuY0hFeFNVMjNwWEZsbCs1UzR4b1lOMW5abGpQVUovSUpIcnNoRWhsTldhbWd0V2NxQ1N6NXNyRWptUnhhckswOHN3eitiTzMzMlROblR5V1B4MlduUE1MYzFXOGNkekZiLzltRndiNmRaeTdvR05pSW9YaFlRYXVHL2l2NzB5ajRqQWMrcCt5QXZxTzNRYkI1QUtZV2RXeFhHTFlQTUMzM0xQSFAzanp1SGR3eDdaZy83WmhObUYzRzMzREJBQmdjQUlkQ2N2QXZyMGV2VThBbVFGYUpHUC9RMjlCeDNMS1pZemVsY0RCQjhlQTBNUWRoWEhmMXZVTHI3MlVlL0dXbjg0Zk1hcjVIeGNXaWkrc3pPa0l4bTB3elZBS2ZiZkdXRHltbDNXWUdoTDM3M1VlK1kzOXppY083S3JjdjMyTGJocDlhWVRWSkZ6UGhPZnFXTHhJcDg4WmRGS1NaM0FnUFFxOWV4UnNsVVBUZGVpcExvZ2liUkw0RUR4RWFjV0RPTytCR1FHNjBxN0piR3k3NjRIMHRyc2V2UDBSUU1mY0s5T24rZzh2ZkZjck9sK3ZMSmFPbXYzcCtJUVUwSGNHMHdzWXBoWU4zTDNUL2R5ZlBsVDg3TDAzTzV2TkxxQ01RY3lWVFBCVndDUTNiT2dhQVNQeEpRUkJvNStnY2VpWkxoaWo0OUJKbVN5WkJIY0NWQllYSVppRjlOZ0l0SzRNYlNkL3JnbmhCZ2hJc1c1dUJZV2Z6Q1BrSjJBUDZCaTlkZmZFNkswM2Y5N1B6WHgrOVUzMzM4KzlkT3F2Yy9PVkUxWTIvYjRCeWpyNTUxWDNieHFNbGlMNnB5UHZHT09mL09YeWszLytXL2s3dEJDWTlkTGczVnRJWlVXd2NoR21HWUpyRkY4VEZwSlpDMzVJcjhuVkdycUEyZDBIdldlWVFEbmtYaDF5MlZYYXJvekU0STMwV1JyWkxWbXdSQjk5R1IzWXNNQXNpKzRJTzdxbmc0VkY1Q2VQb3JSNEJyMjNqeU83ZllJK0QrR3MySGp5OFdmKytMbW4zL3pxVjM4bUZORDE3Sjd4WkJ3ekNWSUZ2YU1QN2kwZS9ZdUhDd1BubDRHcW5rWnkwd1NjYzlPdy9GVVltVFNNcEFuWDU4aXR1SlFzR2VnZFNTRTBHS25RSUxkTFRqTnJveHFRQmxNbTBwdDZZZlIxQXdTKytEcUI5RGd5Vy92akgwMytQTnFCMVlLMXpNYlM1TVpQbmNiWnA1N0MwSDA3MGJOanM3dzZ0UFdOK1BKbnZ2blp6M3o1OU44cm9PdllvVC83ZEpUVVZIMGRaNC85NkluUDNYM3lENGJJeFM3bWljUHVQZkFXYzlCV0xrRHZTcE9McFR6VzBHRFRoZWVVTlpYelBpekpvU2NCdThkQ1NIQXFkQng3cUp0WU1RVFZrT0ltZzErdDBMRnVKZytRcFJ1SGcrbWtUdDJHMEV6NlpqTStyazd4bDVGeU14cXFyNTdDaGFNdllOdkg3eVNmUVo4bmI4RHNzVExHOXZ6TCt5S1lkalNHZnVHTFg0bVdQbzIvL01NUDdhd1dUcUpDV2FraGN4MUJzYTVhaG03cnFOOTBVWnlWU3V0T0lySFp3dFN4RllwL0RGMUROZ0p5djhWWkZ6TGlsdWRMcE1aZU1EL0EwaXNMNk5yWmg4UllDQkk2Z1UxUmtzVEo4eVpwNkREc2tOU3ZSNWt3S2g3czRSNWl5eENXQzVSZ0RVYkh5L1NsVkdQaGNzeWtzZS9nd2VPSFh3ZDZLYlFGNURaWmRRbkcwQ1o0NVpCT01veG95bjh5R1ZwZUxHSHUrQ28yRFNjeHRNVkd1ZWlEVjEwTTdiUmdkREdNM3JrWmZUZjJJVG5haTUyZitnQTBjeGRLSndoT01BNFdqTkV4ZW1HbDA3RDdOWUpKMzA0QVlkRXluY1RzYzYvQ0dFbkNHdGhFbnhmb3pNWXcrK3FVQXJvUmUvak92WGpvOWwvQ3B4NzlBclRTaS8zanY5cUxuMHdhR0tDa01waWZnWXlzeHJaZEJKaFU2anBSMktzNmxLd1VBZ3pRUlRjcFBoWXFwSERLamprVm5JeDFRd1FKbEJmTGxPQ3NJamxzUU9zWlJIbTZDc09zd3N3a1lLUTR4V0lqY3QrUmd6SXBNZXJwUVpoM01QZTlwK0VtY3RoMDcyMjBqdHl0ZlJPOG1ST1lmLzZIWEdXNUc3Q2RhWVpWeHpiMmRGZS85ZmluOGJHN0h0Mk9aMThNRVV3dVkweVUwWjhsVHpnOEJKZVR5M09yME1pRm1oUUhFMTFHbE5ob01sczFDUnBkZkxOdmtNcVdHMGhWQWFyNUNrR1hCZWd5dE13d3JPUWdNcHQ3NmZaTnhmNWNOaDEwVW1UVmgwTVpibVgrTE56OE5NeGhDNE1mbERBcHhsYnpLSjZhUWZudy8rTEVHeWgrK0VzaXEyTG9PalpLOWVHQlVmNzlRdzlYSDhnTEMvblREajY4WDhlNUxZTllPTmNGUDFlQ05iMUFHUzFEWXFBWGhCT2hiOENoMktkektsa29ic3ArZ3FBc1ZTdmtvU1dYd0RKOVNQWDNJYjExSzNnNWdGdHl5TFdTY2owcVQraW1DSDJQbGxUV2VFVlNmb2tnVjJDUDJlaS9leCtkVVJyTzhnemNwVmxVSjAramNES1BoRWYzaUphc3FNYkNCdXltTysvOTBBSHp5UWV5bEFnZG45UFJTd2tPbi9XdzFmS3hkVzhDYzhWK2xISlpsRW91eW1WeXY1U2dHQVF2TGVNZEtZMVJwa3FDaFU1S0Rid3EvT2szd2JwSEtCNG1vM3BUZG9zMHFsbUxNN05Vdy9MbzE0YVV6V3BwSGRZSTdadk9SZ29PS2k1eWt5ZFF1WEFlMWRsRkJFdVVOQkZyVGplUGx1WXl4RHJYUGREUjBkRjF0L25LUC8zejZMa252b0V3alB1dGtLMC9peUtuSThBS1ZRd2xCRVlIRFpRR2JFcEE3YWc1enlsamNzajFDaUtaWkE0Q3FtR0Y0VU1UcEdJZVVLbFJBazlRQXBUdUlwZE1RR2lkakwyZXJGZnBoUzA3UzI2QUFxbWZ6VXloc3JDTWNLVkErUThCcHlSWmVPVEFYYnBoTkRxSGhDeFhoVHczdnBIZnN4R2JtNXU3ZGhYNjBRZnV1UGhYL3dxY21hWHMxdmFRS3dnTWpoQlZSeGI3REs2c1o1WUNNTzRqUzFDMEJLMUw2YWlFWnRRUGtNTUxoVXdFcU1ZazljbTRTTW9VdVhtSWNsNUtseFJNdFNlQjl1bGdYdG1uTE5lRFFUZUVYK2FJa21lU0g2ZjZWUVFHbFVDSVFHcFdmR3lkeGZsRm9hcFBLWmU3QVR2MmczOVlldURoTGh3N1oySWl2d0ovTW9mNWJDK0dCelY0cEJoZjF2dHlIbzFnQlhUeFJabWtRbkFaWFczWkdwUVhQRkVySVlrYnBVYTBudUFLQ1NZb2dKUDBaYWN2ak1EUnRvSUtJTXFJZmQrS2RwTDVvTnduNmdpWlVVczQra3p1bjVTek5KUlJIem1OTnk4NjFtT3FiTm1BZmZzZkR4WDNqR1Q4ai81ZUQzSzdSNmdFQ2ZIYVU4czQrNFpIdGFPR2RGYUx5c09vUmNQaXM0MEF4NU9sVWNlSXhFYUFpQjhsTHdGRnVyQTJBbGRINk1ra2l0VE1EUUl0RlVqdW1hU3NXVlRSeXVQS29kZU9qWGphTG1FU2VFTmdhWVZqeHQ2S3FkU3VILzd0MDlaSnBkQU5XTmRnZDNuNmdsL1p1NTEzMzNlM2hhbWRZeWlkTCtIa2xJdlRVd0ZHU0tuREl6cVZpWXh5SUVaWnFZamd5WUZhMkszRGlHRGpyVmo4dGlGcTI5YlhpOW9xS1g2Q1I1Z2pkMXR5TkN3VkRZclZRSDdSUS9xV0FYenNkKzkrN09MQ2R5NTg3Vm4vVU5QcEN3VzBxUWJPT1V4R01nY3U2L2FYSE54SWdUSzhOWVV0dTVKWW5QZXhkREhFd25tNjZHY0ZNaFpIbXR4Z1NzNWZwd1ZNMlJNd2FyeEV6ZVh5MkYzV2w5RUk2MjQwOHEvUnZFN2dNNWtYMFdDb2VqcGNMKzVPaFRVMzNwc01rQjNnbUM4WEtWTXU0UDZQMy81M1gzdjIrUzgyd1dSWEk5eE9BWTB1eHRkZnRiMVBQQlRJSGptNHJzRXAwblhKT2NpU1Mrd2IxVEN4eFVURlpWak9jUlJvWGE0aVVLWUxmbUZGVUEwcVlKc2ltdURtZ1p4OGkrTUhhMUFocjhYSkNMalFJeFdHZ1lqaFM5QXlvWW9tN3VvM0RJZXB4WXFkcDV6S0R4T29sQ293VTFZOVBMVUMxd2hYWEc5QVdmUHJjelBpcGR0Qy9McE5wYU5ENVRzajErcVJXcXFMOG9vSFViamNUS3BrQkZqR1BJOWdsS3VrTUNveFpHTytXaFh3L0pvU0pUQWVTMWJRZlNJL1Exanp0MFRYSk9vU0dFVlVXSExKZUV5SjFnV1U3Y3JFeTZOajJuNklBbVc5aWVFRXVlUitMRTYrSms5VmYrdFd1VFN1T3JCR0IyQTJMdGtMcjRhUDlmZmdnL2ZjYTR5a1pLKzJSREJZblB4SVpVa2VEcFV4b2h4R1NwU2ZHUkRSQTJUeUVOMjAxSklpdnNKUmhodG51WkVDcFJwREVlMFhMZVhRNG1QSzlmS0dDR3BaclR5dVJmR1VGMEtjdWtqdjc5Mkx6ZnYyb2ZENkpJckhEdE1XZzBiYzRMMEVrNzg5S3Y4Y1dIRTlLWlRWUGVRVEw5c1hWOHJ1Z2VVVi8xdjdidFgzRGZSU25FeFI5dXFLS0xhOXRUVmxwa2JObFRiR3lGWnhrNy9sYXVQWHJPRjFEWHp0MExxYzYyWWhxbmtlemNOV2gwYVFmZlEyOUcvdlJ1NlZJNmorN0FnTWoxVnExNm9Pa3RmT3Z4bHdJOHlPUURVNjVHcTF4dkc5eWNUeWprM3V2OTIwRy92T1RNZnF5NlFwQzZhUnN1TWRvcVFscU5XampVZGlEVWRzTk42d1RXMEgyWHlJSGtRaitySkdkVXNjcFNvbFIxWWFiSGdVNWgxRDZMMmhDN1pZd3NwVC80ZmlxVEpzK2NTS2taQ3RQNnNCWnF2UnJOYU9RRFd1c0NxYlllcjFRV1dKdVd1SFRvbUl3TXcwUjU1Yzcyb1JVWUppMUdLZnJBOXQyY2JWNHVzbTUwYVpIcnZaNklyV2ZIU1U5RVEzUUloQXdndWtndVZ6dlN4Nnh0YlZiT2tHd0ViU0VOMHBwSWRTNkJraVl0NUZyQjc1S1JiUEIxRk5hNFVHMGltS3MwVVE5dWlCVVBrMVlXMDB2cTcvdGthNEhZSGFDWmRiSDNXWThod014NFdvVUJhYm91Um8yMVl0YXQ2VXFLZ3BsQW1DVkZFb0d6Y0V5NCtUR05udWs0cmxQbDF3RmljK2dTZHFmV0VaaCtVaksvTDVXazBtd3ZEbCsxNExtZTBTRW4ydHJhT3ZoL1oxVnlGV3pxRDBYQVVsT2VOR1pZemhtblNIMFRGTVdTWlJGcXhGOTJRejBLRGh4cXgvMXVnZnJsbUZ0bktPOVNyRHFBMXphaEdUdVR3QkhhVHlaVEhxNDBVWjdtQTNiZGhMQU1sWCtqS3JsWjBobWN6SVhycnNFSEU5NnI5S2NWWTlSQXFQdm9SMjFpMGRDWk5CUHVBWFBmWEFLMGdhSVVIMDRNeTRjQ2ZEcUJrZnlxNVNZRVZsamp5V21ZeGpzcXhKWll4ZHJSalRrSk9rUHc4emFQaGRXRU9aVnd5c2NZVmpaMXVGZnYrNGRYelBmM3ZmK0tQZk4zNG5OVUJ1Y1ZsRWNWTzI5dXFOZ1VpWk5Dd2FVaTRadXFTYVdjOXc2YlY4ZkpiVnMxeE9rR2hRaHV5VGNvVnNEQXY1SUJsUmtKMG0rY3lTSEhKdlBXN3VzNGFFSzJYSlBqSEgwUm5iL2U1UiswczFoVFlyVTJzcVZacExHbjZseTVoT05CWmF4ZEVJNnVNL3NnN2x5Mjdoa3cvcGY3SmpGNm1MdGd3cGxsYmR0MmU3OVdhOGJBd0lyd1k4ak9Oa3ZXeUpCNHNINGdaRXRGMXROaVhxSE5WeTAvcERHL0prYkhLeDhtSHVmSVhoK1Rjeko3LzVzdjAzTDAzcnM3V2tLR3dCc3hra2I2SFlLNmJTWDlnaktMWDV3K1l5cGE1S3MyRllUY1BZUHhic2VuQy9lT1RnYmV3ajI4ZFpLcE90bFNzZWo5dDBYaTN4cVFPc2x5VFJhL0hXNnpwYzBmdzZsblRrSmhpUFhDdWo0Ym9NS3lXR1UvUFcyZWRQVy8vNUh5OWJQMmlJaDJHVHkvVnJ3MnRhK3JYMVlVT1NkQ256L1VYUGgzWUM2S1c0MlFLbTFiRGVHT3ZpUGZmdER1N1pPOEVPM0xnWnU4ZUcwSmZOeUttdE9MWnBNbmFHSWlwbG9nUXB5bkRGSmJXaUJyRXVReFkxNWVQRUtmQkZGSVBMbFBVV1NJMFhWdlF6cHhhTVYxNmVOZzcvK0xUeFdvdjZjaTJnamFNUmFIZzlBTlhYQUZwWGJSMXFmUi9XWllua0I4YkNHeWFHK1k2UlhyRmxwSmR0R3VnUm94bGJaSkkyTXBaQmlhbU1oU3hXbm9RWjlXNGx2Tm9zRFdYU1RzbEJxVkRSOG9zRmRuNnB5QmFtbHZXVDUxYTA2VGZtSTdjcTJzVER4bm96MkNEUTRIb0FxalVCTlJ0QU5nUFZHNGJXSXFsaUxkcUphUE4rTFd2VmsyMU9iRVJUN1ZtSDFncW0xMG1GWHNta3FOMGRIemFWQUsyMmJVeEN0QmJOQ3JiV0JNQUdZWW8yNXlxYXpyVVJMRitqWVg5TjluSkZteHBOTkhWWW10ZlZMNkRlM0Nac3FtZWJ3VjR1MEhZZzBlYm00dzNxQzFxNDF1WWs2SnB0em9zV0hWYldBTFg1NGhtMWRYcVRxMll0bE1yYXpPUzBjOFdpemJtdEZUK2JYVzdRWXRUVjIxSEZHbGNJSm10eDE2L2xqaHRodGxPcHRrWThaZTlBb2MzcTVHc0FiUWUxblN1K0pxZlBHdHRoelExczNzTE50bE9udGs2UzFBcnNSbUo3SzNXMmNybGhpeEltYktQUWE5cmxOcnM3M3ViaWhTMDZTV3dOZFdvYlZDaGJKeGxxbDkzeUZva1JiNkZZM2lLT2ltdTU5ZGNNdGRrVjh5WmcybVdBWEUrZGJJUHVWclFKQWEyVXl0dEE1SjNNZHE5MEw3ZlZqRDdIMng2NHZEU3YyQXJhZXE3Mm5XUzZZaDNYeTl2QWJiWHNpQ283M1p4djVYNUZtOXFTcjZQQWQ2ck05Y3FXOVdJcTFxaEJPMXFMZHVveFRyRk9HZEV1SHJZclVWcEJYS3Q3dEY3cHNoNWNyRk9hWEJkUC9WMHUyRlp3c1FGNDdhYXVOdHIyVzZzK3hRYnF5NDQrbTN1MS9PRXBzVWJ4MzhwRnJ3V1F2VWZuc1piaXJpcUlWeVBRdFM3T2VtNVpYSVlpTCtkNzExdW4vbS9MZXdoNG93RFl1d1I1MVFOOFB3SzkzQXY3YnY0VGtjRDczQXhjZXlad0hWdEgvNnlOc3ZmZTFKOG9WMENWS2FES0ZGQmxDcWd5QlZRQlZhYUFLbE5BbFNtZ3loUlFCVlNaQXFwTUFWV21nQ3E3WlA4dndBQnlORXJQUFI4UHB3QUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzBRMEV6UmpZelJUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMFEwRXpSall6UmpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOak5ETkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalJEUVROR05qTkVOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtaNGcyY3dBQUdJaEpSRUZVZU5yc1hRdU1YRmQ1L3M2OWQyYnV2UGZoZmRyclJ4ekh6b01rRGlFdlFvQ2tKRTZCUUFNazBOSldnWlFXUWRXS0ZsR3BWVitvYWtHbFZWRUZsZHFHVUJCVkJFRXFsRlpRR3NvakljMDdUcHpFVG15dnZidmUxK3pPN0R6disvUTdkMmFUOFRDN2RocmkzWGp2a1k3bmRlZk83UG5POS8zZi81OHoxMEpLaWFpZFBVMkxoaUFDTkdvUm9GR0xBSTFhQkdqVUlrQWpRS01XQVJxMUNOQ29SWUJHTFFJMEFqUnFFYUJSaXdDTldnUm8xQ0pBSTBDakZnRWF0UWpRcUVXQVJpMENOQUkwYWhHZ1VZc0FqVm9FYU5RaVFDTkFveFlCR3JVSTBLaEZnRVl0QWpRQ05Hb1JvRkdMQUkzYXo2a1paOU1mTXpJeThuSU9GeDJQWC9HMUNhYW5weU5BejJBVHAvbmN6dzNnQ05CWEgwaHhHdURLMXpLd3hnWUJVM1RwbmNES2pyNzhuSGd0Z1dwc0lEQzF0bHV0QTloMklJTlc3d2J1K3YrajE5TjFpajU1VXdxOXZRSzN2R016QXRmSDFKVEU0UmNxMkRFR3pNNjQrUHEvbFhIVlZWbkU4b25jenQwOTV5Unk1cmJqQlgvMExXL05qL1gyeDNNSG42MWw0d2g2VERNd3BWM1hVQzNMVXNHeDZxNVczVDRjVkNZTEtQL3dRVzBtblFobVo1YTB5ZjNqK3ZIeGtsanFBTk52OWVYNzNaZ2JtYUtYenkySlJ0bkI0b2txdGc3Rmh3WjM5cnpwWTMrMjQ5cWRsdy9zM1hGZS9IVlcxZXJ0eVhHOHBROTMwWWQwTEl5OU9RRjRmTXJodUFjcEJQVUVlNEdUdzBPam1zQzJRUTl2dk1nSEQ4WE1nZ2V2WVZlZUhROE9IcDNXOXgrY2pEM3l4REhqZ1VWUFRDQThTOWpSd2RoMUw3L3JpNkg3VXVqSkF6ZGYzd2V2S3VGbjg3ZkhCMUlmdVBDNnNWOHcrM05wb0FRc2x1RVVKRUV5NEZveHlDQUdYWXZEaU1laC9oUk4wNkVaR3R4cUdSNkJkTDBBWG1FQ2RyVUt5eGF3eVh3LzhDSFlvZnRJbWhMQ2NPR1ZHNWllOGUySFhrZy80VG51L0NVWFp3WjMzM1RidVEycnVEUnhZUHpMUDNsaytpL3UvbTdkLzhOYkEvbkZlNEJrVXNEUXUvOGRENDdQUklDcTlydHZqU011WFh6NHQ2LzQ0TWlsdzUvSzdjeGVCUFRBTGIyQXBhZG5DVjRHOGZRUUVqMkRTT1J5RUFRUkJzbmprMHh1RFhhaGpNYkNIS1Rud096cGc1Rk93UE44V09VSzZ1TXZvRkYzWWRzQjJlcWlZVWw0dm9SRk5qc3VUeUVEOU9jOWJCdHlFY3NLOUYxOUU1SmpZeTNWdFdGTmxKNnA3WC80SFJmZFdSdnY5NlEwVGF4TFFOZVY1RG8xRisvN25SdnUyZjJlM2JjQnRYQWdwMzV3SDBSUlEvN2NpNUhldVFzd0thdE9neTg1Qks0RzRYREFZenFzNlZsWUZSZkpVUnUxeVZsVXB1Zmh1eHFFb094eXp0WWFQdXAxQjlWYVFOWlN6cTBBcGFMRDF5U3Vlb09Cc1dFZ1laREJUaDNWb1dzSTVpalFlQXFJWjhua0dNeXgxQVZtYnUvRG4zemIvMXp5dC8vcVRhVTNtK3RTZmRlVW9kZnNHRDdwOFovK3daN3YzdmliYjc0Ui9tUFV6aXltL3Z0UkJETTZ4dDZ6andPYkFzaXNackdTSUhvNkF0dFhJWlJTNjZBMlZVZHExQ0VyajhPZEN3aVVnOUx4SXVPd1RWQURWQllJS0ZucGtKSHpzdzZLUlE4T1QzYkxqVEZzM2kxZ3pSQm9CYnFRU0Y5MkhUSmJjK0huMkNjbTRWUWRaTGZ6dThhSE1mbjQ4OCsvNFJlZjJaMnNCM0pUandnblMyZDc1SGpFMExDOTliYTlOd0wwSkNLRCt0UUVyS05sN0h6MzIybEpLS3RWeFZnZHZvcXRUc0M0VjRmUWJFaFJKYUkyY2hjWnFCNmN3TXk5aDlIN3VoRktyd1V0SmhndlRWUUtOU1N5TVFqYnc0a1RkZFFjQVpGUG8wZTQyTHhOUTJPV2NkWlZBZGlEa2U5RElwTUl2MC9weVVOWWVtS0tjeW1MOGpOejZMdW1oaTE3ZCsrNjY0OW0vK25qSDMvK3cvMWI4cHdTY2wzeGRGMFY1K3RWRmE5aUpBYTVrK0Nna2xtbzJYenE1SzhwZEoxZ05sTklJV0toOGdXV1RtVTBZZmFhU1BRbUVjOGxsRU9Dbm1TZzQ3RXFUbHFlaXBYS0dBbVVxd0cyamphbmRORHlzVUpuWEtXOEdya2tKWHdTNWYwRmpGMTNQVWIyM1lEZTdaZWc5TUJ4MlBOSGNQUEg5bjdvenRzek44eE9XWWh6MGxEeFQrb1JvQ0V3d05FZi9JajNCam5JQXViQUlMS1hqdUhJOTMrRW9GQUI4dmt3bHVrWkF6RktuWkZNUTlQNytBY01FN2V0cUQ2Zmc1SGRqaTIzWDREa3Bnenk1ekQyMFlrR25vMVVYa09sYUtOYUQwS2o1QWNDaXdVYkk0T2ltWnkweWd1U3dKc21Kd3RCYmt5VTBIZmVCZEMycUlKL0FxbUw5bUR3OGh0UWVtaUs0RmZ4a1UrLzRlNkU4RkFzdVpUeEFJNzlVdCt3Z0RvME5LcmJEdk5FVzZKeTRFbVVmL0pOZ2tCUWtlRUFYb0w4bGNPWWV2Q0hLTjMvRUx5S1ExUEUySllnV0VhTTZZbEtPVHpvcVRqTS9CTHEweVhVajlvb0hwcEc0VkFkWGkxRDFnMGhTRzZHU0tUaCtEcXFEYVkwZksrZU5wRktLVURsaTk3R0p4WnhUaGpwVU1hOU9OSmoyMm0rT0VRQmFWZm41d3dOb25mM3RTajk5RGo2ZC9WdStmVTdOLy9HNGh6bFBxc2huUll2OWcxYldFanExZWFzb2pUVzBUdmllM0ZaZk9BWlVaazlnZDY5RjlDRERLUC9kVmV3TDZDMC95aEtoKytITnQ3RFFkL0VubSt5TkpFTTlUSXhzZ1ZhZkFtMWVjblVKb3ZVU0M5OGhVUFZnak83UU5VVi9CeURVcTFjTGhsSUppVmlyWkpCaTZRQkhZNnZKOVNMNnR0QnBIc0lkZ0RKM0pYMmtjZFFZcmR2Z2JVNEJ4U244ZDZQN2ZxVHIzNWw5aDhucGdPa2t1dEQ3TllVMEhlOC80NXdLQzFYeC9pQjcvMGxZZ1ZxcElieWdSSWw3d0hFdHFSaGJobEFabXdiOGhmdkpITmRlS1V5L1BJMFBIc2FUcG1teDlZWnQxUWNwZXNWT2hMSkpJOWo3amsveC9NeVBXazRxSjg0QVpzcGkwT0NXM1RHcmdLT3ROUjA0Q1NUcng0WUJ0TWRId1laclNSZXBVNkJvL0c1QVBGZU5ST3F5SjEzUHFyUDNZOU5WMkh6amJjTTMvN2xMODNjcyt1OFpETVdiMlJBUC9YWkw0UzM5Q3Y0OHp1dU95OEl4cUhIQ2JGbndDMlRNYy9YNEJ5cm9ab2RSNnlQUm1ld0grYklJSktEUFpSUERRbWh5bmdFMldxUVJRRjBwd1VLV2FpWkhtSk9EVzVsZ1UvNVZGQTY1QmdkcVNGRDV0cENIYXFkdE5TaWFhcjZ3NVRIVXk0NkVab3BGV05GWExHVWp0cW1VNllKVXJtd1NOSlJGU2Z4S3g4ZS9mMXYzanQzVDkzaHhJcEZxeTFoVStOdzJiWFhQbHQvNHVHcll4cWxqUU1lbXRjZ1J2ZXFhck44WExIaFRVNmlaa3hDU3l1ZlFxUFNsNEtmTkFsU0FtWkdEVFluQWhudWFXcVNXUEJFQlU2R1hOUTFCRXNTeEFSZWd2ZUpwcVR4OGhrMGhmYVNLVktBQnBiRFZNZ1A3NGVUZzVLcnFLZkZhdkE5azRDbkllc1ZwSVpIT2RsT1lPZUY0dkpMOXVZdWV2alIrdE9EQThiR0J2U1dLeS9oZVBrWTJQTjJ2T3Z5eC9yTEtSTXpaUjlEZVE4VlNxbnlJZ3g3SEc4T3ZtVDhZLzRJSjB3NzZZa29wM1MvdWxGbTU5TTh0cUh6T0dXWDJjbFhnaHFIUlVjYk1GN0c2alF1ZkcvTkY0Z3piWWw3cWlxRWsxWkVGYmJWc29Oa1FyMmJRSG9xejJIODlGV2F4SmtWZVBDdEZGV0VyNWx4cGtKNXhFVUI3Mzd2d0lkKyt0QUxuMGpFTmppZ3p6MjlIOFdHYVZ6NHdtZS9NYlFWNzdycWpoMzR4cjBteXJORjdCaHdvUk9naGlmQ05FTXhLV1N1d2tzeFNkMVJ3ODdYUWdiek9VSGpvb1czeXNPSTBPUVl2Z3lkYW1BRmpMYzhsbUFxMGlueVdSYi8wYldtNENwQzhyTU1uaXpHeWVLSDlXRTNuSEJDZlRCbmw5UXE4Q3RVQkRwejNXd2drZThIcHVhdzkvV0pXODhaTVFpb3ovZHVZSmM3TWpxTWEwYUNiMy9tRm12ZmtveGo2WEFENzcxVng0RkRRM2o4MFFwNmd3Ylo2aU9UREVJRDQxRk9GYmhCeTVZMndXMjdEY0VrWU9FaUYrOEhJanlPWVJFYXdkSjVEdFcxOEZpSllsa0IyaUpwYUhNMWFLNUZhU1dJNUxkMGJNWlBBWThTNnpRTXBMYTd4RGhBZmFwQlIwM1o3ZHNFYTg3RWx2N3F0cmZjMEhmWjRZTzF4L0k5eHNZRjlQd3JyNy91bXRqWDk2bWl6clBUT2dFa1dDY2NYTmduY09HdEdSeVp6V0xpb0FXM1lNTWtjN0ttUkRZcEtZbFNwYUVodVVUTHFZWWd0c0JVWFRsT1ZiUVJyY0pCdU1DcFdNbm5HM1JoVlVldGliYlYxMVZhdzE0clcyU3F4NVNLOG1wYkVNeHg2bk1ObUVNSkxENDREaU8xaU56NVcxQTlNb2ZHb3NlSjBVTldWM0RScGVsM0h6dFNleXliT1VzWmVqcGJLci93OS84d2N1enVyNFZoYW5uNVdNU1prelpvakRpdzJ3amNPVmNZcU1vTXluVmdidHJIaktyTWxOUjZKdU1jdFZOVkJRMnlMVUVtcVJDbU1nM1JBalZjSGlNemF3eC9TM3gvZ1dudlFsMmdVTkZRcUdrNFB1czJWOGRhQlBWNGJDeE9PWlVFMDNVZ2FsWFl6RWtUZmN3L3pScHE0MlhFMGpYa3RqUDNkUmFvRmdra2N3T2NKUnEyajNodlM4WHNQNDVSOWxmNzIxL3RYUTFyeXRDYjkxMHg4K203Z0NNbmdGN1RRWWtTT0RETW9XM0lzUHhucTN5bVFCWUVMdnBJdDAzcXRURURkZDhJVnpsVXR3bGFNM2EyZ0dUTUN3aTJwNWswT1FZMEdpSlI5K0NXUEtRWG1PWXd0MUZleDJrSUxKWjBwanhhS01OQkMxaU5PYWdXTVBkVWVhM2RZRm9xNGN3ZlkzNDdnTjQ5ZzNDcU5weTVldWpOVlp6V09hUGNSUTNEeWNwbG5GUjk4MFc1dVBydTBMTlljZzk4NSs4SysyN0o0c0N4R001ZFdvUjdxSVRaWEMrR0JqUTQ1WUFwaUpKVUVkcFBUeTJUMVNUQmNna3dBVlFiRGdoa1FtOXRCbExaQmUvNWZFM1Y5SVZURG5OVHoxYUZldzU4amNhMHdWeXhSbWtsaUFibHZWUVJLRmNrZW5QMFB5M0hheEFrcDFTbHU2YjVxUmFSTy9kOExPeWZRbU91aUhnbWdjSlRNNGluOUphZ1VDbU1BRFpaMzI5VTRtWXFkdVV6Qi9DZkc3YVdlKy9uUDFPNWNEamozdnpCSHBUMkRGTldmVHoxWHdzWWY4Wmgzc2MwSTZjaEhtc3pMVm9MWU5VTlZWUVNZUm1QWmhRZUFmRWFWTkRsemp4R3VnYmpvV0tTM3R5YVFnb2JocEpWaEVVQWk1Tmlmb0VUSUxHY2lLcmdhOEJlTEhGeU5NaDRGMzU1Q2RrdFcxR2RhTUF0MTVBZHpZVFNJQzByTkZacWQ0UnYxWGtPc25RVHJqZzB0WUZYVzdJRCtkckVsRnZ2OFdxNDRZMHhiTHRwRkFPWFpuSHdxSU1mM2xmSGdjZHNsSXBCQ0dvbUxaQTBFY1pKSWRwRVRiU0QzY3hibFNOV1hUMVdPZXF5dTFYZDBHVzRkU1N1YnZuYU00ZUQ4TDNLV0tuekJxRjc0blBXSWpTbkNLdTRoSGd1QlRQVEQ2OWFDNnRJbFlreUdlNVFNWXJ3Q2xNUU51bXZ4ekhhNTEvbXVSczNEeFdsaHFncDB3bGI1TjFDQXp0ek92eExVeGpibmNROERVdGh4c2ZjY1k3M3VFU0d5WHlhYmppVlVPREtFTmdRM0ZhMUwyZ1dkTUljMDllYVBZeXJyZGQ5eGxxWHpMUUpXTjJXZE1naWZPMjVZNVJ4eG13RnRwSjFkWTQ0UkppeUJQVjVCSTRKbjBwaDltYlJtRHFCUk14RklxM2U0OE8xNXhpZjFlWTBmaEdhcksyRHdhNFVQNk95QVFFTkNmWXZUNXJPKzkrcHJLWEsyelUwR005UWFpQkh4OW8zb3VIY3NSZ0hYMkNoRklTeHJsU1hxREZ1VGkwU0FBSmt4aFNTYXMxVGhpbktjaFZQdG5iWXVxMWlqOE9QcURzQ0ZjYlNKWkpwaVlaSXVWL2xycWVZdWhSNHZrMjl6VlJHbmNSd1pXaklQTVYwYXg3T2hDcE5hVFJRU2kxOE1sc0wzYkVqYWJKY0dlNGdkSG5lZkVadUg5a2tCMllYeFB4R0FmUm5mbWR5YkZJK3N0ZkgyMDFtQWcyYVI4RVk1eEFFYTE2NUlDOE1sMXZVNWdVQ3JPcTdqdHJFUUdCc0cyR1JRVlY3MUc2RWNHOVIwRnpUbENyR0tjQThoYmNNVXhpZEtET05EUUZXcjZzSm9GTmpTMlRXWVNyQTREQkJVaE5LTFgrU3daNHF5UFBEMDNSZkZuTWV0YVVwbkNqOGdNVlppeTdaUS8rUVNaZnQ4TndHTXhlbEltcmRJTmlLQlcxREFDcTYzSXIvZmRML2VIOFBYdittNjQxaG1rZFkxU1lBeXZ5RVVzbmVvQ1RLbWg4eU1Wemhvc2MwUk5ObjVsWEtrbXp1NjFFYjNrSXdXenM3QTFlR0RGTExaZzBPdU5xVnBHcTR3cWVaY21pNFdqbnNvODhHdVBweXJSV2JSVGdwWW95VnR0RElZcG9laW5EZ05LMjBBbEl0cjNuOGZ2UEg2OGdObXZSUmxITXFnQW9GZk84dzFuQkQ5bG94OU1YZm10ejl1RG16V0xPdldWaDB2M0hacGZwbFN2clVUZ0tYTEFtTDV5OGVMY0t0SVpBdnhjcjJIblI1SExRWTZ5cTJ0alltQ0syNVFUcE9FTlFDZDVMeVBsVUlNRGNYb0MvZjNGaW9QaXRHS2FpcnloRmRVa280Y0JzR0ZZTFBMYW10bndKRFl4bk0weHdWcHV2b0hURHBjdU44VzRCY1V2YTNmZXN6RHFxMlJsSzcvSU9oVVBtK2RTaXg4TUtFL0VyREFvNU1TRHgzS01Cc1FZWXh6cVRKVU81V09WMmpWWnhIcDhOdFAyUDdUNUZheFFhdFZYaFFKa3JGM1RTQlNSc2VFcVN4MmdsWWQzVThkWWpuTjBVVEFiWDhWbGZtU01KU094YWtRek1WTk11QWpLTXEzM1hLRHJMWkJKSVpJOXhQSEtnQ0I5K2NpQVVaclA2enhkYzhRN3Y5Q3V3a1FGVm5maGpidlV1SHk0R1puQWl3Uk9rdFZoQnVrMVJBcW5YU2hLR01VRk1tMGRweG9IYnFLWmtOQy9ZdGpRN1pTY24xS0kwdUFWRlZJRVBGWmNiZWVsWERraGRIemFCVWtsbXhUVEhrU1AwblppdTR0bWFGcVl6YXU2MWszeVJMYXpSckZUNXY4Z1c3SnBGTWFTSExuYm9icnViRUdmTTlteExzQldGSThEMFp3OG0vYWp1alRGMEx5VjN1eTJDcTcyQTBiTWc2WFd5SzVtajdOaTJjN1dxWGU3bEdFQ3hWNG1NY1ZHQzVUVk1qcEd6RnlTQmtvQm95ejVHdHVyQ0t3eXBBVWdwNXExSkxpeFQxK3VLSWJkRVpkelc2WkEwOXdrZStXRWRwdG83Rk9SZUhqeVZ3d1M2NlhxdHB6dHhLZ0VTUDhrb1NXV0dqb2lVNU1lcGhWY0x6bXI5bFV0OUhmV1lzWkxXRGNpUFJhQVB4ak11dXNRWkFMak5UV3daVEZVYVB6dU5RYVltQURqQjltUS9yZUtIREhXQmMwM3BsdUN6bUtsZXJLa084VmJsL21GcUVxK0JOczJReDVpcUdoeC9DTjJzeHZibHYxa0J6R3dwMVZDTjk3WXFMeFlLTEphWkRXa1dIVVRXUUNqVDgrSkVBdTNkb29TS29mV0VxN3FaSTExcmF3T0o4SGRsOEhOVTZXVjJ2UW1xeDBJUUpvaG5vQ1VvTTR5M1BXM05FcWUxdmxXYzZuaHBuT0hhdXlOQnZQeHQvOXNKL2Q3NzJrVjh6ZmptMWlXbkpnZ3hUREZYYWErNEVhVXFycXVQRzJkWGU5b3dxSHNTV0hTNmFXMU5FMCtVR2RFTysrdVZabWZIT2J1NjIxOGhLeGZZR3BWZW9QVUNlQVZNVjVwUE5iUzkxeXNDaG93SjdkZ0R6aFdiVnllWDdzMzBCampNMU1ZdEZKSG9IWUROdlJia0lQYzc0MlhDaGoyeWk2NjVqZ1JOeXNTb1cycnhKMENhOVoyMWhvVnNjRFVIOXErL0ZQN05VczhzZmVLZitXN3QyNjFBbFZ2WFRCOHMrMmUwdUYrTWxLYVIySzRTQSs4MXRtTXRwUzdNTEFpdENFeU9sQ0ZmS1ZDa3dib1pyMmZESjdLQmxvSlJDeC9sTm1FWmh4K1ptRFZuSnZIcFBvdUlqMjIvZ3hMaUxiZG9jM053Z1pESk5ZMlJCRzBuQm9ERXl5bE9ZV1VxNE0yVjlIQ3RmdytGVkIxWmJBekM3c2ZWRktmN2kvWW03UHZGNS9Pb1h2K1I5NjZuSGc3cmFJcHZPTWNmTE04bFBOWXZxbW1oenUrMjEzT1Z0S20wOXJPMHUxM20xWm8xWEZYcVV3VXJTUWVmSnp2Nk14R0EyUUUrU3hvWU82cUg5a1Bsc3E3NnI5aW94Z1IyU0hxeGVFMGRQQkVoV3B2aThBMk93RjdwS1phWW1rS0E1ZTN3OHZuK1JHUkIrOWxvT09Oc1ppbFdBRlkrY01JNDg4aTE4YnZRSHdUL2ZzTWQ3MHlYbmltdDJic0dlMFVIMDVaZ1VKQlBOM1FvS0lNVk1WWU1ORFpLL3pOeVhmcS9TM0Q4a3c0N1dmY2R0VnBnVVlnMUxRN0VxY0x5Z1R6NC9aeHc2TUswL25YMU14bmFNdWg4ZDZGRmxRWVJiTjIwaWRVNmZpNGRUYVFRekRXenZuY1dTUFJ0K1RwcU1Wd3Z3OXoyZCtJKzFCRE1jMEZmcjU0U3RWZnZPUWtKNzNGVDJQdDdSWTYyK2JKYVczeU95Y1ptOGVOUS81OXloWU5kd3J4d2I3aFdiTi9YSWtZd3BNOHhUTXd4bnVscEowVVRURktrbExsVlVVQTdVODVybFFlYTVEUTU4dFZUVHlyTkwydVJjV1JRT0YvUWp4NHZhM1BpaVZtZ3phN2p6YXVjOXYzZWJlNVBHOFZsaUhGVWJyZFUrWUl0cHkvM1BKOUZINmJoNHVCN0t0TXFUNzNvZ0t6LzMvY3h1VjVlS29jcy82VisrVnNPTEY5NTR0WGNzbkdsQXRRNUFZMjFBZGdLcXQzVnRKVGF2a01DTDA2bFNkY3VIMjQ2WG43amUvdWdkKzl4cmswYUFTcVdaWjJaamxONDRIZkhCTkFyVE5mU2xYQnd2NTcydi9qaDk1N1FkZkFmaFJ0TVh3VHpqZ0o1SnllMTI2WmpsSzQxb09PbDNZRDl6YkVmOXAyc3NYbkVCb012am9DTjIreDJQdzgvK20vc1NmMTIxeE9RdlhlMjhMMjlDcjFKV255dnl4c0prclY0N3ZLRHRQSExRUHYvZ1F3Y09QakZ0THg3dU1EM3liSlRjbFFwMG5kTGJlYXUzc2JSYlVXOGxZRThGS0ZaNWo5WWxiMXllZE8yTWM5cHUzYmJiOXQ3T3pyT1NvYklqTDFzZVRMOXQ4Tm9IMEdpOXBuZE1BdEdGcVdLRmxaeVZHQ283WHUvMnVKdWF0SVBxdGg2N0hmRnl0ZXNhblJXRkJYUU1XUHNnclNiSDdXRHFLNWZlVjR5bnAxTWNGeXQ4aCtYbXQzMGYyUVpZSjZqdFBlaUlteEpuYWVtdnMxQWRkRHpmSGxPN0FhbDNLVWlJMHpCSzRtVXFpT3d5OFRxNzF3RnM1K00xQVhJdEpMZXpVaEtzSUc5K2wwcVNXSVdkMm1reVZLd2dmM0lGaHJZelUzYVl1TTVidnd2d2EzS2R3TFZpYURjcER0RDlBb3VuQStTcDJDbE9nNWx5aGNmQkttenRCbUt3bG03M1RGZUtaSmVscGFCamRVSzBQYWQxY2NuaU5PWDJWR0N1eHRCdWdNb3VvQVZkamxuVHEzZXVSZW12bS96S0ZYTEw0QlFNL1A4eUU2dkk3MHJBZGhxNkFDdGZZM2ZOY3RHMTJzYTUyanFoWENVZXJwU2luTTVWcThVcUF5MWZKcmc0UldxeVp0ZWlXdXVmSEo5cUFWaWVJcmQ4dWNXRTFkaUpVNEN6a25sYVY1YzBYeStYaHBOZGt2L1ZKUHAweW51djlIdXN4cmgxZTEzNjlYZ0JaTGxDZFdlMVlnVitEcURLbC9uYXVyd1E4bXZobXZOeUJiQk9Cd0R4Q29GYzl3QytGZ0Y5dVFNclhnRUlyOG4vcStXMUR1aFpEOG9yYWV2cUV1VlJlK1V0K3Mvc0lrQ2pGZ0VhdFFqUXFFV0FSaTBDTkFJMGFoR2dVWXNBalZvRWFOUWlRQ05Bb3hZQkdyVXozUDVQZ0FFQXdPZzFGQXNwM3NBQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXNzZXRzL+WIh+Wbvi/lhYXlgLwvMTAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQnNDQVlBQUFDN0g1YlJBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzBRMEV6UmpZelFUUXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMFEwRXpSall6UWpRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0krSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pSRFFUTkdOak00TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalJEUVROR05qTTVOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCs2WWJaa2dBQUpUZEpSRUZVZU5yc2ZRbVlYRlcxN3IvUFVFTlhWOCtkN3M0OEVVS0laQUlDUXNJWU1JQWdvd055UmZUcTQ4bFRyb0p3QndOUHJ5QjZWWVNuOStPaVBnZnUxZXY0bENjK0JjbEZJRVFnQkFJaEpDUTlwRHM5cE1mcXJ1bU0rNjI5ejZtdTZrcDNwenJwcEZ0U0o5L0pxVHJuMUJuMnY5ZGEvMXA3cmQyTWM0N2k4czVabEdJVEZBRXRMa1ZBaTBzUjBPSlNCTFM0RkFFdEFscGNpb0FXbHlLZ3hhVUlhSEVwQWxvRXRMZ1VBUzB1UlVDTFN4SFE0bElFdEFob2NTa0NXbHlLZ0JhWElxREZwUWhvRWREaVVnUzB1RXpGb2gzdkc1N08yR0hQRVdkWXRLYUFxQTdNVm9HNURsRHQwa3JIYXFrWHpxSzFodllIZEJXVmlvS1FxcUJjVVJHaXk0dEU0eUN0K25qMzRCemNjV0RRNnJvdUxGcmpkSDJEMWhoZG9JL3UxMEduTmRNOU91bGUzZlE4KzJoZmV3Q0lCOFR2QzNqWGw2Y2c1MW1iYnVvaURhaUR3RTB6ZEZ5eFpDWXVzTk9vNmg0Z0pHdUFVSmpPOFhXS1JTMnMwZE1IQ1RwZDl6N0x6c0RHQlBDUTc2WUoyTGEzRXJCeU1jVjFtZGNiRERyZU53UWs0OEI4dXIvQzBOMFJ3elB0SmphSGdKOUc2VEFLQlBkNExleDRaODZQSnFHWlBRZUJqOWNFOExsM3I4YlM4aEt2a2ZzSnpBQUJHWTE2NTZpYTE0STJIWE44SU1RcnVOemJyL25IK1doQSt2c3pqeUMyVFBFNlNlWTZKT1h5dTBhclMvdHNBYnhCNENicE8yMHJJOVNKNkp6WEd0Ry9yUnZmcXdBZW9FZnRjYWVKaEU0NW9MNTZuVXRnZnUrQ1piajR2RE9CZ1JpRHlUVm9JUlYxOVJvQ0pES014RU9obGhaYlZXVUVISzE2VUlJaXdPU3VCNWJyK2lneUgwQWZSQUVPOSsvbjJKYjhBUmZmdVBodXlwTVpYY3d5MHJCSi9Ibm10N1NxcWllNVhUMjBKV0RMNmV6RlZVQnJOL0Q5elRnNHhQR0ZXdURmK0lrT3FOQ2UxRDduOVFLLy9NeDFTNnZYcjNhd1pZK0QraVhMTUhjV2dXcXBTQnNLMGltYjFKNEp3N0JobVdUNDBoWkJJWXlsQ2tjWVE5dVYrNlF4Tk1WbmswQng0TGdFT2hsWDhkMngwckl6aUgrdVkwbWtYRTRHbFBTdFk1bDBMYThkckhSYWZyZWRySFJuVkhzNDdJSGIwa21HbHBUdDFTdUFGWXVCcnowT3ZObUw3ODRBUGluNnpna0pLUFBzNVVYOXdQLzc0bTNydEZPWDF1Q2Y3bjhCTmJWaDFNL1FFQjlNVVVNNlpMZW8wVWtmbW9aRksrbFkxeWFBSEFSRG5EcUVLMVZtUU0rcVduRmhjUXNoc1dJckFNaEltYmlueTBlcVlwNzVUZVpZNXZmK00rWTJqMURMaGlGdHFXUlBUVzNBN1JjRGF3blVXeDhGWHUzQlV3M0FlNFRRbjFDQSttcDJiU3V3NWY3YkxsWnV1bVVkYnYvYnI2SzZJWUVTQWtob3hGREl0MlcrZEdoNmpzM3oxYXl3b1J4WmxldnlrUUJraUE5SGx2UXdIekJ4N1l5eXlCQXRjVjFobzRYYVpybkdQZWNqSDBZYUdDVDE4dEpMd04zdklTcE9LdmlUajVDazl1UDNkY0JsN2drR2FHVVRzT3UyYTliVzNmUGdSM0hqaGp0Z0RNWng2cW5rRTZTOFJoTXNsdnNrU0lEaFNSWWpGYXNTS3hYSUNadXFTUldxa2UraUU5VlZTYjA2RHZmT3A2MTROOXZPQWlxTzJZNUx4MGcxV3k2QlRaL2wrN3Z5K29yQ1NVWFRQUlV1OTR2enVROWlSZ1ZuQ0ppd3FXTHBJRXBlUjM3TWorOE1JRUVBZitMYkpucE4vRXNsY09lTEo0amJvaEszK05sVjU1OVRkKzh2djR2K3B0MVlzVzREcWtqVjJyWVFQVk5hUjAwUFVNTzZLQ25SU1ZyRFpMOENDT29Nd1FEWlFCSkhsYm4wbVM0bWZtS253TncwbmMra2VIRXByb0lsT2ZKYTNQOHN0clpsU3hVdWJLeFl4V2VIMEhJYzczZkNIalBxS0pZdDdMRWw3YlpCdjVIMjIrTHl2RFNwL0NUWmJORXBoTWJvVDdyWU14akdSYXNDdU92R0lkejdXTzhkYVlzL1MrLzYyM2U4aEs1ZzdQcTBxdjdzMzMrNEVhc3ZQQWtkZTNzeG8wYVZoSWFSZlhUU2ZaS1NDa2JycEdOd3pMZ2tUK0l4SGFLWTNFeDRxczhWa1FHUHdycWtveVZUZGJPMmt3bXl4SDJLd3JQR2svbnVEWk1xbHNrTHN4eEdLNndmVThUejVCeUQvM3VtU1NMRzZDWk1NbW5aOWVTekgreXpFUTJUdmlDRWIzMHdocjM5N3Y0OW5NOTd4MHNvM1hCcndPV2J2L3FGLzN2Qm5VUXFTa3FCUnNLd0xDcFVuYWZLaEcyMGZOc25WRzhpNGJzZHRDTmxlS0FKWWN6NG9obTdtSEUreFhGeEREd24wT0RtMk5EY2FJQVBXRUQxQ1pUZktVcUNuaThxN2tsS3dqdE9Qd3dvV1lZZW9KY2g0VVdTekVRMVBYK0tWTzU5dndMMjlhT25qSHpxRXlLd2NJWWZtenNBUEhYaEVsejBwUzk0b1AzZ3gwQjNyMGVDVElNaGJYSVlwa2FxVHRoQlo5aWZ6QUFGNXRzemR3UjNnZTlhRGt0cWZpUW5uK3hrZHFvNUpDa1RvRkJZRm14d1V2MEVjbG5JbGk2T1RuN3dZSkpoeFJ3WE41MUh0cDg2M2IwL0E1NXV3K3V6Z0N2cGNzMHZuUWcyTlBPS000RU5UKzNCaXpNZndlbGYzT1JGYUg2M1E4V0NFS2swMG5PQ29EaXVUZzFuSXh4MGhuK242MWxnMkJoaFBhWm1XU3ozR2ZEd3Zma1lZYXJNZFh4MTdQcEJDbkdOSlBuQ0tUTUFsckRSUnNBcTlIeUdyYUFyNWVDS2xhNlUzUC81YzJCekczWVFtT3ZvMW9OVEZRNmNzbGl1MEdaRTd6Zjg1M040WS9rdk1PdU9UeFBsZjh0Rlc2ZEdObFdvV0dLMHNrRVY2YllNZzhaeXBNei9MTlZrVGd1S3pxSHF2clRhMmJCZ1JoM25nc255T2xvKzRFSktVNmFPaU9JUUF4YkVpZGcxaVhOenA0dFBuV3ZqNnJPQVQ1Rzc4bFFyWGlNdzEwOGxtQmxUTUNXTFB5UXlRTzdtMWQ4Z3A3eWppL3k0bXpsTUVibHhtUjlqNWZJUk0zNmo0dnVnd3RZSnYxUklLNUZoQkVMZXZoR3I1bTBsdUlyM1BST25sYXQvRFFIODhMbkt5RlVHSXhRUGVVMzFETEs0WjJjL3NIS09qVnN2QSs0bk5mdEVJOXBKNDF5cVRqR1lVd3BvQnRRSzhzMTdPZTY0N3dIZ25MT0I4ODl5MEhYUWxiRmFSb0NLTlIrc0RNQUNFQzJRWFROQU1KWUZTYXpJQ2U5bWdKTWRnbnBVSU9qOVZzMEFuM01mWVVlNWJDSkZkaTV4ZkNqTkVGWXNmT0VHanNlM0FvOXVJejhVdUp4Tzdab09veTVUUHNBdE5HQXQ4UFhOZS9HWFgveWFIUE9iaVZXR0hCbmgwZFFzQ0llQXlrZUNHZ3lQQkRFanVTS3dFQi8wSkh0b3lBTmJnQmd1OVk1clFRL0lqT1NQQUZRWEhjRjdDRTNqTWhiY0g3TngreFV1RXNTMnYvUmJHYWkvZ1c3MTZuUVpRcHNXR1F2Q2tGUDdmdmloNzBNeXlSdXVjdEhaNDBoUW1PcU50RWl3dEpFcTBiV3owcWlIUEZDRlZJbE9NRWhxc2JVVk1JaDkzclpwSmI3MisydncvaHZLMGRvRXhHSUVsT0tCTHYxTUowL1ZhcjQ2VnJOdVRvRE9QZEREc1hHbGczTlBCZTc2a1J4WStBYTVKeitmVHVPaDAyS0FXelRJZlU5ajcyMFg0cUZ2ZlJ1ZnZ1dnZpUDQvNTFERHF5aUpRSWIzUkRnT3Z1MFRBTVRJeFRIVDVFWlVVV2VvSm1QYzV4RWV3VGd0a3A1ekw2bEVTZjBNTEg5WEJHdXZWQW1jUmZqWVA1OUJ5SHdicmIxSk5PN29RNXdRMFJYUDV4WGdDaEFWYXBGUUpBb3ptWlJSQnRsWjZMbzlnd29heWl4ODZuTGdXNlJKWG85aHgzZWV4dWZ1dnhEVGFwbFdPVVZraS83eDF5L0QzTE1YK09nSE9RYUdQRnNhQ0hGUGFqUlBDa1h3WWRHeUtweC83YW5TUldtajg4Ky9jZ2t1dkc2UmRQS3YrdkJ5M1A3b1ZmaklwbE93NXZLVFlUY1NNOTFOK2xaYmhnOTljUkh1L05ZeS9OMC96SUZONTNhUVF4d2lNRlBVT1JUZHUvNnNoWXVwNHppZWxJcmdBVEhib1NFYmQxL2pZanZkNndldkFnM0FOWmlHeTdSS1FmbkMwNGgvOWtKODQ4RkhjUGNqWHllU2RIb1EyM2M2cUs3MlNJMFlnK3hwQmxhY1dZNS9ldXdXbEZXWFlmZnYvb3lXWGEzWStQbXJ5TDNvd2J2WFZXUHBLVE9ocGdiQVczcWx4OHVxcm9kaVBRTzcrMkU0Z3dlZ1JNN0F5aHMrajgvRU5sRm4ySWx6cjErRzE1NXB3cjkvYnhEZFBRekx6MW1CeHRlM1N6VU9WeUZYeXNFdDV6dFlTQ2hlUzJhQk1MK0hublZmRWRBQ0ZuSkJ2L0tYZG56bUQ1c1J2dWs2QzkzeGVXRE9IcVJJd000NGJ3bks1ODNIbXJQRGlFUjN3ZDRUeE9LTkg4Y3A3LzA5bExkZlFxamlXcHg4Y1JKS3JBdEtpd29XV0E2WDdZTTY4Q3hZelFvWWZadkI5RlVJaVJodDUxYTgrN0tZRE4yeDBDSmM4cG03Y05MWmpUQ1NMblROd280L01TU0dPSktHaXd0T2NmQ1JEY0FYZnd3MG0zanpmejJOTDJLYUx0TXVqWE1iNTdFbzhKMkgvZzNZL3FxQmVmTm00WlVEdGFpWVBROTNmZmM2L0xkTmM3SG1uUFZRdXVhU1pRM0E2V3BHK2tBQXBsSUdOYkVIb2Q0cVdPMjlzS05YZzVVUUIwMjhUYjIySEJZNVNLNGRSN2o4SExCZ0JFYnZLMFNZVG9aclhRL2VZVUdKVjJISlNYL0NpclVoTEx2Z0t2ejlkNzRHdlhRTmVtTmhWSVJkUFBFaStaczdaZkxZWnpDTmwra0dLTHY4VkJaT3ExaDEzcnVCZVNkWFlmNFNBL2M5L0NWY2VmTktPdG9Hdk5FQ0piVUVnZnBQSUJpeEVUajRVM0R0VWlSTGx5RVplNEplNkdTRVFqTmh1Q1NsUnB5STBueXcyZzJ3MDNzUVZ1ZVRtOVNIeE9BdW1FWUtTdlFXQkVwT28vTUhvWGZlQjZXZEtMQk45K2wrRWd2S0g4VW5idHFHMnorVndGc3hodDRCNEdGeXFSYVg0OTdQYnNUYVVTTEMwNk1CcDBQV24xaisvbW55QWE1RGJjc2dmdnMzRitDc0QyNEVLdCsxRHZVWHZJL3NIMUZaM2dCRzlremtnUEIwTjZsT0d5ejFNcER1QkkrY0NjZnVncDA4Q0R1eUdBSHp2K0RHeUY4cFBZTyt2d3NCZnBCYXZ4NHVpWmZaOFJWaXJiTVJxQ0c3eW9qZXBzaTNxWmhQOXZiejRDVWtyVFViNEJ4NGdOeVZFckNaRlVEVXdoTVBiOFVUUHdIdXZJcHVUK1RwbnAvRGVyNEZuM3Y0VDNqNEt4ZU9uY1o1UW1iOVpjS3lQSWdHa2U5NjQzcWNmTmVuZ1JlM1IzSGFock5SdjJveFdQeGtxSFdmZ0IzN0U1eU9INENYTGlXeVFweWs1dzJ5amRkSjFhcDAvSkpBUG8zbzU1VndrcS9EN1gyTzlHTU4zQm1YSUtnR1lYVVRtM0g2b0tWTnNwbEw0WmJPZ2R2M1F6bWd6Y1BMNENaMlFpbFpTZVFyRFNYWkFhWHNBcW1hdWQySjlNRW4wWmxVOE1hVDdaaE50bncra2FPdi9BcjQyYXY0UHZtaHQ1SVBiVTZYTk00cFY3a0NUSktUT2dMenZ6NXdMazcrOGliZzErVG5QZnRHUFJyV0xJUXlTQ3F3N0h6WUE4UklraVJOTlZjVCttK0M5KzJBR3prYnRqNERwcjBQYWZZMjByd0p4aUFCYSsyRlB2ZDI2Z1RYSXVEWUJKSkk2aVVmWlpDT1YxK0JsTFVONmY0L3cySjFzSU9yeUk1cTRMVzN3blhKbGlvVllCckJGRjFFOXZkNVdqdFFNdk1tTExyd0x0UXNCbjY4aGZvUnNlMU43d2R1WDQ5YnlPVjlwcCtvOUhTeFhjbzBBTFAySVBCbkFuUEpwcnVvVjc5RTBybTdtbnpLTldCMkVJaHZKclc2RmF6M2wrVDAxMEpUQTlBdGhhUnVNVUxSTlNncFlZajBQb2xJeGMwSWgwdWdwMXJnR050Z3Q5MU5QcW9DdGZveU1CSCtFU0c4MEJ3RVVsdFI0dWdvTGR0QXY3a2VKZEZ6RVNBcEROTFQ2TndpaGpzREdxbHR0LzlwSkx1M1FRM1drTVMzZ2UzYmdqTlgxK0k5ZndQOFlodHdzQnU0NVJKU3YrL0ZXU0dHbDNxQU01VVRHVkFCSm5rTU02aGR0bnlRd1B6SHp3T2Q1T1IvNVFIZytrK3Z4NFlieTZEMDJhUUc1MER0MlFvMWVoRVU1eW55TDErRzZ0WkJxVHNUU3ZwcDhDRUN6MHdqN1pRaGFZZGdPUkVDWVEzWnRVNlNybjF3MC92QXpkMEl6UHd5dEpyYllHcXprYVNicDQxZGNHSy9veFlJa0czdWh6NzRNdlN5ZGVCV0wxUm5BQnBURWFxNW5GUnVQOUxkVDhCTmRkT3BxM0Q1all0UmYyWVVqejRCR1dsNnp4cmcvZzlnWm9XR0xaM2V3UGFKQjZnL2dGeENEYkRsdmF1dytMUC9nN1RwSVBEQ3pqcmM4ZlYxdU9SU1VwR3REbUNSVkxua2VwQmtRaVBsMXZjTU5YQVpuSW8xc0ZLYmtVN3NRcXF2RTJidHplREdjd2k1QVhKTEZzSHFmd0dzOUtQRVlsZkFQdkF3QWZjNmpMYXYwajI3U2FLWGtuUlh3TkVxa1U2K2hCU2RhMWRmVCtyM0FOblJMYkNIZHRGOU82RUZROUJESlNTbGYwRDVqRlBwdmgzVVNZVEdtSU9yTG5mUUhXRjQvQVV2QldVVmFlZXZmZ0RxM0FoK1F4MzBSdVZFbEZBQzgwOFhuSXhGZDMzT2k4LytLL21kTCsrcXgvcVBua3FzazBDY1E3YnpKTEpPMVZ2QVo2WGhSRitFWFJlQ1dkVUdLMEFnVkswR256Y2ZTbmtqU2Q4cEtLRnoxTEtYa1F6U2J4WmZoVUJ0QTB5MkUycUZCWHZXT1FpVlBrNjI5bEdrNHc5Q1g3QVJrYm82QkRRRkxOb0d0MkU1N05wcTZqKzd3ZXJDc0paOWdzalVIT29VUTRqV2hJaGN4UWpjRGdUTHhMQkxHblhuWG9ZdlAxaU8zemVUK24wV0dDSkpYYjRBdU85Nk12RUJQRVltOW9hcGF0amp6bkxQSkpaTHZmaW5DNk40LzcvY1QzeUgrTWNnU2VkdkhpZXlRVmhjOWI1U21LRmEyQ2tYTnRrOUptcFkxSlRNNlRFNTJVOGxBVjAxNExEWmNPMFlHV0VSc1ErVG05RUJWeGtrS2FvaFluTXE1cHh5SmxyM1BrTlNSNzh0RFpKTmZBbU81Y2hSOVVEMEhKZ0RqVWpIZWhDdHJJVVRYb2g0ei9Pa2Jqa2lFUldCeXJPUml1MkJNWEJRanJqWWFhOGlqWWtFY1BvZXJTcUJheVR4SkpuM0NKR0FhOC8yRXJycnFSOXVKUUgvNXovS1Y3MXdCK2ViMy9HQUxtZnM5bEJFKytZRDk1UmgyVElIQi9aVGd4TzdMSTF3R0VQZWtGZUtBRTdFU1owNWZycWw1bWY0T2Y1b0MrbHJLK2tuWUx1ZW50RWlNdmVhVkNZMWN1bHM2RlVLQmp2Mnc2SnJCY3E5ZXp1RXZ4cnh6bWZpZDRhb1pZRk00eGVCK1VDSm45VmdldU9rVUwwc1B6RW9JS1JaeEVtREloL0dORWppbzZpcjB4RXVEWkR0SmtvbHlGb29oSmtOVWR6enJVYjhiR3Y3OXYyY3IzN0h4M0twZlc5ZE1YOFdMcnJqWVZpOWFaUXU3eWY3Ukw0ZnRiQmpER0Mrekt1MGlNakVSRm1Sak1wYmhEUzM0akpmVmdRWHhEL1hTcEdVRElxY2Q5ak1sa25TS2ttMHpzV1FUQlZTeGdGb2JnTjBWNGZCREptY0hSUU5MN0xwSlVxQ0RIRTZSNGNpMGtMSlYyV0VxQzF5ZzZtbk1Eb3VrcjFGRXJhcWwxQm4wYjBSQWpxSE9Zek9GU0RxMUtFNHl2eFVRNFdRRDFlR1NTT1FyNHoyS2RHNnh4MVE2dlJOaWFTeHhPb2pOeUZVUmcwU2hxNXJVRVExTDllOURIY3g5c2tVYXNSTURZVGw1WVRKRkNNLzQ0dk9zKzA0clFsWmlpMk9COGwvWkNTbWhoVkRtUFlIVkhKaldBZ0dxV2JiU1pHMGVkK3A2OEJ3aHVSMXhQbGlueXBFVkNRUWNTOHpXM1lZMjZ0MzRDTGJYaVNDMDM3SDhyTE9PUG0zSXJsYmhVZ2NjeEFmU3NuVXp2NUJqcWEzTzBUTWQrQ0VBRFFBTkE5MEQ2RGo3ZDJZdTdnQkd2WDZwaDM3OFAydi80UVFJYlhtZWx4TlpDb29UTlN1a0M5SmtxS1FkSXBzZW9Va1I1UTBxRUdSeGVDU1pERlB1azJkSkoxSlhhcUdEYThPMU5BSURQcE5nTndmamFUZVpYQlNBVm56QXRVaU5XdjdtZldrQ3l3RzI0Q1VaSkZSYjl1aVpNS1d1VVNpN05BVTVkejBlNXYyaVdQeSt0U1JVcWFMMmZWbCtNaE5hNmtES1dReUJ0RFROU1Rlcy9ORUFiU3hMNTVHMS81MnpGMVVSVDRsdlhsTEYxN2YraFpPV3VMWnhVd3lkYVpBYU5oV2lrWjBaVVdDbDB6dEM1U29naERFUmI2UUlEMFJ6emRLRDNwcEttckEzOGV6KzF5ZXRabVpoRzFaTnBxcDVHWlplNTNKSE9SZUV1SndhWVlZL0I0WUVOa1QvWERTcDVGZFZkR3lyeE5kYVJzaGI0NkdkejZnMU42Tm91c2VhRHlBTTg1YkRDZHUwRVBZSUM4RDFYVjVqTTFQbEI3T2dQYzA4ZkFLNWdOaDVQaGh3YXd6NXFTOEVnclJBVlEvdDFlVTFUdFcxaUZXQXY1bm54dktrZ3M3VzU2WXVXK0dPN281T2NBeXc1REFYalNua2pSTEhEeWxZbjlMTDRqUGdUenB0MDhJUUtrTmQ0dHR5OTREeEpBR1lDY3RDYWlRUEpFTEpOSSszQndRTXlVcnJwL2xoOXdDSk1WcmZPWURtd0VabVhwUkoxdUE1UHBTNy9LUm9NaDdaVkk5M2F5MGNpZjd6SWRrNXJPUnBmcTE1U0VFZUJLSkFSdU5qZjFRdlZ1OU9hMEJYYkJnd2FUY3NCcllTKzNlMTd5M3M4b2lRSVZ2U0I0bWV2cENhTm1mbHRsMXF0LzdSV05ybVR6Y25Ja3VjalB5RkphdDFGYjlITnRNQmJlVnlqYThYdXAzQXNkWG1iNVV5cXcrUFZ2c2xDbUhjUDBPTWF3WlJobjFFKzZNeUNDTUJsMW9UaHpkeE5yM05nNktSaFdUTnJ3NUdXM1cxTlEwdlNWVURIdlFUWGUyTkhhdjYrL3FRVGlzd280UDRyVFRUOExpMWZPUkdEUmw3WWdvdjNmRTBKWXNVdklxbGRJcEM2bEVTaFl2Q1hkQmxneTZsaVE1d3NWUk5ML09VOVNJMHZlQXdXVFpvWEJGVk4yckR6VU5ManVSYlhsaTU0cHJ3WjlkQlI1QkVrWEJWdWIrcm9lOFkzTjV6MXpwRmpZK25XYW9DQk5KTW9mUXRqK09qbTVEMk04M0lDZDFlV2VyWE5uSGUrZlBSMGx6ODg2TzlzRjF6ZnZhSWVaV0NCTVFJZDFBV2JnYjVRRkh6azRpR0sxTFFOaCtxYlNZb1VRQUoyWXc0YjV4RXcyY1Rwa1NGTTQ4NEFVUVloWVRyK2FGWUNZeE0wUU5Jdk9xc1IxUnRFdEFPWm5hVXBkbkpWQnFCYThUQ0NibXloT3l0ak1YVEZsbFR0L05JUVdWUVJOMndrYnovZ1M2SFpsOHZZUGU4NUN5bWI5MlFNZE0wYUFldktPYkdyU3RwUnNybHBRZ0ZPRG9iMi9ITTcvZWc3SlNuOG5pVUxXWG1kQWkxNjR4NVZEN2hyeHpwTzFWYzVxWEgyb1hoKzEyWmk0am5pMks0anhiRDVPQlI1eWJJdlpUU1V5NU1oQW4rOG14dThtUU02RFJxVnZHYVFmKzF3WW9POXgra3JadHB2QS85L2JDUHFzV0trbFZTQThpUVV4UjVNVU8xNERtTkdnK1FTbDAzL0JubmdVTGZPemY1NUtsTWEvbDI4K0JJV0s0dFM2aWVsS1dXelIxZVBiWlZaVG5NVXBoVzE0NzhPa09LQ3Rnbi94dUJ3SnZLWWJSdDZlbHZhbzNIWk9KcmhXVnBLNzJreURWZWhMS01UNUloZTdqbzVRUjhzT0FkYmpqbVRjUkdmZFZFUzVpLzJoc0IxcDc1S3ZzUzFaV3ZwMUQwTmtZMG5sTWdOV09BNWdzZjErc29TR3BreDF0UFdDdTZ5UVNOR2NtMlowcThtSjJlSzZMTExQUEtlbkxNRjZlVzBiUGMxb2o1elBQbFVSa1AyZXF6M0piTUJjZ05vb21HRzNOMk5JMGdSbWkzOHlzOU14c2N6ZlFaVXIvYzB0Zk5NckhVTFZzRElubDB3WFF3MGtsRzJ0Ynd0akxIZDE4WFNmMTdNWHpnRkt5UlFrampKWU9UUkloTVR1SlpUbVN2V1pJQzh0eElTVElidlo3cHJVVWRTUnczdndMeko5Q1RobEd6N3VXVDY0Y1BreU9YTW1jZlZYdmpnUXpNNWVEV09Oa0xDdm9jZzNVRVUzcWdMc1B5TUViUkJsNy9qQmdzbU1wclpOdFE4ZVNTcGIvV1dOczZ3QzFraGd1czA0SHlnalFWV3ZuNDV3cnpzWlFYMHhPT1dNWWx1ZGlrQTVXd0dVOFZiZ2JNa1dJUEgvaHhraTJLV2NaczhqMThHS0JndVZtRmk4bTYzanVTMllxRzlkelllUVVjY0xCY2NTVWM5NTVjc280MXgxSnNwQ3RPOVg4R2h1RmJPWnNZbmRsRVdBbzVZVy81TjAxN1Jua3VMcWpnRHFldEU2cGhMTERnSmtQNG9qdlpFZTNPK20wMWRnRVhkUndWbEpQVDhVNjBMRm5PelRGa3FkeDByOEtOYkNZREZmTUw2U1lKb0pDRnp2Q1hVa2o0SXVOcnBMYkUvVEV5aEZBcWM2dytuUlVSdzZ4dVV6K0Q2NjYvcHhFNDd4Wmpwck9WNzhDYXdHb3FPSnVJUDlrQnEzYjlnSnR2Y0RGYSt2YmJyenp3Kzk5ZTl0Ly92QytuNml4TVVETGwxWSttZXBYTzQ1Z2psZ0g2K3M3bE9ibVhmdjM0elJSaUZ0YlI5M2FHc0R6VDJ4SGRaVS9sUnNibmZqa3gzZVJvNDdITkFKOHBFc3pGdWtaN1Y2NUxTMnVJVWliQ0FFdm1PSHRpNFVqZU9Sck5oWnNtRHNuc216d3ErZGRzKzd1Wi8veTV6WFBObXFkQllBNXFhQnF4MEROc3NNQW1vbTRDanY2U3VzQmZsb2IyWi9UVjFPUGJ3QzZxZWRYMUhnWjZtTVJFODRueGtyenQ3a3RsaHZTeTQ4Zlo3YkQ4d2k2WGtjVDh5YUpVYUxaMWNDQnBJNXJiZ3JKc1Z4clppMlNiNzZHVUdWVjFiMWZXN3o1b211Ymw0MnZCOFlFOWJoSzZPRVk3V2hnS3FOOTF4VGxoVDdidWJtVkFIMzNXZDRralYya3VzbzdQZFUyUEYrQ21zTjRjeVl0SHN0dEdWT3EvZUczM0RuN01zUktndVVITWpKYk9YeW5hSmcvVjBOTnRZWmFXc1VVZFNpdFFTU3NrSmxJb1hmSVJkTkJDM3FBb2FvL0FUMjRERXF3Rmd0WHQ4eS85Nk90bjczM2Z6dmZSTTZVcXdYYTBpTUdlREpaN21oRVNCbnZzeDBPdjVpT3g4MDlieU1nN0doTnRaY1cyZDQrY3FocW1NbjYyOXdweVROc2Q0UWsrZy9oNUFRb2JEOC9LVE1SWk1ZZXlnbVFYZSsrR1hZcmgvbkl1ZnpZZXhrdVd4OUdVT2RReGZTZ29WSmcza0tpc3JRMUNOZ1FQZkNNa0V4d1NyZnZnMFU5VFFRWWFtdkRZT2xGdVA1REJ6Yzk5Tmp1Ui9xc1FESm5uQWdqd3lhamZzWjBVTG5qMlV3bFp6djhPVkZUMDZFa0VtODJOdktWUFNTWk0rdUJSYk9waldaNmc5Qk8zZ0IzWnZDYjU4UlZNL3R6dDhNcVFzMjJudUlQVUE5UFhKVmhyMnhrSzRyem9qWDEySFJsSnhvVzFxQ3RLU1ZMdkpscW9LeE9oZHZZVEVUTFJZZ2VNaFNxQk90VndZSU45Rm1GTXZRbW9pdVNzRHU2b0RrelVMSjRRZUNLQ3hxdi9kRWY4ZGhod29CVHBuTFpCSUJVeGdCVFdUSFRxRjUzbXJWODRSeSswaHdxaTVhVGQ1NnNyRVlEQWZxK2FFTG04cVJ0aHQ3R1huUzFrUXRqdStPU2wveUI4QkdCaFFMRGhibkhWcDIzakd4NUo5S05EcmxYaXEvNnZWZGdXaENLNXRKM01lT1pKbnNORnlNMjVEdHprUUlobnlNTko5VUNGVG91T2FmeVF6LzY0OEIvK05LcDVLbGZUTGJFSHF2QUFodEY5U3JMbzRsTFAzdGQ0cjh2T3ptMFVpV2xGZ3JwMEtwblE0blV3RXFUUzFJM0E0dFdWc29Sa1hqeld5aTVZU0VDRGRYNDZRT3Y0YmMvM3VVTms3SHNuRUxDbG1aU1F3NkpzZVZGa2pnZkdSZDIzYXhyd24zYktpUmN6TFZ3dzhZWE1QK2NlblR0RXpOL0JoQ2dBMElGY3haQUtGSVBGbzJTcGdqQ1NUdFFhMUt3alc0WUx2a3UzRVRQejNlZ2N1bGl1RVlQU3NzVzRNeFZkZXRYTE9ndGVhMUpUWXdUV0poeWxUdWVkQjZ5TDJ4YTg3NXpVL2R2MTY0S3plMFpvTWJvdFJHb0VGMlZtS0ZJdmxKYVNJWE5JRjlSRjVPWFFnMEVVYkhxYkpodGpZanYzSU1QL01NWklyTVR6ejN1SlFHSXVJSE0wNlZ0MmhyWkdxNmIxKzE1ZGlBODkvdndIRWpNVzNWL2JxS0xicmdZVHZOVEtGdGZqWkxUb2hqb01jQmtoTW1HeVdOdytuYUFPVFZTTjhlSkJLSFJKa0F0V0QwSnBKc0g0Y1IwVk15dGh0ay9DRFBpSUJBeGNmcnNvWTJ2TlZYOGNoUXlOT25xVnp0S2FUeWNHOFBxZFhmcFF4OXMzM3JTa2twMHRIRUVpUi93Z0k1a0xJMktpQW9IY2JocERjbjJMb1RubFZMamNGblNwNmdtdEhBSVJ0eDd6SGZOaitPc1d6MzdLZjdzaGlCUllxalU4SlBEV0I3UnlSMHFHKzVwVHRabjFYMlduQUUwcUhwejE4ZWplOERtVmVETlZ4Sm9xTk1RMFVSMklZTnR1YkRFeE1ucE5IWElmcGxsNzZSZDJIRkhKbXZiSW5QUVZURFVVRWZxcUFyTTdJTGR1UitCV2h2Um9McUdidldySTNCVEpnenVzUXo5eWZYVGY3dnhhdDc2Q0dKSmtqMDdBUmJ3cGhVWHRRVmlUai9SS0VxWmc4aXNCbklWYXFDWFZ4SXdDb3orZzlSNHJZZ3NXNFQ0bG1mUiszWWJPRG55dWo4cGxHajhhTVNiMDlhYjhCalozTjA4UUxtYjVaZ1NkRDhMUC9OM1h3VERKU0ZEeWhRUzM0NjFIMjlBKzEvU0dLUjlRd1JTdXA5SWtQalRJZ1NWMEFxdVRlclc5R2JLVGduWjFUZ0N6RWE2MVlKOUtqblRBd2ZCcUdNbSt3NmdSQTJob1VhZG1hZTFwbVhvcnlCSnJwckJZdFpnaUNRdmdWQzBCQTYxUHIwL3dxV2tYdlVRU3VhY0JJY0hrR2hQSWxRYlI3bzdCaGF4b0ZTck1KczYwUFc5SjZIMWMyeitTd0N2N1RKUlVRWnZhbkxWTTh5Q3RhcEs5by9uY0Q2R0l2TlZyWkJzeXdjeWJYaEFpckpBb2NhRk94T2w2MithbmNUU1JhcTAyU21TeklUQzVaOFBrVE5vTSs1Ti82cUtWQllYR3RGeHpYUmtOcisrY2haTWVpK3p2NE0wa0Nuanc2WHRCaHJLM2Vwak9jSnlQTVpEaDN0anp5dVBwUzc2Y0JXNmV4d01kRnNvczFJSWxvZGhLaXBzbDJ4TzV4dHdxMmRBcnl0QjBtNGs5VHVFOUo0dUdNMjljT0tLc0tneW9iNnBYLy9ONjcxS2k5dnRWb2dFQXBLT1NzRlk1Si9VNEZ6c0MyZVY2dmloR2Qra0pvaTV4cGpYRDB6cUVTTFRuYk80RXZ2MUgrMnpiLytrdG5xd3o1dUszQ0pwWXlTTk92UFNWOFIza1p2RWlmRnFOV0hxcEFwNGVSbTVMeHEwMTdjalVSZVI4ZWFBem1Ba1RKSHNIUnhGUW84SnNOcFJxdFhETGtremxGS0pEZGFTYzE0OVU0T0JjaGdwR3pvM1BZZGYvSkVjQWkrZGRLVDZkZEsrcndscXJJQXIvdjZZOFI5Ym8vLzY1OTZ5WDZBK0c1eGcyZTE0c2VUeHNCMG13MDZla2g1MGt0M2hLRnNkSmhzZjY2Rm5FQ00xSnRsUmNsY0VlQ0pCM3haVmNXRUNNRWhiMTRJYTZ3QTdtTVlRUFgvQ0pkdExCTStJR2FpY0ZVUlBqQnNUYU51alVzZkhQRW5zcWRlMUp4YzlaLzNod3ZYYXBaeFVsQkVuaGl1SHJzUmZSUEwrRUlBc1liQlZXZllnZ3FTa0ZsUGRNZGIrV2t2b3VjZDNsdjdxclc2OUI4ZHhHcG1mYml2WkhQbG1JbnJEcGZqQW90bDhWbm1aNTlzNEtVNGt6Sk5TUlR3M21SR3J6NUZ6RGlaTUJYMVdtSmRWYTh3bVZkdERuYk1xRWtRb25NVGUvWUd1NC9Yc0JaY1RMbGl3Z0kxSGZrWUxJT1N1VjV3VVgzYnVhZnlERGJXWXB5bThOcUR5V2JyT3F6WGl2STdENDZrVTJyb0gyYzdXSG1YbmpqYjlyYTNOb1phQnRHS1BFbUZpNDdoS0UySGpmSlR0SWV2bHkxTHZXbHp2TEp4UndXZFdSbmxsTk9TV0tvd3pVcnZPWUlMRit1UG9qU1hZL3VaZS9jMlF6c04zWG1mOE1BQUxyZjBFY2srYU5BOXc5LzlwMk5ocUJyZjZRWVhjTlRkdG5JL3lUQ0l2bDA4Vm9JZUU5bkpXTmUrem1yZGZIZVU4Wll4bzAxZys3eEdwM0R3dzg0RjFSOW5tcms3KzltTnJoeTYrZUxueHZxN3U5TUZlYmVuZXgxOEpiMysxdVh2ckdFQzZvM1NpYVFmb21GSmFBTERLRVFJNkVUdktDOWdXQ3Vob3dEcWo3SGNMbE02akJuU3liZWlJWWNSUlZqZnZ1RnRBNHl0NTIrTUo2RVJBZGNmNEhUOGNhRlBGY25tQjlxbFFVTWNLVXVldXVhelB6WlBRSXdGem9xQzZZd0NiQzZCVG9PUWRDWmpITFRoZmFKQjVQRkJIVzVTOGM1UThJTjBDQVMxRVFvOVdTbm1Ca2pvZXFQbjdqbHB5dFVsU3NlTUZtWG1CMGpnYWlPNG90aE1UQVBWSXBiUlFTZVhqMk1iUkFNWW9BR0l5VmJCMmxKSTVYajdwYU9EazIwWVVBT1pFWFJWMkJPcXNJQmRtQWhMTHgxREI3amdTaThtUTFNa2dSZU1CeTBjQk4xOTZSN09UeHhyTXlRUjFMTUFLdGFlVFNwQzBTUWFUalFJa3l3TUplVEhOZlBaNnZNQ2NERkRIWTdYdU9NY21UU0luQTlCQzZqYnlZNUdqQVpzL2xEUWVlRWNLWnFHbGZJV0NlclFnajJXbko4MmVUcWJLTFNTbzdCWUkzSkdRbjhtUTBJbVNwU01CZXJ4N1RKbktIYTFNamhVQUxpOFF1Q1B4TXljTDBJbjRxUk1GdWhBd3A4eHRLUVRVdzluYncyWGQ0eWlsY3FMVjA0ZVRWaHhHYmZJQ1BoOHpNSTkxNkE4b3JGaG5JZ0dDeVZLekV3VjBJZ0VKRkNpTjB6SmpnWS9Tc1BsZ1RxUUNhNktTZUt3QlBWTEpSWUhIcDUzYk1oSG1XMGluNEVjcGlXeVNBRHhTeVozSXNXTWlxZG94Nk4zanpTbkFqeUkrUEowQW5RaEEvQ2p2UGFVMkZPTklXU0hnampXaVV5akFmSkxmNFVqUDRaUFFpYVlOb0lXQXdNZVJzS050VERiSjBua3NnZityQXJTUUYyTlQrUEw4citTYUUxcit2d0FEQUNlSmZmMXFxb3F6QUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC8yMDAwLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFFBQUFCc0NBWUFBQUM3SDViUkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeXBwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRNeUlEYzVMakUxT1RJNE5Dd2dNakF4Tmk4d05DOHhPUzB4TXpveE16bzBNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01UVXVOU0FvVFdGamFXNTBiM05vS1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvd1FqVXdNa0ZHUkRRd01FSXhNVVUyT0VJMlF6Z3pRak13T0VNMk16SXpPU0lnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG93UWpVd01rRkdSVFF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPakJDTlRBeVFVWkNOREF3UWpFeFJUWTRRalpET0ROQ016QTRRell6TWpNNUlpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qQkNOVEF5UVVaRE5EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4K0wzM0lhUUFBTWRaSlJFRlVlTnJzZlFlY1hXV2Q5dk9lYzI2Zk83MVB5cVNIQUVrSUpVRG9SVlFRRUJFTHNpcWY0cm9xbGhXd3JLeXJncXU3c3BiVi9WelVSWEZYVWNRT0t5QkZFWkJPSUFrWmtra3l2ZGM3dDUzeWZzLzdubnRuYm9acGFVRDQ1dVIzY3U0OTk5VDMrWmZuLzMvLzd6dENTb241NWJXekdQTk5NQS9vL0RJUDZQd3lEK2o4TWcvby9ESVA2RHlnODhzOG9QUExQS0R6eXp5Zzg4czhvUE9BemkvemdNNHY4NERPTC9PQXppL3pnTDVHRit1MS9IS0JRT0JnWGs3c3c3RUhyV3JBdHUxNVFGOG1BTVVNQUlwREJmQThvQWNPcERnQThPV2szK1U4b0s4TWtPSUF6SzZjUVlzUE9iRHpnTTRNcHBobU81UEpsZE5zeFRTZjV3RTlSR0JPQjZTWUJkaVpnSlF6YU9naEFmVTFCZWh4WWxJN1d5OTl2VVdPVTFzTUxHZTgxdWdCVlpaQUZWdTEwalN4Z0d1RXhEak9OV1lZS0dLVEI2WFVvVjJRVFMva05DYlhjV0U3RGh6cGNaVkljcHZ5UEF6eHAxNXU5MlE5ZFBBaVBmeStjd1RZMFdKWlBZY0sxUDl2TkxUZWNkNjBKSWIzTlN6QjZla0VTa2FUUUhrbEVBb0RKbHZCZFFGUElXZXBjSWN0YlVJamFIRHJ5UWw5bTZ4MjZndkJWS0RxcmNldHl3dXBjdWNJVVhTNXIzOFV5S2FBa29nTy9BZVhwWjFIbTBad0J5LzlQd1EzZFRCQkZhK2xRdXZKR3Zvc05iVEJjVTZLQXplZWZoek9LSW15a1l1QXNUU0JDd0ZocnRRZ0RacHFCUVdFQXNUTEFhZjJVMnZIRjNXc0lDSlMzVWNkdzdaVHphZStHcWJRNnFiTzkvV09xczFqRFg0MkRWOWdoZ2I0blFESCtEM0FhejNTaEpZbmVuQkRyMlhkUEIybyt4cUh2dXlBdnNRc1R1UFUxR3RRZE9OVWxnVnMwMFZzandxMlFRVi9xMko3TkJqS1RCS1hnSWt5Tmx5WWpWWkNBTUs4dkhxaGtNb3I4RU9RMzBNQkszZFBvcUZ1ci9IUXIyMW9rTlFOTFNJbkxBT0JzSWxBeUtUbVdvZ1ZCYWl0M0JmZ1JTSUJDa01Ba3FnN1dadVg0bzFvVzZYbitNQVNNYy9OUXQ5ZXVzaW1rNUNPNXd1QjhMVStUR3VRcERBTjBSaFg4dnU2YW1CTE4vRGpKL0MvSmNDN21peXIvelVGcUhKV2ZGK1RmdWFLNmdBdWFLekhtVTRhNWIxc2dBcWF4N0F5V1ViK1JYMFhHUXI1alpWM2w5TmRmdkpycXUvWmJNNWNPcjRHcVNXcnJxc0E0T2NNZngrZ3VVd21hTElybGJZS0RMc20zQ0FCS1RlMTV2azJtSUJTTlZWYktvMVVHaTQwMlA1OTFDTXBUVmZQS0h5NVFudS8vN0kzdmhYWTJnNTg1cmRvcFc4L2E0ZGw3VGpzQWMzdklWTjRYMlVRZjMveUJxeFc1bEUxOGlEQkRCTEllTncvUnZrNzdiZGMzeitwWTlRcjVQMmNaVTM0dXBjQW1kdWZmd1N0cllZdkpQbnJLRE9ydmxOWnRmbDBGUEFaZ2t1ZjYzRmJGcU1ROFpqbjlnQ2pmSzQxU3dVaTRaelp6WmxZeTVJYWJLTmduN3FsQmp0bjFoWEFQWHkzZ1RiZ2hrdUEzLzRWK01JZk1FUk5QWHE3WmJVZHRxbS9uSGxkUkRDL2YrWWFuSFA2Q1RSSnd3SlphY0dpK1Z0NWpFV2lJclNKTTlnNmFxczB4ZUkrS3hEU0RhbDludWVEcFUxb1hpMmsvMUhtZkZ1ZVZycU9yVStROEgyaDYyVDF3WUlYc3pOcE9HeEVtVDlYK28ydk5MZTdqMXNDUzFuRDVhY0RyYjNBRHgrazVTZ0pvamhxOFh4ZkpTMmxqYVpQangwK2tOSldqL3NkZCtLQmJNZC9uaGY0NHNsaDROWlBSdEExa2kzOXppUHUzZXNjNThobmxWUWNEcVNvVUVQVkM3TjlUcWYxK2NWSEwxMWRjZG9HRnc4M3VhaGR1UWFMR2dpcWJTS2RNWkJPT1RSN1dXUXlEdXlzaTB5YVBreDdLNW8vWmU3b3E5UStqNDFuWjlYbkxFRnhTWElJT2xWRmZYZnR0QllHOWM5emJkMndIbjJkUjN2cjJsbGV5MjhITzUzVzN4MTNRcnZ6cGowUzhjSGQwd1VNaytDOGVSMzk0SExnWDM3TDMycEs4YVpUcTJHU0dodktVaGpDOTlGVWZjbDcySHhHOVV5ZUZIcGZPczA0aC90Y0tiU3B2bkJUQkFzckJhNzdWZy91MnBiK1NidGx2Zk93MGxEaGs1NnphWFgrOTRZUG4yb2R1Ym9TLy9EbFIxQlpGVUZ0eDNZOE9KSmlRN28wVTY1dWdHekc1cXJpQW9jQXVTUXRTZ004YlRLRGdRbFRpenpweVpFUm1Rcy9sSmtVT1FaYmFJcWw4Q21VWnFnNU9wVWpzWG15T3I0b3M1emlROWVXMHZUUzRkMnhoYWFsRHJqNUt1Q0ROdy9odis4Y3hzY3ZKb0d5ZkQ4Y0pxRUs4OWtDdkdDVTJ5QzExalFEQkoyQ3hvY0swTkk0bm9uaGhJZDBZaFFaWVRFUVZwWUQ1eDAyWVl2UzBKeVozZGdLUFB6bEQ1OWpYSEhscWZqWSs3K0tpcm94UkFtUXNvaUtFV3BmbHRNT0sxRGc4M0ptMXMyWnJieko5ZVRlQU9TSmo4UUU2Y216WEhYdHZMSElFeTBkWWxpNThHUlNQa2dVK3VTY09SK2hlWG44Y2VCVHJ5Y1ZMd2MrOEYyZ2s4KzBib25RV2hyaU0wZElvSWdqWWlGSktzNHQzeXVjQTF6ZEw4N2ZqMW9JTFFSZnZoMjRzeG5QMWdLWFBHTlp6WWNOS2VKN2xPMEN0bjM0a28wMS8vajE5K0x5Y3orSnpFZ0NSeDRKSkZKK282bjNrQ2dJK3FYZnJDNVZ6bEZNUlNxZmFta1RhakYyVVgyZkpzMnJTeitsajNlbE5tV09Nd0dvK3MxaDJPRnh0VzJQWVB1K1RhVVUxUFVOdy9kL3BpSDFmblY4anNTT20rQThBY3ZtMnJtVGxMeUdvTng2VFJCakJQaXFiMmN4NUNtckljYUptS0dGanMvdUJCRU5PVFRIVXNldHJmU2RIejNUd2Z2UEFhNjloUnIvSWg0b0YrSjFPMDNUeWNlbGg0UEpOY2t0Zm5iUkdadHFQditMNzJGdzEzYXNPL1ZjbE5QVU9vNVNQVCtXc3dKQk5xeUhLRzFWbVBGS2hLSWVVdkZna0Q2STZtaVNnSVNVOUt0VG5CU0VsK2J4UG8yVVdsMDlIUStxYThuY1o3VjF5RWFVQ1ZmK1RQczBmbmFKbHV2NjV5bC9MQ2dveXVmWlJFMzU3UXpQMGY3Ymx2cTRORTEra2o1YkNZV3lHSU5KRDAwakVaeDlUQkRYWFQ2S3ovKzRYNXRhbGJ4UXo2ZFd4N0gwSTFrMEJ3YWZzM3NRT0htaGpYZWVDbnp4TnVCMmdqbHNXV2NQSG1EVzZHVUhsUEoyU2RBMHovbmcrOHJnZGY0bmttMzkrTVFuU2pXaEVmU1BianFoS2FsaXRHNTZHRzQyb1NWY2FZWkxpaW16WTc3Z2V5cVk5eG1qWjlna1FDcW9uUENkSXBmRjBmbTh2RjJHbjlKVEZ4UUJaZkw4RElNb1lMUndsVmszK1R3RnZ5RjNQbjJjSW1LS3RZcGNpb2lpcDRIcVljRGEwU0t3b2RGQVE1RkE4NGlINm9nWXQ5V2VzaVNXcDhPaE1ZWS94ZFRVejE3cTRiWS9BLysxR1Z1bGFaNTNNSHBpWG5hVGU2d1FDN1BDK09FUmpkNloxM3lBSVVBUll6RXl4dUs0bnlKVHBrejVSanZuKzVURkdSdkxoUjNja2NyNG9DbGx6TWVpZWIrWWJ3YjF1L29Oc2lEUjRCWDQwRWw5SXVwak1KZm0wK0VQMTJqSWowWFZQWDFDNDJ0YTBKaGc2Q3J2cThLUEpOMUVSZHhQVU54NEIvMXFKMzFLaVVBdzdMK1RwSERZV1ZvWWtqeEJsZTdvOWZDNU45dUk4ZnlyZm9yaG1CQkh0cGhtOThSVFRxU01YL1VtbCsvWEdwTGVXWC9laFhzRFA4RFpYL3djVU0zQTdwWmJnZDUrbndSbE13THByRVFtYTlIVUtUL29qc2VUZWFDUVM5K05FNWdDOWlJeG9hbVRPeXZGVkoxZnVYeXJLT2pjVXM5aGlBbXdJUU02OTFzY2RuU0lvOUtKSTBtQmRRczlYTUdZTkVHaCsrSXZnVDhUbHZweUEyYkFkNTZLQTlnWlUxOUhFYnYyWG9rTE50aFlWQVY4Nkhza1EwSmNSREQ3Q3JycERxalA5R1VITlArRTljQzU5emJoc2ZydjRyZ3ZYTzluYUg2LzJjUVNVa0doWWprU0I5Y0xzT0VjUkVMdStIbjV1aTh4bVhrVzRtTk9zRmlaWThEajk1Nmgra2ZtOUVMa1ZDV2ZoMDB5Rms1Unc4U1lnellDYS9ENU1vNkI3cFNMQzlaN1duUC82ZWZBUTR4UGF3bW1vVmhzT0toZENQK0RWR3lkenpRNEpyQ3d6TUZGRzRHYnFNa2Rqdmpzb0drK09lbDFEcy91TTJXSmFnanFiUS9oK2FOdVI4TW5yd2EydnVDaHJjdENkYVV5c1VMM2ZpZ1RwY0lXV1NDM29nQlJrZFBHUWxCMUwwa2dwNjFPUWZjWEpzRGQ2MXFGT0U4Q1hHbHBLcXM2U0YyQ29vZ1QyVFhWZVhlWGh3K2Q0dUROSjFMVEdLN2MxNjc4b29HczlNT3NlRVVsRW4wZDQ4S1ZwdG5OWkR5OCsvVVNmM3dhdUw4RGZ4bTF6UDg3UlFmNkFmV1R2bUoxdWJrWWZvaHU1czAzM1V6NlQxUDFnZmRJWkZYbXhoTzVIS3Z1eEpySWsrYTdvMHpmZkNsdEpSbjJmWlU1YWJYOHJRWTNaL3J5ZVZxOTVxNmhnQjgvMXRoN1ZmdUU0YmV6U3VXcEIxSDM3Q0lWWGIvUXdRZmZ5Tmp4WjhDOWJTWVdOUmhZZTJvRUZWVitiMG9vVnErVCt6ckdGWW8wU1Z4OHZLdmY1WHNQQzRkczkrK21xSWc0dkR1NEZWeWw1QkFkRXArODhTdjQxLy80Qm5ER2lTNys5S2lCaFd3ZzIvRWRaMkdmNUxnazVrQVNCU0twTEZ5ZStPU1QrSXFsT2dXOUhycnZVN2szeXdkVDVFeXI1MHpTM3R3OWJNZlFRbVVZanI3dWFGb2dRbGI5dWNza2Z2c29jRE1ONXJsdnFrSnhjUi9DdFV1eGNrMERlcnZHVUJRTllxUmRZR3hVQ1Nsdy9ISWJKNndFL28ybWxyenV5NE9HMFQrRmRvb0RaYm12ZU9XOGFrTUs5ZGZ1MzRHLzNrNVNjZFY3eUNyRHJzN3dLTCtUNzNxYXZPcHFBc1BYTW90YUdvcE1hSnBhODVxcm1HZGl4TmZzMFZFZmJCVWZxbzV1OWJzVndualB5T1I3cUd0TDZUK0V5cFdyWFBEZ3NJT1BYZURwME9PTHZ3R08yMWdHS3hxR2F5eUMyOHNEUTNFc1hnb3NPcW9lRjE3NUxzUXJGNkIvMUVSNTFNT0R6MU42QjlFeUdqWnZ6Ylc5TVFuSS9Ta2hmWFVCbWpjVGJOOTNmZk1IZmhYQlpSZDU2T3B6TlNqQzlIdGFORmpXM2liUmN5YTBNUkQyUWMzM09ZN1FMTGEyVWh2SVBqOTgvWHI4eTEyWDRHMlhsYUIxRnpBOERFMVU5UFg5L3VpOVRhMlZNOGZtUkpnVDVMSHRmUkp2V08vaWxDT0I2MzdFMEdSWk1VcXJGSU5kQWlrYTRZa1UzTDRINEdZc09NTXBScXhQNE93ejIzRFpKVGFhZUUvQjUvM1lLU2lyY3QxcllrVXdwOURNdzl2a0ZwcmVHKy9EamcrZmhXOSs0OXU0K3JxUGsyUTg1TExoVFVSajBPazlsWTVEenZjcEFJWnBzTEpwRXBGeUNrT0ZYOTZoVEtaaW5EYTE1NVRYbFNGYVc0MmpqbzVoNDRVbXdWbUcvL09sNDRuTXQ5SGFuMFR6NWdFa2tnVFY4R05lQmE0Q1VabmljQ3lPYkRLcHN3eGFXSGpkdmhFRGRjVTJQblErOEExYWtsMHlpSTNMR2NKWXl4Z0w5OUtzSmlBWXZCcXBmbXBzRnViSWt3aWtzaWhmdmhHTFRra2lGbjBPN2R1QTg0OUZmRUU1M3YrTnU5eGoyajN4b1lSaDdNQkxLdzRQWDVOYnVKRDFmdmFYVHlEYnhGZDg3enNraGtZOTNlOFpERXRmYXl4ZkMxWHlZZG1hY3B6eGxpTTFpMnpqOFdkY3VCSm5YYnBNQi9rWHZlc29mT3ptaS9EdTY0L0FzZWV2Z3ROTVpycWQ5dFphZzNkK1lSbXUrY1lhZlB3ekMrSHcyRTZ5VTBZWVNGRTRqSUIvL1lhbHl5azRycStsS280a3N4MGRkZkNwU3p3OHpYdmQ4Z3l3N3BnUzJGWTFzdTRRNCtaTzJIWXZuR3dLanRYQWJZOU9SOHJnUW1wckdaek9TcXcvZVNNdS9ydTF1SE1MVUVjaHZla0tITGUrMUx1bjJIWFBmYzFwYUg3NTNIMUlmT0lzM1BUMTcrSlQzLzBhc09tNEVKN2U0cUtpd2ljeXFnK3liemNiODRRUy9NT1ByMFJ4UlRHMi8vNVAyTE90RlcrNDlpS0dGMzA0K2RRS3JENmlIbVpxQ0hKUHY0NTRSZmxiWWRnUHd1bjlGdHlSZGhpeDQ3SCtzbXZ4MGVIcktReGJjTXBiMStEWkIzZmh2NzgvZ3Q0K2dhTTJyVVB6YzA5ck13N1BZQ2psNHNvelhDeXRBOTVDdDdEaWlEcVlVZFBQT3pNbU1nTDhibmwrWllKVnduMTkzTlpUelR3NDFGUWpYZ2xSdFFtaG9oYlVyZHFNdS84S1hIRUM4SlhMVWZ5dnY1WS92Yi9GdVhiSXNyNTlVTG9sWHkwMVJaKyt6OS9lZUJaS3FEU2RYN2tLa1RVclE3anBsc1Vvc3BxUXBJS3RQV1VsU2hZMzR0aVRJamo2TkpxNzNTR0k1WmNoWU4wRjg4VVd1S1Z2UVNyK0VNemhia1Q2VFNTQ0sralhkc0xLaEJHdFBCcGpBL2NUaEFaRUFpYU00cVZ3M0orUXhiWkJoTjhFVVhFcGRqM1dqRXpTNC9WczNQVHhMekhzb0pWSUJMQ2t4TVhuMytYaEM2UXl2MnV4Y055Wks0bHpKWnhNcSs0VXNBSVJoTUlsQ0xyTmlNWWJFU1hEallXeWlFZGRoSUlTcFRFUElYTVFaV1dMRUc4WXdlYUh1dkhFN1VQNHV6ZjRsWUhmdmd2NCtSWjhjOUN5cnNubk5BcFNmL0t3TmJscWVWTEs0VGp3blcvK0ovRDBNeGtzWHR5QXA5cXJVTHBnTWE3NzNxWDQyK3NYNGRoTnA4SG9YcVRxb09GMjcwYTZQWWlzVVF4enJBbmgvbkxZSGYxdzRtK21UeXNCeGw2a0dhSjVaSURrMGM5RlNqWkJoR0xJOUQ5RndyUUtudjFXeUU0YlJxSWNLMWY4RWVzMmhySG16SXZ3NmUvOEN3SkZ4NkovT0lMU2lJYzdINE0ybDZ2VzF2S2NVWnBTYXJxWG9TYVcwYWVyVG9SK3VGWWRYSmRiWjRqSDlPck84MkMwaGlhNUZ5RUdzSjZrYzA4dHc0bWI0cEQxQXJjOTZQZVhmcFR4N0h2VzQrb2F4L212ZzVDd2VWVXQ0dndqUlNSdDRwalRUd1lXcnlwSDQ4b01idnpXRjNFaDN4aWlEWGgrRDRuSFNnUnJyMkx3N2lEWTgxTVNrL09RTEZxRDVQQ2RmS0ZWQ0ljWjFIdmRNRElKRXFWR21ydHo0YVNiRURISlJER0FzWkZ0Yk9RVVRlR1ZiUEMxUEg0RWdhNGJZWFNRQWp1OFQrODkxTXFiY2RVVlQrSmpIeHJEQzhNQy9VUEF0eGhTT2UxRFNDYjc2QUxvSjQyc3ByOEdrbVRpZE1neEJtQldtdmZzZ0l3dmdoZXJJY0FkM0plRlk5cmMzNHBNaXQrajlmamdKNWRqTTAvNTBUMStQZkJIM2tDYXZ4YnZySEtjSDc1bVRPNU5sNkpxendoKzh6ZG40c1IzOEFYTGpqNFZ0V2RlVFA5SEtpdnJhTjRvZjVrTVpMb1hJc0JBUC9VRWtPNkNqSjFBcmVpR2sreUJFMXVPWVBZQmVNT01WNHFPNS9lakVXVGpDMUN6U0hLeW5mOU0xcm9Bd1VyNlZVRkFVb3h0U2h2cGI2K0ZqRkpiSzgrRjIvNFZoaXRSaVBwU0lHN2p6bTg5aWp0L0FseHpFVzlQOG5UOXo0RnRTWU14Wmtobk5yeDBHcUdRUmRQTGM2aXRxaTgwSG84aVJCWm4yQ09JQmlTQ3d1KzFJZWRDQlExSE1ZblI4ODlKUkVqd3psbm5kd0NVYzk5WGZ3L2MwNHl2dGZybWQ1OU43cXVtakZPR1VOZVJ4ZjJYbjRaVjExME5QUFowSEd2UFBRbTF4eXlIU0t5Q1dYTVZZN3Mvd3UyOEJiSm9OYjNNVGpLazV5RXFMOVdtMWVqOEJVRmVTd3A1SWR6a2MvRDZIMks4VVFtdituWDBYeUhZdldRejdnQVZpRVFtdkJwZTBVSjRBei9VSGRveXNnYmUyQllZMGZYVXZEU01aQ2Q5N0puYU5FdW5DK21lZTlCRkFKKy9wd01MNk1zYlNZNysrUTdnOXpzRXlxc05YWVZva2h4WmJNdFEwRUJFRldvYnRpNDNpVVdpaURFMmlqT2tpWVZOeEVtcG8wUXZFZ3Fpb1NHR1dGRVFLVGVJUUNDRXBjc3JjTjhEYmJqNmhvZmNGc3NLN0ErZ3I0b3lUdXBKVFc4V0Q3ejlGS3k4NFhyZ2gvUWt6WWxhblBlcHBSQkRiT1RTalhDR3lFaFNERUFyMzh6dEx5QUh0bE16TjBFR3F0bm9XM21oRnltZGNZaVJYeUFnRFFRV2ZReWVsNExsREVLU3dPaVN0SkZkeU5SOUFITG9Oc2pCWGRSQ0JrcWhXZ2piaGF6NklMelJQeEdjVXZwRmFuZDhHVEQ0QzlyWUtDM2tGVmkyYUFHNmRuMFV0NUtMZnZCTWF1bmJ5Si92a3ZqUjVpQldITDhRc1hpUTRVOEEwVWdFc1JoWGdocUxCVkVVRDZNb1lpRmVSR0NKY0V3QkcvRXJNSUw4SENMWVp0cG1ISjJBdWFJSy9mY01xeWZ0UHl6RGxoeVlWVDNBbjk1Qk1LKy9EbmppY1dybjlncGM5dEZqSVJ5YXRBU1pLZU5RTVhBSFJQSDdHWGVxZ2lPRDIrVnNkQjRUNWZjMk9xTFM5eERZSFhCVGUrQ0tBWGh0ejhCYytFOHdTOTRJTC9HTVgvNFhYb2hnNmxHWWJnQ2lqT0dmRWRSMVIyN2ZiZnBwcExRWmZsUXJ0WUk5ZUI4eXZVK2lxUGJOTk9WdENPeHN3UWticWpENk43MjQvVmZBMjQ4SHJud2RVRjJTd2sxM042UDhpQWFVMEdZR0xaZm1NMDJ5WXhGZ2s1OEZ3aUdEVmtMb1dxS1FaZWhxeFlDcU0xWmhEUjkvNllJaXJGL0xNS2RqQkx0ZjJLVUtMd2J5YmJSa3laTERBMUFGSmgrOHVoZjRDOEZjL3RscmdTN0dLLy84RmVERDN6d041MTVlRE96aUVkR0ZOSzJQQWlWbjAyVGVTekRwZ0R4cVZrMDl3YjZQV2xoTWhwbG1DTUt0RTRaQmhoR0lMWUZyL3k4WjdrNTRWaVZrZGp1QzlUZkFJeG5LcFA5RTl0a0JNN01OZ1d3YmpOS0w2WnNIWVkwOEFWbDhLdHl4RjJDSkpJOHhhYzdQcDVBTUl0MVBJU2c3bHZnZmcvTXZiMFo3UnpkdS92MG9QbklKOFBwajZmdUtIUHJWUFdpTkNnU0Nmc1dmeXV1cFZZRm9pWW5hSWlPM1h4ZXZHSDR2MDZrYnEzSDY4WFVZN3U3QjdwMzlDUHRERHc4ZkRjMTFJRWU3Z0ljdlBBYkxQdkVSSURrQ1BMS2xCcC84MmtxY2RoNERsMWFhVjF2VmNwYjRUMm1SOG5jOVNQLzVMbmlsRERmRy9vZU4zd00zc1pnNi9oNkk1RU5zaUZwcVpCMVN2WGNUZ1BlU3hhNkQzZjR0WHFNSWR2LzlNSXRQWkl5NG1oclhoQXpERFhmb2x6VFROVEFyU0liR0hvQXhOZ3BudEJ0V0pBUXJ0b3pBQkpGb3ZRTWx0U2ZEVG5YU3ZOTXFKQmJpb3ZNN2NOMERBcjk5Uk9MaVRjQXh0TTVmZlR2dytWOUtKUG1zSmFYQ0h4K2o4c1dtdjFXa0o1QmJGWkJtcnA1WURmRllUQTMxVW9Qb2F4OUd5NTRoQldoemNYSHhmZzNmZjhYQ0ZvTDV4ek5YWWRsMWYrL25aLytEY2VjVDIycHgybnVQcFBra2lBc1pQcXdZSkNWOEdMSWhEVGYrR0p5YU1MTGxiYkNEajhBcDN3QzV1SkY0TjFQN2prQ1V4NWpGVHlBWjRqbkxMMEt3cWc1WnNRVm1xUTJuWVJQQ1JiOUYxcmtaNmNUWEVWanlCc1JxYW1nZWFicmpiZkRxam9KVFZRSGIzQTVSUTNPNzVpcVNxWVVRUmFOa3NtemV3REFDNFU2RVZCc3pMS2s1NVkyNDRlc2x1R3MzY1B1ZkFUWFc5S2dsL3NBamMwQWlOU3IzNnIvTmZ5NGNVNVB2bmxOb1ZjWXRNdkVFV25iM29DZGhxMzdpRnliSi81eFRnNjlFVFJGb1puKzZPbzRUci9tSW4xRHY3dks3c3NUZ3M3am55enVSRFZmQlNTbi9vb2I0cWM3bHAzVk5UNVlhRXpCK1RTblAwRTh1Z09jTTB3bXIxdm9DRzZtVGNlRUlHNmlIRFhVa0ZoNXhBbHAzUEVoTkpzVW9vdWtkVkVNY3R1aGU5V0Q4MThnT05TTTluRVc4akQ0M2NqTVNmWCtCSktHTXhUb1JMTHNWcVdGcThWQ1A3bkZ4MGx1MHhnbjdON3BZT2w0ZWhaZEpZaVdqcVQ1Nk8xV28yTUp0SStYd21qT0FMOTJ0T21HRjdxWlRsWVhhOUdxVDY0OTN5UmRaSzJCSCtBb2xZWVpnMldIczNEa0FpaVBveFo4UEJBSWlFb2w0MDNTbnlWY05vQlRtajFYRXJMZDk1blBGcUcxMDBkNmlCakRiZVB2YkpUS2pxc3NyZ2RSSUFtTnNKTnZOZFVwYnVRby9OOWZid3RlMGsvMStRYlhuUzRrVjg0YzFPS05kREFVczlMMzRJa1k2VzhBd0VNRVMvOTRNRVdIRzFQRi9VYVUrdXFlNUo4MUEzKzdRaWZsZ2xGellkR0ZrSDlMOXBNaFZNYWlxZHFYTnFyRkNvWkFXam5CUkNkNzNlalZtTklna3lWdlFEQ0lURHVQOEUrTjRiS1FadjNxcUMzVzFwaDVQcXJycVBEM2tVT2p5VHljbjJLcGlNRVNKaVFjeTlOTjlhTjQ5NG8rZHNxeG5wK2dQbFhNQjltVUhsTzM3d1hXTkRUajdrOStpWDB1ajZDaUdGUTVqUDdhd214bENvNjZydEVsa2h0V3dJcDJWdDRtMHRCTzZYbFlsRnpSUHRGUFVraEZWODA1bGNIU1J0RW1ORGtqVkpWT09WS1lkbGxlSGdCZEFSbVIwY1hhSURhOGJWTlZpV2tHZFdMZjR1NkZIY2ZNM0l1cW8ybUJLaXVEdnF0aGJGV0diZ1NpRkplRDNFQVJWOG9EQVVQMkVHYUJBU1JUblNnME55MEtrTEVLTGNBdWZ0UU9WcFhMY1oxbzVYK3I3VDZrSlVzb21vZWI3VkFTVGFHOTFzSVBDemJ0czdhNm82REVNWTZvcGNhWXFjWk92S0tCOHIxMWp5Y3hLZTRDTU1Gek1Cb2t3cUxaZ3FORzhNdUJYdUN1YUtBdzJZbjRNaE8wN0VWMWlsSi9zd0lYakpMaU82ZEhUZXN5UnhhYWxtbWJzWVVTNFAyaEdFUkJoWkdpYUhUZUZvT0YvcCtnZzQ0N3E2NmpqMVQ1VHFhZ2ViKy9ueGJYQU9INU5yRlRWOXFvUW5QdGQyNjg2azY2amh5R2FVSVZqTGhLaktWM2FPVGdpc2V0Rit0dmMrRkpWQzY3bmE4aFpFcVd0cnZCcmVnZHBNUnBLWFZSSGh2RnNzNGUyUHQzUi80aE53WkJTVGpWamlwaE5XMTkyUUlQQTdxSGVJWFMrdUIyTGx0ZnA3TXF1elR2eGc2LzlCS29WTE0vM3RLcFN3UkJxN0lxcWNRM1M5Sm02bXQ2ZzVxZ2hEV1pJK0YxVytqaENsQTFRMDRWdU9UT1M4Y2VCWnRnd2pGbU5vTVB6YkczeTNKUWZlOEswYVdhZFhMOEdiWUV0NEdTZ05WbjVQY2RSUXlZY1hhaW1oaDFtVmNVWHozZGNSLyttcjA5QlNtVTlMS2d0eHJ1djJFZ0JNdWd5aHREWFBZcElhTzhCditNRGYzUCtVN2tPTlN4VmxhYW9BVXQ3R0w0by8xa3N4TU5DaUttbWxwdlRsRGl2QktETkE0azB1bHM2c0doWk9VdzJhQmZmNXJsSFg4Q0tsYjZmekJkVDV3Y0lqZnRLK0lsczR1d1hVK2NVU2pVTXJiYi9Rb3IweFB4WFRvLzRaU3BtTUxkUFR1enpmT3M1WGpTbXJxK0hqZVpIY29zSmY1MnZISlIrRWVMNDBBelYrYTBxL0liN0IrR20xOUt2bXRpenN3dmRhUWMxUlg1WW91UE9ISmdhRGQ3WXlZMlVNMXgvYUtMTjd5OTJhSmNPTHhCNFdEMDlTWkhFMUhNR1RsZnFxYisvN0lDeXZadEphdEhlM0k3alQxL09PREpEcVhMQUtBTVZOWk1jUks1UWVyd0MzcmZFNHl0eVE5emRUQUdMRGswRVk3U3kydXdwQVRCenRiMXFXTDFyVHpTQkVkemJpT2toRjg3RThNVDhmZk1wYjYrZ0JsaUhJZ1I3MmNJeVdwWUVaTXBrSE5rUDhqbVVVK01WZXkrc0JETnl5UVZWZVpHeC9aSGdpNnZJOGlrVVRRU1VSUCs1Z2FxcURzUFhVQU5UVDF3MUk2Z3ZPNkI4Z3UxcXUyZEhPeG5TRUlOOFd3T3FORS9WQXFtVXRGY0FZdjZKdlZ5Vkh3b0hJQmwrNHdzeE1lWE0rRkI4YjJJOEROemNkRE81b1lDRm9IZzVIK2RyejRTMlNyZWdKZVhVZ3BZZnFsOVZFbVljbWNUWWtJUG01a0VkcGhURkNWQTBCMkN1eGxlRkxRRlZvNlEwbTNTL2p0dmFNallJbTZLTllVOVVpQWNkMDFRZEpnWW14cmxnWDBDZE02RDdtbE9jYnFrQWR2QnBCM2J2NkNxM0NhakwySVFSSnVPNU1QYTBwSFYxblptVGZ0WFlsam5oZC9LTldWaVJsL2RMdXNGQ2ZrbG5mZ1MzblpwbytFQlI3clhkQXRIUENZNElUQXgyeWcrSHlFOXVNVzRacGdqcmxhYXBDc0o0eUlQbEp0QkwxcjZqZVFScWFHaFp1Vzl5elp5SkZ2blVYMjZyQmxuVnNURXFpNEhmUGU0bmI4dE04d0d0eUVMSUdXTE5tVFQwRlVuOXBYalRMWHVhZTA4ZDdPNURKR0xDU1l4ZzdYRXJzSHhESThaR3NucnNpQnArNzZxdUxWMXI3UmRjcDhuelUyTXBQWGhKaFF0NnlLQm5hNUtqUWh6RHlvM3pWR05FK1QyWUVUbWY1WkJZK2VORHN4bXBoY2pKOVVwNTZscklGV2JESjBocVVMQ2R2Ny9udDZIclNIM1BRdTFXUGo2ZEZpaU5xTVRBS05wYUV1anN6YUEwN0tmNDhpV2dJcDlVeUF1bHFTTXpMSzZraHZNYVRlMWF6b2JHU2tzZjFySnNLTytLNmJSMEttSWtYZ21XcTErbnY3RVIwZDI3dDNSMmpKeTZlMmNIMU53S0VRSVJabkJkSE9sRlNkRFZzNU1vUnVzUkNDYzNWRnE1RmQwejR0Z2FKTitmU1lLYzFhQkk0UU92Z0ZDem1QaGpYZ2d6MVN5anhpQUtmelMycXdidHFza3E4bU5MdlluWndHRDRJNjMxOWRWRVV2cUFDZDlaQ0tZZVpjN3YyVkVEWmFFc25ERUh1MXZHMEVzb1ZsVlpXTDdFUW5XRmhTcXVrWEFRZ1pKS2VGVFhaRHFGenM0TUtsdVRhR2lnQVBSbm9ieFBSSWlIN0Znc0N6OWN5WU01RzZqWWI1Tzd2d0JPdFZDQU4vZXlRZHYyOUdMZHlpakNRWW5Camc0OCtNc21GQmZsbUN4ZWF2YnlFMklVK2pWaHZOUy9ZZEl4UnI2TEk5OE04cVYrY2R4djUrY3lraE9Eb3FTY0dBK1RienAxYklyc3A0eCtzaXlZb1ArVWVHSzN4QmMvRU1aRlowUVFJa2sxMVVRUlliNlFLcVdQYzV1aFB3alR6bGFIVmFvTDZZNmQ2R3NiUWNXZlgwRExNNG03YlY4Nzg5bzNIYWh5bXNUQ0lXTzVzMDRlVEcxN01xdml6eDM5Y0U2c2drbXRDZ2RDR0NOVFZIV3g0Mk5BQ3hwME1rR1o2Nzd4endXVEwwSk9mMzRoV1pyMldqbi9PVFJLaGx2Rk9ES1F4Ri9iYXZIcHk3cFF0N1FTYmJ0U3V0aFhtTFE2TlNhODV0MXdHWitGcStzUkRwZEI5SnNRb1RwK05sRmRzeFczUG40ZTFwVDk0YjVKekxZUVRERkZQSHJJVTM5aUR2djBkeWNZZk1ISVpBYWE5blNVOTZlSGRhRk5hUm5OVlFzVnFTbzNteVZtQm1tdSsrUVV3d2psTEdETjluditUVlRGZlhsTW9vaGtySFRGR3ZRT2RDSGQ3TUlTUnE1M3hWYzB3ZURZc0R4K1YyTmZMZTFFcGZMZGRDZVN3WEEyNDNySmtwTEJYRDVCVE5KUU1VdW1xRkJURDFyWU1oT1lldnVXdFltS28xZDc2K3Bxc0tFaVhuVE1aNzhxZ3EzdGFUVjdGaGJXQXlWa2hTT2IvZEJGRDdNdkdOS1haN3l5Y0JpOUxIaXpncyt5VUJNeDhWbktsN1pHSVVCaUNrc3cxWnIzcFdtQ0dlWTU5UXc3L3RRRU5CNzdDQnJQcVVYM3pqR2RQZ25TQjRlSXRCUkJoR08xRVBFNExVOElidHFGV1VsaWwrbEZ4dHZCaTVMaC8yeVhuUnZzTDZkZ3NWT05TcHYyanhSWWgxZ3J4WWFTeEJ1dmZzdll4MWV1aUJ3bnZGQThIQTdBTEcvQW1TZjI0S2MvM29rdUJ0VExGek51aTZySkpDTFkwMmxwSXFSbUo3RnRWN1BYUEdrUkJTR0VCdG1iK0Q3dWVNeEo5a240bXVKUElXZU1vK2RmSzBldVhEbE9qdnhla1p5cDkvWUdNeitYZzFvVGhLQ1VsNnRUNGNrUjV5QzkvVjRVbjFLQjZObzRodm95OU1GNllqaGs1VERjZ2MwUWJxVis2TVFnQVcvbS9tUVdBKzBxalZrRDQ4VnVWNGhGaFpvNVhTWm8xbkV2MWlIeW42SW9uVzM4NXJ2NzdqMStYYml4ZDZnWTJUNEhrUkkxR1dJQWJpYUxJMWE1cXVkRmp4Q3pqd09LQ2VneEd4dXg2WUtUTURvd3JLZWN5V1JzUDhTZ0RUWWdkVDVWaFJ1Nlk1aVJ2d3BqTk52VXM0eXBlaUEvRitnVVREVGg1MlJkUDN6SlQyWGorU0dNbmlKT0JUaXVtbkxPUDA1UEdlZDVlNU1zVEhSUVc3a3hOZ1lmZmtIWUw4ZE1wNXNRVzF1S3JVK05vYTdHUXN4U2VXYUdQNlRCdHBwQ0o1MkcweitvKzF2ZHRJZjIvakJxYXh3czNiUU9zVFhyK1h0alpPV0RqMVkzOVpxZFUzUnE3OU9ZVWVzZ2F1YzRtSXRDM3BxdnZMMXo4NG9WWmVob2t3eXdrL0FZWlNlSDB3eE5UUHJJTVN4dERPbk82K1pkL3VSUUtoQlBEWGVpcytscFdJYnRWOTNRL2hwUzZzbHcxZnhDUmphTGtMTEZyZ3BYMG5yK2NEMnEybVRZRS9MVnlsVkFtZTY0K1hSTlYzZXhlVUwvRDJsNnVUbUpabml6QWpNOTJmenF1WVlzZnhSM1hZa3FFZ09lNmVuQUdlK29ROGRmMHhqaG80OTZCdEtESkVHcU1JeWlxT1RHYzJodXN4TDlwQXdubkIzU1BVdDJmUldTVzU5RnVLeGMvUHQzbHY3eWRXL2RjL0lNWWNxMFhXWUhBMUF4azcvOHlBY3V1RlEyL3dlR2tpUUJUaEpDUmRrcXZsTnoyN2xjS2FVVlpIOHJsaGVocFdWVUQ4U3RxcUhVMjBQNHk1MVBvNkk4TjVXYm1KcjRUTTd2b3NBY1Qrc0U1TjRoelhTa1o2cDc3Y1U2aEUvYVZBcDRTYlcvcjJrN2diMHJpVFhMVFczR1U5VE1NVVlmYWlKSlBaZVNrUDVFSUNhM1NocG9MY2FNQUFUTmJ5QzBCa2FvQ2l1TzI3UHd1bmUyL2UxWC9zZjl6aHhBUGFRMVJTLzVpd21WTldMWUxnNFJ1Q1FDUlJFNE9qTnVJQkpUV2hsR3JINFpna1VyY1BUU0VyU3FQQ2JYV2dKYVYrZjNINWJTM1JSUjhtTnhmeDRqdFVaaWZtNVVoVFZxVlNVcmdWQnVHL1JUZm9IY25JRDVkYTlCd3ViRUU0cEpjV3ZoL0g5NjVMWTVzVlh0YnhvVDRaT3lKb00wdDZxWGFBRkRTalhjdm1tWGcvLytkUllwVDZDblh5SXhUUGVRVUtrdER3SEhnNlc2VnpMY2w2UTVGMzczanV0bVlVWEtZWlhXTVhqa0M2V1g0WXIzTExvMlpxcmExUU1yOFRuWWpGYjBQWGxMOHZnTHloRlpWWVRoR0Y4bVFFa3M5NUFKcUQrWE1JS3hycTFJMmgxWWYzSU1BMndRQmFySzRhclpRN3I3L1Jvak5SbVZ5cE1xN1ZVellLb2grdms1aWZLVE91Wm5zZzRFSmxaMUhiVVdmbGJYVmR0d2J2YnIvTkI5WVV6UVNtVVJWRktLN2s0UEJGYjNIUmdDZXZ0QWtQaE12VUJuRDAwdDEyMGtwOVVVc0FYVVVEWGI5b0JaaTdjZWwwRWtMbEN6MEVRb2FzQUxHSHAyelRTbEloMjBrQ0VaZEdJaHYyd2hOK0dTU2dvSk5UL2hXTGRPaU1aV0xBbGNjSnA1NFN3RllZZVVGRTM1aDJtU2RqaGxrSjZYV3hJbHRYd1pXVXlmUjdxdThxNHFYWllhaFRzeWdNV0dDNWRQMFBTaUwvbVZGWDZkVFVmSDNsMVY0MHhXVHN6Zm5wK1NQTTkyOTRvamM4L2g1aElVaXFDVWxwbFlzTURDNG9VV2FsZFZJbHhjb1orNHIyc01xVEViQTZNQ2V6YjM0N21uaC9YME0vaytXTU1vbUhBajEyMm5CbmN2cjJVTVNndWlCZ0N2UDQxbU0zTWZIdjFkQm5YTGVKOEdobUhGdmlOMlV4S1p0Sjl1TkdoKzlxUWN2MWRZK2ZGc2lwNUl4YWRwWFNCdUlvRHpUeSs5OUxiN2gzOVNFTUxJZlNubHRBNml5UjNYME1lM0czK29mOWo5L2FhVHpmTUYvVWdxNFNLZ0p0OTNwTTZscWpEQnNRMlVVYUtYMXB0b1pqRGVSeTJvWnlNdFcwRHByOHVWYjB6cTRGYXJuZStyTE9qcXl2K2UzNDQvRU5YeTRyTUZUajRoaWdodHN3cVpySW9GTUdLVnNCbElobXFxWVphVTZXZEs3SDRCMFk4c1JiQ3VBcmQ5OVZuODd0WnQyaDhxVGM0RHErZUc1RnJFWjIyczhzM3QvVnVCZDc2TE1lZ0dQd2IxTWdaZWVJYmFSNXN2QWhaZFM5UlAvS3U4c2doZ0pLaUM3Q0Y0NlF6czBSRllkaGROY1F2UDYwTlI4UktjdUtIMmxPVjFnK0VkblVaaUNzMlVCeHZRbWY2azFQajZ1NmJZME8rYWNObmJIaGxkczI0Vi9xYW1BbzM4b1pvTm92N1lUUlg1QWVOdU1ackpvS1U4WXBvdHplN3FkalZ4VTdGQWVaV0pCbXJTSXE0bGl5clpJQlhhL3czMmpURVl0NUZJQ2ZUdDZrZFh5N0NlRVhxcWp2Qmt4c1M1NncyY2ZrSVlmVU1SR0tNT3pGTEZOTWdzOWVSQmV4Q3VydFlOYktyNUc0SWhsQjV6RXJKdHpVaHNhY0xiUG4yODlrVlAvSEhyWGowckN0aitoTTlzRjFUNmYrSGhwRGVlQTI4UFk5RFRKMkxRNGpvL2xQU0hWaVFnU3Z3WTFNNFM4TjZNL3FNRVFmWFhlZ1o3RUNpdGdVd09Ja3ZIbkkyNUNNYXlPSFhweUxrN09rdC9WZER6TzlWZmFacFNldzlWWWtIdnYyMUwvSVhidHVBZk1ORngvNUkxM3BrK054Z0ovaUNkRUZqVkdNWGZYemtIVFhxN3Iway8vOXF6dVB1MmJYNVNJSGZUTE1PQnE5L29ZTVhLRW5TMnFkRmdTY2hjeUZRYVk4aUVCTFhEUXJLakc1SEZSUlFTRmRlV1VtZ1VTUWtqdzhaT2pYcEk5QTBqVmhyR2trVVc2bGJTUkpkVWFDM3Q3aGhEbkdHVlZjYVFhMGMvL2YyTFdIUFMzR1BRRUsxVmYzMEZHaXJvWDBmcGtLUERiSWh5aUd3M25LNFdCS3NjRklmTkRYeVZPNllBYlRvdEhmL2RPbGhtRnROUG9qVFZxc0VNMmM2aWY3dGFmdW5rWTMxTnN2c2NSUGRCazk1NjdmRklrSlRjL2JPdDQySEZtaE9QZzB3OGdtRWRNbzFCQlAxSmtsVjFzNXFoVERXcVVld2kxbEJIczE2SkFBVkZGUWhrcUMxUFB2SThpdDFPMURidHdKdE9DQ0o4V3ZXTWdyWHlyS1dvMjlLR1pVZDVjNHBCVlRKRFZ5SDN1bGhJQytRT3BKSHUzb2FRUVVBcFdNbUJka1ROTU9xcnlMTDJyczJZQ3RRRExoSVQreEhHVEFlbXFMVGtxdSs4by8zZUZTdkw5bHVUMU9NZnRTQ0IxZThtMHh4UkJjc0dHdGRMdEQ0WDV2RmpDTWVqY05YODd1clBWaFZSS0FKaFJCZXVZR2dVeEZoSEV1R3FCTks5dytnYVRxRHIzb2V4WVltSHZwRUlzZ3hMNWlwWXB1aEM1K01lNnN2RnJER295OThzejhGb3IvckRBb3pGUEJPcFRBb2lQY2ozenVwc1ZWRUhpVldKVjFFUWkzb3pnUGlTdjRwNHNNZTJ6QWxNdFg3NHZlZGNJQm1yK1pxVTBWcGtxUDh0WTF5VFJJQ2F0SUFCcXRLa2FDVlZPcWcxS1RteUI3RTF5NUI0K00rUXZXMndhS0tyR1JLdFhSbEhiOU5XYkx5d0hOSFZjWXdVVVJ1RENZUXFYV1JEZnNpVTdIb2VLWWZuMUtTUjlKcXh2V2t6ZXUrNEM2dHJEUXFXQ1VOTnNzekdWNEpsSXNOV1N1aUV1aElzR0FNVWxCRjRiSGlaOWdXcm9pYUNYbEUvcHhqVU1VS3dLdU1vVzFxRTFnNHk3NURRYWNzeE5lR1NLL1cwNXBteExNMnpGNXhHUTZmenA0ZTBCR1ZHdjVvSHRxU2NGaXExYjVva1lqYU1DaFBaWFozby92NDlzQVlsSG5zK0NGbTJIaHZEajJuaGtMUnhKZ0dvQ2toVTFETmtRZ2t5REJVQ011dVRHL1VuUDNiM0k1MTB0ZEJrMG5SWDQ0SzFieWJhU2JkcXdRcHQrd3NpOVFJUldwYmhQbDVUNVkyejlLTVd3eC9HT2FwYzJGRmpkQ0lXTElKb01YenJhWFd3cUpZQ05DQXg1bVVRby9abmhqTW9hd2pSMnNqMEhNQ1VoNkszWlgvOUtucWYvWG42Z2l2TEdiaTdHT3ExVVd5bkVDcWh1U09sZGFoSkxqWEpxNmhHb0NhS3BOTk04enVLZEZNM01nVERUU2hkTm5XaC9mM2J6R2NYSDJtVWJhZ0pMMUxDVVZFV3hWT1B1emgybzZra25hYlpRVkFuNHRYZmQvR25OZGNGMlk2cGJVSlIzTUZneVlFSlZwaUNkY3NEcFk5dE9qbFF2N1JCTHBndUJwVzhoejNnNmhuUVNsd0RPL2ZFNU9JS2lCZDdIUFJSY01waklZUWpTZXhvQ1hUTkVjeUQwc0V0OXRHblRubU5wQjFLN1lzbXVlbGM0VFZvdG9LZW1ybzA4Nk9IaTcvLzFGajgxOGNGdDcrUlp2YWplZUdvcFhBMGJ3OWpJR0VoR3ZZbllOVEpCL292UXpGaUNvMytnd0twTEJLSjUzRFNoUWN1V05zN3pWLzkwei9HL25EeDBhbjF5MnJjWlRWbHNyNjBTSlNyRWZtR01JU2RrZTdJV0hob2VBeTlvMG14cDMzUWVvNWhhdXhERjdrL1d4eW4zK2ZMOVRBMGEya0RmdjlNK2ZmMkFjeFh2T3BQTDNjK0UzaGdkV1AydnZQT05NK2FpeWFwNUtudElOMHpKRHFmMlIxNTVEZlB4MzY3WXlDZzV5SkkyY0gwVk1KUlZ1bm0zbGdSRWh2dVpPRlFDWnVRaVFNVnJKOCtGdi8zbjI2TzM2MUU1bGZQUlo3QWMvaXI3Z3pOSmZseTV0T2R0TlZyTERSeStTbXI1V1U5dmFudW9kQlJUYjkrcXVpcDNkbXVSekhGL1BOejBGQTU1MWxRbGl4Wk10dWZORFlLUTVJcFZuT0tyWG42NHVTcXM0L3gzdEpRTFJlU3BGYUdMYTgyR0pUbEZwdmJjZVhZV0JJZEJISGI3aDd6aGMzdGdlMVB0SVphUnpPNS9yWGN0V3RpYnRGbjNwSzY5c0xYbVNjcTRVZ2twQjdHbHhjT3RWVm16MU9mSGFsanhGU0dFY09nNkg2eU9mak0wcVhXNG92T005ZnZ5N205UTZKamMwdmd6Ny9iRXJ0OVcyK3dvd0FzZHdvQXB3UnowanBkbU9KaDVyL3h2ZGYrZ3dsb0laaGlHakRIZ1p3QjVNbm5GQXFMT1lWdkhtZk82Mm95alc4NDFqbHZVWTJzQ3dka2FUUWdxOE5CcjlRU01tQTdNcGtZUTFmbmtORzB1OXZjVHVGb2VxWTkySnJJR2xvVmVlNmlOMnh3emx0Y0sydENBVmxXZUs0U0xKN2IyVE5zYkd2cE5iWSszeDdZK25ocmFOZHdXczAyOVJMUUNyL1BCVWh2QmthTFNabzZVNEwra0FFNkZ5MmREdGlaVmpIRkZwT0FCV2FmVEhoeWVZZWNKbWNxcDJuc1FvRGtMTnJvVGdMTm5RWE02Y3lzbkEzSVErVkRDeHRycXRXYjlMczNDOEVxUExldzFzYWJCQ0FtWFV2TWtIZkdMUDVvY2dOTzFlaVRWM2VLejg0MHg3dVQ5c3RaVW54ekJuTmZBWlZ6WkxaekJkV2JCY0RDNjNoVG1GeDNHdTJjUy9HYW5FVmI1VFNhS2FmUUxuY1dNK3BPczM4dVlNNVdOWC9RdXMvbVVpT0tXVUNkcnNPOThKakM2bkZSQU94MEFCcHpTRlhLT1dqcGJLWjNLbURtNGl1OWFZUmxUbm5hUTlGOU5oZXRuVHptUXM1Ukc2Y0MwWnVjTXB3aTg3U3Yycm12Sm5jbVRaVXphT1pNZmxMTzBBMG05eFhFQXdGMHFxSGgwOTEwS25BS3IyTk0wV2hUZ1RuZE9oMkl4ajY4QzJZQmRTWUxNeGVOOVdZZ1Z6UDFjKzR6a0FlVEZNMEU3RlRqTkNacnI1aUM3T3d2bVB2YUkzUXdRSjJKRGN0OU1MUDdEZUtoTXJsVEFWdG9NcjBwVE9aazlpcGVCakFQcHFiS0djQ2FEY2k1eEpiWXRXdlhJUWQwdHNrY0poT2o2WUNkUEFoSHpDV3B2NDlnaWpuNm83bUNlcUFnNzFkcytVcVozTG44RVRadmpzQ0phYnJkWmlJL0IwTkQ5NVVzN1EvUWM4bkp2dXdtZDZweGltSU80TW81QWpjYmlITmxzdnNES09iUThISS9nWjVUZ3YyVjhxRnpBWFUyZnl1bVNTVk9aMUwzVlN2RlBqYldiTnFLT1dSelp2dDh5TUE4MUtrL3pBS3NuS01HenVRcnhTRjQvdGw4NjF3MWVDNkppNE8rV0FlcEFjUU1pWVc1Z0NyM1V4TVBOYUQ3cTdtWTQrOEhIVnpySUd2bVRObzZGNkdRQjZpSjRpQUJ1TCthdXkrL0hSSk50UTZCZE04MHg2czhnUHp3cXduUWZRRklIdUM5WDFFZkNzeGhIb0Fad0pXejVGMW5BMDRlNUhmWTMyUGtRUkNpL1ZyK253QURBR0NrSUtocTluUFZBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8LzUwMDAucG5nXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFIUUFBQUJzQ0FZQUFBQzdINWJSQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5cHBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5pMWpNVE15SURjNUxqRTFPVEk0TkN3Z01qQXhOaTh3TkM4eE9TMHhNem94TXpvME1DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJREl3TVRVdU5TQW9UV0ZqYVc1MGIzTm9LU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8wUTBFelJqWXpOalF3TUVJeE1VVTJPRUkyUXpnelFqTXdPRU0yTXpJek9TSWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzBRMEV6UmpZek56UXdNRUl4TVVVMk9FSTJRemd6UWpNd09FTTJNekl6T1NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qQkNOVEF5UVVaR05EQXdRakV4UlRZNFFqWkRPRE5DTXpBNFF6WXpNak01SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pCQ05UQXlRakF3TkRBd1FqRXhSVFk0UWpaRE9ETkNNekE0UXpZek1qTTVJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNTZGR09nQUFRQVpKUkVGVWVOcnNmUW1jSFZXVi9uZXI2dTNkci9jdG5YMkZFSkpBQ0FtRVJRVkVRR1hSd1gzRGJkeHhSc1VaUjhjTjBKbHgvenVPNGpnNk9vcUt1S0F3QThvaXlMNkVoSVNzM1Vtbjk3MWZ2LzFWMWYxLzkxYTk3cGZtOVpLUU1Qci9wL09ydkwzZXJYdk8rYzUzemozblBpR2x4SW0vLzNmK2pCTlRjRUtnSi81T0NQVEUzd21CbnZnN0lkQVRmeWNFZWtLZ0ovNU9DUFRFM3dtQm52ZzdJZEFUZnljRSt2L2luelhYTndZQ2dXUDV2ZUlJM252TWtzMkZRdUdFUUY4Z0FZb1pCQ2lPbFlDZnAxTCtSU2loOVFJTFVqeVBpWk5UWHBmL1B5amhuNHVGaWpsTWpEaENUWjg2Z2NkTHNIL0pTbmhjQkNwbXVTOW1lWjhzYzErV21hQnk5LzkvVmNMakpsQXhpeURGTElLZFNaQnloc2w1dmtMOVMxWEM0eXJRNlM1NnBtTXVrMVB1S0RkUlJ6dEpmNmxLZU9RQ1BVT1VqTnNxLzlhRnR0MWNDYXhnUUx2WUJlb3RnVVkrWFdlYW1NOGpZZ1ZRU1hJWk13VXFwRUJRU2gzN2h1UU04R1hiS0RnT2JOZUZ6ZmRucEt1UEViNDB3T2M2OGk2NmVaSStQdDZmQVBaMVdGYi9YQ2RKalRjT0xQZkgyOER4TnZBRDljWHhCdnp4R2dZcU1EbmVJTThxcGh1ejdhREFNZHZTRzI5YWpaZmpIUFhIZTlBZmIvL1JqUGNGczlCNXR2MktKVEc4bzNVSnpzOG1VWlZJQTdYMVFEZ01jR0xVUmNKVk14SHdkTUV3dmFHclc3ZkUxcWFxc1hxZ1Bzc0pnc09ERStJZGZENWllTThOandQNURGQVYwWm1Sa1dWWisrRTlDZHpLVS8rWWs1VXBOMGxUeHp2dWp6ZWt4c3Z4T2NYeFdpcTg0VXp6WkdLdTQ3VW54K3p5MXVHSlpNbDRoNDVpdkVjTmt6TVZpWlZhNk5PK2hiYmE5bG0weUJ2T1B3TXZxb3B5MEJWQUtzdEpDUEorMkxzWTRlZWZIT2tMeFo4STlieFZuQ0RoQ1VwZG9WRGZvOTdEc2FqaHFJY21UVWVkUmswUUxadjNhU3A4d2xDdkdaNEFSb2Y1bU9lUDhYR0E1M3A0RHpvZTY4ZjFBNWIxbmVLNHB4dHZNRVRsQzNsalVFSlRRMUpqVjk5WEhLOTZYaWxuOGMvMXIwMldHYTlCQ0JMK2VEMjdtMzI4RDNHOGozdmp2V2s2b1I1cEhIcEVBcTIxN1d2WE40Vy9jczFyb3BDY0RUdlNpbmpjUUUxdEFJV2NpMnhHWVkrTGZNR0ZvdzRFT0FrQytieURiSlk0U3V6SlpJbWxCZDR2ZUJkZXlLdkhCVTZVNEJ5b0diWDFaRWpPWGlHYlE0N256V1ZzcE5OWjNwYzhGeTJoNEUyUW1tdWxNTVg3QWROVG9td0JCWjZPNzBhQWx4QUtXUDUxVUJycWtyUThwSmY1MUVvbGxLS1pFSmFCUU5oRUlHVFNjaTNFS2dLMFZqNFg0RWtpQVNwREFKSlN0L09UNDVVY3J4WXNCK0U2ZVo1S1NkcEJQcHVHNUZ4b0pSQ2UxU3YwNG1WZ2xHQmN6OGZyNkp4MjBISDg2SEg4ZHhYd3hqMldOZlNDQ0ZSWnlnRnErWXRPcXYrN0Q3MWpNMzcydTEzSUlJWmxLK0xJcG5KNndBVmVaSXIzODVrQ0o3MmdoV1lGMUxsZFhpUXZuT0oxMUdRUW0yeDFvWng1TlNrT3IxZzZ4UW55OUhSd2xKT1RkdEJZSldFVGtBWTRBWFVLemhWa0djVUw5YUE4RlBJbXEraml4VFNlZWVwbHFzZGFPV3dmM2gzditidzZyeElBNytmeUhyeW5rNFRzZW1XdEFtT09DWWRvVkY5cmFzdnpNRmdwb0tNRnF5eFNXYmpRd3ZhK1J3MUpXYm9hby9DUnFrdUpqc0s5NGErQW5WM0EzOStHUS9UdEw5bG5XZnVPcTBCTlQ1ZzNibHhVOS9FZjMveGVmUHZyUDhidWcvdlJHQU15cWNuSjFIN0g4S0ZLZVA1b2d1b0pIOUtrT0l6K3FjblRCaUs5Mnc1ZTJGQzN4UHFUNkcraTNpU1BVSmhCQ3JLeTBqdWY4bmRGUDF1MFRuVUpSVDluV1pPKzdqbUNMRUsvbUJTK0dyTmhUSjVId2F4NlRHUFY4R2tyd2Vjb1hQcGNsN2Mxdkc0YU1MWWZCTVk1cnRWTGhYWTFHblo5aUxVc3FZVnRsRHduaXZQaXc3b1NjRCt2YmJnVHVQNHE0TFpIZ00vK0QwWnBxYWZ1dHF6TzR5TFFUUnhsTC9EbXhsam9CM2YrOFhwODk2cy94Zi9jOGhqT1BjL3pRNjd2ZDlRa1NtRnhVazFOQ0F1MGFUdXYvSXZKNTRTK0VwTXpwWHhQb1VDclU1WktDOVdXUVVua2N3NzJkS1d3WVpHTjg4OGtKSTBScHFVRmkvRFgxR3lScUFodHdRWm5SOTBxUzdING5CVUk2WW5VUHMvMWhLVWh0R2dXMHJzcmk3N1lkMitPd214bFFmQTB6Ykh6K3MzS2x4ZHlXZTBDWlBHejBwdDhwWHg5Zzd5bFlEbnBXRjRMSEJvQWZ2QkhnWEJWRVBHb3hjOTdKcWw0Z21WNjlGaFJkV1d0cnBUNm1vc0RLdGplZUhhUjc1Ni9BUGpoUnlLNDhlWTgvdlVoNTlsVzRKU25sVlljYTRHdUZtSnpwRHI2MEU5Lyt5VXMzM0lXZm5UOWx5RTBNU0NJMm1uS3lkQmFGN0JjUktKaFdpa24zM0RJRUQwL1l4aWVEeWx3Rmh6U1BJY1hWTkNReTBQNUhONGVPRGlHLy9oMUc5NzU4dVU0NzNRSEQrNXgwTHh5TlJhMlVxZ0ZFOW1jUWQ5TUg1ck0wNGZhMnVmbTZDU0Y5bGFFUHdWM2hIRDFuS3Y4Ymw3ZHoxTW9oSGo2YjR1bW9oNDdoYXdldC9ybk9nVTlzYTVVWTdENVdwN244dWFoa00zcXg3WXphZDFGYUk5RVBPRWVwSmFQa2VCY3VZNStjRG53ejdmeHRhWnF2T0xjUnBpRUcwTWhoU0U4SDgzcmxDb080eGpWbUpTQ3ErY1VwMUN1UjZHV2tzRXJ0MFN3b0Y3Z3VtLzA0NDVuc3ovcHNxelhIL1BrUEkzd2lsTWJnbWdNM29yK2UzNkFTODROb1licUtWeGVjSFpjYTdTMGN5aGt4am5aRkJKcFNEcVZRU2JOQ1JRS3FpUTRsekFWS2VKOWwyTVR0aHFseDMzYU80Q2JicGY0OUh2UHhTa24xZU1mYm53STlRMFJOSGZ2eG4ySkRDZlNvY0k0ZWdMeU9mcm1uSzAvbUNPeENvV1ZCYmdhTW91aFVkRUVOZW54eVlqMHd3OEZrOEpuc0tWUXJMMUF5TE5jL1ZySS85d2tXWjM0VTdDY29VOXZyaWIwMHVIZHVvTnhiUXV2NFYzQWUyNGF4WC9kUG9ZUFgwRUNaWGwrT0V4Q0ZRNTR6Q3pLMnlDdDFqUURGRG9WallNS0VHbHMxOFJZa29ReXlUa2t5a1VDQ2psdzhYRUpXellLRVNIS2ZQKzhGYmo2SHo1S21DWGM3TnJyK3k0ZU9mb1VKVERPTlpKSmoxeVEzQ0tUOXlaQ3dYR3VJUFJFcWZ1T2YwdEYxZWQ2ckVQaXh2ZGZpRGRkY3k2dWZlYy9vYTRsaGFqaHNWakZDTFV2ODYzRENwVDRQQjltSFIrMmlwRHJ5c01GVUNRK0VwT2twOGh5RFdQU2x4YUpsZzR4TEQ4OG1aSVBFcVUrMllkekZYcy85aGp3OFpjQjh3bkI3LzQyME1NeHJWc2l0SldHT09ZSUNSVGxpRmhJZ2g0RU1WNVgyQmU0K3I1S3ZyNkdrS3VVNE1aYmdOdmI4SFF6Y05WV3kybzc1cEJMZ1VMTkF6MzByZGVjanlzLyt5bmdZNThFZnZ1Z2lmbVZpZ1hTLzltRVBVZjV0RHhra1JLTElnY1JFeFB1K2xyditnUmhnQmI3M2lzMzRSKy8ramE4NGFLUElKZEk0cFJUcUJnWmI5TFVkVWlVQlAzU20xYUhKbWNycGlLVlQ3VTBoRnFNVjlSYXAwbDRWYkN1Mys5SURXVzJQU2xROVpyeTN5NlBBalV2bi9kOG0ySUQ2dnlHNGZrLzA1RDZlZlYrbjhST1FIQ1JnT1g5ZWU1SkFFMFV5ZzgvR3RSSytxNXY1akhxS3RTWW1BUXZudVo0SFR1SWFJanNuK2RYY2V1aE1lQkRMN2J4emdzNXI5L25KTy9GdmJWQ3ZIUy9hZHJGdVBTWVFxNmVVQjVOMUpqL3ZBK1BuWEVienZqcmE0QUhIMVZXWnFHaWtoZnVHaHJUd2tIUEFxVXNzbHFoU1ZPUk9PbWczWDg4bXBCNHhmbGI4T2xmZkJjajdidXg3dHlMVUV1b3RXMWxlbDRzWndXQ25GZ1hVV0pWbVBGS2hLb2VVdkZnVUZtOFM5aHllWi9qVXg5aGJDUGNMTi92MFVndm5uVjFQS2pPSmYzNzZsYUZVd3JDbFQvVFBvMzNIZHNMcVhSY2FTc1l0N1RQVTZHWTh0czVma2I3NzRMVTc4c1M4dE1xMkMxNGtEK1NkckVuRWNFRnB3VngzUnZHOGVrZkRXbW9WY2tMTlQ1MTJMYWxoMlFSRGd5T3MyOEVPSHRCQWE4L0YvamNUNEZiS013eHk3cGc1SGxtamVZY2gvS0xha01DQjM3NVBWVGVkei93NWU4RnNLVEY4TmdxWTdOUUtLdXpPVTRSQWpWbjk0U3JoS2swV3NNdFlYbzhaZUMvZm5BSlRuL0pDdlRzRzBKanZha0pqYUIvZExMRG1wSXFSdXRreDBpbWt2cjdOWVNUWE1sOHlsTTJWd1h6SG1OMGlkR2FxYnFUdmxQNFdSeXRRVVdZOEVNa3lHSVk0V1VZUkFtalZSY2dERk1uUkNaZWcvOTUramhGeEJSckZYNktpS3FueDk0L2JLTXlRcnlnaE4vejFURzBKVnhlbC9CZ1hJZG9RVzJaS2h4SzVZU211ZDkrbDRNL2JBVStmdzkyU3RNOExTRTB3emdzc1g5Y00wWDF0bjNwUzAvQzcyNzRESER0eHdVNmU0T29aZkNmSXh1TlJCU0xsTDRsZXRhcHI4VFAzaWgvVzlCeEk5a3IvZTJxZVM0KyttNGdXc0ZZakRLTVYzb3BNaTE0NVl0OTM2ZXVKNVh5d3c0K2tjbDVRbE1UVll4RmkzNnhxTnZxZGZVYVpFbWl3UzN4b1ZQV1JOVGRvSi9tazc1U1JFTmVMS3ErMHlNMG5xVUZpLzdXei91cWEwclRUZFJWZWh6aWhsdnBWM3RJbXFvRWdtSHZtaVNWbzVBbndwRGtLWUYzRDdqNDVKVUZ4UGo1ZDkyTXNaZ1FwM1NZWmgrbWhPL0hYYURxL1RXMi9SOWZmUS9lVXQ5STNQK01oWVVMdk5BaUVzN1JMN2c2RUZmYTdmakpBaEgwL0thNmNJWjRPcFJnaUltQklZa3RpeVErOTBsUGFOLy9vWHJPSTBGNWFuQ1cvam1YdDNTNlQ0VTV4WGl5S0NqNDZic0pBbFBDWGlRbUxiWHNpbk9abWdTemhDUVZFeFNHbUJRMlpFRG5mdU5oVzRjNEtwMllTQXVzVytEaVRlZlQ5MVBwUHYwejRINkdOUE9xVmJyUVN5NW9vZWNJNFZUNmlvaURyZ0dCUzlmbWNma1p3UHUrUytTenhZdTZUZk5oVEhxa3c1WUlqM3RORWJYcGZWLzZkM25sOTcrQytJWG5PWGpnVVlHNkJvOTZLZ0lqZk10UklZb2ZyOE9NRkJGTEtCZXBNMHlWY1lFL0hnQys5VzBKUmJaVWh1WjMyMHdzSVJVVUtwYlQxaDdneE5tSWhKeUpLeXpXZVltcHpMTlVQdVlraTVVK0E1NFE3QXpWUDdJRWp0MWlNcDRQMGxUWURDMU1wR3gwVXJBR3g1ZXpEZlJsSEx4OHZhc3Q5ek0vQng2Z01KdHI2U01WaXlXcFVDNUVCZTdTWDVRWVNRa3NxTEZ4K1NhNkxGcHl0eTArTVdLYVQ1UlpIMzdobHM4NlRUT1R5dHVmK3ErYjhkV3JyNUI0OUdrRzhnVkRoeGFtWjhRSUJyMGt0Sm9NQlpmNWNhQzZ5VUtlRXpETyt4dk9hVVI4ZmxRNzFWLy9vZ05yYm5IeGtROENPM2U1aEhHTHZrZEJyUEJXYm9SM2JsbXluQzFLSkNwOGF5d1ZxbDRsQ2ZqV2FwY3NmMkZTdUllZHExVE9Vd1N1ckRTVFZ3dWtEb1dpaUJQOUlrM3ZRSytMOTUxajQ4ck50RFNHSzNkMzBYcERCdkxTQzdNcTYrcVJIT3llVUs0c2tVa3ROTHpsWlJKL2VBcTRweHQvR3JmTWZ5dXpnUDY4MWttUHF0QjZ4TEwrejQvdlIxK0N3cm5xRWtuSXJmRFdRVG1KS1Q3WDFRR3NQMmN4cnJuaDFiams2cVU0K1pRS3ZQS3RtM0hlcFV0d3hubDFXTG01QlJXMXlxSkQySERlY256NUp0Si9lcEIzdjFXRlFiYUdaUy9IcWpQRGszblM0bktVNmNXbHlsclZzbDNRWDRNOTdMQzhXeTFjdzN0Y3pOUHF3eitIR3ZQRWU0M0REL1djdHhRb2RDcFBEVVI5Wnk4WjR2b0ZOdDV6S1dOSHd1enZPMDBzYkRXdzl0d0kwY3BiVFFuRjV1bmt2dUdIY2YzREVsZHNkUFMxZlBkQllaUHR2bmVhNm8wWHpFSVArMUlxK2hkdStpRytjdDBIWGV6dHI4Tklid3FaWkJKTFRtcEZzS1lTTDcycUVXNzFPRUlYWG9obEc3Y2pteXFnZWVVcENEZnVRcDRzeUU1RjZSdEpET0pCMUsxcndBMWZITUMzdmdhOGFMT0RQejVzWUFFbnFHQjdqck4wVFhKQ0UzMGhpUktWZE8xSjRsTk00aXVXYXBlc2V1aTFUeFViV3A0d2hRK3RldFhPZmU1M0ZHeERLNVZoMlBxODQxbUJpRkhBSjYrV3VJMmU3eVlDNWtXdmFFQThQb2h3ODFLc1hOMktBYzVGUlRTSVJKZWdnaXNsWlV5L3ZJQXpWd0pmSWRTUzE5MDRZaGhEWmF4VFBOOHFocU95ME5YcnBCQUx6Vy85b1EwRHY3aU5rekhjanVxTnIwTHRnZ1g0OERjdXhqVi9leFppTldmVFZIT1F3d21Tb1Nwa1J0SndSMUlRNHlieTJSaHNxNUhNYjVTeG9Jdlc1ZlB3eEZBUXQveVNyTyt0WkpWaFIyZDRsTjhwTGoxTlBYUTFnZUZabVVVckRVVW1MVTBkUmN0VnpET1o4Q3hid2IwU2lvb1AxVUszZXQwS1lXSmxaT3AzcUhOTDZRMUM1Y3BWTG5oa3pNYTFMM2NaZWpCKy9BMko0NllhV05Fd0hHTWhIQkllaENxeGFDbXdjTTA4dlBLYU42S3lmajZHZU0yMVVSZjNQVU1HUElLTzhiRDVRMy91alJucXJIQTBsbnZFQXQxOG5oVHhLaGlCUWVmQ3RWVUluckl1aGkyWG40ek5HMXJ3bG85ZlEyMWZDbWQ4TVdkeVBvektaVEJURDhCd2w4QU9OaUNiNlNhY1Z2UEk2NWpTdGVOd0EwMXdDcU00K2ZUNStQcjN2Q3FDcXk5MzBUdm9hS0VJMDF0cDBjS3lEb2RFMTU2MHhrRFlFMnB4elRGQldEeDBpTlpBSC83K1Q2M0hQOTl4RlY1emRSVU90UU5qWTlCRVJaL2ZXNDgrSEdvdEg0N055VEJIOFlLdVFZbEwxanM0NXhUZ3V2OWthTElzanVvR2srYTBoUEgyWXJMNURKekJlK0dRMWRwakdVWnNqK09DRjNmaTZxc0syRFBtNWJHdlBRYzFEWTd6MFZnRnpHa0swVjc0bXFLT0I1dzNMS3pBOS83Ky9VRGo0aEJhWG40cFF3MlZrbnNUeG50dVJuN2tqOGdGMWlHWGJFUE9iQ0xqN1lXWkdhTmdXdUJhVVU3QWlFNGd1S0VsT2lIZ3VCV3dJaW1ZOHkxODdaczJydnN3U2NZRERpZmVSRFFHbmQ1VDZUajR2azhKWUl5QWxTZnhpdGNDRlhWZWVZZUNUTVU0VmZMaW5KZldJTnJjaURXbnhyRHBsU2FGc3d4di8veEdTdWFiT0RTVVJ0dTJZU1RURktyaHhieEt1RXFJQ29yRHNVcmswMm1kWmRES3d2TU9KZ3kweEF0NDMyWEExNGdrN1RLSVRjc1p3bGpMZUEwRGhOVWtCSU5YSXpORWk4M0RURHlCUUNhUDJ1V2JzUENjTkdMUjdlaDZGcmhzQXlybjErS2RYN3ZET2EzTEZlOUxHc2ErTWhXSEx4emtIcmpYZWN2OEdMNzNiOWNUd2hoUTkrWlBwUmxVRVZvSm9VTy9JYXMwNFlTVkVMZkNTZEVpeFVJVU9FdjViRHNGcnBheGFKbUNFb2l0WlJoVFRTdEw4dWpqK3pOWWVQSTgvT3BKZ1QyOHhMZTlUbUowM05Ycm5zR3c5S3pHOHF4UUpSK1dyYTdGaTE1MWltYVJuWHovaTE2NUVpOTU5VElkNUYvK3hqVzQ5cWJMOFpaUG5Zd05sNjJDM1VabXVwdDRhNjNHNnorN0RCLzkybXA4K084WDZHcUlIckpUbGJiTVVEbU1nSGYrMXFYTHFUaU9aNlVxamlTekhSKzM4ZkdyWER6RjcvcitWbURkYVZVbzBHM2tuVkVxY3cvanpBR0dhUm02a2xiZTl1dDBwQXd1b0xYV3dPNnB4L3F6TitHSzk2N0Y3VHVBRmlycGw5K0VNOVpYdTNmRkhlZWlZMm1oUnlUUVJ0dStodEhHdjMvblJpK05kOXZkZFdnOWVRWHg3VDZJUUFRaThRdVliaEJXZkIyc1pEc1o0Y2tJeEZiQnloMmduMk1zSXNjZzgyMXdzM3Q0d1NOZStpZXdpRWNyZlpWRks3UXhmMGtNWDJVWXNIa0RzT1dNRUFhSHBQWjV5azhxWDdoM0YyTzlSVlg0aDU5Y2c3Lzk5bXZ3eVgrNUVCKzZiaFhlLzZVcmNNM256c2Zudm4wbVh2T081VVNFVWNqOVE1Q0hPTkRhdjRKUjFRbDc0QnR3OW5kQkRDN0ErcXUvaVE5OVlqM2UvdTRBYnZpdmRYajdCK002bTlYWktSaGlyZE1aS0YxaTRob01wUnk4Zm91RHBTM0FEWXczVjV6Y0FsT2xrbFRlMmM0U3B2bllXa1EvWEVFbG5lK3RHVnZ6YUdZdWJGcXFrZXVGQ0o5Szk5cU1sbFhBblhzSjEzUVJYM3dENGhjc2tEZFgyL2E3WDlDcVAzVmRQY0RiT1kvZi9kY3ZrTFJRYXovekwvUk5YN3dDSjU4WlFtR2dBcm1NeVdEYlJpYm5JSjJTblB3a2tua1RpV3dLaVo0bmtNQUdNcjUycE5PQ1ZqU0NuRmhINXR2RDJMU2JsMDJMdFJvZ0M1MVFadlBRM1gyNDhlMFNxMWVHOE9YdkwwS0Z0UWRwR3RqYWMxYWlhdEZpYkRncmdsUFBJOXdkQ0VFc3Z4b0I2dzZZZXp2Z1ZMOEttY29IWUk3MUlUSmtJaGxjUVRUWVQ0VUtJMXAvS2xMRDkxQUlyWWdFVEJqeHBiQ2RuNURGZG5LeVh3RlI5MnEwUDBvWGtYWjV2Z0srL09IUDY5V2swV1FBUzZvY2ZQcU5MajVMS3ZQYkRndG52SGdsNVZ3UE8zZElMd3BZVk9aUW1JVENhVU8wY2pHaVpMaXhVQjZWVVFlaG9FUjF6RVhJSEVGTnpVSlV0aWF3N1lFK1BIN0xLTjU3aVZjWitNMDdnSi92d05jWkRuNTBTc1pJcGY3a01iVlE5WVorNEhXTlFYejNpNThnZTFzQS9IRmJNOTc4NGZNNHFZM0FNUEhEb1VEb1UyU3dDbTdxRVRneUFqdFNTVisybGVUZ0FOem9xVENkUGxoR0V5MlI5TjlvcGg5TVVvQmtDZ2JoV3NGdW5wYmo1bUNGNjdCc2NSaGYvdzd3MU5ZY0ZpMXF4Wk5kRGFpZXZ3alhmZmZWK090UExjU0dMZWZCNkZ1b1VoaHcrZzRnMnhWRTNvaVRnTzFCZUtnV2hlNGgySlZYMHFkVk1URGVTNkpBZUlRSDc1R3FMUkNoR0hKRFQ1SXdyU0xVL3hWa1R3RkdzaFlyVi93QjZ6YUZzZnJGbCtQdi92V2ZFYWpZZ0tHeENLb2pMbTUvRkJvdVY2MXQ1bWZHQ2FWZEpIczVXbUlOcjBVdElnekJzVnJnT0x5MVIvbWVBYjB3RVl3MkVaSUhFR0lBNjBwQ1FHWVpObStwaEp3bjhOUDd2UFhTRHpHZWZldDZmTERKdHYvanVFS3VlcEZjNHlVVkJuNTgvZDh4bUQ2TkFSUXQ5T0JJSzg1L0c2RTJYdzlaSDRNYjJ3bzNQZ0k3UUw4WkNjQ0pFZTRza29TcStZU21jY2FsQzJGRSticG9vM25YY0tJYnlUSkhZWVNvQktUNVJtQllyWkJDbW9Rd1BwY1l6K0Y4UmoyTFZ0Vmk4Y29jYnZqRzUvQktYakVFTGZpWmd5UWVLeEZzZmhlRGR4dkIvcHY1WFJjalhiRWE2YkhiT2VaVkNJY1oxTHQ5aERvcWpic1lvdUVpMklUNWlFa215aXRLSlo3bEpHZkl3cS9oaEsvbCt4TUk5TjRBbzVzVTJPYjNETnhGcTd3SjczclRFN2oyZlNuc0doTVlHZ1crd1pESzdob2x5Z3hTTWVrbmpieW12d2JTVkZJNjVGZ0RrU2JMNyt5R3JGekllU0dEZDdyNVhCNjJXZUR6aDRoa2ZCeWRoL2Q4WkRtMjhTUC9lWmZudmo1d0NmREd0WGg5ZzIzLzRMaEI3dWxDTEtFTjdmN0VHeEM0K09Va1FMM0FIKzcyMG5xbmIxSExRQlhJNWx3VVhGVWdWU0RrQnBBcFdOVFFCSWxMbFBBYkpyeG1rQ1ZSeWpscEVnK2JiTENCRXhGQ0tqMUdDeVl6SnBkMzh5bXZ0cFlzcEw4emo5ZHNkdkU2WG1ETnFlZWkrY1ZYd0NpUXlzb1dXckNobDIxa2RvQSttNWFlZVJ6STlrTEd6dVIzOXNGTzk4T09MVWN3ZnkvY01jWXJGUnY1K0ZRRU9ma0N0Q3lTbkh6UEY4aGE1eU5ZVDc4cVZHS1pzVTMxWXNpREg0T00wbHJyTDRMVDlVVmVUeFJpWGpWUVdjRHQzM2dZdC84RStPamwzZ0xEcCtoSG4wMGJqREZET3JQaFpyTUloU3hDTHo5RGExVnJvWldWVVlUSTRveENBdEVBZVlEd1ZtMGlxaytFd0JFbnNEMnpYU0pDZ25maE9tOEJvSmJQL2RQdmdMdmE4S1ZESHZ3ZU1lVE9LTkFXSVo1NDk1VXJUci91aHBQUnRiZWYvaVdGNmpqOTVOZ291anNMMVBSUlVuOWJyNGVxeGVKTVZ1aVNGTVZDRld0VUsvZ1oyOHRqWmltd2JFWXRqRWY0WEVablR3bzVvV3VQOUhKbFhxWC9IRng5Rm1POER3S1BQbFdKdFJlZGhlYlRsa01rVjhGc2VoZmgrdzl3ZXI0UFdYRVNQN0Nmc2NRekVQV3YxdEJxOVB5Q1FsN0xRYjhTVG5vNzNLRUhTTGJxNFRhK2xQNUwrWGtHdWM0d0RZZ29FRDRKYnNVQ3VNTS8wQXZhTXJLYXJtSUhVV1E5TFk4a0o5MURIL3RpRGMzUzdrVzIveTcwVW9EUDNOV04rZlRsaTBtT3ZuQXI4THQ5QXJXTmhxNUNORjBKaTNNWkNocUlxRUp0bzZETFRXS1JLR0tNalNwSm9tSmhFNVdrMUZGS0wwSWthbTJOSVZZUlJNWUpra0NHc0hSNUhlNit0eE1mdlA0QnA4T3lBa2NqMEJualVNcGoxWW96WDRMSVNaL0dnc2J0dW9MQWlOTVhrUWdzY0ZUVldwS2tJcTJyQVBLcE1lUkpRMVUxVzRieFY1SXh6ZmpJSUViSEVraW04b1NwZ2hib2VES0RCR084Zk5iVjhWODJuME0ybmNmVER4L0Nxelk1dVA1VHdBL29TZHFTemJqNDQwc2hSam5KMVp0Z2o1S1JaS2dWOVZmeTloY01rM2JUTXJkQUJnamY5azZxNWw1cVo2Vm0yZ0ZwSUxEd1dvNHpBNHRzV3BMQThFTms0KzNJdGJ3YmN2U25rQ1B0dE1JbXhpbk5FRlJHMmZBZXVPTi9wSENxNlJmVmN0QXlZT1FYeE5nb0VmSk5XTFp3UG5yYlA0UWZmaE40ejR0cHBhOEI1dDBoOFovYmdsaXhjUUZpbFVHR1B3RkVJeEhFWWp3bzFGZ3NpSXJLTUNvaUZpb3JLRmhLT0tZRUcvRXFNSUs4SDZLd3pXeUJjWFFTNW9vR0ROMDFwa1k2ZE5TSmhTVkxsa3o3SWdGbDE2Rzk3UnNnbjRiSWo5QWl4L0dubi93S0NWcFd3SytXMHFVbXF1eEQxK1VLdlhhWjU1RmgxSjkzOG5xdE5NY2puYVltY3VCcFZRbVlVKzBScGw5eUtiRnI2eUZjZFVZZW43b09lUHd4V3VmdU9sejlvUTBNQ1RpQ0pKa3A0MUF4ZkN0RS9KMk1PMVhCa2NIYjVaeDB2aWZLeDUxMFJOVnZwV0Qzd2NrY3BOVVB3KzNjQ25QQloyQldYUW8zdWRVci93c3ZRRER6TUFsYUFLS0c0WjhSMUhWSHp1QlB2V3VSQmNKK296SXJGRWJ1Um03Z0NWUTBYMGtvNzBSZ2Z3Zk9QTDBCNDI4ZXdDMi9BbDY3RWJqbXBRemxxakw0OHAxdHFEMjVGVlhFektEbEVENnpKRHNXQld6eXZrQTRaQkFsaEs1WUNGbUdybFlNcURwamVPdkhTK2RYWVAxYWhqbmRDUnpZeFhoZFV4ZnZieWI1SExHRmtvQWQ3Rzd2M29EQkhnN0F3TDU5Qi9IdHovNGJZbkcvcjhTdnRDdldFbm1MMm9SUlZZbXUxa1g5OTlERjBKS0ZmcXkrMGZFckVWUjViSHJjeGRVa1FKLzRHSDAwZy93dmZKSGgwTmZQdzBWdjRKZTA4eE5SMHVyQmg0R3FDL2lCMy9PRGRFQXVMYXRwSG9WOU41VXBUb2FaSmV6ejFnN0Q0QmNHWWt0NDd2OG01dStIYTVHNDVYY2pPTzk2dUNSRHVld2ZxWHpkTUhQUElwRHZoRkY5QlgzekNLekU0NUR4YytHa2RzRVNhYjdISkp4ZlJpVVpRWGFJU2xDemdmSS9EWmU5b1ExZDNYMjQ2WGZqK01CVndNc1lMOWRXMlBTckIzRW9Ta1VQZWhWL2ZyR0dWM1lpSm11TERQOTVYYnhpZUt0TTUyNXF4UGtiV3pEVzE0OERqSjNEWHV2aE1VdjlpUktCN3U5bzYwV3F1eGZSNmdvNHhNeEZTeTNNbjJmclhHaXhHczcxVytwVWVhWTYxT3BHM2kvWHpPWThmNXIzMndyVStydDZYcVh0RG5XNHVJeUU0RzgrUU1FbWdJZDJOT0VqWDFxSjh5NnU1SXZxWkdFZDF1aFJXanhSNzMzMG4yK0VXODF3SS9WalRuNC9uT1Fpb09HdEVPa0hPQkhOdE1nV1pBYnVwQURlUmhhN0RvV3ViL0FjRlNnTTNRTXp2cGt4NGttMHVEM0lNZHh3Um45Sm1HNkNXVWN5bExvWFJtb2M5ampEcTBnSVZtd1pCUk5FOHRDdHFHbytHNFZNRCtHZHFKQmNnTXN2NjhaMTl3cmM5cERFRlNTSHB4R2QvK20xd0tkL0taSG1XS3VxaGRjZlkzZ05WT3BXa1o2QWZ5aEJtbjQ5c1dyeFdFUUxkUm1iRDNhTm9lUGdxQkpvV3p3ZVA2cjJmV09tQkRFQmIyOS85d2c2MnhsODJ5a0VrRU1xSmRIRjZHRmt5RHZHU1lPVDQxNEJzckpFWFRicCtLc2gwbHZGME91V2ZzTGI4dnRHK3JwZG5NdUp1TzV2dmZ6c3R4aDNQdjVzTTg1NzJ5bUVUd3B4QWNPSEZTT2toQTlDdG1iaFZENEt1eW1NZkcwbkNzR0hZTmVlRHJsb01lWGRSdXM3R1ZHK3g0dy9qblNJbjFsK09ZSU5MY2lMSFRDckM3QmJ0eUJjY1J0ZHdVM0lKcitLd0pKTEVHdHFJandTdWlzNzRiYXNnZDFRaDRLNUc2S0pjTHY2WFNSVEN5QXF4c2xrT2IyQk1RVENQUWlwT1daWTBuVE9wYmorcTFXNDR3Qnd5LzJjQTVLTk5VdTh4aU56V0NJekxnOWJ2eTNlTCsycEtTN1BLV25WVjFwazRrbDBIT2hIZjdLZ1hkMDBYZkJ6c2xBeG5aV0doTmc5UUhNNnRMY1RxOWJVd0NBSnlzdDZ0UFdUcHBNZ3FWNE9SNWNWU0grTjFOVjFyN3FqelBEcmNlRVhXZ3V2dGtpVi9nOFBPRmhNNFg3MEExNUN2YS9YVzhvU0kwL2pyaHYzSXg5dWdKMVIvc1hVWlN1VytaU3U2Y25UWWdMR3I2bmxPWjV2UGx5YjJwUlhzL1ZaanFXSDRWQ0NFOVRQaVRvRkMwNCtFNGYyM1VkTHBxWlZFSHBIVkl2RERxMmx3Y3BmSXovYWh1eFlIcFUxOUxtUm01QWMvQk1rQ1dVczFzTzQrWWRrOHJUaTBYNnZlVG03UTF1Y0tQeEdGMHRYMWtiaDV0Sll5V2hxa040dW13UTZlTHVZZXZqUkZ3R2Z2MU5CbHRBcFM4TnYrUEpnMSt0M0tSWlpLOEVtZUFsVllZWmcrVEhzM3orczI5VHB4WjhKQkFJaUVvbTQwNkNubkF2a1BtY3RUbGpXem5TaGtObS91eXR5WWFJVk5yOTkzWWFGV0x5K0JibWtRLzhsZGIxcVBwZlhkYXlxTURtWnpHcUdteXQ0ZmFJNXhvMDV4akVGUjJxeU5IaG9IQlVpaDcvL1pCek5peDEwZFdSMGI4UnJYOHR6amFzbHJ5UXlpU1JTU1ErYTlhSzA1VmY0T2Y1cWk0THo5SkJYVU8wM0RWc3hyMlRVSHU5bEtHQmhjTzllSkhvNndEQVF3U3EvbFlHVFo4YlUrLytrODYxcXBiay95MEMvMEswVDg4RW9rY1owWU9RZjBPdWs4S3NZVkZXN3NtWTFXYUZRU0N0SHVLSUs3M2laNmhrTklrM3lGalNEeUlYRHVHeHpKUjVOdE9GWFQvYWlwZG5VL2FTZWNrdGQvYWZLUDIwZkdsWGhYSWdhVXhrZzB4OGFSTnVCaE5jN1pWbFB6N0wzeExTQ3RXYmFPR0swdFhWVUhqaXdlOS9lM3ZXRmtXSEdUeEtwd1c3c2VuQWZvbUd2MFZHeHhFSStyK3R6bGZXcGJqSkxPVkhISXdlNnk0c1liUGluN2h2SzQ4emxpM0RCUjc1QnY1WkZ4UnFHRlNyQnJhdzlONHJGdXE2eVFDSXo1aFdEcXZOVDByS1ExUFd5S3JtZ2VXSWhReXRKZUtnZ2JGMGtiZEtpQTZxa01GU0xUSzRMbHR1Q2dFdEhRUVZTeGRraFRyeWVVRldMYWFraUxvNlZyeHU2aTV1dlVhSzJxZzJtcGdpK3JvcTlWUkcyR1loU1dRSWVhUWlxNUFFRlEvTVRaa0FyZGR3dk5UUXNDNUdhQ0JIaCt4eHJOK3FyNVlUUHRIeGY2dmxQcVFsU2hvUWl4dXVwQzZiUmRjakdQaW8zdjJWblgxMWR2MkVZNWJiRUtWZmlKcWVEM0xLMy9JS242YWpYajNTUElTb1pvTk1DdTN0SE9GaWY1YnFZYkJlWTZHRVJFejBzU3JZRnYwNVczWVlEQXFsMERvVmhNc0p3bkorUDZLNDFRM1h6eW9CWDRhNDBRU25MUkhkUndYTWl1c1NvdU5tQm8rTmdtNzVkZFUvcm5pT0xVOHZ2emhYR0VPSHpRVE9LZ0FnalIyaTJuUXlDaHZkWTlaYm5uSEd2V1lQdlY4K1pSckhCMWN1TGE0V3hDMzR0cGUwVmdxdEM4b0pYZFNZWmg2dTFYQk9ld2lwVVVxV2RJd21KOXIzMHQzNS9xV0wrZXI4R0gwbWtId0dvOHM0UklrWnJ0WVBHeUJpZWJuUFJPVWhkSURjc1VER2tsT1YyVEJHeldhdUY4dHZRVEx5eFFvaXRIVjJwdCt6cmZGS3Zmc1FaZHcwdzdvN0UvSVpkZDFLd1JTSWtWSGUycXI4dDFrTVc5eDF3dkthZDBZRlI5T3pkallYTFczUjJwWDNiZm56dlN6K0JtZ1hMOWJpYXFsUXdoT3BkWWVCTlN6Rm9uYXFhM3FEbHFKWUdNNlNxR0Z6ZEk2S3RPeCtncFFzOWMyWWs1MzFkamhQRG1OVUkydnhjUVVPZWsvRmlUNWdGd3F6dHIyc1FDd29NcTNMUWxxejhubTJybGdsYkY2cXB0a1BsVmhRSnNIVkN4ZmJPNzZoNDI4WDg1amplOHFaTlZDQ0RMbU1VZzMzamlJUU9iL2lkYVB6MS9hZHlIYXJNVlpXbXFJYWxnMzI2T3dGeElSNFVRcFRiV201T1crS1VnOXpEN2x1RzhkUVF6V3N2QTZaMW14UWhBSVlZcDlkVWVqNU5HRk1xMTkxaWM0NWZweVA4WGhmaGFXZVVnaGdrMVBaMWRHUGhzbHFZZkg4dnIyYjd3N3V3WXFWM3ptSXhkYkZCYU1KWCtuR3RzSHhVOEExS1RReFIyN3NnUlhwaTN1aXpDYTlNeFF6Nno4bko1MXdQUFNlS3hyUmlGanlHTHVYa3BFdDNzbkpRZWtXSUU2MFphdkZiVmZpTkRha0tqTFgwcXlZTzd1OUZYOVpHVTRVWGx1aTQweGRtc1lYRDl1TjN3L0ZhRXhWeTdlM1dMaDF1SVBDZ0duMGdFSkFvdjJmZ2RLV2UrckUxVGRYWnhIUDVxcXJ0cWVIaGtZNERxRkhzVE9VbkVhaEJ5aVdVTWNBcytCMWNqbFB3K2xGY3IydExFUW8xU1hsRmxqVGtTaStyNUtqMWpnSzYycnF3OGZ6bGpDTnoxQ29iakRKUTF6U1ZsV0ZpbDVGaUliUldJUDhvN3FUaTVFcmlzTkJrTUVhVTFiQ25GTUQwYTN0Vlc3MVRtTHhpSTNnNGlPbVdDM3V5UGJINHZjV1V0MXRTQTZ4REVWN25zZ1UxUkpZa1pNWmtIRGtFOGpuVTB1SVZleSt0QkNzcXVLcThVQzJZMUNjc2FpQ3ZvRkxzb1VBNXRkdUhHeHE2RGM5Q0RaVGZ1R3BHb1ZyVENIUGl5TWJqZVdOazVNbTJkbm1CMnU5QVdlYnBaeS9HNWd2WEl6RTh5dml6Z0Z3MjUrM1J3LzlVdzYvcUluUGNBdStUL1JaVXM2K05UTlpyTjB5TVpMQ1BWM3B3WHhjZmpETElMMmlCRmh1WlZLenFsZ2hSbFBRYUdjWWtDc0MzRnVrWGloVzNuSmxveFhjbisySGcrTnZOK0syQXBVSnhmUitIa29KdHYxbHQyZzAzaW9wV2JOVnZxQW96amt3ak5XcWpyVzFFaHlrVm5LZHcxQmVnWCtPcndoWVZqNnRqbExGckMyK2JhNERkbklwT2hqMVJJZTZ6VFZNdG1CZ2xmUzQ0RXFGYU13aHpvc1F3SnNUakhRZmxCWDBESE1RODRKNkhkK0tSMnp0MFdzdHh2VzFxQkdkYnJiZ1VORjRhdkZCYkMxTlpwZTE2bXhZcHd3M0FDd01PN090bFNERkthMUdiMytRWno0VnhzQ09ycSt0TVgvdlZaRnZtcE44cFRtWnBSVjdSTCtrSjgwdFZpaDNjaGN6a3hBY3EvTXQyU2xUZlZ4d1JtSFFaeFhhSTR1WVdFOGhRSmxwWGxxWXFDQ3RETGl3bmlRRzZrbjF0Q2FqVzBKcGFEM0pOSDZKRk1mWG4zNm9TbDVZNm9ENE8vUFl4TDNsYlk1cjNlazF4UXM0UWE4NWtvZE1LMUNpOURaam1FNzNqTHRvUEFPZHVKdXdHYzlpM0k0ZjZlbCtyeGVGczE1bkNmUFcrQWlVK3NaTFljckJ0QUNOOWc0aEVUTmpKQk5hZXNRTExUMStNVkNLdmUwZFUrNzJqbHJaMHJiVlhjSjBsR21RMEFuZ3hzRzRaZEF1YTVLZ1F4N0Q4UGsrVjJPRGpZRTc0UHNzbXNmTDZROVUyQVk3dURmV1RJZXBjeGQxVi9CNTlsUndwRkwvZjllYlFzYVgremxMclZ0ZVR6UXBVUjFSaVlCeWRIVW4wRE9SUUhmWlNmTVVTVUZGTUtvakozaHRHWmxoVTc2VkU5M1JwUFJ0TlZWYy9xSFhaTUJ4Lzd0MDVDUFd3OE1XYVRaanExcW1vZUR3eE1wSnRhMGY0NVM4ak5CQktFcXFGenMvK0ZGdlpSY2xaaXUzeE9venhZOVNBRDNtMXRKWWV0Ykt3djF2dnJSQ2hJTUlNcnVPUkFWUUZQYXRXL3RpbElHeS9WVnJ2NTZCOHRWM1FRdkw4bWFTUTgxb29YcE94MUlMUUcxbkJhK056YVdZNTFZTW92RzVzUnpYdCtra1F6eEluZHdPRDRTbWZQci9hMUFOeVlrcUxXOVRKRXIrcXlFeCszRUJOaUhGNHlzYUJqaFFHS0lwVkRSYVdMN0hRV0dlaGdVY2tIRVNncWg0dXpUV2R6YUNuaDhad0tJM1dWaW9BNDNMbGZTSkNQRkNJeGZMd3dwV2lNR2NUS21hRFhLUE1yWkdwcWtxSjBkSEg5KzJUNTZoOGJieFNJQnd6VWNlQkwyemx3RmZVSXh5djB6NXNzQytsTjU5S1pBUzZkZzFoMzdOanlDcmlCQzlUb3ViUjRPMEE3M1FlSE1DNmxWR0VneElqM2QyNDc1ZDdFSy93bVN5ZUMzdkZEVEZLL1pvd251dmZNT1U5Um5HSm82VHpjcXBmblBEYnhiMk01R1JUbEpTVC9UREZxVlB2elpEOTFGQzVhNEpKK2srSnh3OUlmTzdkWVZ6K29naENxcDFRTmZ5RWVVR3FsTDZTdHpuNmd6Qnh0akdzVWwzSWR1L0hZR2NDZGZmdlFzZlc1SjBGenpwbHlkeVhFNnFjSnJFd3dYSXhnMUFuU0ZyWU1CN3M2RGJQMmJsZDRLckxvbmpOeThNSWh3T3c2dWJEaU5XalFOSVRhbXFFRWEvUlZwQThzQXZSdHk5RmtJN2lwLy95Tkg3em8yY0pMMTVIdEdxclY1Mkc3ZnVHWUc5dWdFbXJDZ2RDWk01SlhSYzcwUU5hTXFGVENjcGNueXR0RTV6WWtFcE8vL2xTc2pUdHVYei9PVHBPaHR2QU9ES1F4aU9kemZpN3EzdlJzclFlbmUwWlhld3JUS0pPa3dtMzdRQWN4bWZoeG5tY3N4cUlJUk1pMU1MN0pocWJkdUtIajEyTTFUWC9jL2NVWmxzcVRGRW1IcDAyOVNkbUVLbyt3Z1Y3MGRldk5kOTZ6c1l3QmtjamNJZnBrNnJWTjZrOS9sU0wxVUdFR2hyMTNuNHF4V2NHUTZnKzdTemtPdHN3dm1NUHJ2N1lSbjNDeCs3WjZTKzFTZXhsSUwzbllEZUdzbU82MEthNmhuRFZRVU5xbVBUQk13bHBycy9KTW0yRWNoWmh6Zlo2Y2JaVXhVVnRUS0tDWkt4NnhXb01EUGNpMitiQVV2czNGVGVsVkRQQzROaXcxR0tHNm4yMXRCT1Z5bmZUblVnR3cvbWM0NmFycWtiOGZJS1lZcUZpbGt6UllXMkkxa3d4cURvYUF2S2tiNzZ1Njk0VksydlEwNmxxWnRJY1JBRHBzU3lxQ2JzT295NG5ZOEhwN2tOa1VZWGVxOGd3cWdtRnFpUXpwQlB1cXVGbnJDZUZvV0VMQytaYldMTEl3cDVETmc1MVpkRkxFclNBekxtS3JEQ3h6UXRkZEp0OVNVdGZrZkhLMGpaNitkd21YbGxpamFYOW5ySmtjN0hEdXZIbGMwT1JVdUdWTzRxK1ZOVk9oZm1aZVF3Ny9yZ0hXTHpoSVN5K3NCbDkrMU42SlRsSUh4eWlwS1VJMGowMVExUldFbmxDY0xJT3pIb1N1OXdBY3U0K25wUU0vMmZ0QmIvWlg1WmhzZVc2MHFiOWtRSnJocTRuclNVZnVPYWxyNURkTjJFc2JlbzFVUkgwdHBKUmEwQzJhc3JOcURvakI3SFdGdnE3ZWxqeGFxZ3dTaTA5MlpsT1JFOWVpdVNERDJCTlhUOWU4ZUVHRGRObWJTdjZodnB4ODQvMm81Y0I5ZkpGak51aXFvb3dnb005bGlaQ2FuY1NGZmJvalIvbEpHT2MyTTdVbUNRcHBSdEZHZVlVZkJLZXBYaGJ5QmtUMHZQTzVaTXJSMDZRSTI5VnhJZDY5M0JoRmpOaTZraFNCTlU4WFlzS1QwNitFTm5kdjBmOG5EcEUxMVppZERCSDE2STNoa05lanNFWjNnYkJ1VkdEVG81UTRHMThQcDNIY0pkS1l6YkIyTnZuQ0xHdzFES255d1ROMnZkaVRiT1FPaUhrNm5va0Nxa3dOU3FGY0dVVWp0b0ZTMjN1VzBIQkJNS0lMbGhCb2hORXFqdE4yRTBpTzBnSWplWWhhazNrMjN2USs3MjdZS3E5V3B5NFRuWFpNZ0NITUgzeUtnY0plQjFpaFROSXRDalEwell0eHBhWG40WHg0VEVkMCtaeUJTL0VJQWFySFZaVVBsV0ZHM3BobUpHL0NtTTAyOVM3aktsNklDOFhhSmZzUytEbFpCMHZmQ2x1WmVONklZemVJazRGT0k3YWNzNTduOTR5em5VUEoxbVlYS0MyL0I0Ymc0T2ZIL2JLTWJQWlBZaXRyY2JPSjFOb2FiSVFzNFRlNzFlMVN1cXR1Y2trN2FFUnZkN3FaRjEwRFlYUjNHUmo2WloxaUsxZVQ4VmZITDNCdnZzWEdjZmV2cTA5ZkpzWk16cHVmU1RVY1RROW83TjJudzArZFhQbWtyZldZbURRd2VoQUFYRkc2NkdxQ0hMMEF3VTNBYWYzR2JoMWpiQ2Fva2piYlhBejQ5VFdQbVFQRE1OSkN2MFZhajNUb01ZcW1JNHo3blRjRkpZdUR1bkY2N1oyYjNNb0ZZaG54bnJRcytjcFdJYTNtYTRrL2hwUzdjQmw2T1NGa1NmeFVsanNxSEFscS9jUDExM1ZKc09la0dkV2FuSGROWjBKK0hSTVJ5K3h1VUwvRDJtNi9wNUVNMi9RSk11UXBTTGtLb0dxTHU2V0tsVWtCbXp0NzhhTFh0ZUM3a2V5MUg1ZzNEV1FIU0VKVW9WaFZFVkhiNFZIdU0xTERGSGZ6N3dncEZlV0N2TWFrTjc1Tk1LOCtMTmVzMnBqWkZmN3hqZGZJcTg1ME9mMFhMb3hzM1BVQ1gvbkk5OFNkODYyWkhZa0FoWHBRaWhqRXZmcFMxRTN6MElPVmNpbWJjYVVlYzhDMUVhSkI0YVFTVHRhKzV4c2NhZkpJTW1SMUtteC92RXdGcllZT3BtdVlOcm0rK3JJL2xZc3IwQkh4N2h1eEcxb290QUxvL2pUN1UraHJ0YmZ5azJVSno1VDg3c29nZU5wNnkvazRTSE5kS1NuM0hjZHhqcjhmWmRVQ25oSm8vZmNudDBVN0IxcHJGNXVhaGpQMERKVGh0UjVicjJYa3BEZVJpQW1iNVUyRUMxU1JnQ0M4QnNJcllZUmFzRGl6UWZ4NktNSEVJcUcwTHFndW1YUnlkR1dSRHAzN2s4V3UyMDlLZU1qZi9QWm9mdm1ZcUZtZFhWMVlLWmM3dGc0ZWhzajlxb1ZLNHlsR3ZiU3JxNnMwd0VsTmM1Vm16S3F2WVAwTG1DR3Q3K2ZZeFpJNmMyUnBLcEhyVUJObGFYWmI2UXlDQ01jUmFSMU9VU2dBWHUzajJENzFnVE9PQjFZdVFMWXQ1K2FQd0MwTHZTYmVJT1RoNjVIS3U2SFlFM3VtVEN4ZDRKWjBoRHNQeFlsdFR5bDhhcVlFcmVXSG9aZndDWDhXLzM1RXNLbEZFM3Q4U2VwdUJldDhTRDN0Z2RkN095MWNQYm1JSWFIMVU3Y0ZHYUd3cU5nVmJtclVCcytjNTVVeVdwR3FnSnJJb3hhN1dsYXBTc1VvYmFKbFZXb2JtQnMydG1IVUhVVXRtQjhYdGRpTG1pdHEyK09KMSsxOFJRamZ0dDkrVC9NVm9JeXEwQUgwbWJ1dGllRHQrM2NtcjhqT2VibWttbWk3N0JJSk1ZWmEyWVJ5cVJoSmxKSTlnMkw5bjA5NXYyUDdndmVlbURRYUx2NHF2aHA0Zm9BWTB1SDJreVlyclpRVU5BcGNpUlNJOGdIWGVxRHhCMi9IOExhVmNDNlU0SHRPNENuZGtDM0VxaCtXOVdXcjQ3aTh0bEU3dGFZYkpzM2pQSXQrNlhQVzM2cmZzQXFXYTBSaDhlNHJyOXNwOXl2aXNSVXk0TXFSMUtiVXFyRzRISGVKcExlNDdaTzRLUkdyNFJ6bUw3MDdvNW1YUE9TSkJhc2lhSWlMdlRtazFraVVZRUs3dEt0RkRpWUFqWE01a0R5cm9uV1pncFh0WDdVTFlZVlpMaVhIcURDVnlJNDM4U08rOXNSdFBNSXhCbFIxTktBTXRXSUx6blZXamcvdlBudDc0aS9QOVRUYzlzais0ekJ1VUR1ZEwrUG9sKzdxeTIyKzY0MlhPL25YSW9KQjdPRW1VM2NmOXZaNmNzQ0pCKzFaRTlWellScEdkZjcwWnNxNzZyU1pmU3pUbUlZaThpU0hJNWd6MTZ2V3JDK3pvUHI3dTdEbDZvbW1LeWMzTCs5dUNWNWtlMGVGa2Y2ZzNiOEJJVWlLTlUxSnVZelpGcTB3RUx6S2krenBVWTdxRGI3U0JVd1BDNXdjTnNRdGo4MXByZWZLU3FSWVpSc3VPRXJnMUsyNWMyTVFTdWhHNERYbjBmWXpOMk5oMytiUThzeWZrOHJ3N0M0NTRpZGpHZVpLdDFvRU5VT3F0NFFCZGpLaitjekRHdFVmSnJWQmVJbTQvaG9jeE1xR2huUlZ3WXdzbXNBMWFjczBwcytXZkg1c0xxeVZXLy94S2wvaUFhM24zWGpyNjJEMHdsVVRwT0JrQ1dCYlRsaEYxOHpTeDVyeW4zbjl1QUQ2KzdKM2YvU0Z4dm5DdlhEQVVrT1VPODNMM1VXU1lVSmRzRkFUYVhBMG5rbTJoaU1EdzR4cHVNa0xadFBmOVRpbDI5TVdlRFdteWtYMXlwTGxycUtyMDlZOGtSaGNSQlhYQ0J3OXBtRStXRDV6SlpaVlpMWitvQ2YyZnFucC9IYkh6NnIvYUZwVGdyVzhIUFhGUnpyNGdiby9weDdkZ0t2ZnlOajBOTzlHTlROR2RpMWxhU00va0dvRGFFWmorbkV2OG9yaXdBU1FSVmtqOExONWxBWVQ4QXE5TktOZGZCemc3VHVKVmkxb2g1NUp3d2pPb2JLNVZRVXdySDZNUVV6YUNMR2lHSm94LzExYi8vODVtMlB0VDFhLy92dFJuNDZ5SjBwdVREZHJoelQvcExTZU43SS8vZTI0RjJQUE9yY25SaVZoZUVSbVZBdG0yTnBCTkt1WWFWanRTSlRNYy9OVmRZWE90cXloVDNQWkt6TkcrbVBDRmY3RDFsWXNEQ0lVOWVFc2ZiY2VUaDF5ektzUFdzZUZxeW93dEtUcTlDNm9nNlZVYjJUSXlJUkNicG9mczQ3YW1xOEl4UTFjZVY1Rmo3MGhnanE0cFV3YUNHaEVPTm9DdFUxZzNBd2pGQmpsQ1N0Rm1aSVpYRkNpQ3hjQW1la2dFelhQcHorNm5WRWtEeVNnd09JeGJ4aWFGWHlwSDdqaFh3UXBBUzQ4RlN2TGtndXV4QlYvWHV3OU14cVZEVXlyaVNycnF3VHFLd1ZpTVZkVkZUYXRMbzRJblZCQkNveW5LQXNJdkRRS2tlV2FGbFZjTk05eUROVU0rTU5DRWF6ZUhiclFWUkZteEFoVXpRNFpwT0QwT1ZPdVNRS0l5TUlOVE5BUzhtcU8vNlUvdTl5eTJleWpCVzZKUUd1TEVrT2x4T3dNdzIzbEtUb3pTM1ZtUlduckF5dE5tVXdHZ2dGWUZUUGc0alVJcGZKRzRHNnV1RExYbFdQeHgrL0cxbUdPS3NXUi9HMzE4ekJrbDdyV2RMUHYvUTA3dnpwczE1U3dCOUVudUhBQnkrMXNXSmwxYlNaTFRkcklUMGxzMldZZVZpUk1EaG55SXk3Rk9ZWVl0VmhMRmxvb1dVbElicXFUbHRwWDNjS2xReXJyQnFHWFB1RzBOZTdGNnZQbW5zTUdpSmFEYzJyUTJ1ZGhleDRQMlAyTVU1MExVUytEM1p2QjRJTk5nWTZCN0JnSmQwUWZVOEZyVEo3cUVCQlZ5QXoyczN3VU8zeVllR1VqWXZXMG1GTXpSUk5KT2RMZjYrclhJYmZtQUsvVTVkdmpNTmFLR3luK1N0WEQzenZ6SFdoZVlPakZYQ0dHZWJFMVpxb2wxUnc1U0VFYXV2UjNXK2pmdkFSM1A4ZEwwZGNHS1EyVDhrUmh4c2JOVlNaSlRuaWZHY2JranYyNEs4K3RoSEpVZURPbisyY0dOanF6V2RBSmg4cW05bFNPNVNwU1MzTmJBV29LRHF6TmRLUEp4NTZCbkduQjgxNzl1RVZad1lSUHE5eFJzVmErWktsYU5uUmlXVnIzRG5Gb0NxWm9hdVFCeHlkQW5XR3M4ajJQWXNRa1VLbzdkMkh1eEExd3dqUU5TVWZiU2UyQnpEZXRnOFZ5eGFSc0JtSXpxY3g4QnlISG1uRFNLTDYycGw4S01waytFdUZXdHdMMlNscG55aTlMVnF5VVdQSlZWKy91dXMzUzVmVm9MZExrc0NrNFpERnBCTlpWRWJJOW1TS1dtdWhZMXNmWWdmdnhScWRJemFQeXBMVThOZk1UK0trdHlpMnFRcVdEU3hlTDNGbys5d3lXMkdWMlJvWVErOVlFcjIvZnhDbkwzRXhtSWdnVCtZNlY4VXlSUzk2SG5NeHIxYk1Hb09xSHlleVhCdmpBK3FIQmVncnlIZ3pPY0p3ZG9UWG5kZlpxb3J1SEtJQlIyZTlDZ2tiY3RERlNOZHVLb1JLaTJ6VDMzMm9XLzdwbXAvUDIxYW01a2o3VUhPR2hpVXhUZjJuUVBtZldNU0gzL3ppMTllUGJOMWt4aXNZcTJVNE1EOG9WTzF6aEZ5MWFiNnFockxEZEVKN2Q4Q3FxdENkd0dxYmNhRiszWWlhSFlqUXp4RThqQ2dRbzFaS09ROUJ0ZDVLZHBFYkhVQXUxWUhZcXZsSVBmSXdCcllmZ0JraDFPVWRyQ2JNZHJiM1ljTmxWU2hFQXhoakhCSVdGRnl0aVFLRjdhaUM2K3d3Q21HU3REclZoRHhBMk96QStKMFBZOVdpS0FiNmhPN2ZrWHl2blNWYVZETHNDSG9iU2RvcEVvQ2FpTFptOWFUS0R4dVN5aVdHMFRWV2dYZ3dNV3NNcXZ5M1ZSVkdxQ2FFVEZxZ29VSmlqS3pYVWRTRzc5RXBSY2RHMTZqWTJ0Nk5leGhDR2JVVlRtT3VZTGdoUy9YREdlZ2FORHFUZWZQZHQrK3E2Q29YazFyVEJLbHVtZVdiVW5qRkZMOWJmSzhacjhWWUlldFppR0o0S3IydTFrRERNV3EzeFl0cFdVTGZFa0FvSVpHcU9qSkxFakZlWVoyWEkrNzc5N3RnalVnOCtneUpTTTE2YkFvL3FtRlcvVXJUMU15VytxbXQwc3lXYzJBSVdUK3psY3VlenVCU0hoVkUyOWxEaUsxZWh0Q3pmMEprbmtDRXlESkdpOHFwdkhHZVNtQXgvQkVxOXViM3FoNGRLcDRWNGkwSlVmOGhHd3ViS2FKaHpvT2JRNHpXbnh2TG9hWTFoS0V4T2ZMaFcrcmVlZEhLVEtRdTVNUlhOQmJPVW1uMWNNQnRHaHczZi9QVDdSVlBUMmRRMWd4WkIzY2ExaXZMRUttaUFtRGttVittTG4xakRmcDE3dGVtNVdRUnFnd2pyK3M2eDJIMkV6NnE2Wk15S1d4NjVYTnp4SGtWZ0pma2lBUEZISEYySE5rOWZjaFJHRTVTcjdycVF2dTdkNW83RnEweHFrNXZDczlYeWxGWEU4V1Rqem5Zc0ltdnE5NmFwSTJnNi8wMGw3UzliYzExVnNzMmRSRzNZcUVqejFPeHdsU3M3OTliL2VpV3N3UHpscmJLK2RQRm9KTGZVUmgyZEN0bEZYM2kvb014dVlqQXM1ZGNZcENLVXhzTGtVMm5zYThqMEt0ai96MFJ0UmFuU3Z4L2p2Sy9uVHB0YjR1Y29SQ3BuSVU2VTN6bnhFYmdPVHVZVWhaU3p6TlhONVBKNmFTQ0RjdkplMFZqdVFJS2gwYVFHYUE1TDR6TTJaSlVqbGdYbVNFRUsraXE5Y2o4dno4US85RlQ2Y3JmbldidHZvaks4ZGRGNVdpbWNyVHREbU00YWVrZUhQMExUNjYzWGFlaEdMSDZsU2YxZ3dKcTY0RGtkcHgxREJScmQ0LzVxOC84WSt4L3JqZzFzMzVaazdPc3FVYk9xNjRRdGFvajN4Q0dLT1NrazBpRlI4ZFNHQmhQaTROZEk5WjJocW14OTEzdS9HeFJKZjArTDY1L01JV09UdUIzVzJ1L2k5bC9DRmZPQkxrQ3MvOGFMY3FzbkQvbjlkOXZEL3greGNMOFhlZHZNUzhTWkhaWjMwTFVWcWxTL3dpUFd1OFMrcmRMSG53b2p5MWJnbk95SkZWaVg3QkpDa2RFM3hQdGtjZHUyMUZ4ZS91SXBWdlgwL2xncGh6TTF0UTcvZ0FWSVNuQW1hb2NLbUhEK1BSSUlIcXFZcEV6NVc1K3RQTC8zTHl0VXEyS3VML2FIbmtjMi9FSXZBWjI2ZDhXRzBKS2IvVVJDeVhlY001Sjh1citnVXpmYUdqTm5sOC9XZkhrZ1h6dnd5aXovL3djTEZTS3hZc1htelAxdGt5VGNDaGx1TStwUDFLM0Z5NUpyejU3amZ1YXBucTUwRlMvb0d1ZzFUSmxuWkF5V0hCa0twMUc1MkRDMk5FM0xBWmFHckNndFJFVmRGL1ZrWURiSEFySUdrdklBSlVnVFM3UzB6dGk3RzdyTi9kczZ3enMzZG9WN0VybWRZWmtZa0c0SWVyRS92NVYyYis1NG1Kam8xS09aRkxxTnI2aWNxaGJCWHV1dW05TEhTTm1jcjV5dEFXM0xsMXFMYnI4WW5QOWtYeDJZRlIwYitzSTNQL2JIYkZibmgwSWRwY0l5eWtqd0xMQ25IS1VscERMS2JWRk0vM0c5MkhQSzRFYU0zV2ZsUkhpVk1HS21RUmJrdWMxcDl3WFU1NHpwdVNKaldrVVorcksvc1M0VG0zTUxicmtkUHVpUlMyeUtXekptbWhRTmtTQ2JsVlJPWklwOUhhUEdIdmJxUnpiT3dON251NE9IdktWUTY1cnlpM2taMSs2c0ZrMmh3T3lPaHFRamVHZ1c2MCthMU1CK2RtZS9qSGoyWTRCWStjelhZR2RqeDBLdFk5bDFXNVR6eEZhNmVPNUNISTZZWllLRk5PUm9ISUNGWmo5VitETDFodk5VdjVwbGhIeTFNUytOWU1TekVXd015bmdiSC9sRmlFd1pXTExUWGFwZ09RczF1aE1FWm96aXpDbmcxazVteURMa2FLNWxEbklLY2tFVVNhTFpFeDUzOVFKTktjTWNLcWd5NlVneFpSRWh5aXpyWjFSaHNqSkdWYjVwOU44V1Naek52VjI2dUdVdVc5UDgzNW55dlBURVo5WkdlMU1MSGZXQXQ2cGJMYk0vYWxRN0V3WmFEbmhHcVV4N0F5d0xVb2dlanAzWUUrendVUTVvY29waXV5V2VWN09ZSzJ6V1YwNTYzWExuR00yWWM1V05UOXQ2ay9NcGN4K3l1dkdET0hOMURoMXJ2Qm5sTEhLVXFpMXl5UTNNQVVkTU0zK0JPVnFXdDBackVET0FMM2xCRE1YWCtsT295eHlGamN3cXlCbmlrUEZIRTRncGxsSExiWFlxYmxnWXc3K1VzeEFnTVFNamNsSDYwT251NTJycGNvWkxITW1QeW1uS1NxWWxyMCtuNDJuWnZqdG9lZFlucGpHU3FmNlUyT0c1VGwzRm1GT2Qwd25SR09PRXlKbkVlNU14MXd0MXAyQlhKV3RESm5GWno3L01zNDVFaVZqRnUxeXk1Q2FjbFhpNVhMSU13bFR6c0RNWjZ4bVBJWkNuWWtOeXlPQTJhTVc0bUVYSnVYY3psR3lpZUIwVmZhWUliU1pEajduYW8xenNjeWozWVQvK1FoVnppQ3NJeFZrV1dOb2IyOC81aFk2WFk1M1RnMm8wL2hWVWFZSlp5YmhIYTB3eFRHRzMrY3I1S09LTFkrM1FER0RNR2VMWmQwNUN1NW95TSt4c05BakpVdEhJK2k1NUdUeFFndFV6a0NXWmhLdW5LUGdaaE9pbUlNMUhxMUFNWWVKbDBjcDZEa2wyUDgzQkRwWG9XS1dGWnpwRmdMbVVtRTRGeUdLSTV5czJhd1ZjOGptek1WSEhoZGhIaXZJUFJKZldrN3dzMW5nVEw1U0hJZnh6K1piNTJyQnMxbWp4SEg0czQ3UkJNeVVhcHVMVU9WUld1THhGdWpSV2k3bStQb3hGNjUxakMxekptdWRpMUxJNTJtSjRoZ0o4R2d0OTBoZU95NldhaDBIN1JaelNQalBwaFR5ejF5Z1J5SWcrVHkvKzMvVmh3SnoyQWNBTXlmOXhSR21JNC9ISk1ubitSNTVESlRvejBhZ2N4SENiRW4vNXpPWjRoaGI1L0VVL0YrVVFPZHlZZUovOGVMbFg4ZzUvMndGZWpRVElQN01KdlYvWFdDemtvaTVKdWRQL1AxbC9QMWZBUVlBeHpNbWlUck00UmtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC8xMDAwMC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlnQUFBQXhDQVlBQUFBQmYrSHZBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3hOREJGTVRoQk1qTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRveE5EQkZNVGhCTXpOR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pFME1FVXhPRUV3TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPakUwTUVVeE9FRXhNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtnbWFTa0FBQUNVaEpSRUZVZU5yc1hIOXNGRlVlZnpPelA3dWxXRWk1dGtETElWQk5GZFNURkVRaEp5SFJRT3A1WURoTXVFVE44Y2RkRElueHgybjg1eEp5cDJnMHhCZ1RJOEdEUk9VT01Sb001SWlZNDRRVWtZQWNCRGxhTFdocER5aUYwdjI5TytQN3pNemJ6UDZZMmRudHpIWkwzeWQ1eVRMNzV1M005MzNlNS92alBTb01iSzhqSnZEUjlodTlMYWF0V2IvR01mNHhRdHRQdEIybjdSUGFQbTNjMko0bzFGRXdJY2lqdEcybWJRNjM1WVJBTjIwdlVKTHNMa1lRU1ZiSTMwU0JQTWR0TnZGQTUvNDFPdmN2VXFLazJUWFIyQ0VsQzY5d2NreGNZTzdCZ2F4cjdFTXNLYTcxaU1xejNFd1RHK0JBNyt0bjFtWVI1SEIzS09EenlHOXc4M0NvMllsSGZuUDMwNzJCREVIYXA4ZldVWGxwNXFiaDBGMU5FK1hFNCtwbkdwQ0lYa241TFRjTGh4RTZKeVFvaUovKzR4NXVFbzRjZ3R3TmI2TVNSQktWQm00U2pweGdGWnp3aXlwTEJPTGxKdUV3UXRBNG9TcUlXSWtmUFBxL09IbDExd2o1OTM5ampvNkw4WFlkaWxqMndmY3Y3N2loUGtPcGlDV1VDUjJ2ZWtDV1N2elNsRHFSbkw0ZzA1WWdjNmQ3U2ZNVXlaRng5NTlJa2tsQjYxYzQ4WDJhWExpc2tLQy90RmZkKzAyVW5PeE5rL1VQQmgxNzNsd01qY2lrYnpBMTZuR21UL1dRK2xySDE3cFFNWUxjMnVnbHl4Y2t5QmZmcHNtT0ExSHl3cHBhUjFRSkUvL1VDaTg1ZFQ1aDJnOTlHQXIxTXpOdU9LNm9wSDdsbnhIeTU4ZHFza2dDOG54NE1GblM4MjUvSm4vZnErdTdlTW5qRk1LNnBWN3k4TDFCVndoU01YUjJCQ2xCUmpMU0hmQ05qcHNIVG1xR25kRWdrYjk4RUMzYWYvUEhzWktNdTJaSkRRbjVOU0lVSW9rVG1FbWZmZDNTOHU4L2RDYVZ0UUFjRDFhZEdBVCszUzdhVzBSeUk2cVFUVHRIaXZaOVlrVkFWWjVDZ0JKZ2RYZTBTV3FmZFVzTHkvVDMvNWZKa2JOcDlYZm56NUpNSjhrTUlFNE5kVTFiOXlleVNJTHJkbGZzNzk4WU52M3VqbFlmYmFNaGlHYjdHcjlRdlFRcGpjSDIrMGJqNW4wL1A2cTVpbVYzZURNVGFSYWdBb3ZhUEdUWm5ZR3kzZy8zWFI2V3RWaXF0aUl4ZmNtWVdpZFdMMEVLK1ZhMnlwbXNQNzNLVHhiTzh6dVd1VUE5b0FwWWdRdzlBOGs4VXZYMHk1YnhoL0YrSzhEZE9PRVd6UlRZVFRjeDVnUXhTdy9mM1JmUCtQaGNjdUQ3bmYrSmtJRWhoV3pzRE5rMlBPNzcrTEFXZThCVkdiRnRmOHpVMEhBUmhjbHQvNUNjRytRQTdwb05GNWN1Njk1aEtwRFh3c3I0SWdnbWNjdG5ZZlhCbHkrUUNzby9qQjBLQ0ZRSjBtbzg4c2VWOWdKQU5xNFZubDlkM0pYQVJVR0ZTb21wTnEyZjVNb2tRSjNXTENudlhoYmZCS3M1QnNrRmxJRzVnTFVQMUZnYWhwQUkrZXhJeWxhV2dOUVM0N1kwQ0phU2JNZHRmSFF3N2xCTVZSMHdDK2FyamlBSUNsSHJBRG5zdUE2UXBLRXVscGNsNU9MaTFYU21YdkJJaDQrOHRTZHVTU1FuWXlxekxLU1U3QzBYaUpmZ0VwMk1ZeGhXM09VdE95QjNqU0NvQ0w2N0w1S1I3VnViUlBMbHlWZ21WN2V6VXVFNnpFaUNmOE5kelpvbTZmR01PVUdjS0R3NW43M2xaMmhPS3BWeHJFaGNxVDRGNmI2WXpQTHBjQnQyQUhmQk1MZFpWTlhIakNSd1YzWUNSYk9zeXEzTW9kanZGVklndUVFV0lCZkxqdGo5VnIrREJlcENxZDA1Z21CVmQ3U2x5T3hmaUZuRko1Ym1idGxRbS9VQzdLVnpBNzlRUUl0Snp2VWw4d2ppVmhiaE5wREZGVk5lWU9WQ24yWDhoUFErMTNXd2hLQnZVQ0dyNzNQT3RiZ1NnL3hwWlNqdjVSbnNzaHN4eVgyM3AwZFYwcllUR3d4SEtrY1FxNHBya0pJZUZWNjR4ZE1YWXFTekkwVldMUXdXWEF4STd6dmEvSm52RUpkaFg0c2xCTmdFSFRkMUVPWjJBRHg4S1hCcjU3UWFnY2tHZ1JiTTlxbVREZlhzNlE4WDNFRkdqQWExd0VZbjFBU0V3YlhPRG84cHFhcWFJT2N2cHpNQmF5VmhwMTRCbGJrV3JoNmlnQXpJK3ZZY2paS0RwOUxrNmcxTlJhRVNEQWpTRWFPeCtPbVdrT0JvaGJxaUJJRnZ4SXNDclEybEt3SlMxVVczK1YwSnZKeDR0M0pXSzQ0bldFMG14bVF1dHU5S2lyejllVmpkYUdUQWJ2akFrSllwZ2h5Ym42aDFQUzV6alNCSWNTRi95RkxLWVRoOE1wcWRqTVJPMXVBVUlPMDRwRlJPVlJXMW01YUdoT205aU5sd1BzUzRoWS9kYWtZU0xCYW9ETndNU0lLQ3BOM01ycW9JQWlNYWkxcmxGSkZ5VTJDbnNnYUdjczVSc0JXTjFXc013TzNBNmtBVGxPWHJjNmtNRVRBKzNBa1VBNlE0Y25ZNFMyVVlTZUJ1am5XUGtQVy85cm5tWmh3bENLUVhQcFRWUUJBOGxmUGdQMTFPaitvNTdKelRZT2NvaXNFWUE3QnpKUnNlcWluWjllWHVNak5ic2VPUWJFR2dDbXJNVk14Y0VZdFhZR3NvVTN0TGNsUkhHbHdsQ0ZiODhaNmtHbk93amJTblZ2Z3NINWJ0cCtBZ2MrNnVMRXRCWWF4U1ZxZDJObFd4WEswTXVYM25OSGtMVHNyaE0vRXNaVEtTRHlzZDc0c3hyT29YSUFNNy9iYmtkazlta3NNeHJab0swajA0MzF2U1ltTHh5bTB6RXVxK0VqdnZpOHpHeVhxSXh3blYyUFZWUEZORk5VcWpGZUI2UGoxaXZxT0tjZXkrWk81UlFyT2poVmIzUHI4NmY1T1BCZG9nd29hSC9IbmYvMnFPVnZuVnhpaitteGdIZ2JjeDZPenN5SzhSd1VYYkxaZmptVGF0OTZuM2RKMU5xUVV6S0ZEVktBaVlqQXJnb2phWnpQK2x6N2IwWXJVNDVUZnR4QnpGZ0lQTGhkNE54REJURndTSXM2YkYxYUMxR0hEbVkvbUNRSlo5ekd3RmN1VHVKeFY3Unl5bVpYY1N4dzgxQ2FSK2NmUEFsdE45NDYzQUJGbkhHUWkzdHJuSE9vM3U3azltcWNSWW9IRmorM1IxMmFSa0llb1JsZUI0TXVKWUdhMFNnQUtNOWZ2SkNsRXpEV2ljRWs4S1Z3a0hod0h4cEFoT0tDcEJoc0xTRDl3a0hFWU1qa2puR0VIU0ozNE1mc1ZOd21IRXR4b25aQkFrK2RLdXBuMlJoTWpkREllV1JTWEVvWmQzTis2bEh4TWdTUHpTc09mSzdtT1QzK2VtNFFBb0Y3YjFYL05lQVRja0VweUpTcFgwcjFPVHJ0OC9MOXd3WTBweUxqZlJ4RVZYVDgzZUo3ZTI3S0FmTDlBMkxBNXNPUTJDWEtmdDR1L2VhWDN2bTk2YUE5eE1FeFBIZW9OZlVnNXNwUi83ZFU2a3BXY2Y5WlBYOTAzRGpsUXFKUXZpQjEzMTNiVUJlWEJlWTZMVjcxVkMzR3czUDRhajBxVy9INXF5L1EvYlp2NkRjdUE4dmZRajBmNmV1NUw1VTl5Tkc5dFJOS3VuRGYvWGZHWmRNRDMxcFZXWEZpMlpHNzY3Y1hLeU5lU1hieEVGSW5GempuL0lDa21INCtLMWdldmU4NGZPaFk3L2RjKzBMa3FTUVowWUlNZ1FCQU45cy81V3UwNFNYR2lrclVrbkRDcXNxR2VESEFJMzcwMEI3QVRDYTZDZUg5VUpBYmN5QUVGaDVGQUpRdW9YNTk2TXpDYWdFMlVxYlpOcEMra2tFYmx0Ync0UjBja1IxbU9OUVowWU1mMjdERHdtTjBmMHpyZ1pXNjQrblJ3Q1Y1R2JRajBVZlo1eEdDYXV0NExuTG40V1lBQ2VKempTQ2Q4bDJRQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+WFheWAvOiusOW9leaMiemSri5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWZRQUFBQnNDQVlBQUFDY2xFQVFBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzJOMEl5TUVZNE5ETkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMk4wSXlNRVk0TlROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pZM1FqSXdSamd5TTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalkzUWpJd1JqZ3pNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCthcUgwYUFBQUtGeEpSRUZVZU5yc25jMlBOTWxkNXpNaXM2cjdlWjU1WnZ3eXF4Vmk0QWluUFlGdkhEQUhWa2pJZTBBQ1dlc1RJTm1BUVdKUENJRVAySHZibSswRENPMEpzSkU0SVhGWXRGcXY5cmpBSHdCWEJuRmd4alB6dlBSTFZXWUc4ZjFGUkZaa1ZtUm1aSFoxUDkwOTMrOU1UVlZYWjFWbFZkdjFpZTh2ZmkvcXN6L3p1NFZTcWlqc3YvaVAzTVlQQ3JlMXZkYis5K0cyWEd0NzN4ZnMxUmZ0RHo5dDcvd0plLzJqOW9IUDdPMnp3cGlpYVEydVZrbmJsOWlVWlhIWDJqZE4wYmJySG91UHFDcjlaMlZsUnQ3ODZFZVNPdDdlMVpqMW55TkZVUlIxSDlWOXFWL2J5MnY3SmY4djlyNS9zdHo0ZTN2N0IwWFIvcDI5YnUyLzltNTNFYWFFbi9GNCsvTVAvOS8vNkQxclpmeVRxMEozTUE4Z0Y0RHIzdlY3OW5lL1phLy9xOUxsanlrUC9pSXNBanpZNUhZTHFLK2tJeDV2Z2E0T1A5M054OXZhOTFtdW8yZGxQeDl0Z1I2OWd5VFVwOTVMNzNqQTNINkdoVEozOHY0cGlxS291K2E2T2JQL1BiTzI3WFAyTy84L3FjTDhrb08yK1djTDh6OVhwdjJ1L2ZsOWdGM0ovZllJZTNGUVArWnJGWEF1Y0E0dzE0QjdHVjkvM2w3L2tiMytkZnY3cllYNXdjMkhSVUJ4Y1BrUTJOWmF4N3ZHWGNwRDdPdHF2UjVsd1NrUFlZbjdVNkJ0RVZIUTY5MjV4Z0prOEpvcUJlcnBaVXgzZkF0blh0eTlOWS9mQWlNREZFVlJ0KzBrdldtVEwxem52QzBCZmt3Wjgzc1czUC9OdE0yZldwaC9vekROaDZaMXJCMzdhcTRrdE80UGNEQXZEOWR5MGI5czRmcGRlL3RkT0hVTm1JdDdEeEEvaG5rQVoyVmRmOTIwSzkrbmp3b3NnSFlPTE1kY2NtMmFRcTFjUHlEVVhsWjZGSVNxV0JpQ3Q0dUx0bTFYbjg5TlFSN2ZSNmhURkVYZDFoZHZSQUxqTFp3QjRGdjM1V3ZhclFYaGIxcDMvTXZXbVgvZDN2K1hCcXhxdTJWQW4wV0hzTG0yVDJIQmRJQjVaUy9mVnJyNkduNE9JRmNlNW5LN2cyby9PSzY4czhaek5jVTZsKzZpQTNvVnZGZC9zQ3NpQWhvTGwwM1pYekNvWTFDclJMU2c1OHFqU0VHTmNJcStteHlDMlkrVlFLY29pcnBkbTI0Y0RKUUh1d1ZBNGZiUExRY3R3QzI4MzFWR2ZkOFV6YzhxVS95MlBhSlc3WWhEanhQZUFQVktWMDh0elAvU1huN1J3Ync2QU5ZbnlYVUxnZGlWRHh3MWZyMHBWYkZmNGRLeFQyQ3dMNzBDNU9FaCtGeHlRc2hHRXM5VWJ3R1I3YzRyUkMzMEtNQlRyK21jcnpsMjhhMEx0YTg1ajdVd1YvNU1EY2xOVVJUMVpvQWUvMWM1d0R2RzJtOW1oTmwxSS92bjlvNnZXVmE5WjIvOWlqM2s0aGpvaFhmYnNsZnVuSGxUNk85dExNeXRPeStVN0EzNzN3a2RENW5jWGJoOTZLQlZCQXo3Mk1ZVUFxb2xhZ09RSjF6ekhPdUh2eDg3dm01OGVzSEN4UU1XRzV1cVREcnQxT0tpZjM5L0x4K2ZUeTBoRjNYcldZQXh5SE9PWmRpZG9panExcjZSby8rYWc3M3lYNzVnb0V1RWE5d3hiZkdMMXJoL3o5NytKZUJyNE5CajU0MndldmtkZS8ybEJrNWRBZkJWTDlTdTR0STJmeFlwUnhreHZ5aEw2L3pyRlM2OUdFUUFiZ2wwYnJHeC9NbXJxang2M0JUWXg2QXVNRzljbE9DMk5SYnhjSGtVaGxDbktJcDZJMHozSEpKbzhhSCtUUDcxK0RSYUJhaC95U2p6SFh2cmE3M3Y5MTU1bXRhL1loMzZWeVdMSGM2NkNJNzhzSC91NE8xZHBGS1RNTy9BVjY0TG5XTS8rZUQwbDM0KytROHc3WEpheWQ2NVZxTjcrMnBCUkFHSmc3Y05UTW5FbDc5WGNhZkpkaFJGVVZRdTFROXNEZEZ3bEpSTFR0VlJ3bnI1MVhmLzg3ZStQT0JTMkVNdlVacjJuVUtGTFBaU25yQXhqZ0E2em1idjZ0WFZFVFNPd3R6K1VsWEw5NFZSeHo2V0hhNW0vc2s1Umx3cHNndFcxTXR2cXNQV2czem9DVXFxQk5qanp3anZiVi9mUHN4MStQdXA2Y1hGMUNLSWl3Q0tvcWczQVBhT3ZmckFabjhOWnIvNzg5LzhEejJIN2tQdTM3TGtmOWMxa0NtN2VuVEF4am5sZmplNUZNeW5YQ3JjYkxrd2kveTQvS3NQN0ZQSXJPakVodmRSbGFuSXhEallVNENFTTI5dmtlYXkzV0hQZFVrOVA2Rk9VUlIxWDhBK2dIcVhuRjc2cUhyNU9YdmptejJnMjh1UFcvdithNzBESlpUdTlzMmJ6c1dxckM5Nk5YSmtDb0p6cWx0emNvajNvd0RMZ1lwRU9LWEd0d0p5M0RxYytaclhYdUxLUzkyUEl1UUNXckUzSFVWUjFMMkR1bU55Nk56cWpMZGw5NjlhbC83ai9udGZEdmdOZTltRWhqR0hYdTZISjBUbEdRQTA1OHpUYnRRNVYybkFzdENsTnhNbGJ6RlUxMTZXTnI3QmU2aktqT2pFaEZ1dkxjelhOdHpKZGVXcHoxblJZbE1VUlQxTXFCZWV5UkdqdlNIZkNNT2RRMWVBK2xjNld4L2k5SEVjM3o4aElCUUROaGZtUTNlN1JNT1E5SlF6WHFPbEllOHQ5czRMTmJxNG1Idi9xTW5mM3hMTWd5c1BDWWc1SDlGU2w4NDFBVVZSMUJ1QWVzZGlOV2p5SnR6K3lycy8vMGNTaFArQy9lazl5YVFyRGhuc1NxV1JBQmcxaWJha0tzT2h1b2xrYW5Ib1BiemVxV0d5MUNWdkpNS2dGd012ZkE3WVB0alh0d1B6NE1yblBxSWxvZmVsaXdDS29panFkc0YrcUJyM21mQnVhL3c5c0J5ZDRuNnVpRWgvT1BxNFAzc0g5Ym9WTUlTd3Jsb0lEYmhjbDhFK2YvbzRCb3VJcVVYQVdzRHNGNVNMNFRXMm16THBZb2YxMjZsbU10aXUyTzJiVzNMbGcyWTBwci9RTXBudkw1V0V5QTV5RkVWUjk4V2xtOUF4YnJCL0xBei9Jc3JXZmlvQS9JRG5zYlMyR09xTlpMOHZoYmxBU0M5ejZjY05XVTRUZWw4U2JRKzE5R1BsWG1OaGVBaGgvVjE5ZXBpTEt5K1hkNWJqWGpwRlVkUURCbnVDMmZaNy9hZUI5WjhjMGxIMUhqamhuRkZEdlJEbUFZQ2JCYzFtWkxTcE9mSGVlWHRvWEpQamdyYytzMzBxSXBDQ09zcmlybmIxU1d2TlhZOThMUjM0a3NsM0szSWJKZ0k4SjQyS1VCUkZVVGVCZWZTZDNvK3MveVNJOENNOWdPY1o5SVB6M0RkKzlPbzh6R01uaTczb3Nzd0VPaHF3ak8xM3IweHZSeGxlYmtJY3puT1lOVDZhQkJkOWNIajY2MzF6VXBpSC92SDY2SHlXUTUyUXBpaUtlckFHdlE5NHkzTEV2Wi8zdi9JemFlN1Z0S0hibVptRitWQ3g2ODJCZWhMaUs1VmJBNDZYT051TW4yZTZPNTY3QXpBL1ZhMTVjT1hTb1c0RTBrdEQ2UXk5VXhSRlBXU3E5MGp3SEVEZit2RmJxNFZzOFRoN093Zm1vVjQ2ZHkrOVd6Q2NDRUltMHpiRERYZkpmeE5yaU42WVZ2dlA5YTQ1V2EyNURqWDhTeHZ6bk1pbE0reE9VUlIxbjlrdVg4WmJyZlZwdnBVUkVrZmlWeTdNZzg0M1ZSWVlwQVord3UycUJaZTJNVm13eFhtZGI4b3NWeDYvcjExOXVscHpnQnpaOVYyNW5GTExJRDA3WW5iOVhqb25zRkVVUmQwZmFZQ2lrdVNxRTBDOWJnVm1ZeEJJZ1JDY09yTlFuM2ZVMGZTMXhHV0oyc3orN2VmYnlzMWpIeUY0Nm01WjJKeWdQQzJVeWJraE1Fc2VwMjdDOTh6b0JtRk9VUlIxMzZ5NkRoRFlsT1hpdHF3cEFXYVk3WjJDK1ppanpjMTRYemUxUEFXa2VScTV6SGFkWjgwam1DT2ovUlN1SEl1SnNiL0huRXRYYWtXc2ZlWnZoVzBFZ3B5aUtPb2VPL1FlU0twUzRIcFR0MzY5cjNzalNhZGczcm4wN1h4TDJKQlJQK1ZPNXk2bWNNbHE4KzY4SEhlN0E3Q0hudkEzaGJra3Z0bEZ4TlludnFrSnlDNE92UzlaQUF4QTNxNllTRWRSRkVXOUlhQ0hML1ZTTXFsdjV0Yng1USs0cFZyRUpnR3ZYRjM2WElJYzl0Qk50STgraEhYdXljMWxudU04Tm43dmZES2tIMXE2TnFhNHZHR3RPVDV2dVBMTmlUcmlMWFhwOGZIaXhBbHlpcUtvaHdmMDRaYy9FdVZrLzNiRnVOTSsxUHRsVzhtSWRXaG1vNVc0MHh3WHV3amdpZk9hMHpZcURZdDVxRVlXR1pmWE40TTUzamRncmxQOTd4ZEEreVl1UGN5Rngvc2h5Q21Lb2g2d1EwODZWUXNhMUdEcmxmQnNmWmUwMFFZdWcrZDEyZHpUcjNXNXkwODRTN1dJdlpvSnQ4T2RueUVaYnVROTkxcW1lNWkzSyttSHp4VWdQeHYyaUovNHZFK1pJQmRBamtoS0FEbEZVUlQxUUlFKzVmSndHNERGL25hMTBxMERGSERxUjZ3WW1SVU93RTFwbitpSlB0WVFMblhjZnFhbitubTBsejgxMHh4dkNEQmYyemdHMFk4bloxVTNXMzJLdlV0Y2VvNHROLzd2RWtCT2psTVVSVDB5aHo3ZW85eDFTOXR1eWxVSmM1SXd0cTlIWHlnT1p5UDhQTGQ0dU1sd2xxa0JvNVhQSDhpQkppSUZhMnJOcGJiZExscENpSDBOcUpmQWY3ZzNEb0RqNzhHd09rVlIxQ01HK3FoVDkxQVFWemxSVGpYdHJGdHg2a1hHdnUrVENaY3VlL1BYNjdMSjBiMXRLcXo4OUt5YTZBUjNjT3Q0SDJ0cXpiRmdlSGErR2MxTm1NcGtYK3ZTRVZKdlBjUUR5Q21Lb3FoSERQU1lDWFB3UUtoNGpWdEh1VmdNd3JFcFlCaUdzdDJVazR1RHNVWEkxR1VLd3JKL1grcGVCQ0FsUE1mUzhyVFFEeDRMQm4yMG9GbVhuekQzMldOL3Y2NWRTMTZHMVNtS29oNi9xcVVQQ0NCQkpqaWMrbTdoQUpKTDc2N1BOdU9oYlZ5ajVTcjJ1K2RBdEFpSEl3Y0RzaysyWmNJaEg2SUN6dUhYeGNYQzZFQW9SNHVqR25qZXFUekIwZDhWeFdRZFBuNEhOOTR5d1kyaUtPclQ2ZERWQlBQVW9JRktieldnWGJsVlRyblpFT3JENWk3RHNIRTVVWmN1Q1YxTnV3am0wZ3UrU1VNT0VZRnFwdjU3RGN5ZEs5OUk0dHZZWWlIbDBudS9tMHBhVk9IemFQMkFuSVpoZFlxaXFFOHowTWRCTnBHWTVkRWlwVmViU3NMd1MwTHdnSG9Za0RJMlMvM3ArU2FaT0NaejJPdDI4cnlIRnh5ZkFoMmVIL3ZhQVphcGV2UDl2bDBFYzV3eW52TWNJZlp5ZkVHVStqeHovdzU0S3dpcG95c2Z3K29VUlZGVWRzaDlFa1orVm5kcElYYTlJUHY3NHFvdTNucXlFWWVjZWkwWnIycmRmMnJ2VzJVc09vcUp5RVAzQWZpdGc5VHhVdDVsMzh2cnEzMzJCNHBveFpNdzFDWGpNMTBDNFJCU0Q1bnFGRVZSRkhVd3FCblF5M1dUY0x0UHoxMmpsQnpPd2pGZlNKYzEwd0Z1K0RnQVB5VXNHbkpaaU5jWlcyUTh0ODgvdGlqQWFiMit5bXNjRThyUjRNeVBSdEtxUEpjK3RvQUs1NCtGemZXK0ljd3BpcUtvWXdidm0zUXBsOHFFVU9wM2FNNENzT1UwbzZrbkhIQUlmNGVRZUEvb2RTc2g1eHlGYk8raDNvcGdubW9pOCtweWx3VlB2TS9uVDdhOXBqUnJJaC9EaFJLY09BQXVVWSs2WGQzRWhxSW9pbnI4cWpBVURjbFVqZEZGdFVFaTJrelpXcEhYOEtTVW1tdmxHckRNWktzRFZoY1c2czlHM0RqQzJIRC91Y2xlVXdsb2NUUmhxb25NcTh2OWFIbGMvTHg0RGxlL3JucGpXWTh5MHFQNCtsU29YZmJHRzdjQVlYSWJSVkVVbFEzMGNFUEN1bnZzZjZNa3JTcktTczAya0prTkgvdWFkZXl2dStscjQ0QUtXZThCNnZGVDR6endQRU1uRC9ERjllckpPZDRtWGJjZTJxNm1tQW1ZejlXYTQ1d2tnejNLOEI5Q2ZZbHFuNm1PQ3psT1VSUkZyUVo2enpIRElWcjRWbVVwKzhHVnZlZ2xjQitRMWJWejNjaCsrWlRyRFZBZjdwc3I1U2F4QWFMeG9nRFBoMHp5cVlWSDJLZnZ2V2xwOGFwN3B4b2dtZ1B6YldnU280OFhCREhVNTF3Nm9pTzd1bUdTRzBWUkZIVTdRSThkY0dFWld5c0g5TzFJUnZnazZDUFFZUzg4N0ptUHVkQWgxRU1JSEJBR1NDOFgxb0tuemhidlkxZzdqNWQ1ZVRFTmN4enoxdm0yMkd4MGl0SFprcjF4UDFxV1lYV0tvaWpxMW9FZXU5eTJjZE81c1BjY3hweUcvZlFwZDM3c3RNdmk3YWRLblBCWUNCNVFsNUQySUJrT3JualltUTVsWEdPTERKd2Z6amxXNm5uRjdWL1ZrekRINDU0LzNYYXZaZExHTzdtZ3dLK01MemNMNDJRZkc4ZmpQenZYS0JSRlVmY1U2UEVYZGVQSGh1SUxmRnM1c0MvdEZLZTFMdDUrZGlad0czUGNHSUN5c1F1SGVKQko2Q09QeFVEUWk5ZTc0dlB2bkhjQUh3cS83eThLWExNYUV5RVoyd0JUemg4TENieHVQdHdPWVhlM0wyNmtBY3hEQnQyeU9leUVPa1ZSMUwwRytoRHVJVHkrYVJDSzE4WFpSaCs1MHhoeXd5LzlKMzcvRy9BZTdpSER4YjYyNEg3bjJUWXFMWE9QR1I2Zk8rQWt6Q0FQandsUXh3SWhGZnF1L0hTNU0xK09OcFhGSGtNTXgxMzdTTUthcVd6M0FkcGo3V2hUb0RhRklkUXBpcUllS3RCandlRmFKTnBydDljT1I1dHI2UkMrQnpnQndLRkxCclRoc045NTY2ejNkTS9PcStLVGdmUE8wZE5oc3AzOTU2T1hWOG1FdENmZWxldGVQZjUwRnJ2eENYanRBMGh5a3lZK3hhSEgvSGh6blhWVUpzd3BpcUllSU5DREdyOVAvS0xadWE1eENHL3IrZmFzcFY4RTRLaXJ3Y3h5Wk54Lzh1cTZCM1VzQXRDVkxleEhmL3o2dXZqTXM3T2o1OFg5NGJsdy9GbFVkdzVYK2JGOTNtRUhPWndMT3QyRjhya3BNQ24vbmdGd2dCejc5ZmNKWkIyc1BiaWxlVTRjT2ttNjdkTzlOcUZPVVJUMVFJRWV1elBzdGIrODNMa3d1WXdQMVYzTjloamZneXQrY2JIcmxiY0oxQzJjMzNsMmdEckMrNGdJdUtFa1poUm1IYVMzZlpqRDRROUw2SkFMRUw5R0dsVE9wWWZHTHhlWnJXSHZ5bTNIME81dUQwRGRmVjdxeEJTbktJcWlIaGZRaDNDLzhFbDBHNTlFRnllWXBjYTF2djEwSytIM3k5MGhrUXdBQmRRL0E2ZGV3RVZYMG9XdWFadlpOclVJNlo5dnl1NThBUE40YjFzbXU1MXRwQS85bk5NTVUrSjJHYlBhYjBQYWx4QU9vZTFhMS9iUDFkQWlVeFJGZlhxQURzQWFTUkM3ZmJBSGlLSzNPcUEwMXVwVktWZGFkbWFkL1FzTDhWQ21CcWgvL1BLNitPeHpsOVdPV3ZXUGZVOTNoTi9qaGNLbE5MRnBCSUJ4bzVxUFhsMzFuRG5lUDhMNW1PMGVPL2locE13T0RYZnVjRys4OUExOUFzVEhGa0YzaVcyRzBpbUtvdTRwME9GZVZWbmFDenFmbFlWUlpRRis0bUtNNmdCM3lpL3h2VzlZQTVlTFVEekFYdXJqWEhXMFpvVWpSMkpjYU1LQ3h5S1VqMkVvbFEvajd4SVR5TUo4OEkzMHAzZXdmaG1GOGdGSmpHMUZpRDA1YzExZXp6M210dmJHUTZoY3pzZkRlNm9ySDkwM1JWRVVOUXIwNFBoQzJOYUJUbnVvcUE1dUlmbXJBNTR4TjU3K0ZRYVJJT2t0bElqQktNZERVM0FlbjNsK1p1RnZRVzdCanRkRmw3WHpiU3RsYUNocis3ZVBMNDhnR0NDTjMwTTdjZkZOOTd1MzdmMUlmaHR5OFJxaGRKL2tkc3BNOVhJQWFyeGZMRWhDWUtBUDYvRkl3V2tXRW9vTEFvcWlxTWNJOUhrWW9jNzg0Q29EZE9CY1k2YmZKQ1JkZStjTklTTWQ3Vm5qUkRiOERBakRZYU4xTEp3ellJMXpRNmdka0QvekpYQjRMb1Rnbi9xeU15dzhjRHdXQXdpL1k4R3dqUkwwcEtiZWdueVhLSjFiSXl3MEVEbFEwYUpFSWhCcXNMVXhBOVc0VnY1TmlmQ25LSXA2UkVCUGY5RVgvUTV4UWtZdEEwZU03TW83R0FHMGRkUitOWWNOZ1BIMUh2dmdXcUlGYm02NTYwd1h1dE1oRS82amw5ZlNKUTdnL3ZENnlyNk9rZkd2QURnV0Z0Z2J4K3Y5OE1XVndCd0xBQ3dXNG5ONTRVUHFTNmFjeFJGNmwzRG5JZ3Q0ZkpkcDdnOTY2REFrekNtS29oNDUwTWRJcDh1NHk1Z3FxaWY5MXExdzhjaGVqOFAzeGhSSHBWOHk5dFE3ZnJSTlJWWTdzdENWZC9ES1FoMmQ1RDc0NUxMNC9OdFBYRE1iL3h6NHI1dFJYaFQvOXNtRnVQaTNuN2dRZXloelEwajlhamZkampVa293V29sYjdUWEtVUFR2dG9vdHBnMFhKZkhHN3FQRzl5M0gyTEpGQVVSUkhvdHcyU1FjSVpRdEhQcTIwSEQ4aUZ5SnZlWXhEK0RwREhGZUNMQzl3NXByWWhPdkM1NStjU3BvY0R4MzBJQk1oZWYyTUU0aDkrY2lYNzhnalZvNTg2SGo4MkZDWU1uWWwxdmkyN0tJU1pvUFlVQkIrYXd6V0p2OS9jZXlETUtZcWlQZ1ZBQnd4RzI0cDZHRllTVnRlOTQvWVdwZ0J6REEwMGNaRk9kQmV1RXgxZ2l4RDh4ajYyOVVOanNHQzR1TjVMWGZuenB4dmg3c2V2ZHIwRmd2YWpYSHZOWnpBanZkVFprSHBvZTh2bUJuOC9pcUlvaWtDZmJQczYxUkFXY0ZXRHM1T3M5T2puMmlmSUljbE5FdEhzQlFDU1VqeUY0VEd0MUtKakR4Nzkzd09FUTIxM3dteC82a0czSnVST1VSUkYwYUZQUWozVWtoOFdCLzNmUzhMYzA2MExsMXRuL3RTK25SKyt2SkpRUEk2dDBKNjFMVjFudGNoUlN4bGVoQzJ0VkxJV25icnBZbzVOYUNpS29oNEUwRU5XOTV3UTZqYStNY3dVb0E4dVVibUV1TG9aclhVUFdlK2h0bHRaT3krZ2J0em9VaG5MNmt2UVdobjFPcDRBQjBlUDhIMEl1VTlCS0dUd0k2c2RjOTFkYzVoVExvRGU3UDhnekNONkx4UkZVUVI2QW1MR09MZHQvQmYxNGJZWmdGYjEzSG5oTTlpSE1GOHJoTTlEOHhzQUdDRjN2TTZWOUl0MzlkNXVuT3Vodi9uejgwMVJOMVUzVUFXSmNiR1FsSWZMNVlMejBQNjVnL3RYRTFBOE5PMDVuRk40L0pzQTM2bTNDNWpsVGxFVWRRK0Fqakt5cGtEeGVHUEpCbEloUks2OWZWWkhZTDlMQUlYV3FFaHVLNzE3RGozWDRiaC82R3ZJVWJZR3NLT2NETWNCNmdBMCtzRi8rT0pTTXVpeGh4NTZ2Wi81YkhiVXJhUDczSnJXdHExZnJDenRsaGVQTkoxODN5TlQwOEtDS1JYZHlLK2pQMjFDSDJGT1VSUjFENEFPcUNtRnhpOElINHYxdm9OUkxlTWdDOEJHbDdqUUJDYUdGMEx4cjlDVDNWN0Q1UUxteUdESEJjY2JoTnU5YzBjby9kMTNua2o1R2lhc0lVdisrYk50RjFySDFmWWROK2psNnJxUnNqWUgrdHViYTU3VjF0V2tmSDcrUWlIK3ZIcVQ2R2JCbkgvK0ZFVlIxRDBEK3BzK0FmQUdUV09jYzlhOVB1NHhxT0NFQVcwWFluZjczdWo4QnFpampBMk5aSkFZOThvZUoyMWpyUXZIL2YveDdHbnh1YmZQaTQ5Zlhjc2k0S09YVjhWYjU5dGl1OUZTcXg2OGI1akZEdENpNzN1WUREZlhmT2ErcUxkUU1Nc3duWnNQR0VjVjVsdzV3VTlSRlBVcEFEb0E0Z2F4dUQzdktxci9Ub0VCZmRnUlFnL2hiVFNBZVVzbXRHbUJ0clJmQll6TjRUSDRlU2N6MUYzUGQxeXdkNDZFT1RTanFYWXVOSTlwYTBOSWJhVytYWGV2aFhwNC9CTVdFNDlOdWUrSm9YV0tvcWhQTWREalVMQzBUUzFsVTFoZ21vYUw2Zlo0MFo0VlRqbUFITS8xOXRPdHVIamNCcGpob0pHaFhubTRJMXlPYXh5SFkvQjdTWXg3c3BXT2NZQThacXk3UkxoQ3l0eWs1RzNRYUNaSXd2TSthSURYeFhraGt4NXdENUNqRzZVb2lxSWVKZEFCeGpMc2hXOWMrOVNwQmpQRGV2UVFXbzhUemdUbTFrMEg1NHdTdGRyUE5nOE9QOHd0YjlyRC9jaHNCN3lSeElidy9KbUZNbHo1SnhicVlYeHJMZjNpWFFPYXVQM3JFTlNsOUhWMzE5dk5tWnozZnQvZXlkNDdSVkVVUmQwSjBBSExNREswR293UHpWWG82WDY5YjQ0V0NIRGNNY3hmK01TNDRMN2RjYXAzamZzQjI3MkUzcThGNUs0SlRTblBoK2NJQU1iaUFlRjVKTlloSVcrVDJBWklaWVp2c08rL2NhK1BCUVlpQURndWxNaFJGRVZSMUwwSGVoaG80aHk1RDZQSGRlaVI4eDUyakl1YjB1RDJLK3ZJNnhFSWhqQjdlTXhPV3JvNkZ5Nlo3Uk43dS9nOWVyenZmYUpieUp6SGVjUHhmL0xxdW5jOEZnQTREbEdGWjc3bVBRWHoxS3dXbWNZV29nVit6eC92QnlOa0NYZUtvaWpxWGdBOXdOY05SWEV6eVVOemxGNDBQYmQ5bkhmYUVscHZUQko0OFo1NVVOTWU5cThEc0tlRTdQZEwzekVPU1hFQWRlZ3VCOGVQbWVrdmZQaTlPeS9qdXMwaFl0RE5ZMS93b1hiOTRxUFhjWlBnbklNUFd3SmtQRVZSRkhVblFEOTBORk5kNGxrSzhya01EeTRkd054YllGNU9sSVRoZGRGUUpvWTVIZzlISGVEdkZoVWpyMVdFUkRxWFJSLzIwVkcrOWxuZjZ6M0FGazc5bFRTcDZaOE1mbTdhcHZpb2JtUjZHMXc5WG05cS92bnhlUlRkbkhoZEhzYXhTamM3SDVGSXpZT25LSXFpcUJzQlhYc0FGbEpPVnZheTBVTWY4d3h5ZDRRZkpyeGRJNlR0RTlYR0pPSHU4NDFQUWp1RTZyRy9Ia05YMnNENjg1UHdkaHNOWDJtTlBCNFBSZWc4aE5aeFB4ejcwL1BEV3c5Ty9iVXZhMHU5SFVRRkVJckgvdnBVNGx5dVpJSFVKZk1aeVFjSUdmU0VPMFZSRkxVSzZJQzBqQnkxQUFmRTRTU1ZiLzJhNzc2bmp3T29KRUZ0QXVSUWFQQ2lCczVlZXEzNzBIbFllQlJLZFVERlBuVllKRWpXdXYwNVFGdjU0d01vdzl6ME9QRU52M2UxN1VySzVWS1NnVEdYYmJIeHoxM09KTTZaWXR6S3g4eDJrUWEzU0dncjArMjlOMUh0UFVWUkZFVk5BbDJTMmdUaWJtOVpGZE1qVDVkQVBCejArcXJPS3VuQ2Z2ZTU3N2NlTzNzd0RmdmZzWFBkRElCOGxMUTJPQmJ2TTVTWHlZQ1dpMTN4R2V2S2U2MVI3VzFYajY1NisvUXBzTCs4MkF1STRmN1ZTT0pjcm9ZVDZLUldINHNwUDkrOWFjT0ZaWEVVUlZIVUNOQ1BSN0RNd0djaTdCNERIdDNWZG5XVERHR1BPZk1BODlqaDR1bmk1aklCZW1Fdk9oZVVnUDkxTko4YnozY2RaYjNIQzRIemJkazF0aG1UVEpCcjNKNjhsTHB0K3JYMnVlNThTc3BQWndIZ2tVcGdqTzdnam0wRk5yV2hLSXFpT3FEbk9zZ3hKejc4SFg0T3ZkQno5NExoek0rMlZmSjFybjJUbWQ1SmE5MU5UTXNWOXI2dmRyb1g4b2ZyeCtMa3pBTjh1TUNZYytwQnJ0Uk5kZnZyeXpMaTgzNW5va1JBeVMwb1hLNUFsMVRYY3UrZG9panFVdzMwWHExNE1WNDNudVBTUTdKYlBiTlBIanZRSjFzSDh6RmRwbHl5NmtOT1paYkpTUUxkSUdCd2NiMlhRUzFqaTRCd3pCd3JBZE5RN3g1Qy9FdmRlVnhQUDVzNTc5K1BNajdjci8xOCt2YXdCMDlSRkVYUm9TOXk2UUFJWE9xU0JDNHQrOVhWMFdDV21FTVhnL2F2WVJId2x1OE1GN3RYTXdLOVdOanZ4alpBL0JwNGZqajFaNE5hY3hOQkhZNTR1SWMvcHJDZ1FZUUNwVzVhcjNQblN5V0xHaXpDZlAxN2dMdHNEUmlHNWltS29oNjdkREVCd3Fra0x5QVVTVm9BK2VzRWVDZFhFYjVaUzRCNTZuVUF4TlQrTzNyRUQydlA4ZEs3d2JGaDMxMWc3eStxT1BTWWozWHQ1Nm1IOXo4OEcyVEVveVorYWlwY2FwR0Q0VEhZaHcrZlRUK0VQdTdPajhHL2pzYUFPekx4Y2Q3SUlZaWJBVkVVUlZHUEVPaTV1QWhjYVgxQzJXVkdHZHBRcnNhODZ1ckhVOUF5dmxOYlNuaXNHWUEzVmQ0bHlXT0pjM3Qybmc1S29NYmRUTHh2cmZYUjhKWWNJUVNQQmMvbGd2YXZxYjN6OUlKckNkMWRpTDVFZ3AwbTNDbUtvaDZicWhnT09YdnBBTzNhNWllQU9STGdwSDY4T002dUQ2K0Y4UGJZUHZ4d3YzenBXWXp0dCtQMVhyN2VGYytmYlVlQktXVnRQaE4vbDVtOUg1NEh4Nk5YUGR6K1dWV091dk9jdmZPa3cxLzQ5M0IxL0lWa1F4Z2ZrbWZXUEVWUjFDTUEralNRWEtMVmNQOTVMY3lMeE1JaGFMZHZSbUdPeDJ1OXpGSU9UeGVQUnhlNlZQYjYzdTk5YjZwcEY3NEc2aExac0I5ZUFEdWN2cXMzUDczV0xISkNpVndNOThWUkFJcWlLT3FOU2M5QklkUnI0N0wyeXgzd0NoQXNFaUhrY0UvcjI3S21vZVAydndVMjV0Z0JMMUZvQ1p2U3hWVnR6Nk1kWGRqRVVGOGFmby9CanR5RFlTdmJxZGViVzNDZGt2YWhoMys0SEEzZ29TaUtvdTYzUTQ4ejJVUHprbnJoSHZrUURKZzlmbFF6bmtpWkQ0MWN4a0w1U093cVM3VUk0bVBIaEVTeE1JSjFDRnQwdHBzYW5ScUVXblVjYzcydlZ5MTJRa1o4NWMrbjF6ZC9abHhyTnI4bkV4c3ovNDRoanFLV044ZWhLSXFpN2dqb0lmczdCbHFMRVo4U2VsMXZ5OEJDZEZEYmRKbnMwMk5XOXpNRFcrRE9SL2UvUnh3MTd0OFVPZ2tnUE4rK2FNZEI2K3ZKNTBDSXNqWndlR3B5WEE3WVVUR0FaRFhzc2VzWk81eWJOTGVVNEhOT1A0QmQraEFvZ3AyaUtPbytTY2RmNXNnS3h6NTUzZHlzWnppQTlDU0MrUnlaMEVMMWNsZFB3RHpkelMyY2Q4cHBoMFZDS2tRUG5XLzdrK1NHUWpPWk5oRU9UMzBzTGo5Z013dml1WThDZS9qU2RhN3VaOXpuWnJhYmhZQmVHK0VZTHR3WWpxY29pcm9uUUc4eFJheTVPY2dEZkJHS0R2dmRRMENZeEREeE9YY3IrN2dScE1JbFFHek0yZGQrSkdrYVJHb1N3SGpZc0plN21hQWVFdHhrQXB1K0dkMEU3TFdiRmxlM1p0SlUzd1RZcTBQNEJTMDVSVkhVL1pNcHRJU1hUelRGQ3pCRG1EMEdaZXA1NC91dWRzMWtxRDJFN3RjQ3pVekFFTTg3NVM1cmNjeE5zdGxNYW5VaWtZbXphbEVEbWpHRmpQZzQ2LzlHN3R4TWZ5YkgwK3I0ZncrS29xZ0g1ZER0Ri9uTzF5bmRTSUJZQU9UUXhZMUJYWnhvUnVtWEx0V05UaTkyOWJHN0x6UEt4aEFDcjRjaC9XVG9QNEw2OWpSUWg1Q2N1RThNdXpsbFpudDJOdjNJRXhIK0ZFVlJiOHlZaHkvaEhhanpzdit0YjRxbGRNZGVPVExaZTFQWE1xQytxK2N6NkdOM2JsSm5kME9hbkcvblMvR2wzank4emdUTTQ2aENWZzdCUXJBSHQ5N09KTUlaRXBhaUtPcXhVM3hJZ0pmWTZQNVhFeDlrbGpFZDBBcjEySFA5eWVNbzlkVyt5U3FKcTdTZWZEdHpQZVNSY0RkMy9uUGErOUI3WWNiZlQrbytMQmJXMXFxUENaL1p2dlo5NmxlNDdady9LOWNERkVWUjk1emw1dkNOTGpTd0xMYzBNLy9ZVVNoS05NdjUrajhhRTFya0RSMEowOGhtRndzbzRkTFRoS2xuZ0EwWW04Rm5FRitrVmo0RHV0ZXlBSm11dzA3ZHQ2Mld6MjdQQVc0TTlwc1FuT0YyaXFLb2gwVHo2R3U5WTdmODhJL1lRLytIZ0RkempQOVJBWUp3dHlZakJEMkVnYmpkRFBYMm9VZnF6NW9abHovM2V4Qzl5c3hNUnhlN09WZWVldCtiVzRCNkRIYnM4YWRLN0FwekduZk96SGFLb3FqN1o5RmpabHNXL3oySS9JUEN0RVhmcGZ1TE9jWUFIQzNnVkUxME5adUNPcExNY2dhN0lHTStHVzZQejlQM21KOEVlc1pZMTJHWHRqSGh2SWV0YWNjQU9JUmduRFI0YXVHOEF0aVhzSmQ3N1JSRlVROEk1Q1lDZW8rRnd2QWZXR0syLzkvZWVOOUkxN1MyZTVBWmdUbGF1V0xBU1U0aTF2Q3V2UytSeTVIMi9kYkgzTzlpSzV0WURJU0w5SW5QVEdERCtlK2JkdGFWcDE1ZUd1UnNxaHMxb0prRE84NE4wL0RNaWR6NUtZK25LSXFpYmdaMTA5cy94NWF5d1B4OWUvdnY0TkF0QjlvL0M0UXlRdnIyeUtVRFFnSG1ZNUNZZ3JxYm9WNW5keDhiSnF2ZEdPeG1Qamt1aDdONG11dVIyZVpUTU84V0tzcTFpNzFwQTVvNXNLT1ZiRWljVzVNOE4vV2VDSE9Lb3FnMzZjNWJ6K3FPMjMvMndkOStvOVVlNE4rMWwxMFhlaS9DUWU0SkFKOU5wYVM3MnB6emkrdTg0eS8vWFozZnZBYUxoM0lzdTMxZ3NHL0M4dmg1OEI1em5YTm8raEpETHdmbTNZS2xjRGtJdHdsMXZIWUErM0IvUFNlYVFsRVVSZDBUbVBmY2VSeHlGMzd2aE9GZ3A3L2pmZE0yZityZzN0Z2ZnMHR2eFZGaXY5dzFYMDNQeUo1alFaZ3FscXNxR3VneUJScm5RT2ZLdEl5QUxSVnRQM0xwVlg3aTJyN3hvZmRNQnp0YzZBU29WeWVzVmM4Qis1SjljeWJEVVJSRjNRT1lkOUJ5YkhhTWJzU2xXM2IvencvKzlnL2Y3NER1WGZvM2lyYjVNRDZ3OGpBM1hTaSt5SVo2QUJoZ2t0TU5yZ09kMzZkUE9la2swR2ZMc3VaTDI0SlFZclprZXh0YkNNZnVOdzN6c1RVWE11QnZHK294MkZ0amJqeFBubTZlb2lqcWJtRXVCcXNOdlBiRzJ6TGIzdmlEOEFodE90dHVZVzZhcitOQS9Gd3E3SnZqeTcveDRYZi9oSkhsejNIcSszclpQUFd4UmpJeExNT2x6U1JMem5IaE9hZGVQL1dZWFRUUkxWMmJQait4RFVEZjNBSFVVMkFmM1k2Z082Y29pbnBESUk5WTI3RzNEYXp1cmkyZmY4ZTY4dzg3b0llREhPM2I3MXY3L3NmYTJucFZJRVRiK00xM2Y5MDY1eDYvV0dvZWQ3aG52ekRVSGh5cmlmNlpCSFdiQ2ZUV2pDVzRIMEZ0YkFiNm1Hb2ZlaTlHSWhSek1POHk0TzhRNmpIWWszdi9FNTg3M1RsRlVkUWRnTHhvdlpFV0p5NFg0Uyt1M2VWUFB2aGZmL0FYUFhQb2dPMzN5QzI0UzZWK3g4TDhSNHEyL2xKSWl0ZXFMSXd1NUJoNUhkZStUZUxqeWpoNHFUaFdyVnc0dkc2YVJXK245S1ZxL1Y1MThiNnpTbjhBdVI5VWh2RFd3TldtelNmWHZxN3RZdzdsYURrZ1Q4RlJoc1hZNXpqRkdOc2xZTWRuTEhQTkQwTnFDWE9Lb3FpN1pIbkVxcTVzM01RWjdjMEI1cWI1YS92emJ3K2ZwZ29wOE02dUt4eThNMHA5MmY3NFYvYnlDeFl6UlN0ZjlnQTRxTzdpK1BMMWo1bm5SUVF4NVlHTVNXcjdabkhqRWpkRGZjSWRGcGt0MmhJa211OXhibm9MaTJaQlpFRkM3N3Q2dElXc3lRQmpPRDk4Zk1oYnVFdW9EOEUrL3o4NmlxSW82bVEwTjBXL1U2dGN1V2g0eUdzN1JNbWJ2N0dHKzh0ZzlUSFF2YlhYVXBMV09sNDN4WVZGOTMreDkzemJQdDFYNVU0TGRybFdEdHlBdTdIUTBlTFdWWHhlNG02YmRsbW9IVStwQyswMi9hUDdwdFMyZVlzR0NibTMrZGx1T2hUc0x3QlkzZUI4VGJHSjl1RE5FaVlPTXVBbFN0Q1k3RHlCVTRJOTlkblRuVk1VUmQwZTBBKzNnMHNQZGViTklhdTliZjRZenR4ZTd5VU1uM0xvTWN6eEhERGk5dGk5QmR2WDdDLytiNkhOdCszMXUwWWpDMXg3cDk1S2lMYkY0NVR1S0NEZHl2Yk40cmVFUFdRMWdHaHFMR2tQMGsyVFJScHNLZUJRblZuM2pjTksrN25VQ3hjbCsxMVRxRTA1K2pwTGsrYTBySzd1SHVyRGhZZFNkT2NVUlZHM0MzVWZKKzdLMDZKd2U5dDhnQVE0Qzc3dkdSUHRwdytCTHV5UmNIbmhvQzVPMzRWZTRaV1ZOdCszdi9qZmhXNi9XWmp5ViswZDJ5SzRjdVV1Q0xzRDZqaWR1akdyZW9UamRUSHFWRTNZOHZoWkd3RmRYdWM1dkcwQS9YZ1BmbUx4VVBoa3dJWGE3OXZaQ1hSVE1COStKcTdTNE0xQW5lNmNvaWpxdHAxVFZKN1dnYjBEK2c1MTV2YjZENjJEL1NEMGlBbUo2a2RBZDF2ZkI4dHZpdmJRUXFiMTlsK2JEd3FqZjhOQy9iOWJvSC9kR1AwVkMvQWZkU0EvUUYzS29kcDFNRmZHYnhPTU9QSWpTQWVIbnZtWnRRcFFYQkIyeCtmUzFvdU5LVDdpR3NtRm9Ubk9DcEFQajlYK2o5MlNyQlJGVVk4STZORTRWSE5vNjJwdi80dHJ5ZDUrUnhxL2RTVnJiUkhmUGdKNmVKNGgxTjNRRWd2TkVJZlgxblVhL2I0Rit1L1pYL3krVWZvTEZ1WS9aNC82S1h2OUUvYUk5NXJHdkdVZnZqbGdPaE9lYUY3VGpCZExwY0RlSW1tc3lRZGNxOXBGUUhkUXh6Q1o1UkRkeTA2QVRyYVNIWU81bWJIR2J0Rmppb1c3QUJSRlVkVDl0T2FDQzN0NTVZYXJtSCtTY2ViRy9COE1XdkZ6VmlLUVI3WG9SVG9oL044RkdBRC9mRTMwQ3dxV1ZBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Fzc2V0cy/liIflm74v5YWF5YC8L+Wdly5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUhRQUFBQS9DQVlBQUFBeEJleUlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlwcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1Tmkxak1UTXlJRGM1TGpFMU9USTROQ3dnTWpBeE5pOHdOQzh4T1MweE16b3hNem8wTUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFV1TlNBb1RXRmphVzUwYjNOb0tTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzFOVVJGTmpGRlJqTkdOVVV4TVVVMlFVTXhRams0TjBaR00wRXhPVVkwUmlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvMU5VUkZOakZHTUROR05VVXhNVVUyUVVNeFFqazROMFpHTTBFeE9VWTBSaUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2pFME1FVXhPRUUwTTBZMVJURXhSVFpCUXpGQ09UZzNSa1l6UVRFNVJqUkdJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPalUxUkVVMk1VVkZNMFkxUlRFeFJUWkJRekZDT1RnM1JrWXpRVEU1UmpSR0lpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCtDaWJydUFBQUNwaEpSRUZVZU5yc25YOXNFL2NWd04rZHo3OGR4MG1nWXhEYVVFWXFUWlFXMW1panFLaFRTYXMxbzZXcXlxcVZRZFdvQlRaYXRYKzBVTFdqUXRYYVAxcXRHaTJNZG9LMWhXbEFrUkJhUWFpdE5xa0krSU1mQVJwRUNMOUZnSkNRMkU1c3h6bi91TDEzOS9WaEo3WnpOc241WE80cFQyZkhkK2V2MytmNzN2ZDkzMzE5NXE0LytTUVVLVHhxQStxdlVSOUFyVWVkaE9wR3RZTXBXbVFRTll4NkJiVWQ5VERxLzFBUG9TYTFuR0RLQlUvR2M2R0lSdFNpL2duMU9kVEpKcE5iRWp2VGF0UjdVWjltLzcrTStpL1VkYWdkaFhxWlZxbGhiM0FPZFpVSmMweGxNclB4T1diem10RUd1aEMxRGZXUHFEYlQzcnFKamRtY2JQKzcwUUFxWUNEZmdOdHRxT05NKzVaTXlQWmJHWXU4dzZRZzVYN05oYTl0NXdDYUpOT2doaEJrc1JTaDFuSkt4SXdVNHFGQ0FyMlNZSnBtTkJ6VXBvUVNNUVhOUVBHQTlSYUEzNXJtTTZZUUcyS2tDZWlnQkwvSEExNDB6V1o0cUM4aXEwWERQTGp6aVNmVUo5MEpibnlOUldyamxYbVJLUVlYekczOFYrTDh6K2QydUR1emVxaVhsOTQzWVpiVmVGbzEzcEw4UzBiSWxSVFNjREhHVDdWeXNDVDEzTlR5VUdTMitMK1R3bE16UEhUcXhRb09RKzBLcnJoU29DbWw5VktCMkNrUEdkQmZPaEoySnljOWE1cW5QSVhZRVVNVjZPcnE2QndMQnhOTTA1UnB4b3ZzaUtFTUZNTXQ3K09sUmtNMmRNb1U4SzFaQTNkczNRb1ZLMWFNNlh0VnJsd3BxL1crKy9MdVI2OVRlMnJXclFQWE04OFl4bGJJY0I3eEpBKzEybm1ZWmNRQlAzN2hBbkF1Ri9CT0o3Z2JHMEZBWTQ3RisvRFljWndQUGlpclVGK2ZkMSt1b2tKdWo3VzJGcEtoa0dGc2hReC9RU3dKcU0yR2VaRlJ3MGx3L2MyQ1NPVkxMNDNOR1BUd3cvSTJPVEFBMGUrK3krK2gwNmFwajhXMk5zUFlpVEcwQ1RKUVRqTHNsWlFFZW1ua3dBRndvZmVRVjFDWWkzejExYWkraDJ2dVhIa2JiV2tCeDd4NVlKOCtQVGZRTysrOE9XOS8vdm44YmUvdWhyNVBQdEVIcU1KUUJtcmxPWEFaZWREdi8rd3pjTXljQ2JITGwwSENNRGVxTUxHRFdLcVZXa3BrNzE1d1B2UVFPTzYvWDlPeEkrMFg2K2pRelVhTW9WV1FreVJKRXZTNlJGYno0WWRncjY4ditEZ0toM1FjcVcvWk1rM0hSSThkZzk3VnEvUHU0M244Y1hrNzJONE9JdTV2bVRnUjh0bkMwOWlvN2grN2RDbC9tOE5oa0NSOUxNdHFDQlloTlNIVnJTZTVpZ3NHbElpTXRuaGVlRUgxenRDdVhmSjJZTThlR01peHY0REpVd29vN1QrNGI1L2g2Z3k2QXcxOS9UVllKdVNlOHZKdXQybzBlZjl2djVWN2VqRVNPM01tOS90VVZZSG5zY2ZVMEtnRmpxVzI5dWE1VzFzTldUalN2ZFJISGpCU1NFNkgyZmZ4eHptOWhmTjZJWGI4ZUZIdDhDNWRxbnI5d09IRHcxOS8rZVhoQ2RGZGQ2bmgzN05vVWQ3ejUycjNXSXNNMUNoTFRDb3dCS2JHVi9LYVlBNmp1QmN1Qk8vVHlvckhYc3dpQ3cxOWRreDhLR3RPRnluSFdKa3IvT2Q3WFo1dWxSS29FWVNNN0Yyd1FQV0EzZzgreUIxS1Q1OVdEVHZ1OWRlaEZ5ZjdJM2wrZXFqMU5UZHJibGNZcDB5SnJpNU4rMXJyNnNDcE1VUCtVUU9sOEZtZFZ0cnJlZTg5dVVxVVMwUU1zOTJyVmtITk8rK0FnRWxOTldhOUFZOEh3dHUzai9oZTFXKzlKUitqVlFaUG5ORGNXU2pDbEJvb2J3U1lCQ1kxbnQxQXp4UTFqSXNFdkdmTkdvajM5c3JQZlRpbVVTak9KNVU0THFaQytnQk9VWDZNVXRJeFZQWk1ESmtwai9GdjJRTFJQT01oaFV2MXNjOG50N3NmdmFlS0pTZ0VsZjZYeTFNNXQxdnBETmdKL0I5OUJNNHZ2bERIejF3MjhDMVpJa2NBclhQbFhHT3l2aUZYMHYvdFhUaWg5NkpIQ1RYS0t2OTRUdzg0cGsrWGxlYXFxZmtxaDU2YjJrZUxFTnpFMWF0Wk8wWnd3d1p3WXpMVWl6Q1R6TFBWenovYU5wQ2tFZ0l0Z1Robno4NEFSWThMQVpkUHhyM3hCblQxOTh1Vm53d1A4dnZoNnVMRjhsYXJCRDcvSENJRmpLR1ZUejExZXlaRkF3Y1BxZ2tFaFNvYVExTzFUeXVid0pQWERodzVvaFlXRXAyZFVERi92bkxwQ28vcFdya1Nrb0dBQ3N1Qm1UTEJsSk9mVjErRnppekY4MEpnbW1Ob0FSTEdYcDhnTDJwdHpUQXlqWk9UdnZ4U3lURGIyaUF3WkQ1SG5rMUE1UTR3SkJNZXdEQWJuRFlObkEwTjRQLzAwNEkrVjY1OTdUTm01SzFzcFlzTmN3SmpqS0Vsa216am5DM3QwbFZjNC93dm8wS3phWk9zb3lYdU9YUEt6ME9OSkxiMEM4aDVhckc2UlpMOSt6VjNMUEpRczdDUUoyeUpCaWlBUjArYzBKd1VlYzNDd3ZCNXB2MmVleFNZbUNEZFNnSkRDZEx0S01ZcXp1TWNNbFV4aWh3NmxMVmRrb1pFaG1ROFpydlJCUXNnc0huenNPbEx0blBtT2xjVlpzbzF5NWViaFlXQ1F5MkdLdStqajZxR0NlM2NPWEs3Y3J6T3M4cVRvNzRlYktoaVM0ditoWURicmJDUTBZaTc3NFp4cjcxMmN6Sy9ZMGRtSmFmUTBPM3ozY3lVcjEyN3BiYjFVbUZoOTI1dFkyaHpNL2lNVUZoSTR1Zm1Td1RYMWRRRTFSalcxRkNMNFRHMGJkdXRmYWkwbFFWeEhSZHFsVktJb1FvMEprSFV4b0ZIendhNEVhVG5rVWZrc0pnU2d0bjk5dHY1RzU2MkhNWDN5aXRabDZlNEdoclUwQjA3ZjE1ellhRUt6emZzWExObmcyMnF0bVhMdHJxNmpMYWwyaHZjdUhITTdVa01VMENscU1UNWJaeWtDOUNhTjk4RTE2eFpHWXUreVBCOWUvZHErdUEwamZDd3lYNXF6TTBsb1FKWE1tUTduNnZJYVVqcVhKU3Q2d0dVR0JKTEdXZ3d5VjN4OHBJdU41SktCMElnSTBlUFFoQkRiRnlqSjRWeFBCTW1USkM5MEpZV1d0T0Zhc0RSdGpid3IxMWJVTnNpWTNDTnRKaHFWekZDREZOQUU1MEp2bjJ5a1B5VkxwVVhCb1MrRnhLbUZYMUZKRC9VNDBlajEvZDk4NDNpUmF3aU5WSzRON0pjUlliRWtvREdEZzhLaHgrd3h4ZnI5ZVlCSFVLUXBneTJRQTgyc2h3ZEZPaUdqekdxRkluLzZMTWZpU2d4MkpReUZHS0hESThTU3hrb0RxaUJrNkpsdjJtYThoUmlSd3lKcFJ4eWFUaloyR2ZmT1d0YzdEY1crUlk0cHBTTEpQQ1AyQkZET2VTZXJQWFRqWGI3OTBXdHAxdEZZWjlwb25MelRtRS9zU09HTkhIZ1djV1Jxc3BkNy9wZFc5QjF3K2J0WXNwRGlkVWF2MnN6c1dNTTFjdG5GSFo3VHNVc1ozYUViZjgyKzMxNUNMTGExaGF6MEhTbGh6RlVnTGJXK2drNGZaTzI0LzJBYTg4eFVUaGdtc3ZZY2h3WklTdTZhdERCMkVucEhrcFFSWnBibzE1YWZzT3o4VnpNY3RJMG16R0YyQ3hEUnNTS01STlRydzFkc1VBMzFiM2NuK1RPTnQvd3JMOFl0N1NaNWpPV25JOVpUaEViWWdUS2p3MWszQWc1QXloNmFZSUtPZFFKYmlUNDB3dXZWL3l0UlJRT21tWTBoaENMWjdzcTFoSWJVSDVnd0svTVhOS0FEczJjZnFqMXg1Z2J0MGNrN3V3ZnVpbzJiZXAzbU5sdmliUFpmeUlEWW9GTXFQQk1pVkEzWTVVaFdTOXE0NDdpdlIxVjE5bjV4TDhHbmVLdWlPM1VuMzJSK1RQdDhRYmVMRDdvSWtuMHZwWkI0ZEM3QWRkL2NOeWs1T2NpODB5Q0tXWTdoanZIN2dLU1RSQ3FGVGUwbm9NdXJkSDMwZStZWVl0UFhPNk56a1d3TTkyY1ZHbWFmZlFsTEhGQkJObnk5ejdIOXlkRTRTcWJaMTVpWTJZZzNUT1JrWGFnN0FEeVJ2b3EySGhRZmxYcHB3Ulo0TURWNUJLbnpIWEVmbFluSkdwcmVHbThoNWNxclp4a016MVl1d2ZHSkU0TUpibGdUNUxyeGlTMDQvdW85ZXp1aU8xQ1hKS1RIY3BucnJHcENRMkRrUitVUEFlS0JwcDJJUDBvREsxcW9LK0kvWVJ0dmFnT1VINHdSbURLZ2M1M1ZpbGpVVzlyeUpUQ0tDMGw2V1BGZ3V0c0c4b1ZZb2NCZGMxNHJwQUdFQ2dLdzdSK3BJSUI5VExRVGdiV0FnWmJ3RzFzSjVXelZKR1Y3a0lNSm1rLysxOE1DbGptS3hUUm8wU20vU3dNMkpoYUdVelRRd3YzMEFRRGw3SnRERFQrT3VGUStiOEFBd0J3a2JDeDlpSVl0UUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hc3NldHMv5YiH5Zu+L+WFheWAvC/lhYXlgLwucG5nXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGltZyBjbGFzcz1cXFwicmVjaGFyZ2UtcmVjb3JkXFxcIiB2LWJpbmQ6c3JjPVxcXCJyZWNvcmRJbWdcXFwiIHYtYmluZDpzdHlsZT1cXFwicmVjb3JkSW1nU3R5bGVcXFwiLz48ZGl2IGNsYXNzPVxcXCJyZWNoYXJnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWltZ1xcXCI+PGRpdiB2LWZvcj1cXFwiaXRlbSBpbiBtb25leURhdGFcXFwiIHYtYmluZDpzdHlsZT1cXFwibW9uZXlibG9ja1xcXCI+PGltZyB2LWJpbmQ6c3JjPVxcXCJtb25leUJhY2tcXFwiLz48ZGl2IGNsYXNzPVxcXCJiYXJjb250ZW50XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJhcmNvbnRlbnRcXFwiPjxpbWcgY2xhc3M9XFxcIm1vbmV5LWltZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJtb25leUltZ1xcXCIgdi1iaW5kOnNyYz1cXFwiaXRlbS5nb29kc2ltZ1xcXCIvPjxkaXYgY2xhc3M9XFxcImJvbnVzLW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcIml0ZW0uc3ViP2JvbnVzTW9uZXlIYXNTdWI6Ym9udXNNb25leVxcXCIgdi1odG1sPVxcXCJpdGVtLmdvb2RuYW1lXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJib251cy1tb25leSBib251cy1zdWJcXFwiIHYtaWY9XFxcIml0ZW0uc3ViXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImJvbnVzU3ViXFxcIiB2LWh0bWw9XFxcIml0ZW0uc3ViXFxcIj48L2Rpdj48aW1nIGNsYXNzPVxcXCJyZWNoYXJnZVxcXCIgdi1iaW5kOnNyYz1cXFwiZG9yZWNoYXJnZVxcXCIgdi1iaW5kOnN0eWxlPVxcXCJyZWNoYXJnZUJ0blxcXCIvPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm15LW1vbmV5XFxcIiB2LWJpbmQ6c3R5bGU9XFxcImZvb3RlclxcXCI+5oiR55qE6YeR5biBOiB7e3VzZXJpbmZvLm1vbmV5fX08L2Rpdj5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L1JlY2hhcmdlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIF9fdnVlX3NjcmlwdF9fLCBfX3Z1ZV90ZW1wbGF0ZV9fXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ydWxlSW50cm9kdWNlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/cHJlc2V0c1tdPWVzMjAxNSZwbHVnaW5zW109dHJhbnNmb3JtLXJ1bnRpbWUmY29tbWVudHM9ZmFsc2UhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcbWVzc2FnZUNvbXBvbmVudFxcXFxydWxlSW50cm9kdWNlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIilcbm1vZHVsZS5leHBvcnRzID0gX192dWVfc2NyaXB0X18gfHwge31cbmlmIChtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzLmRlZmF1bHRcbmlmIChfX3Z1ZV90ZW1wbGF0ZV9fKSB7XG4odHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcImZ1bmN0aW9uXCIgPyAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyB8fCAobW9kdWxlLmV4cG9ydHMub3B0aW9ucyA9IHt9KSkgOiBtb2R1bGUuZXhwb3J0cykudGVtcGxhdGUgPSBfX3Z1ZV90ZW1wbGF0ZV9fXG59XG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7ICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgdmFyIGlkID0gXCJfdi00MWFmMWFlZC9ydWxlSW50cm9kdWNlLnZ1ZVwiXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChpZCwgbW9kdWxlLmV4cG9ydHMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnVwZGF0ZShpZCwgbW9kdWxlLmV4cG9ydHMsIF9fdnVlX3RlbXBsYXRlX18pXG4gIH1cbn0pKCl9XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL21lc3NhZ2VDb21wb25lbnQvcnVsZUludHJvZHVjZS52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcnVsZUludHJvZHVjZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9ydWxlSW50cm9kdWNlLnZ1ZVwiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLXN0eWxlLWxvYWRlci8xLjAuMC92dWUtc3R5bGUtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcclxcbmRpdi5pbnRyb2R1Y2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZT80ODJjYmRiYlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtJQUNBLG1CQUFBO0lBQ0EsZUFBQTtJQUNBLGNBQUE7Q0FDQVwiLFwiZmlsZVwiOlwicnVsZUludHJvZHVjZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LmludHJvZHVjZSh2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiLHYtaHRtbD1cXFwicnVsZVxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcmVhZHkoKSB7XFxyXFxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5ydWxlKVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXFxyXFxuICAgICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHJ1bGU6IHJlcXVpcmUoJy4vLi4vLi4vZGF0YS9ydWxlSW50cm8uaHRtbCcpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICAgICAgY29udGVudCgpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODAgKiB0aGlzLnpvb21SYXRlLnkgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA5MCAqIHRoaXMuem9vbVJhdGUueSArICdweCAwIDAgJyArIDM3ICogdGhpcy56b29tUmF0ZS54ICsgJ3B4J1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuZGl2LmludHJvZHVjZSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9tZXNzYWdlQ29tcG9uZW50L3J1bGVJbnRyb2R1Y2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI8dGVtcGxhdGUgbGFuZz1cInB1Z1wiPlxyXG5cdGRpdi5pbnRyb2R1Y2Uodi1iaW5kOnN0eWxlPVwiY29udGVudFwiLHYtaHRtbD1cInJ1bGVcIilcclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgcmVhZHkoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucnVsZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BzOiBbJ3pvb21SYXRlJ10sXHJcbiAgICAgICAgZGF0YSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJ1bGU6IHJlcXVpcmUoJy4vLi4vLi4vZGF0YS9ydWxlSW50cm8uaHRtbCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NTggKiB0aGlzLnpvb21SYXRlLnggKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTgwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDkwICogdGhpcy56b29tUmF0ZS55ICsgJ3B4IDAgMCAnICsgMzcgKiB0aGlzLnpvb21SYXRlLnggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuZGl2LmludHJvZHVjZSB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBvdmVyZmxvdzogYXV0bztcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbn1cclxuPC9zdHlsZT5cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogcnVsZUludHJvZHVjZS52dWU/NDgyY2JkYmJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuPHA+MS7ku4DkuYjmmK9QS+aLvu+8mjwvcD5cXHJcXG48cD5QS+aLvuaYr+ernueMnDEw5Liq5byA5aWW5Y+356CB5o6S5YiX6aG65bqP55qE5b+r5byA5Z6L5b2p56eN77yM546p5a625qC55o2u5LiN5ZCM55qE546p5rOV77yM56ue54yc5LiN5ZCM5L2N5pWw5Lit55qE5Y+356CB5o6S5bqPPC9wPlxcclxcbjxwPjEu5LuA5LmI5pivUEvmi77vvJo8L3A+XFxyXFxuPHA+UEvmi77mmK/nq57njJwxMOS4quW8gOWlluWPt+eggeaOkuWIl+mhuuW6j+eahOW/q+W8gOWei+W9qeenje+8jOeOqeWutuagueaNruS4jeWQjOeahOeOqeazle+8jOernueMnOS4jeWQjOS9jeaVsOS4reeahOWPt+eggeaOkuW6jzwvcD5cXHJcXG48cD4xLuS7gOS5iOaYr1BL5ou+77yaPC9wPlxcclxcbjxwPlBL5ou+5piv56ue54ycMTDkuKrlvIDlpZblj7fnoIHmjpLliJfpobrluo/nmoTlv6vlvIDlnovlvannp43vvIznjqnlrrbmoLnmja7kuI3lkIznmoTnjqnms5XvvIznq57njJzkuI3lkIzkvY3mlbDkuK3nmoTlj7fnoIHmjpLluo88L3A+XFxyXFxuXCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9kYXRhL3J1bGVJbnRyby5odG1sXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW50cm9kdWNlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNvbnRlbnRcXFwiIHYtaHRtbD1cXFwicnVsZVxcXCI+PC9kaXY+XCI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vLm5wbWluc3RhbGwvdnVlLWh0bWwtbG9hZGVyLzEuMi4zL3Z1ZS1odG1sLWxvYWRlciEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1wdWchLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvbWVzc2FnZUNvbXBvbmVudC9ydWxlSW50cm9kdWNlLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm1vZGVsXFxcIiB2LXNob3c9XFxcImRpYWxvZ1Nob3dcXFwiIHRyYW5zaXRpb249XFxcIm1lc3NhZ2VcXFwiPjxkaXYgY2xhc3M9XFxcImRpYWxvZ1xcXCIgdi1iaW5kOnN0eWxlPVxcXCJkaWFsb2dcXFwiPjxkaXYgY2xhc3M9XFxcImNsb3NlXFxcIiB2LWJpbmQ6c3R5bGU9XFxcImNsb3NlXFxcIiBAdG91Y2hlbmQ9XFxcImRpYWxvZ1Nob3cgPSBmYWxzZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29udGVudFxcXCIgdi1iaW5kOnN0eWxlPVxcXCJjb250ZW50XFxcIj48L2Rpdj48ZGl2IHYtYmluZDppcz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0udHlwZVxcXCIgdi1iaW5kOnpvb20tcmF0ZT1cXFwiem9vbVJhdGVcXFwiIHYtYmluZDp1c2VyaW5mbz1cXFwidXNlcmluZm9cXFwiPjwvZGl2PjxpbWcgdi1iaW5kOnNyYz1cXFwiZGlhbG9nSW1nW2N1cnJlbnRJbmRleF0uYmFja2dyb3VuZFxcXCIvPjwvZGl2PjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL01lc3NhZ2UudnVlXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgLy/mlbDmja7mqKHmnb9cbiAgICBub3RpY2U6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiAnPz8/Pz8nLFxuICAgICAgICAnY3JlYXRlZEF0JzogMTQ2OTU0Mzk4MDAwMCxcbiAgICAgICAgJ2lkJzogNixcbiAgICAgICAgJ3RpdGxlJzogJ3RpdGxlJ1xuICAgIH0sXG4gICAgb3B0aW9uczogWyfmipXms6jorrDlvZUnLCAn5byA5aWW6K6w5b2VJywgJ+a4uOaIj+inhOWImScsICflhZHmjaLnpLzlk4EnLCAn6LWg6YCB5aW95Y+LJ11cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2RhdGEvZGF0YS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL25vdGljZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgLy8g55So5oi35L+h5oGv5pWw5o2u5qih5p2/XHJcbiAgICAnY3JlYXRlZEF0JzogMTQ2OTU0ODY3NTAwMCxcclxuICAgICdtb25leSc6IDEwMDAwLFxyXG4gICAgJ2NvZGUnOiAwLFxyXG4gICAgJ25pY2tuYW1lJzogJ+a1i+ivleeUqOaItzIyMicsXHJcbiAgICAnb3BlbmlkJzogJ3h4eHh4eHh4eHh4eCdcclxufVxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9kYXRhL3NpbmdsZXVzZXIuanNcbiAqKi8iLCJ2YXIgX192dWVfc2NyaXB0X18sIF9fdnVlX3RlbXBsYXRlX19cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbl9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3ByZXNldHNbXT1lczIwMTUmcGx1Z2luc1tdPXRyYW5zZm9ybS1ydW50aW1lJmNvbW1lbnRzPWZhbHNlIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gc3JjXFxcXGNvbXBvbmVudHNcXFxcdGlwLW1vZGFsLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdGlwLW1vZGFsLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LTY5MWMwMzFiL3RpcC1tb2RhbC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC9jc3MtbG9hZGVyLzAuMjMuMS9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vdGlwLW1vZGFsLnZ1ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3RpcC1tb2RhbC52dWVcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1zdHlsZS1sb2FkZXIvMS4wLjAvdnVlLXN0eWxlLWxvYWRlciEuL34vLm5wbWluc3RhbGwvY3NzLWxvYWRlci8wLjIzLjEvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdGlwLW1vZGFsLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXHJcXG4udGlwLWNvbnRlbnQge1xcclxcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcclxcbiAgICBtYXJnaW46IDAlIDAgMCAzMCU7XFxyXFxuICAgIHdpZHRoOiA0MCU7XFxyXFxuICAgIHBhZGRpbmc6IDVweDtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAuMzUpO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XFxyXFxufVxcclxcblxcclxcbi5ib3VuY2UtdHJhbnNpdGlvbiB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgLyog5ZCm5YiZIHNjYWxlIOWKqOeUu+S4jei1t+S9nOeUqCAqL1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLWVudGVyIHtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGJvdW5jZS1pbiAuNXM7XFxyXFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLWxlYXZlIHtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb246IGJvdW5jZS1vdXQgLjVzO1xcclxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBib3VuY2UtaW4ge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2UtaW4ge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZS1vdXQge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcbiAgICB9XFxyXFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvY29tcG9uZW50cy90aXAtbW9kYWwudnVlPzc5MTg3Y2JlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTtJQUNBLG9CQUFBO0lBQ0EsbUJBQUE7SUFDQSxXQUFBO0lBQ0EsYUFBQTtJQUNBLCtCQUFBO0lBQ0EsYUFBQTtJQUNBLG1CQUFBO0lBQ0EsbUJBQUE7SUFDQSxtQkFBQTtDQUNBOztBQUVBO0lBQ0Esc0JBQUE7SUFDQSxxQkFBQTtDQUNBOztBQUVBO0lBQ0EsaUNBQUE7WUFBQSx5QkFBQTtDQUNBOztBQUVBO0lBQ0Esa0NBQUE7WUFBQSwwQkFBQTtDQUNBOztBQUVBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0E7O0FBUEE7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7SUFDQTtRQUNBLDRCQUFBO2dCQUFBLG9CQUFBO0tBQ0E7Q0FDQTs7QUFFQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtJQUNBO1FBQ0EsNEJBQUE7Z0JBQUEsb0JBQUE7S0FDQTtDQUNBOztBQVBBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0lBQ0E7UUFDQSw0QkFBQTtnQkFBQSxvQkFBQTtLQUNBO0NBQ0FcIixcImZpbGVcIjpcInRpcC1tb2RhbC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxyXFxuXFx0ZGl2LnRpcC1jb250ZW50KHRyYW5zaXRpb249XFxcImJvdW5jZVxcXCIsdi1zaG93PVxcXCJpc1Nob3dcXFwiLHYtaHRtbD1cXFwiY29udGVudFxcXCIpXFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgcHJvcHM6IFtdLFxcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICBpc1Nob3c6IGZhbHNlLFxcclxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAgIHNob3dUaXAoY29udGVudCkge1xcclxcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnRcXHJcXG4gICAgICAgICAgICB0aGlzLmlzU2hvdyA9IHRydWVcXHJcXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaXNTaG93ID0gZmFsc2UsIDMwMDApXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGV2ZW50czoge1xcclxcbiAgICAgICAgc2hvd1RpcChldmVudCkge1xcclxcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpcChldmVudClcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuLnRpcC1jb250ZW50IHtcXHJcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXHJcXG4gICAgbWFyZ2luOiAwJSAwIDAgMzAlO1xcclxcbiAgICB3aWR0aDogNDAlO1xcclxcbiAgICBwYWRkaW5nOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgLjM1KTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYm91bmNlLXRyYW5zaXRpb24ge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIC8qIOWQpuWImSBzY2FsZSDliqjnlLvkuI3otbfkvZznlKggKi9cXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1lbnRlciB7XFxyXFxuICAgIGFuaW1hdGlvbjogYm91bmNlLWluIC41cztcXHJcXG59XFxyXFxuXFxyXFxuLmJvdW5jZS1sZWF2ZSB7XFxyXFxuICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG4gICAgfVxcclxcbiAgICAxMDAlIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL2Nzcy1sb2FkZXIvMC4yMy4xL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjx0ZW1wbGF0ZSBsYW5nPVwicHVnXCI+XHJcblx0ZGl2LnRpcC1jb250ZW50KHRyYW5zaXRpb249XCJib3VuY2VcIix2LXNob3c9XCJpc1Nob3dcIix2LWh0bWw9XCJjb250ZW50XCIpXHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIHByb3BzOiBbXSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNTaG93OiBmYWxzZSxcclxuICAgICAgICAgICAgY29udGVudDogJydcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNob3dUaXAoY29udGVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XHJcbiAgICAgICAgICAgIHRoaXMuaXNTaG93ID0gdHJ1ZVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaXNTaG93ID0gZmFsc2UsIDMwMDApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgIHNob3dUaXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VGlwKGV2ZW50KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4udGlwLWNvbnRlbnQge1xyXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcclxuICAgIG1hcmdpbjogMCUgMCAwIDMwJTtcclxuICAgIHdpZHRoOiA0MCU7XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC4zNSk7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XHJcbn1cclxuXHJcbi5ib3VuY2UtdHJhbnNpdGlvbiB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICAvKiDlkKbliJkgc2NhbGUg5Yqo55S75LiN6LW35L2c55SoICovXHJcbn1cclxuXHJcbi5ib3VuY2UtZW50ZXIge1xyXG4gICAgYW5pbWF0aW9uOiBib3VuY2UtaW4gLjVzO1xyXG59XHJcblxyXG4uYm91bmNlLWxlYXZlIHtcclxuICAgIGFuaW1hdGlvbjogYm91bmNlLW91dCAuNXM7XHJcbn1cclxuXHJcbkBrZXlmcmFtZXMgYm91bmNlLWluIHtcclxuICAgIDAlIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcclxuICAgIH1cclxufVxyXG5cclxuQGtleWZyYW1lcyBib3VuY2Utb3V0IHtcclxuICAgIDAlIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcclxuICAgIH1cclxufVxyXG48L3N0eWxlPlxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB0aXAtbW9kYWwudnVlPzc5MTg3Y2JlXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInRpcC1jb250ZW50XFxcIiB0cmFuc2l0aW9uPVxcXCJib3VuY2VcXFwiIHYtc2hvdz1cXFwiaXNTaG93XFxcIiB2LWh0bWw9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlwiO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1odG1sLWxvYWRlci8xLjIuMy92dWUtaHRtbC1sb2FkZXIhLi9+Ly5ucG1pbnN0YWxsL3Z1ZS1sb2FkZXIvOC41LjMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9cHVnIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3RpcC1tb2RhbC52dWVcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8YmFja2dyb3VuZD48L2JhY2tncm91bmQ+PG1lbnUtYmFyIHYtYmluZDpnYW1lLWRhdGE9XFxcImdhbWVEYXRhXFxcIiB2LWJpbmQ6bm90aWNlPVxcXCJub3RpY2VcXFwiIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIj48L21lbnUtYmFyPjxiZXQtYW5kLWJvbnVzIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIiB2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDpsb2NrbW9uZXk9XFxcImxvY2ttb25leVxcXCIgdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIiB2LWJpbmQ6bG90dGVyeW51bS5zeW5jPVxcXCJsb3R0ZXJ5bnVtXFxcIiB2LWJpbmQ6Y291bnQtZG93bi5zeW5jPVxcXCJjb3VudERvd25cXFwiIHYtYmluZDpjb3VudC1udW0uc3luYz1cXFwiY291bnROdW1cXFwiPjwvYmV0LWFuZC1ib251cz48cGxheS1wYW5lbCB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOnVzZXItYmV0PVxcXCJ1c2VyQmV0XFxcIiB2LWJpbmQ6YmV0cy5zeW5jPVxcXCJiZXRzXFxcIiB2LWJpbmQ6bG9ja21vbmV5PVxcXCJsb2NrbW9uZXlcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCIgdi1iaW5kOmxvdHRlcnludW0uc3luYz1cXFwibG90dGVyeW51bVxcXCIgdi1iaW5kOmNvdW50LWRvd24uc3luYz1cXFwiY291bnREb3duXFxcIiB2LWJpbmQ6Y291bnQtbnVtLnN5bmM9XFxcImNvdW50TnVtXFxcIj48L3BsYXktcGFuZWw+PHN0YXRlIHYtYmluZDp6b29tLXJhdGU9XFxcInpvb21SYXRlXFxcIiB2LWJpbmQ6dXNlcmluZm89XFxcInVzZXJpbmZvXFxcIiB2LWJpbmQ6dXNlci1iZXQ9XFxcInVzZXJCZXRcXFwiIHYtYmluZDpiZXRzLnN5bmM9XFxcImJldHNcXFwiIHYtYmluZDplcnJvci5zeW5jPVxcXCJlcnJvclxcXCI+PC9zdGF0ZT48bWVzc2FnZSB2LWJpbmQ6em9vbS1yYXRlPVxcXCJ6b29tUmF0ZVxcXCIgdi1iaW5kOnVzZXJpbmZvPVxcXCJ1c2VyaW5mb1xcXCIgdi1iaW5kOmJldHMuc3luYz1cXFwiYmV0c1xcXCIgdi1iaW5kOmVycm9yLnN5bmM9XFxcImVycm9yXFxcIj48L21lc3NhZ2U+PG1vZGFsIGNsYXNzPVxcXCJtb2RhbFxcXCIgdi1pZj1cXFwiZXJyb3JcXFwiPjwvbW9kYWw+PHRpcC1tb2RhbD48L3RpcC1tb2RhbD5cIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi8ubnBtaW5zdGFsbC92dWUtaHRtbC1sb2FkZXIvMS4yLjMvdnVlLWh0bWwtbG9hZGVyIS4vfi8ubnBtaW5zdGFsbC92dWUtbG9hZGVyLzguNS4zL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWxvYWRlci5qcz9yYXcmZW5naW5lPXB1ZyEuL34vLm5wbWluc3RhbGwvdnVlLWxvYWRlci84LjUuMy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiIWZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiKGEpXG59KHdpbmRvdywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjKGIsIGMsIGQpIHtcbiAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSA/IFdlaXhpbkpTQnJpZGdlLmludm9rZShiLCBlKGMpLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZyhiLCBhLCBkKVxuICAgICAgICB9KSA6IGooYiwgZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkKGIsIGMsIGQpIHtcbiAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSA/IFdlaXhpbkpTQnJpZGdlLm9uKGIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkICYmIGQudHJpZ2dlciAmJiBkLnRyaWdnZXIoYSksIGcoYiwgYSwgYylcbiAgICAgICAgfSkgOiBkID8gaihiLCBkKSA6IGooYiwgYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPSBhIHx8IHt9LCBhLmFwcElkID0gei5hcHBJZCwgYS52ZXJpZnlBcHBJZCA9IHouYXBwSWQsIGEudmVyaWZ5U2lnblR5cGUgPSBcInNoYTFcIiwgYS52ZXJpZnlUaW1lc3RhbXAgPSB6LnRpbWVzdGFtcCArIFwiXCIsIGEudmVyaWZ5Tm9uY2VTdHIgPSB6Lm5vbmNlU3RyLCBhLnZlcmlmeVNpZ25hdHVyZSA9IHouc2lnbmF0dXJlLCBhXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZihhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lU3RhbXA6IGEudGltZXN0YW1wICsgXCJcIixcbiAgICAgICAgICAgIG5vbmNlU3RyOiBhLm5vbmNlU3RyLFxuICAgICAgICAgICAgXCJwYWNrYWdlXCI6IGEucGFja2FnZSxcbiAgICAgICAgICAgIHBheVNpZ246IGEucGF5U2lnbixcbiAgICAgICAgICAgIHNpZ25UeXBlOiBhLnNpZ25UeXBlIHx8IFwiU0hBMVwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGQsIGUsIGY7XG4gICAgICAgIHN3aXRjaCAoZGVsZXRlIGIuZXJyX2NvZGUsIGRlbGV0ZSBiLmVycl9kZXNjLCBkZWxldGUgYi5lcnJfZGV0YWlsLCBkID0gYi5lcnJNc2csIGQgfHwgKGQgPSBiLmVycl9tc2csIGRlbGV0ZSBiLmVycl9tc2csIGQgPSBoKGEsIGQsIGMpLCBiLmVyck1zZyA9IGQpLCBjID0gYyB8fCB7fSwgYy5fY29tcGxldGUgJiYgKGMuX2NvbXBsZXRlKGIpLCBkZWxldGUgYy5fY29tcGxldGUpLCBkID0gYi5lcnJNc2cgfHwgXCJcIiwgei5kZWJ1ZyAmJiAhYy5pc0lubmVySW52b2tlICYmIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGIpKSwgZSA9IGQuaW5kZXhPZihcIjpcIiksIGYgPSBkLnN1YnN0cmluZyhlICsgMSkpIHtcbiAgICAgICAgICAgIGNhc2VcIm9rXCI6XG4gICAgICAgICAgICAgICAgYy5zdWNjZXNzICYmIGMuc3VjY2VzcyhiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2VcImNhbmNlbFwiOlxuICAgICAgICAgICAgICAgIGMuY2FuY2VsICYmIGMuY2FuY2VsKGIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjLmZhaWwgJiYgYy5mYWlsKGIpXG4gICAgICAgIH1cbiAgICAgICAgYy5jb21wbGV0ZSAmJiBjLmNvbXBsZXRlKGIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaChhLCBiKSB7XG4gICAgICAgIHZhciBkLCBlLCBmLCBnO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgc3dpdGNoIChkID0gYi5pbmRleE9mKFwiOlwiKSwgYSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugby5jb25maWc6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBcImNvbmZpZ1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG8ub3BlblByb2R1Y3RTcGVjaWZpY1ZpZXc6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBcIm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGUgPSBiLnN1YnN0cmluZygwLCBkKSwgZSA9IGUucmVwbGFjZSgvXy9nLCBcIiBcIiksIGUgPSBlLnJlcGxhY2UoL1xcYlxcdytcXGIvZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpICsgYS5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgICAgICAgfSksIGUgPSBlLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsgZS5zdWJzdHJpbmcoMSksIGUgPSBlLnJlcGxhY2UoLyAvZywgXCJcIiksIC0xICE9IGUuaW5kZXhPZihcIldjcGF5XCIpICYmIChlID0gZS5yZXBsYWNlKFwiV2NwYXlcIiwgXCJXQ1BheVwiKSksIGYgPSBwW2VdLCBmICYmIChlID0gZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGcgPSBiLnN1YnN0cmluZyhkICsgMSksIFwiY29uZmlybVwiID09IGcgJiYgKGcgPSBcIm9rXCIpLCBcImZhaWxlZFwiID09IGcgJiYgKGcgPSBcImZhaWxcIiksIC0xICE9IGcuaW5kZXhPZihcImZhaWxlZF9cIikgJiYgKGcgPSBnLnN1YnN0cmluZyg3KSksIC0xICE9IGcuaW5kZXhPZihcImZhaWxfXCIpICYmIChnID0gZy5zdWJzdHJpbmcoNSkpLCBnID0gZy5yZXBsYWNlKC9fL2csIFwiIFwiKSwgZyA9IGcudG9Mb3dlckNhc2UoKSwgKFwiYWNjZXNzIGRlbmllZFwiID09IGcgfHwgXCJubyBwZXJtaXNzaW9uIHRvIGV4ZWN1dGVcIiA9PSBnKSAmJiAoZyA9IFwicGVybWlzc2lvbiBkZW5pZWRcIiksIFwiY29uZmlnXCIgPT0gZSAmJiBcImZ1bmN0aW9uIG5vdCBleGlzdFwiID09IGcgJiYgKGcgPSBcIm9rXCIpLCBiID0gZSArIFwiOlwiICsgZ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaShhKSB7XG4gICAgICAgIHZhciBiLCBjLCBkLCBlO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgZm9yIChiID0gMCwgYyA9IGEubGVuZ3RoOyBjID4gYjsgKytiKWQgPSBhW2JdLCBlID0gb1tkXSwgZSAmJiAoYVtiXSA9IGUpO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGooYSwgYikge1xuICAgICAgICBpZiAoISghei5kZWJ1ZyB8fCBiICYmIGIuaXNJbm5lckludm9rZSkpIHtcbiAgICAgICAgICAgIHZhciBjID0gcFthXTtcbiAgICAgICAgICAgIGMgJiYgKGEgPSBjKSwgYiAmJiBiLl9jb21wbGV0ZSAmJiBkZWxldGUgYi5fY29tcGxldGUsIGNvbnNvbGUubG9nKCdcIicgKyBhICsgJ1wiLCcsIGIgfHwgXCJcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGsoKSB7XG4gICAgICAgIGlmICghKFwiNi4wLjJcIiA+IHcgfHwgeS5zeXN0ZW1UeXBlIDwgMCkpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEltYWdlO1xuICAgICAgICAgICAgeS5hcHBJZCA9IHouYXBwSWQsIHkuaW5pdFRpbWUgPSB4LmluaXRFbmRUaW1lIC0geC5pbml0U3RhcnRUaW1lLCB5LnByZVZlcmlmeVRpbWUgPSB4LnByZVZlcmlmeUVuZFRpbWUgLSB4LnByZVZlcmlmeVN0YXJ0VGltZSwgQy5nZXROZXR3b3JrVHlwZSh7XG4gICAgICAgICAgICAgICAgaXNJbm5lckludm9rZTogITAsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeS5uZXR3b3JrVHlwZSA9IGEubmV0d29ya1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gXCJodHRwczovL29wZW4ud2VpeGluLnFxLmNvbS9zZGsvcmVwb3J0P3Y9XCIgKyB5LnZlcnNpb24gKyBcIiZvPVwiICsgeS5pc1ByZVZlcmlmeU9rICsgXCImcz1cIiArIHkuc3lzdGVtVHlwZSArIFwiJmM9XCIgKyB5LmNsaWVudFZlcnNpb24gKyBcIiZhPVwiICsgeS5hcHBJZCArIFwiJm49XCIgKyB5Lm5ldHdvcmtUeXBlICsgXCImaT1cIiArIHkuaW5pdFRpbWUgKyBcIiZwPVwiICsgeS5wcmVWZXJpZnlUaW1lICsgXCImdT1cIiArIHkudXJsO1xuICAgICAgICAgICAgICAgICAgICBiLnNyYyA9IGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbShiKSB7XG4gICAgICAgIHQgJiYgKGEuV2VpeGluSlNCcmlkZ2UgPyBiKCkgOiBxLmFkZEV2ZW50TGlzdGVuZXIgJiYgcS5hZGRFdmVudExpc3RlbmVyKFwiV2VpeGluSlNCcmlkZ2VSZWFkeVwiLCBiLCAhMSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgQy5pbnZva2UgfHwgKEMuaW52b2tlID0gZnVuY3Rpb24gKGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGEuV2VpeGluSlNCcmlkZ2UgJiYgV2VpeGluSlNCcmlkZ2UuaW52b2tlKGIsIGUoYyksIGQpXG4gICAgICAgIH0sIEMub24gPSBmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgICAgYS5XZWl4aW5KU0JyaWRnZSAmJiBXZWl4aW5KU0JyaWRnZS5vbihiLCBjKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHZhciBvLCBwLCBxLCByLCBzLCB0LCB1LCB2LCB3LCB4LCB5LCB6LCBBLCBCLCBDO1xuICAgIGlmICghYS5qV2VpeGluKXJldHVybiBvID0ge1xuICAgICAgICBjb25maWc6IFwicHJlVmVyaWZ5SlNBUElcIixcbiAgICAgICAgb25NZW51U2hhcmVUaW1lbGluZTogXCJtZW51OnNoYXJlOnRpbWVsaW5lXCIsXG4gICAgICAgIG9uTWVudVNoYXJlQXBwTWVzc2FnZTogXCJtZW51OnNoYXJlOmFwcG1lc3NhZ2VcIixcbiAgICAgICAgb25NZW51U2hhcmVRUTogXCJtZW51OnNoYXJlOnFxXCIsXG4gICAgICAgIG9uTWVudVNoYXJlV2VpYm86IFwibWVudTpzaGFyZTp3ZWlib0FwcFwiLFxuICAgICAgICBvbk1lbnVTaGFyZVFab25lOiBcIm1lbnU6c2hhcmU6UVpvbmVcIixcbiAgICAgICAgcHJldmlld0ltYWdlOiBcImltYWdlUHJldmlld1wiLFxuICAgICAgICBnZXRMb2NhdGlvbjogXCJnZW9Mb2NhdGlvblwiLFxuICAgICAgICBvcGVuUHJvZHVjdFNwZWNpZmljVmlldzogXCJvcGVuUHJvZHVjdFZpZXdXaXRoUGlkXCIsXG4gICAgICAgIGFkZENhcmQ6IFwiYmF0Y2hBZGRDYXJkXCIsXG4gICAgICAgIG9wZW5DYXJkOiBcImJhdGNoVmlld0NhcmRcIixcbiAgICAgICAgY2hvb3NlV1hQYXk6IFwiZ2V0QnJhbmRXQ1BheVJlcXVlc3RcIlxuICAgIH0sIHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiLCBhID0ge307XG4gICAgICAgIGZvciAoYiBpbiBvKWFbb1tiXV0gPSBiO1xuICAgICAgICByZXR1cm4gYVxuICAgIH0oKSwgcSA9IGEuZG9jdW1lbnQsXG4gICAgICAgIHIgPSBxLnRpdGxlLFxuICAgICAgICBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLCB0ID0gLTEgIT0gcy5pbmRleE9mKFwibWljcm9tZXNzZW5nZXJcIiksIHUgPSAtMSAhPSBzLmluZGV4T2YoXCJhbmRyb2lkXCIpLCB2ID0gLTEgIT0gcy5pbmRleE9mKFwiaXBob25lXCIpIHx8IC0xICE9IHMuaW5kZXhPZihcImlwYWRcIiksIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gcy5tYXRjaCgvbWljcm9tZXNzZW5nZXJcXC8oXFxkK1xcLlxcZCtcXC5cXGQrKS8pIHx8IHMubWF0Y2goL21pY3JvbWVzc2VuZ2VyXFwvKFxcZCtcXC5cXGQrKS8pO1xuICAgICAgICByZXR1cm4gYSA/IGFbMV0gOiBcIlwiXG4gICAgfSgpLCB4ID0ge2luaXRTdGFydFRpbWU6IGwoKSwgaW5pdEVuZFRpbWU6IDAsIHByZVZlcmlmeVN0YXJ0VGltZTogMCwgcHJlVmVyaWZ5RW5kVGltZTogMH0sIHkgPSB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIGFwcElkOiBcIlwiLFxuICAgICAgICBpbml0VGltZTogMCxcbiAgICAgICAgcHJlVmVyaWZ5VGltZTogMCxcbiAgICAgICAgbmV0d29ya1R5cGU6IFwiXCIsXG4gICAgICAgIGlzUHJlVmVyaWZ5T2s6IDEsXG4gICAgICAgIHN5c3RlbVR5cGU6IHYgPyAxIDogdSA/IDIgOiAtMSxcbiAgICAgICAgY2xpZW50VmVyc2lvbjogdyxcbiAgICAgICAgdXJsOiBlbmNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaHJlZilcbiAgICB9LCB6ID0ge30sIEEgPSB7X2NvbXBsZXRlczogW119LCBCID0ge3N0YXRlOiAwLCByZXM6IHt9fSwgbShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHguaW5pdEVuZFRpbWUgPSBsKClcbiAgICB9KSwgQyA9IHtcbiAgICAgICAgY29uZmlnOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgeiA9IGEsIGooXCJjb25maWdcIiwgYSk7XG4gICAgICAgICAgICB2YXIgYiA9IHouY2hlY2sgPT09ICExID8gITEgOiAhMDtcbiAgICAgICAgICAgIG0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhLCBkLCBlO1xuICAgICAgICAgICAgICAgIGlmIChiKWMoby5jb25maWcsIHt2ZXJpZnlKc0FwaUxpc3Q6IGkoei5qc0FwaUxpc3QpfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LnByZVZlcmlmeUVuZFRpbWUgPSBsKCksIEIuc3RhdGUgPSAxLCBCLnJlcyA9IGFcbiAgICAgICAgICAgICAgICAgICAgfSwgQS5zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeS5pc1ByZVZlcmlmeU9rID0gMFxuICAgICAgICAgICAgICAgICAgICB9LCBBLmZhaWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQS5fZmFpbCA/IEEuX2ZhaWwoYSkgOiBCLnN0YXRlID0gLTFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBBLl9jb21wbGV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgei5kZWJ1ZyB8fCBrKClcbiAgICAgICAgICAgICAgICAgICAgfSksIEEuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBkID4gYzsgKytjKWFbY10oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEEuX2NvbXBsZXRlcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIEFcbiAgICAgICAgICAgICAgICB9KCkpLCB4LnByZVZlcmlmeVN0YXJ0VGltZSA9IGwoKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoQi5zdGF0ZSA9IDEsIGEgPSBBLl9jb21wbGV0ZXMsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGUgPiBkOyArK2QpYVtkXSgpO1xuICAgICAgICAgICAgICAgICAgICBBLl9jb21wbGV0ZXMgPSBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB6LmJldGEgJiYgbigpXG4gICAgICAgIH0sIHJlYWR5OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgMCAhPSBCLnN0YXRlID8gYSgpIDogKEEuX2NvbXBsZXRlcy5wdXNoKGEpLCAhdCAmJiB6LmRlYnVnICYmIGEoKSlcbiAgICAgICAgfSwgZXJyb3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBcIjYuMC4yXCIgPiB3IHx8ICgtMSA9PSBCLnN0YXRlID8gYShCLnJlcykgOiBBLl9mYWlsID0gYSlcbiAgICAgICAgfSwgY2hlY2tKc0FwaTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgZCwgYiA9IGEuY2hlY2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgZm9yIChjIGluIGIpZCA9IHBbY10sIGQgJiYgKGJbZF0gPSBiW2NdLCBkZWxldGUgYltjXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjKFwiY2hlY2tKc0FwaVwiLCB7anNBcGlMaXN0OiBpKGEuanNBcGlMaXN0KX0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBhLmNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYyAmJiAoYS5jaGVja1Jlc3VsdCA9IEpTT04ucGFyc2UoYykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9IGIoYSlcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlVGltZWxpbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVUaW1lbGluZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVRpbWVsaW5lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdfdXJsOiBhLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogYS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfSwgYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBvbk1lbnVTaGFyZUFwcE1lc3NhZ2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVBcHBNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYyhcInNlbmRBcHBNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6IGEubGluayB8fCBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nX3VybDogYS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGEudHlwZSB8fCBcImxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdXJsOiBhLmRhdGFVcmwgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlUVE6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVRUSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVFRXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlV2VpYm86IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVXZWlibywge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVdlaWJvQXBwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIG9uTWVudVNoYXJlUVpvbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKG8ub25NZW51U2hhcmVRWm9uZSwge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGMoXCJzaGFyZVFab25lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhLnRpdGxlIHx8IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBhLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ191cmw6IGEuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rOiBhLmxpbmsgfHwgbG9jYXRpb24uaHJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGEpXG4gICAgICAgIH0sIHN0YXJ0UmVjb3JkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInN0YXJ0UmVjb3JkXCIsIHt9LCBhKVxuICAgICAgICB9LCBzdG9wUmVjb3JkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInN0b3BSZWNvcmRcIiwge30sIGEpXG4gICAgICAgIH0sIG9uVm9pY2VSZWNvcmRFbmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkKFwib25Wb2ljZVJlY29yZEVuZFwiLCBhKVxuICAgICAgICB9LCBwbGF5Vm9pY2U6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwicGxheVZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWR9LCBhKVxuICAgICAgICB9LCBwYXVzZVZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInBhdXNlVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZH0sIGEpXG4gICAgICAgIH0sIHN0b3BWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzdG9wVm9pY2VcIiwge2xvY2FsSWQ6IGEubG9jYWxJZH0sIGEpXG4gICAgICAgIH0sIG9uVm9pY2VQbGF5RW5kOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZChcIm9uVm9pY2VQbGF5RW5kXCIsIGEpXG4gICAgICAgIH0sIHVwbG9hZFZvaWNlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInVwbG9hZFZvaWNlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZG93bmxvYWRWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJkb3dubG9hZFZvaWNlXCIsIHtzZXJ2ZXJJZDogYS5zZXJ2ZXJJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCB0cmFuc2xhdGVWb2ljZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJ0cmFuc2xhdGVWb2ljZVwiLCB7bG9jYWxJZDogYS5sb2NhbElkLCBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gYS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMX0sIGEpXG4gICAgICAgIH0sIGNob29zZUltYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImNob29zZUltYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBzY2VuZTogXCIxfDJcIixcbiAgICAgICAgICAgICAgICBjb3VudDogYS5jb3VudCB8fCA5LFxuICAgICAgICAgICAgICAgIHNpemVUeXBlOiBhLnNpemVUeXBlIHx8IFtcIm9yaWdpbmFsXCIsIFwiY29tcHJlc3NlZFwiXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiBhLnNvdXJjZVR5cGUgfHwgW1wiYWxidW1cIiwgXCJjYW1lcmFcIl1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBhLmxvY2FsSWRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiAmJiAoYS5sb2NhbElkcyA9IEpTT04ucGFyc2UoYikpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIHByZXZpZXdJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoby5wcmV2aWV3SW1hZ2UsIHtjdXJyZW50OiBhLmN1cnJlbnQsIHVybHM6IGEudXJsc30sIGEpXG4gICAgICAgIH0sIHVwbG9hZEltYWdlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInVwbG9hZEltYWdlXCIsIHtsb2NhbElkOiBhLmxvY2FsSWQsIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBhLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxfSwgYSlcbiAgICAgICAgfSwgZG93bmxvYWRJbWFnZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJkb3dubG9hZEltYWdlXCIsIHtzZXJ2ZXJJZDogYS5zZXJ2ZXJJZCwgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGEuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDF9LCBhKVxuICAgICAgICB9LCBnZXROZXR3b3JrVHlwZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgZCwgZSwgYiA9IGEuZXJyTXNnO1xuICAgICAgICAgICAgICAgIGlmIChhLmVyck1zZyA9IFwiZ2V0TmV0d29ya1R5cGU6b2tcIiwgYyA9IGEuc3VidHlwZSwgZGVsZXRlIGEuc3VidHlwZSwgYylhLm5ldHdvcmtUeXBlID0gYzsgZWxzZSBzd2l0Y2ggKGQgPSBiLmluZGV4T2YoXCI6XCIpLCBlID0gYi5zdWJzdHJpbmcoZCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VcIndpZmlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZVwiZWRnZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlXCJ3d2FuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhLm5ldHdvcmtUeXBlID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5lcnJNc2cgPSBcImdldE5ldHdvcmtUeXBlOmZhaWxcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGMoXCJnZXROZXR3b3JrVHlwZVwiLCB7fSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiKGEpXG4gICAgICAgICAgICAgICAgfSwgYVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LCBvcGVuTG9jYXRpb246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwib3BlbkxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogYS5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGEubG9uZ2l0dWRlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGEubmFtZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGEuYWRkcmVzcyB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBhLnNjYWxlIHx8IDI4LFxuICAgICAgICAgICAgICAgIGluZm9Vcmw6IGEuaW5mb1VybCB8fCBcIlwiXG4gICAgICAgICAgICB9LCBhKVxuICAgICAgICB9LCBnZXRMb2NhdGlvbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgPSBhIHx8IHt9LCBjKG8uZ2V0TG9jYXRpb24sIHt0eXBlOiBhLnR5cGUgfHwgXCJ3Z3M4NFwifSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLl9jb21wbGV0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhLnR5cGVcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIGhpZGVPcHRpb25NZW51OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcImhpZGVPcHRpb25NZW51XCIsIHt9LCBhKVxuICAgICAgICB9LCBzaG93T3B0aW9uTWVudTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJzaG93T3B0aW9uTWVudVwiLCB7fSwgYSlcbiAgICAgICAgfSwgY2xvc2VXaW5kb3c6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhcImNsb3NlV2luZG93XCIsIHtpbW1lZGlhdGVfY2xvc2U6IGEuaW1tZWRpYXRlQ2xvc2UgfHwgMH0sIGEpXG4gICAgICAgIH0sIGhpZGVNZW51SXRlbXM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiaGlkZU1lbnVJdGVtc1wiLCB7bWVudUxpc3Q6IGEubWVudUxpc3R9LCBhKVxuICAgICAgICB9LCBzaG93TWVudUl0ZW1zOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInNob3dNZW51SXRlbXNcIiwge21lbnVMaXN0OiBhLm1lbnVMaXN0fSwgYSlcbiAgICAgICAgfSwgaGlkZUFsbE5vbkJhc2VNZW51SXRlbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGMoXCJoaWRlQWxsTm9uQmFzZU1lbnVJdGVtXCIsIHt9LCBhKVxuICAgICAgICB9LCBzaG93QWxsTm9uQmFzZU1lbnVJdGVtOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhcInNob3dBbGxOb25CYXNlTWVudUl0ZW1cIiwge30sIGEpXG4gICAgICAgIH0sIHNjYW5RUkNvZGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhID0gYSB8fCB7fSwgYyhcInNjYW5RUkNvZGVcIiwge1xuICAgICAgICAgICAgICAgIG5lZWRSZXN1bHQ6IGEubmVlZFJlc3VsdCB8fCAwLFxuICAgICAgICAgICAgICAgIHNjYW5UeXBlOiBhLnNjYW5UeXBlIHx8IFtcInFyQ29kZVwiLCBcImJhckNvZGVcIl1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYztcbiAgICAgICAgICAgICAgICAgICAgdiAmJiAoYiA9IGEucmVzdWx0U3RyLCBiICYmIChjID0gSlNPTi5wYXJzZShiKSwgYS5yZXN1bHRTdHIgPSBjICYmIGMuc2Nhbl9jb2RlICYmIGMuc2Nhbl9jb2RlLnNjYW5fcmVzdWx0KSlcbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIG9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYyhvLm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3LCB7cGlkOiBhLnByb2R1Y3RJZCwgdmlld190eXBlOiBhLnZpZXdUeXBlIHx8IDB9LCBhKVxuICAgICAgICB9LCBhZGRDYXJkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGUsIGYsIGcsIGgsIGIgPSBhLmNhcmRMaXN0LCBkID0gW107XG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBmID0gYi5sZW5ndGg7IGYgPiBlOyArK2UpZyA9IGJbZV0sIGggPSB7Y2FyZF9pZDogZy5jYXJkSWQsIGNhcmRfZXh0OiBnLmNhcmRFeHR9LCBkLnB1c2goaCk7XG4gICAgICAgICAgICBjKG8uYWRkQ2FyZCwge2NhcmRfbGlzdDogZH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5fY29tcGxldGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYywgZCwgZSwgYiA9IGEuY2FyZF9saXN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChiID0gSlNPTi5wYXJzZShiKSwgYyA9IDAsIGQgPSBiLmxlbmd0aDsgZCA+IGM7ICsrYyllID0gYltjXSwgZS5jYXJkSWQgPSBlLmNhcmRfaWQsIGUuY2FyZEV4dCA9IGUuY2FyZF9leHQsIGUuaXNTdWNjZXNzID0gZS5pc19zdWNjID8gITAgOiAhMSwgZGVsZXRlIGUuY2FyZF9pZCwgZGVsZXRlIGUuY2FyZF9leHQsIGRlbGV0ZSBlLmlzX3N1Y2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmNhcmRMaXN0ID0gYiwgZGVsZXRlIGEuY2FyZF9saXN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhXG4gICAgICAgICAgICB9KCkpXG4gICAgICAgIH0sIGNob29zZUNhcmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKFwiY2hvb3NlQ2FyZFwiLCB7XG4gICAgICAgICAgICAgICAgYXBwX2lkOiB6LmFwcElkLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uX2lkOiBhLnNob3BJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHNpZ25fdHlwZTogYS5zaWduVHlwZSB8fCBcIlNIQTFcIixcbiAgICAgICAgICAgICAgICBjYXJkX2lkOiBhLmNhcmRJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNhcmRfdHlwZTogYS5jYXJkVHlwZSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNhcmRfc2lnbjogYS5jYXJkU2lnbixcbiAgICAgICAgICAgICAgICB0aW1lX3N0YW1wOiBhLnRpbWVzdGFtcCArIFwiXCIsXG4gICAgICAgICAgICAgICAgbm9uY2Vfc3RyOiBhLm5vbmNlU3RyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuX2NvbXBsZXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5jYXJkTGlzdCA9IGEuY2hvb3NlX2NhcmRfaW5mbywgZGVsZXRlIGEuY2hvb3NlX2NhcmRfaW5mb1xuICAgICAgICAgICAgICAgIH0sIGFcbiAgICAgICAgICAgIH0oKSlcbiAgICAgICAgfSwgb3BlbkNhcmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgZSwgZiwgZywgaCwgYiA9IGEuY2FyZExpc3QsIGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGYgPSBiLmxlbmd0aDsgZiA+IGU7ICsrZSlnID0gYltlXSwgaCA9IHtjYXJkX2lkOiBnLmNhcmRJZCwgY29kZTogZy5jb2RlfSwgZC5wdXNoKGgpO1xuICAgICAgICAgICAgYyhvLm9wZW5DYXJkLCB7Y2FyZF9saXN0OiBkfSwgYSlcbiAgICAgICAgfSwgY2hvb3NlV1hQYXk6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjKG8uY2hvb3NlV1hQYXksIGYoYSksIGEpXG4gICAgICAgIH1cbiAgICB9LCBiICYmIChhLnd4ID0gYS5qV2VpeGluID0gQyksIENcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+Ly5ucG1pbnN0YWxsL3dlaXhpbi1qcy1zZGsvMS4wLjcvd2VpeGluLWpzLXNkay9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==